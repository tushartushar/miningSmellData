Implementation smell,Namespace,Class,File,Method,Description
Long Method,HutongGames.PlayMaker.Actions,AnimateFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateFsmAction.cs,OnUpdate,The method has 101 lines of code.
Long Method,HutongGames.PlayMaker.Actions,CurveFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveFsmAction.cs,OnUpdate,The method has 110 lines of code.
Long Method,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The method has 100 lines of code.
Long Method,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The method has 113 lines of code.
Long Method,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The method has 105 lines of code.
Long Method,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadSkeletonData,The method has 115 lines of code.
Long Method,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The method has 103 lines of code.
Long Method,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The method has 223 lines of code.
Complex Method,HutongGames.PlayMaker.Actions,PhotonNetworkGetConnectionState,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\Photon Unity Networking\PlayMaker\Actions\PhotonNetworkGetConnectionState.cs,DoPhotonNetworkStateSwitch,Cyclomatic complexity of the method is 15
Complex Method,HutongGames.PlayMaker.Actions,PhotonNetworkInstantiate,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\Photon Unity Networking\PlayMaker\Actions\PhotonNetworkInstantiate.cs,doInstantiate,Cyclomatic complexity of the method is 8
Complex Method,HutongGames.PlayMaker.Actions,PhotonViewRpcBroadcastFsmEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\Photon Unity Networking\PlayMaker\Actions\PhotonViewRpcBroadcastFsmEvent.cs,DoREC,Cyclomatic complexity of the method is 8
Complex Method,HutongGames.PlayMaker.Actions,PhotonViewRpcBroadcastFsmEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\Photon Unity Networking\PlayMaker\Actions\PhotonViewRpcBroadcastFsmEvent.cs,ErrorCheck,Cyclomatic complexity of the method is 8
Complex Method,HutongGames.PlayMaker.Actions,AddForce,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AddForce.cs,DoAddForce,Cyclomatic complexity of the method is 8
Complex Method,HutongGames.PlayMaker.Actions,AnimateFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateFsmAction.cs,Init,Cyclomatic complexity of the method is 10
Complex Method,HutongGames.PlayMaker.Actions,AnimateFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateFsmAction.cs,OnUpdate,Cyclomatic complexity of the method is 41
Complex Method,HutongGames.PlayMaker.Actions,CurveFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveFsmAction.cs,Init,Cyclomatic complexity of the method is 11
Complex Method,HutongGames.PlayMaker.Actions,CurveFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveFsmAction.cs,OnUpdate,Cyclomatic complexity of the method is 40
Complex Method,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,OnUpdate,Cyclomatic complexity of the method is 10
Complex Method,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,SetEasingFunction,Cyclomatic complexity of the method is 84
Complex Method,HutongGames.PlayMaker.Actions,AxisEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AxisEvent.cs,OnUpdate,Cyclomatic complexity of the method is 9
Complex Method,HutongGames.PlayMaker.Actions,BoolOperator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\BoolOperator.cs,DoBoolOperator,Cyclomatic complexity of the method is 12
Complex Method,HutongGames.PlayMaker.Actions,CallMethod,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\CallMethod.cs,ErrorCheck,Cyclomatic complexity of the method is 8
Complex Method,HutongGames.PlayMaker.Actions,CollisionEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\CollisionEvent.cs,Awake,Cyclomatic complexity of the method is 9
Complex Method,HutongGames.PlayMaker.Actions,ControllerSettings,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\ControllerSettings.cs,DoControllerSettings,Cyclomatic complexity of the method is 10
Complex Method,HutongGames.PlayMaker.Actions,ConvertFloatToInt,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\ConvertFloatToInt.cs,DoConvertFloatToInt,Cyclomatic complexity of the method is 9
Complex Method,HutongGames.PlayMaker.Actions,CreateEmptyObject,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\CreateEmptyObject.cs,OnEnter,Cyclomatic complexity of the method is 8
Complex Method,HutongGames.PlayMaker.Actions,DebugDrawShape,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\DebugDrawShape.cs,OnDrawGizmos,Cyclomatic complexity of the method is 14
Complex Method,HutongGames.PlayMaker.Actions,FloatInterpolate,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\FloatInterpolate.cs,OnUpdate,Cyclomatic complexity of the method is 9
Complex Method,HutongGames.PlayMaker.Actions,FloatOperator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\FloatOperator.cs,DoFloatOperator,Cyclomatic complexity of the method is 18
Complex Method,HutongGames.PlayMaker.Actions,GUIElementHitTest,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GUIElementHitTest.cs,DoHitTest,Cyclomatic complexity of the method is 8
Complex Method,HutongGames.PlayMaker.Actions,GetAxisVector,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GetAxisVector.cs,OnUpdate,Cyclomatic complexity of the method is 26
Complex Method,HutongGames.PlayMaker.Actions,GetChild,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GetChild.cs,DoGetChildByName,Cyclomatic complexity of the method is 10
Complex Method,HutongGames.PlayMaker.Actions,GetDeviceRoll,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GetDeviceRoll.cs,DoGetDeviceRoll,Cyclomatic complexity of the method is 11
Complex Method,HutongGames.PlayMaker.Actions,GetMaterialTexture,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GetMaterialTexture.cs,DoGetMaterialTexture,Cyclomatic complexity of the method is 8
Complex Method,HutongGames.PlayMaker.Actions,GetTimeInfo,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GetTimeInfo.cs,DoGetTimeInfo,Cyclomatic complexity of the method is 27
Complex Method,HutongGames.PlayMaker.Actions,GetVertexPosition,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GetVertexPosition.cs,DoGetVertexPosition,Cyclomatic complexity of the method is 9
Complex Method,HutongGames.PlayMaker.Actions,IntOperator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\IntOperator.cs,DoIntOperator,Cyclomatic complexity of the method is 18
Complex Method,HutongGames.PlayMaker.Actions,MouseLook,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\MouseLook.cs,DoMouseLook,Cyclomatic complexity of the method is 10
Complex Method,HutongGames.PlayMaker.Actions,MouseLook2,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\MouseLook2.cs,DoMouseLook,Cyclomatic complexity of the method is 10
Complex Method,HutongGames.PlayMaker.Actions,NetworkGetNetworkDisconnectionInfos,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Network\NetworkGetNetworkDisconnectionInfo.cs,doGetNetworkDisconnectionInfo,Cyclomatic complexity of the method is 8
Complex Method,HutongGames.PlayMaker.Actions,NetworkGetOnFailedToConnectProperties,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Network\NetworkGetNetworkErrorInfo.cs,doGetNetworkErrorInfo,Cyclomatic complexity of the method is 60
Complex Method,HutongGames.PlayMaker.Actions,NetworkPeerTypeSwitch,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Network\NetworkPeerTypeSwitch.cs,DoNetworkPeerTypeSwitch,Cyclomatic complexity of the method is 12
Complex Method,HutongGames.PlayMaker.Actions,SendMessage,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SendMessage.cs,DoSendMessage,Cyclomatic complexity of the method is 47
Complex Method,HutongGames.PlayMaker.Actions,SetMaterialColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SetMaterialColor.cs,DoSetMaterialColor,Cyclomatic complexity of the method is 8
Complex Method,HutongGames.PlayMaker.Actions,SetRotation,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SetRotation.cs,DoSetRotation,Cyclomatic complexity of the method is 8
Complex Method,HutongGames.PlayMaker.Actions,SmoothLookAt,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SmoothLookAt.cs,DoSmoothLookAt,Cyclomatic complexity of the method is 10
Complex Method,HutongGames.PlayMaker.Actions,StartCoroutine,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\StartCoroutine.cs,DoStartCoroutine,Cyclomatic complexity of the method is 31
Complex Method,HutongGames.PlayMaker.Actions,SwipeGestureEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SwipeGestureEvent.cs,OnUpdate,Cyclomatic complexity of the method is 16
Complex Method,HutongGames.PlayMaker.Actions,TouchGUIEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\TouchGUIEvent.cs,DoTouch,Cyclomatic complexity of the method is 14
Complex Method,HutongGames.PlayMaker.Actions,TouchGUIEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\TouchGUIEvent.cs,DoTouchOffset,Cyclomatic complexity of the method is 13
Complex Method,HutongGames.PlayMaker.Actions,TouchObjectEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\TouchObjectEvent.cs,OnUpdate,Cyclomatic complexity of the method is 17
Complex Method,HutongGames.PlayMaker.Actions,TransformInputToWorldSpace,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\TransformInputToWorldSpace.cs,OnUpdate,Cyclomatic complexity of the method is 26
Complex Method,HutongGames.PlayMaker.Actions,TriggerEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\TriggerEvent.cs,Awake,Cyclomatic complexity of the method is 9
Complex Method,HutongGames.PlayMaker.Actions,Vector3Interpolate,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Vector3Interpolate.cs,OnUpdate,Cyclomatic complexity of the method is 8
Complex Method,HutongGames.PlayMaker.Actions,Vector3Operator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Vector3Operator.cs,DoVector3Operator,Cyclomatic complexity of the method is 44
Complex Method,HutongGames.PlayMaker.Actions,iTweenMoveTo,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenMoveTo.cs,DoiTween,Cyclomatic complexity of the method is 15
Complex Method,HutongGames.PlayMaker.Actions,iTweenMoveUpdate,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenMoveUpdate.cs,OnEnter,Cyclomatic complexity of the method is 9
Complex Method,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,Cyclomatic complexity of the method is 34
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,Cyclomatic complexity of the method is 15
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,SpawnPrefabsForChunk,Cyclomatic complexity of the method is 13
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,HideTileMapPrefabs,Cyclomatic complexity of the method is 13
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,CreateRenderData,Cyclomatic complexity of the method is 15
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,GetLoopOrder,Cyclomatic complexity of the method is 35
Complex Method,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,Build,Cyclomatic complexity of the method is 8
Complex Method,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildForChunk,Cyclomatic complexity of the method is 8
Complex Method,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,Cyclomatic complexity of the method is 13
Complex Method,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,Build,Cyclomatic complexity of the method is 9
Complex Method,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildForChunk,Cyclomatic complexity of the method is 13
Complex Method,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,Cyclomatic complexity of the method is 21
Complex Method,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,Cyclomatic complexity of the method is 8
Complex Method,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,Cyclomatic complexity of the method is 10
Complex Method,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,Cyclomatic complexity of the method is 20
Complex Method,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,Build,Cyclomatic complexity of the method is 12
Complex Method,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,Cyclomatic complexity of the method is 14
Complex Method,Spine,FFDTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,Cyclomatic complexity of the method is 11
Complex Method,Spine,AnimationState,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\AnimationState.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,Spine,AnimationState,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\AnimationState.cs,Apply,Cyclomatic complexity of the method is 10
Complex Method,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,Cyclomatic complexity of the method is 13
Complex Method,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,Cyclomatic complexity of the method is 11
Complex Method,Spine,Skeleton,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Skeleton.cs,Skeleton,Cyclomatic complexity of the method is 8
Complex Method,Spine,Skeleton,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Skeleton.cs,UpdateCache,Cyclomatic complexity of the method is 13
Complex Method,Spine,SkeletonBounds,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonBounds.cs,Update,Cyclomatic complexity of the method is 8
Complex Method,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadSkeletonData,Cyclomatic complexity of the method is 29
Complex Method,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,Cyclomatic complexity of the method is 31
Complex Method,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,Cyclomatic complexity of the method is 54
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The method has 5 parameters.
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The method has 8 parameters.
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The method has 9 parameters.
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The method has 7 parameters.
Long Parameter List,tk2dRuntime.TileMap,BuilderUtil,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,SpawnPrefabsForChunk,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,BuilderUtil,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,GetLoopOrder,The method has 9 parameters.
Long Parameter List,tk2dRuntime.TileMap,BuilderUtil,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,ApplySpriteVertexTileFlags,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,BuilderUtil,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,ApplySpriteVertexTileFlags,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,Layer,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapChunks.cs,Layer,The method has 5 parameters.
Long Parameter List,tk2dRuntime.TileMap,Layer,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapChunks.cs,Init,The method has 5 parameters.
Long Parameter List,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The method has 7 parameters.
Long Parameter List,Spine,Animation,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,Animation,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Mix,The method has 6 parameters.
Long Parameter List,Spine,Timeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,CurveTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,CurveTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,SetCurve,The method has 5 parameters.
Long Parameter List,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,TranslateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,ScaleTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,ColorTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,setFrame,The method has 6 parameters.
Long Parameter List,Spine,ColorTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,AttachmentTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,EventTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,DrawOrderTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,FFDTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,IkConstraintTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,RegionAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\RegionAttachment.cs,SetUVs,The method has 5 parameters.
Long Parameter List,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The method has 6 parameters.
Long Parameter List,Spine,SkeletonBounds,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonBounds.cs,IntersectsSegment,The method has 5 parameters.
Long Statement,HutongGames.PlayMaker.Actions,PhotonNetworkConnectUsingSettings,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\Photon Unity Networking\PlayMaker\Actions\PhotonNetworkConnectUsingSettings.cs,ErrorCheck,The length of the statement  "							return "Connect to Best Server is not available on this platform' the normal connection protocol will be used instead.";" is 120.
Long Statement,HutongGames.PlayMaker.Actions,PhotonNetworkInstantiate,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\Photon Unity Networking\PlayMaker\Actions\PhotonNetworkInstantiate.cs,doInstantiate,The length of the statement  "		GameObject newObject = PhotonNetwork.Instantiate (go.name' spawnPosition' Quaternion.Euler (spawnRotation)' networkGroup.Value); " is 128.
Long Statement,HutongGames.PlayMaker.Actions,PhotonNetworkSetPlayerCustomProperty,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\Photon Unity Networking\PlayMaker\Actions\PhotonNetworkSetPlayerCustomProperty.cs,SetPlayerProperty,The length of the statement  "	Log (" set key " + customPropertyKey.Value + "=" + PlayMakerPhotonProxy.GetValueFromFsmVar (this.Fsm' customPropertyValue)); " is 124.
Long Statement,HutongGames.PlayMaker.Actions,PhotonViewRpcBroadcastFsmEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\Photon Unity Networking\PlayMaker\Actions\PhotonViewRpcBroadcastFsmEvent.cs,Reset,The length of the statement  "	// JFF: how can I set this silently without a plubic variable? if I set it to private' it doesn't work anymore. maybe I forgot a setting? " is 137.
Long Statement,HutongGames.PlayMaker.Actions,PhotonViewRpcBroadcastFsmEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\Photon Unity Networking\PlayMaker\Actions\PhotonViewRpcBroadcastFsmEvent.cs,ErrorCheck,The length of the statement  "		//return "Photon target string must be set if selected.\n Available enums: All'AllBuffered'MasterClient'Others'OthersBuffered"; " is 127.
Long Statement,HutongGames.PlayMaker.Actions,PhotonViewRpcBroadcastFsmEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\Photon Unity Networking\PlayMaker\Actions\PhotonViewRpcBroadcastFsmEvent.cs,ErrorCheck,The length of the statement  "	return "Photon target string must be set if selected.\n Available enums: All'AllBuffered'MasterClient'Others'OthersBuffered"; " is 125.
Long Statement,HutongGames.PlayMaker.Actions,PhotonViewRpcBroadcastFsmEventToPlayer,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\Photon Unity Networking\PlayMaker\Actions\PhotonViewRpcBroadcastFsmEventToPlayer.cs,Reset,The length of the statement  "	// JFF: how can I set this silently without a plubic variable? if I set it to private' it doesn't work anymore. maybe I forgot a setting? " is 137.
Long Statement,HutongGames.PlayMaker.Actions,AnimateFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateFsmAction.cs,Init,The length of the statement  "			keyOffsets [i] = curves [i].keys.Length > 0 ? (time.IsNone ? curves [i].keys [0].time : (time.Value / curves [i].keys [curves [i].length - 1].time) * curves [i].keys [0].time) : 0f; " is 181.
Long Statement,HutongGames.PlayMaker.Actions,AnimateFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateFsmAction.cs,OnUpdate,The length of the statement  "							resultFloats [k] = fromFloats [k] + curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time); " is 132.
Long Statement,HutongGames.PlayMaker.Actions,AnimateFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateFsmAction.cs,OnUpdate,The length of the statement  "							resultFloats [k] = fromFloats [k] - curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time); " is 132.
Long Statement,HutongGames.PlayMaker.Actions,AnimateFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateFsmAction.cs,OnUpdate,The length of the statement  "							resultFloats [k] = curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) - fromFloats [k]; " is 132.
Long Statement,HutongGames.PlayMaker.Actions,AnimateFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateFsmAction.cs,OnUpdate,The length of the statement  "							resultFloats [k] = curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) * fromFloats [k]; " is 132.
Long Statement,HutongGames.PlayMaker.Actions,AnimateFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateFsmAction.cs,OnUpdate,The length of the statement  "							resultFloats [k] = curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) != 0f ? fromFloats [k] / curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) : float.MaxValue; " is 253.
Long Statement,HutongGames.PlayMaker.Actions,AnimateFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateFsmAction.cs,OnUpdate,The length of the statement  "							resultFloats [k] = curves [k].Evaluate (currentTime) != 0 ? fromFloats [k] / curves [k].Evaluate (currentTime) : float.MaxValue; " is 128.
Long Statement,HutongGames.PlayMaker.Actions,AnimateFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateFsmAction.cs,OnUpdate,The length of the statement  "							resultFloats [k] = fromFloats [k] != 0f ? curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) / fromFloats [k] : float.MaxValue; " is 172.
Long Statement,HutongGames.PlayMaker.Actions,CurveFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveFsmAction.cs,Init,The length of the statement  "			keyOffsets [i] = curves [i].keys.Length > 0 ? (time.IsNone ? curves [i].keys [0].time : (time.Value / curves [i].keys [curves [i].length - 1].time) * curves [i].keys [0].time) : 0f; " is 181.
Long Statement,HutongGames.PlayMaker.Actions,CurveFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveFsmAction.cs,OnUpdate,The length of the statement  "							resultFloats [k] = fromFloats [k] + (distances [k] * (currentTime / time.Value) + curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time)); " is 179.
Long Statement,HutongGames.PlayMaker.Actions,CurveFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveFsmAction.cs,OnUpdate,The length of the statement  "							resultFloats [k] = fromFloats [k] + (distances [k] * (currentTime / time.Value) - curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time)); " is 179.
Long Statement,HutongGames.PlayMaker.Actions,CurveFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveFsmAction.cs,OnUpdate,The length of the statement  "							resultFloats [k] = (curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) - distances [k] * (currentTime / time.Value)) + fromFloats [k]; " is 179.
Long Statement,HutongGames.PlayMaker.Actions,CurveFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveFsmAction.cs,OnUpdate,The length of the statement  "							resultFloats [k] = (curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) * distances [k] * (currentTime / time.Value)) + fromFloats [k]; " is 179.
Long Statement,HutongGames.PlayMaker.Actions,CurveFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveFsmAction.cs,OnUpdate,The length of the statement  "							resultFloats [k] = curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) != 0f ? fromFloats [k] + (distances [k] * (currentTime / time.Value)) / curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) : float.MaxValue; " is 300.
Long Statement,HutongGames.PlayMaker.Actions,CurveFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveFsmAction.cs,OnUpdate,The length of the statement  "							resultFloats [k] = curves [k].Evaluate (currentTime) != 0 ? fromFloats [k] + (distances [k] * (currentTime / endTimes [k])) / curves [k].Evaluate (currentTime) : float.MaxValue; " is 177.
Long Statement,HutongGames.PlayMaker.Actions,CurveFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveFsmAction.cs,OnUpdate,The length of the statement  "							resultFloats [k] = fromFloats [k] != 0f ? curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) / (distances [k] * (currentTime / time.Value)) + fromFloats [k] : float.MaxValue; " is 219.
Long Statement,HutongGames.PlayMaker.Actions,CurveFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveFsmAction.cs,OnUpdate,The length of the statement  "							resultFloats [k] = fromFloats [k] != 0 ? curves [k].Evaluate (currentTime) / (distances [k] * (currentTime / endTimes [k])) + fromFloats [k] : float.MaxValue; " is 158.
Long Statement,HutongGames.PlayMaker.Actions,EaseColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseColor.cs,OnUpdate,The length of the statement  "			colorVariable.Value = new Color (reverse.IsNone ? toValue.Value.r : reverse.Value ? fromValue.Value.r : toValue.Value.r' reverse.IsNone ? toValue.Value.g : reverse.Value ? fromValue.Value.g : toValue.Value.g' reverse.IsNone ? toValue.Value.b : reverse.Value ? fromValue.Value.b : toValue.Value.b' reverse.IsNone ? toValue.Value.a : reverse.Value ? fromValue.Value.a : toValue.Value.a); " is 385.
Long Statement,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,spring,The length of the statement  "	value = (Mathf.Sin (value * Mathf.PI * (0.2f + 2.5f * value * value * value)) * Mathf.Pow (1f - value' 2.2f) + value) * (1f + (1.2f * (1f - value))); " is 149.
Long Statement,HutongGames.PlayMaker.Actions,EaseRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseRect.cs,OnUpdate,The length of the statement  "			rectVariable.Value = new Rect (reverse.IsNone ? toValue.Value.x : reverse.Value ? fromValue.Value.x : toValue.Value.x' reverse.IsNone ? toValue.Value.y : reverse.Value ? fromValue.Value.y : toValue.Value.y' reverse.IsNone ? toValue.Value.width : reverse.Value ? fromValue.Value.width : toValue.Value.width' reverse.IsNone ? toValue.Value.height : reverse.Value ? fromValue.Value.height : toValue.Value.height); " is 410.
Long Statement,HutongGames.PlayMaker.Actions,EaseVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseVector3.cs,OnUpdate,The length of the statement  "			vector3Variable.Value = new Vector3 (reverse.IsNone ? toValue.Value.x : reverse.Value ? fromValue.Value.x : toValue.Value.x' reverse.IsNone ? toValue.Value.y : reverse.Value ? fromValue.Value.y : toValue.Value.y' reverse.IsNone ? toValue.Value.z : reverse.Value ? fromValue.Value.z : toValue.Value.z); " is 301.
Long Statement,HutongGames.PlayMaker.Actions,CallMethod,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\CallMethod.cs,ErrorCheck,The length of the statement  "		return "Parameter count does not match method.\nMethod has " + cachedParameterInfo.Length + " parameters.\nYou specified " + parameters.Length + " paramaters."; " is 160.
Long Statement,HutongGames.PlayMaker.Actions,CallMethod,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\CallMethod.cs,ErrorCheck,The length of the statement  "			return "Parameters do not match method signature.\nParameter " + (i + 1) + " (" + paramType + ") should be of type: " + paramInfoType; " is 134.
Long Statement,HutongGames.PlayMaker.Actions,GUIHorizontalSlider,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GUIHorizontalSlider.cs,OnGUI,The length of the statement  "		floatVariable.Value = GUI.HorizontalSlider (rect' floatVariable.Value' leftValue.Value' rightValue.Value' sliderStyle.Value != "" ? sliderStyle.Value : "horizontalslider"' thumbStyle.Value != "" ? thumbStyle.Value : "horizontalsliderthumb"); " is 241.
Long Statement,HutongGames.PlayMaker.Actions,GUILayoutBeginScrollView,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GUILayoutBeginScrollView.cs,OnGUI,The length of the statement  "		scrollPosition.Value = GUILayout.BeginScrollView (scrollPosition.Value' horizontalScrollbar.Value' verticalScrollbar.Value' horizontalStyle.Value' verticalStyle.Value' backgroundStyle.Value' LayoutOptions); " is 206.
Long Statement,HutongGames.PlayMaker.Actions,GUILayoutBeginScrollView,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GUILayoutBeginScrollView.cs,OnGUI,The length of the statement  "		scrollPosition.Value = GUILayout.BeginScrollView (scrollPosition.Value' horizontalScrollbar.Value' verticalScrollbar.Value' LayoutOptions); " is 139.
Long Statement,HutongGames.PlayMaker.Actions,GUILayoutHorizontalSlider,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GUILayoutHorizontalSlider.cs,OnGUI,The length of the statement  "		floatVariable.Value = GUILayout.HorizontalSlider (floatVariable.Value' leftValue.Value' rightValue.Value' LayoutOptions); " is 121.
Long Statement,HutongGames.PlayMaker.Actions,GUILayoutRepeatButton,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GUILayoutRepeatButton.cs,OnGUI,The length of the statement  "		buttonPressed = GUILayout.RepeatButton (new GUIContent (text.Value' image.Value' tooltip.Value)' style.Value' LayoutOptions); " is 125.
Long Statement,HutongGames.PlayMaker.Actions,GUILayoutToggle,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GUILayoutToggle.cs,OnGUI,The length of the statement  "	storeButtonState.Value = GUILayout.Toggle (storeButtonState.Value' new GUIContent (text.Value' image.Value' tooltip.Value)' style.Value' LayoutOptions); " is 152.
Long Statement,HutongGames.PlayMaker.Actions,GUIVerticalSlider,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GUIVerticalSlider.cs,OnGUI,The length of the statement  "		floatVariable.Value = GUI.VerticalSlider (rect' floatVariable.Value' topValue.Value' bottomValue.Value' sliderStyle.Value != "" ? sliderStyle.Value : "verticalslider"' thumbStyle.Value != "" ? thumbStyle.Value : "verticalsliderthumb"); " is 235.
Long Statement,HutongGames.PlayMaker.Actions,GetAngleToTarget,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GetAngleToTarget.cs,DoGetAngleToTarget,The length of the statement  "		targetPos = !targetPosition.IsNone ? goTarget.transform.TransformPoint (targetPosition.Value) : goTarget.transform.position; " is 124.
Long Statement,HutongGames.PlayMaker.Actions,GetAxisVector,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GetAxisVector.cs,OnUpdate,The length of the statement  "	var h = (horizontalAxis.IsNone || string.IsNullOrEmpty (horizontalAxis.Value)) ? 0f : Input.GetAxis (horizontalAxis.Value); " is 123.
Long Statement,HutongGames.PlayMaker.Actions,LookAt,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\LookAt.cs,UpdateLookAtPosition,The length of the statement  "		lookAtPos = !targetPosition.IsNone ? goTarget.transform.TransformPoint (targetPosition.Value) : goTarget.transform.position; " is 124.
Long Statement,HutongGames.PlayMaker.Actions,MousePick,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\MousePick.cs,DoMousePick,The length of the statement  "	RaycastHit hitInfo = ActionHelpers.MousePick (rayDistance.Value' ActionHelpers.LayerArrayToLayerMask (layerMask' invertMask.Value)); " is 132.
Long Statement,HutongGames.PlayMaker.Actions,MousePickEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\MousePickEvent.cs,DoRaycast,The length of the statement  "	return ActionHelpers.IsMouseOver (testObject' rayDistance.Value' ActionHelpers.LayerArrayToLayerMask (layerMask' invertMask.Value)); " is 132.
Long Statement,HutongGames.PlayMaker.Actions,MoveTowards,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\MoveTowards.cs,UpdateTargetPos,The length of the statement  "		targetPos = !targetPosition.IsNone ? goTarget.transform.TransformPoint (targetPosition.Value) : goTarget.transform.position; " is 124.
Long Statement,HutongGames.PlayMaker.Actions,NetworkInstantiate,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Network\NetworkInstantiate.cs,OnEnter,The length of the statement  "		var newObject = (GameObject)Network.Instantiate (go' spawnPosition' Quaternion.Euler (spawnRotation)' networkGroup.Value); " is 122.
Long Statement,HutongGames.PlayMaker.Actions,RebuildTextures,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\ProceduralMaterial\RebuildTextures.cs,DoRebuildTextures,The length of the statement  "	#if !(UNITY_IPHONE || UNITY_ANDROID || UNITY_NACL || UNITY_FLASH || UNITY_PS3 || UNITY_BLACKBERRY || UNITY_METRO || UNITY_WP8) " is 126.
Long Statement,HutongGames.PlayMaker.Actions,SetProceduralBoolean,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\ProceduralMaterial\SetProceduralBoolean.cs,DoSetProceduralFloat,The length of the statement  "	#if !(UNITY_IPHONE || UNITY_ANDROID || UNITY_NACL || UNITY_FLASH || UNITY_PS3 || UNITY_BLACKBERRY || UNITY_METRO || UNITY_WP8) " is 126.
Long Statement,HutongGames.PlayMaker.Actions,SetProceduralColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\ProceduralMaterial\SetProceduralColor.cs,DoSetProceduralFloat,The length of the statement  "	#if !(UNITY_IPHONE || UNITY_ANDROID || UNITY_NACL || UNITY_FLASH || UNITY_PS3 || UNITY_BLACKBERRY || UNITY_METRO || UNITY_WP8) " is 126.
Long Statement,HutongGames.PlayMaker.Actions,SetProceduralFloat,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\ProceduralMaterial\SetProceduralFloat.cs,DoSetProceduralFloat,The length of the statement  "	#if !(UNITY_IPHONE || UNITY_ANDROID || UNITY_NACL || UNITY_FLASH || UNITY_PS3 || UNITY_BLACKBERRY || UNITY_METRO || UNITY_WP8) " is 126.
Long Statement,HutongGames.PlayMaker.Actions,Raycast,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Raycast.cs,DoRaycast,The length of the statement  "	Physics.Raycast (originPos' dirVector' out hitInfo' rayLength' ActionHelpers.LayerArrayToLayerMask (layerMask' invertMask.Value)); " is 130.
Long Statement,HutongGames.PlayMaker.Actions,ScreenPick,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\ScreenPick.cs,DoScreenPick,The length of the statement  "	Physics.Raycast (ray' out hitInfo' rayDistance.Value' ActionHelpers.LayerArrayToLayerMask (layerMask' invertMask.Value)); " is 121.
Long Statement,HutongGames.PlayMaker.Actions,SetVelocity,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SetVelocity.cs,DoSetVelocity,The length of the statement  "		velocity = space == Space.World ? go.rigidbody.velocity : go.transform.InverseTransformDirection (go.rigidbody.velocity); " is 121.
Long Statement,HutongGames.PlayMaker.Actions,SmoothFollowAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SmoothFollowAction.cs,OnLateUpdate,The length of the statement  "	currentRotationAngle = Mathf.LerpAngle (currentRotationAngle' wantedRotationAngle' rotationDamping.Value * Time.deltaTime); " is 123.
Long Statement,HutongGames.PlayMaker.Actions,SmoothLookAt,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SmoothLookAt.cs,DoSmoothLookAt,The length of the statement  "		lookAtPos = !targetPosition.IsNone ? goTarget.transform.TransformPoint (targetPosition.Value) : goTarget.transform.position; " is 124.
Long Statement,HutongGames.PlayMaker.Actions,StartLocationServiceUpdates,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\StartLocationServiceUpdates.cs,OnUpdate,The length of the statement  "	if (Input.location.status == LocationServiceStatus.Failed || Input.location.status == LocationServiceStatus.Stopped || (FsmTime.RealtimeSinceStartup - startTime) > maxWait.Value) { " is 180.
Long Statement,HutongGames.PlayMaker.Actions,Vector3HighPassFilter,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Vector3HighPassFilter.cs,OnUpdate,The length of the statement  "	filteredVector.x = vector3Variable.Value.x - ((vector3Variable.Value.x * filteringFactor.Value) + (filteredVector.x * (1.0f - filteringFactor.Value))); " is 151.
Long Statement,HutongGames.PlayMaker.Actions,Vector3HighPassFilter,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Vector3HighPassFilter.cs,OnUpdate,The length of the statement  "	filteredVector.y = vector3Variable.Value.y - ((vector3Variable.Value.y * filteringFactor.Value) + (filteredVector.y * (1.0f - filteringFactor.Value))); " is 151.
Long Statement,HutongGames.PlayMaker.Actions,Vector3HighPassFilter,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Vector3HighPassFilter.cs,OnUpdate,The length of the statement  "	filteredVector.z = vector3Variable.Value.z - ((vector3Variable.Value.z * filteringFactor.Value) + (filteredVector.z * (1.0f - filteringFactor.Value))); " is 151.
Long Statement,HutongGames.PlayMaker.Actions,Vector3LowPassFilter,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Vector3LowPassFilter.cs,OnUpdate,The length of the statement  "	filteredVector.x = (vector3Variable.Value.x * filteringFactor.Value) + (filteredVector.x * (1.0f - filteringFactor.Value)); " is 123.
Long Statement,HutongGames.PlayMaker.Actions,Vector3LowPassFilter,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Vector3LowPassFilter.cs,OnUpdate,The length of the statement  "	filteredVector.y = (vector3Variable.Value.y * filteringFactor.Value) + (filteredVector.y * (1.0f - filteringFactor.Value)); " is 123.
Long Statement,HutongGames.PlayMaker.Actions,Vector3LowPassFilter,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Vector3LowPassFilter.cs,OnUpdate,The length of the statement  "	filteredVector.z = (vector3Variable.Value.z * filteringFactor.Value) + (filteredVector.z * (1.0f - filteringFactor.Value)); " is 123.
Long Statement,HutongGames.PlayMaker.Actions,Vector3RotateTowards,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Vector3RotateTowards.cs,OnUpdate,The length of the statement  "	currentDirection.Value = Vector3.RotateTowards (currentDirection.Value' targetDirection.Value' rotateSpeed.Value * Mathf.Deg2Rad * Time.deltaTime' maxMagnitude.Value); " is 167.
Long Statement,HutongGames.PlayMaker.Actions,iTweenLookFrom,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenLookFrom.cs,DoiTween,The length of the statement  "	iTween.LookFrom (go' iTween.Hash ("looktarget"' pos' "name"' id.IsNone ? "" : id.Value' speed.IsNone ? "time" : "speed"' speed.IsNone ? time.IsNone ? 1f : time.Value : speed.Value' "delay"' delay.IsNone ? 0f : delay.Value' "easetype"' easeType' "looptype"' loopType' "oncomplete"' "iTweenOnComplete"' "oncompleteparams"' itweenID' "onstart"' "iTweenOnStart"' "onstartparams"' itweenID' "ignoretimescale"' realTime.IsNone ? false : realTime.Value' "axis"' axis == iTweenFsmAction.AxisRestriction.none ? "" : System.Enum.GetName (typeof(iTweenFsmAction.AxisRestriction)' axis))); " is 577.
Long Statement,HutongGames.PlayMaker.Actions,iTweenLookTo,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenLookTo.cs,DoiTween,The length of the statement  "	iTween.LookTo (go' iTween.Hash ("looktarget"' pos' "name"' id.IsNone ? "" : id.Value' speed.IsNone ? "time" : "speed"' speed.IsNone ? time.IsNone ? 1f : time.Value : speed.Value' "delay"' delay.IsNone ? 0f : delay.Value' "easetype"' easeType' "looptype"' loopType' "oncomplete"' "iTweenOnComplete"' "oncompleteparams"' itweenID' "onstart"' "iTweenOnStart"' "onstartparams"' itweenID' "ignoretimescale"' realTime.IsNone ? false : realTime.Value' "axis"' axis == iTweenFsmAction.AxisRestriction.none ? "" : System.Enum.GetName (typeof(iTweenFsmAction.AxisRestriction)' axis))); " is 575.
Long Statement,HutongGames.PlayMaker.Actions,iTweenLookUpdate,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenLookUpdate.cs,OnEnter,The length of the statement  "	hash.Add ("axis"' axis == iTweenFsmAction.AxisRestriction.none ? "" : System.Enum.GetName (typeof(iTweenFsmAction.AxisRestriction)' axis)); " is 139.
Long Statement,HutongGames.PlayMaker.Actions,iTweenMoveAdd,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenMoveAdd.cs,DoiTween,The length of the statement  "	hash.Add ("axis"' axis == iTweenFsmAction.AxisRestriction.none ? "" : System.Enum.GetName (typeof(iTweenFsmAction.AxisRestriction)' axis)); " is 139.
Long Statement,HutongGames.PlayMaker.Actions,iTweenMoveAdd,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenMoveAdd.cs,DoiTween,The length of the statement  "		hash.Add ("looktarget"' lookAtVector.IsNone ? lookAtObject.Value.transform.position : lookAtObject.Value.transform.position + lookAtVector.Value); " is 146.
Long Statement,HutongGames.PlayMaker.Actions,iTweenMoveBy,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenMoveBy.cs,DoiTween,The length of the statement  "	hash.Add ("axis"' axis == iTweenFsmAction.AxisRestriction.none ? "" : System.Enum.GetName (typeof(iTweenFsmAction.AxisRestriction)' axis)); " is 139.
Long Statement,HutongGames.PlayMaker.Actions,iTweenMoveBy,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenMoveBy.cs,DoiTween,The length of the statement  "		hash.Add ("looktarget"' lookAtVector.IsNone ? lookAtObject.Value.transform.position : lookAtObject.Value.transform.position + lookAtVector.Value); " is 146.
Long Statement,HutongGames.PlayMaker.Actions,iTweenMoveFrom,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenMoveFrom.cs,DoiTween,The length of the statement  "			pos = (space == Space.World || go.transform.parent == null) ? transformPosition.Value.transform.position + pos : go.transform.parent.InverseTransformPoint (transformPosition.Value.transform.position) + pos; " is 206.
Long Statement,HutongGames.PlayMaker.Actions,iTweenMoveFrom,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenMoveFrom.cs,DoiTween,The length of the statement  "	hash.Add ("axis"' axis == iTweenFsmAction.AxisRestriction.none ? "" : System.Enum.GetName (typeof(iTweenFsmAction.AxisRestriction)' axis)); " is 139.
Long Statement,HutongGames.PlayMaker.Actions,iTweenMoveFrom,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenMoveFrom.cs,DoiTween,The length of the statement  "		hash.Add ("looktarget"' lookAtVector.IsNone ? lookAtObject.Value.transform.position : lookAtObject.Value.transform.position + lookAtVector.Value); " is 146.
Long Statement,HutongGames.PlayMaker.Actions,iTweenMoveTo,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenMoveTo.cs,DoiTween,The length of the statement  "			pos = (space == Space.World || go.transform.parent == null) ? transformPosition.Value.transform.position + pos : go.transform.parent.InverseTransformPoint (transformPosition.Value.transform.position) + pos; " is 206.
Long Statement,HutongGames.PlayMaker.Actions,iTweenMoveTo,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenMoveTo.cs,DoiTween,The length of the statement  "	hash.Add ("axis"' axis == iTweenFsmAction.AxisRestriction.none ? "" : System.Enum.GetName (typeof(iTweenFsmAction.AxisRestriction)' axis)); " is 139.
Long Statement,HutongGames.PlayMaker.Actions,iTweenMoveTo,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenMoveTo.cs,DoiTween,The length of the statement  "		hash.Add ("looktarget"' lookAtVector.IsNone ? lookAtObject.Value.transform.position : lookAtObject.Value.transform.position + lookAtVector.Value); " is 146.
Long Statement,HutongGames.PlayMaker.Actions,iTweenMoveTo,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenMoveTo.cs,DoiTween,The length of the statement  "						tempVct3 [tempVct3.Length - 1 - i] = (space == Space.World ? transforms [i].Value.transform.position : transforms [i].Value.transform.localPosition) + (vectors [i].IsNone ? Vector3.zero : vectors [i].Value); " is 207.
Long Statement,HutongGames.PlayMaker.Actions,iTweenMoveTo,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenMoveTo.cs,DoiTween,The length of the statement  "						tempVct3 [i] = (space == Space.World ? transforms [i].Value.transform.position : go.transform.parent.InverseTransformPoint (transforms [i].Value.transform.position)) + (vectors [i].IsNone ? Vector3.zero : vectors [i].Value); " is 224.
Long Statement,HutongGames.PlayMaker.Actions,iTweenMoveUpdate,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenMoveUpdate.cs,OnEnter,The length of the statement  "				hash.Add ("position"' go.transform.parent.InverseTransformPoint (transformPosition.Value.transform.position) + vectorPosition.Value); " is 133.
Long Statement,HutongGames.PlayMaker.Actions,iTweenMoveUpdate,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenMoveUpdate.cs,OnEnter,The length of the statement  "	hash.Add ("axis"' axis == iTweenFsmAction.AxisRestriction.none ? "" : System.Enum.GetName (typeof(iTweenFsmAction.AxisRestriction)' axis)); " is 139.
Long Statement,HutongGames.PlayMaker.Actions,iTweenPunchPosition,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenPunchPosition.cs,DoiTween,The length of the statement  "	iTween.PunchPosition (go' iTween.Hash ("amount"' amount' "name"' id.IsNone ? "" : id.Value' "time"' time.IsNone ? 1f : time.Value' "delay"' delay.IsNone ? 0f : delay.Value' "looptype"' loopType' "oncomplete"' "iTweenOnComplete"' "oncompleteparams"' itweenID' "onstart"' "iTweenOnStart"' "onstartparams"' itweenID' "ignoretimescale"' realTime.IsNone ? false : realTime.Value' "space"' space' "axis"' axis == iTweenFsmAction.AxisRestriction.none ? "" : System.Enum.GetName (typeof(iTweenFsmAction.AxisRestriction)' axis))); " is 521.
Long Statement,HutongGames.PlayMaker.Actions,iTweenPunchRotation,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenPunchRotation.cs,DoiTween,The length of the statement  "	iTween.PunchRotation (go' iTween.Hash ("amount"' amount' "name"' id.IsNone ? "" : id.Value' "time"' time.IsNone ? 1f : time.Value' "delay"' delay.IsNone ? 0f : delay.Value' "looptype"' loopType' "oncomplete"' "iTweenOnComplete"' "oncompleteparams"' itweenID' "onstart"' "iTweenOnStart"' "onstartparams"' itweenID' "ignoretimescale"' realTime.IsNone ? false : realTime.Value' "space"' space)); " is 392.
Long Statement,HutongGames.PlayMaker.Actions,iTweenPunchScale,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenPunchScale.cs,DoiTween,The length of the statement  "	iTween.PunchScale (go' iTween.Hash ("amount"' amount' "name"' id.IsNone ? "" : id.Value' "time"' time.IsNone ? 1f : time.Value' "delay"' delay.IsNone ? 0f : delay.Value' "looptype"' loopType' "oncomplete"' "iTweenOnComplete"' "oncompleteparams"' itweenID' "onstart"' "iTweenOnStart"' "onstartparams"' itweenID' "ignoretimescale"' realTime.IsNone ? false : realTime.Value)); " is 373.
Long Statement,HutongGames.PlayMaker.Actions,iTweenRotateAdd,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenRotateAdd.cs,DoiTween,The length of the statement  "	iTween.RotateAdd (go' iTween.Hash ("amount"' amount' "name"' id.IsNone ? "" : id.Value' speed.IsNone ? "time" : "speed"' speed.IsNone ? time.IsNone ? 1f : time.Value : speed.Value' "delay"' delay.IsNone ? 0f : delay.Value' "easetype"' easeType' "looptype"' loopType' "oncomplete"' "iTweenOnComplete"' "oncompleteparams"' itweenID' "onstart"' "iTweenOnStart"' "onstartparams"' itweenID' "ignoretimescale"' realTime.IsNone ? false : realTime.Value' "space"' space)); " is 464.
Long Statement,HutongGames.PlayMaker.Actions,iTweenRotateBy,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenRotateBy.cs,DoiTween,The length of the statement  "	iTween.RotateBy (go' iTween.Hash ("amount"' amount' "name"' id.IsNone ? "" : id.Value' speed.IsNone ? "time" : "speed"' speed.IsNone ? time.IsNone ? 1f : time.Value : speed.Value' "delay"' delay.IsNone ? 0f : delay.Value' "easetype"' easeType' "looptype"' loopType' "oncomplete"' "iTweenOnComplete"' "oncompleteparams"' itweenID' "onstart"' "iTweenOnStart"' "onstartparams"' itweenID' "ignoretimescale"' realTime.IsNone ? false : realTime.Value' "space"' space)); " is 463.
Long Statement,HutongGames.PlayMaker.Actions,iTweenRotateFrom,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenRotateFrom.cs,DoiTween,The length of the statement  "			rot = space == Space.World ? transformRotation.Value.transform.eulerAngles + rot : transformRotation.Value.transform.localEulerAngles + rot; " is 140.
Long Statement,HutongGames.PlayMaker.Actions,iTweenRotateFrom,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenRotateFrom.cs,DoiTween,The length of the statement  "	iTween.RotateFrom (go' iTween.Hash ("rotation"' rot' "name"' id.IsNone ? "" : id.Value' speed.IsNone ? "time" : "speed"' speed.IsNone ? time.IsNone ? 1f : time.Value : speed.Value' "delay"' delay.IsNone ? 0f : delay.Value' "easetype"' easeType' "looptype"' loopType' "oncomplete"' "iTweenOnComplete"' "oncompleteparams"' itweenID' "onstart"' "iTweenOnStart"' "onstartparams"' itweenID' "ignoretimescale"' realTime.IsNone ? false : realTime.Value' "islocal"' space == Space.Self)); " is 480.
Long Statement,HutongGames.PlayMaker.Actions,iTweenRotateTo,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenRotateTo.cs,DoiTween,The length of the statement  "			rot = space == Space.World ? transformRotation.Value.transform.eulerAngles + rot : transformRotation.Value.transform.localEulerAngles + rot; " is 140.
Long Statement,HutongGames.PlayMaker.Actions,iTweenRotateTo,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenRotateTo.cs,DoiTween,The length of the statement  "	iTween.RotateTo (go' iTween.Hash ("rotation"' rot' "name"' id.IsNone ? "" : id.Value' speed.IsNone ? "time" : "speed"' speed.IsNone ? time.IsNone ? 1f : time.Value : speed.Value' "delay"' delay.IsNone ? 0f : delay.Value' "easetype"' easeType' "looptype"' loopType' "oncomplete"' "iTweenOnComplete"' "oncompleteparams"' itweenID' "onstart"' "iTweenOnStart"' "onstartparams"' itweenID' "ignoretimescale"' realTime.IsNone ? false : realTime.Value' "islocal"' space == Space.Self)); " is 478.
Long Statement,HutongGames.PlayMaker.Actions,iTweenScaleAdd,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenScaleAdd.cs,DoiTween,The length of the statement  "	iTween.ScaleAdd (go' iTween.Hash ("amount"' amount' "name"' id.IsNone ? "" : id.Value' speed.IsNone ? "time" : "speed"' speed.IsNone ? time.IsNone ? 1f : time.Value : speed.Value' "delay"' delay.IsNone ? 0f : delay.Value' "easetype"' easeType' "looptype"' loopType' "oncomplete"' "iTweenOnComplete"' "oncompleteparams"' itweenID' "onstart"' "iTweenOnStart"' "onstartparams"' itweenID' "ignoretimescale"' realTime.IsNone ? false : realTime.Value)); " is 447.
Long Statement,HutongGames.PlayMaker.Actions,iTweenScaleBy,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenScaleBy.cs,DoiTween,The length of the statement  "	iTween.ScaleBy (go' iTween.Hash ("amount"' amount' "name"' id.IsNone ? "" : id.Value' speed.IsNone ? "time" : "speed"' speed.IsNone ? time.IsNone ? 1f : time.Value : speed.Value' "delay"' delay.IsNone ? 0f : delay.Value' "easetype"' easeType' "looptype"' loopType' "oncomplete"' "iTweenOnComplete"' "oncompleteparams"' itweenID' "onstart"' "iTweenOnStart"' "onstartparams"' itweenID' "ignoretimescale"' realTime.IsNone ? false : realTime.Value)); " is 446.
Long Statement,HutongGames.PlayMaker.Actions,iTweenScaleFrom,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenScaleFrom.cs,DoiTween,The length of the statement  "	iTween.ScaleFrom (go' iTween.Hash ("scale"' scl' "name"' id.IsNone ? "" : id.Value' speed.IsNone ? "time" : "speed"' speed.IsNone ? time.IsNone ? 1f : time.Value : speed.Value' "delay"' delay.IsNone ? 0f : delay.Value' "easetype"' easeType' "looptype"' loopType' "oncomplete"' "iTweenOnComplete"' "oncompleteparams"' itweenID' "onstart"' "iTweenOnStart"' "onstartparams"' itweenID' "ignoretimescale"' realTime.IsNone ? false : realTime.Value)); " is 444.
Long Statement,HutongGames.PlayMaker.Actions,iTweenScaleTo,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenScaleTo.cs,DoiTween,The length of the statement  "	iTween.ScaleTo (go' iTween.Hash ("scale"' scl' "name"' id.IsNone ? "" : id.Value' speed.IsNone ? "time" : "speed"' speed.IsNone ? time.IsNone ? 1f : time.Value : speed.Value' "delay"' delay.IsNone ? 0f : delay.Value' "easetype"' easeType' "looptype"' loopType' "oncomplete"' "iTweenOnComplete"' "oncompleteparams"' itweenID' "onstart"' "iTweenOnStart"' "onstartparams"' itweenID' "ignoretimescale"' realTime.IsNone ? false : realTime.Value)); " is 442.
Long Statement,HutongGames.PlayMaker.Actions,iTweenShakePosition,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenShakePosition.cs,DoiTween,The length of the statement  "	iTween.ShakePosition (go' iTween.Hash ("amount"' amount' "name"' id.IsNone ? "" : id.Value' "time"' time.IsNone ? 1f : time.Value' "delay"' delay.IsNone ? 0f : delay.Value' "looptype"' loopType' "oncomplete"' "iTweenOnComplete"' "oncompleteparams"' itweenID' "onstart"' "iTweenOnStart"' "onstartparams"' itweenID' "ignoretimescale"' realTime.IsNone ? false : realTime.Value' "space"' space' "axis"' axis == iTweenFsmAction.AxisRestriction.none ? "" : System.Enum.GetName (typeof(iTweenFsmAction.AxisRestriction)' axis))); " is 521.
Long Statement,HutongGames.PlayMaker.Actions,iTweenShakeRotation,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenShakeRotation.cs,DoiTween,The length of the statement  "	iTween.ShakeRotation (go' iTween.Hash ("amount"' amount' "name"' id.IsNone ? "" : id.Value' "time"' time.IsNone ? 1f : time.Value' "delay"' delay.IsNone ? 0f : delay.Value' "looptype"' loopType' "oncomplete"' "iTweenOnComplete"' "oncompleteparams"' itweenID' "onstart"' "iTweenOnStart"' "onstartparams"' itweenID' "ignoretimescale"' realTime.IsNone ? false : realTime.Value' "space"' space)); " is 392.
Long Statement,HutongGames.PlayMaker.Actions,iTweenShakeScale,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenShakeScale.cs,DoiTween,The length of the statement  "	iTween.ShakeScale (go' iTween.Hash ("amount"' amount' "name"' id.IsNone ? "" : id.Value' "time"' time.IsNone ? 1f : time.Value' "delay"' delay.IsNone ? 0f : delay.Value' "looptype"' loopType' "oncomplete"' "iTweenOnComplete"' "oncompleteparams"' itweenID' "onstart"' "iTweenOnStart"' "onstartparams"' itweenID' "ignoretimescale"' realTime.IsNone ? false : realTime.Value)); " is 373.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The length of the statement  "			UnityEditor.EditorUtility.DisplayDialog ("tk2dRuntimeSpriteCollection Error"' "The tk2d/BlendVertexColor shader needs to be in a resources folder for this to work.\n\n" + "Create a subdirectory named 'resources' where the shaders are' and move the BlendVertexColor shader into this directory.\n\n" + "eg. TK2DROOT/tk2d/Shaders/Resources/BlendVertexColor\n\n" + "Be sure to do this from within Unity and not from Explorer/Finder."' "Ok"); " is 437.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The length of the statement  "		sc.spriteDefinitions [i] = CreateDefinitionForRegionInTexture (names [i]' textureDimensions' scale' regions [i]' trimRect' anchors [i]' defRotated); " is 148.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The length of the statement  "	Vector2 v0 = new Vector2 ((uvRegion.x + uvOffset.x) / fwidth' 1.0f - (uvRegion.y + uvRegion.height + uvOffset.y) / fheight); " is 124.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The length of the statement  "	Vector2 v1 = new Vector2 ((uvRegion.x + uvRegion.width - uvOffset.x) / fwidth' 1.0f - (uvRegion.y - uvOffset.y) / fheight); " is 123.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The length of the statement  "							entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4])); " is 123.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The length of the statement  "	return CreateFromTexture (texture' spriteCollectionSize' textureDimensions' names.ToArray ()' rects.ToArray ()' trimRects.ToArray ()' anchors.ToArray ()' rotated.ToArray ()); " is 174.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,The length of the statement  "			tileMap.Layers [i] = new Layer (tileMap.data.Layers [i].hash' tileMap.width' tileMap.height' tileMap.partitionSizeX' tileMap.partitionSizeY); " is 141.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,The length of the statement  "				newLayers [i] = new Layer (layerInfo.hash' tileMap.width' tileMap.height' tileMap.partitionSizeX' tileMap.partitionSizeY); " is 122.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,The length of the statement  "		tileMap.ColorChannel = new ColorChannel (tileMap.width' tileMap.height' tileMap.partitionSizeX' tileMap.partitionSizeY); " is 120.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,CreateRenderData,The length of the statement  "			layer.gameObject.transform.localPosition = new Vector3 (0' 0' tileMap.data.layersFixedZ ? (-layerInfoZ) : accumulatedLayerZ); " is 125.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,CreateRenderData,The length of the statement  "		BuilderUtil.GetLoopOrder (tileMap.data.sortMethod' layer.numColumns' layer.numRows' out x0' out x1' out dx' out y0' out y1' out dy); " is 132.
Long Statement,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The length of the statement  "					Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90); " is 136.
Long Statement,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The length of the statement  "	BuilderUtil.GetLoopOrder (tileMap.data.sortMethod' tileMap.partitionSizeX' tileMap.partitionSizeY' out x0' out x1' out dx' out y0' out y1' out dy); " is 147.
Long Statement,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The length of the statement  "				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' sprite' sprite.positions [v]' flipH' flipV' rot90); " is 121.
Long Statement,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The length of the statement  "					Color color = Color.Lerp (Color.Lerp (tileColorx0y0' tileColorx1y0' tileColorX)' Color.Lerp (tileColorx0y1' tileColorx1y1' tileColorX)' tileColorY); " is 148.
Long Statement,Spine,ScaleTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The length of the statement  "	bone.scaleX += (bone.data.scaleX - 1 + lastFrameX + (frames [frameIndex + FRAME_X] - lastFrameX) * percent - bone.scaleX) * alpha; " is 130.
Long Statement,Spine,ScaleTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The length of the statement  "	bone.scaleY += (bone.data.scaleY - 1 + lastFrameY + (frames [frameIndex + FRAME_Y] - lastFrameY) * percent - bone.scaleY) * alpha; " is 130.
Long Statement,Spine,AttachmentTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The length of the statement  "	skeleton.slots [slotIndex].Attachment = attachmentName == null ? null : skeleton.GetAttachment (slotIndex' attachmentName); " is 123.
Long Statement,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The length of the statement  "		child.rotationIK = childRotation + ((float)Math.Atan2 (targetY' targetX) * radDeg - parentRotation - childRotation) * alpha; " is 124.
Long Statement,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The length of the statement  "	float parentAngle = (float)Math.Atan2 (targetY * adjacent - targetX * opposite' targetX * adjacent + targetY * opposite); " is 121.
Long Statement,Spine,SkeletonBounds,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonBounds.cs,AabbIntersectsSegment,The length of the statement  "	if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY)) " is 121.
Complex Conditional,HutongGames.PlayMaker.Actions,EnableBehaviour,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\EnableBehaviour.cs,ErrorCheck,The conditional expression  "go == null || component != null || behaviour.IsNone || string.IsNullOrEmpty (behaviour.Value)"  is complex.
Complex Conditional,tk2dRuntime.TileMap,ColorChannel,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapChunks.cs,Optimize,The conditional expression  "c.r != clearColor32.r || c.g != clearColor32.g || c.b != clearColor32.b || c.a != clearColor32.a"  is complex.
Complex Conditional,Spine,SkeletonBounds,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonBounds.cs,AabbIntersectsSegment,The conditional expression  "(x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY)"  is complex.
Complex Conditional,Spine,SkeletonBounds,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonBounds.cs,ContainsPoint,The conditional expression  "(vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)"  is complex.
Complex Conditional,Spine,SkeletonBounds,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonBounds.cs,IntersectsSegment,The conditional expression  "((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))"  is complex.
Complex Conditional,Spine,SkeletonBounds,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonBounds.cs,IntersectsSegment,The conditional expression  "((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))"  is complex.
Magic Number,HutongGames.PlayMaker.Actions,PhotonNetworkConnectManually,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\Photon Unity Networking\PlayMaker\Actions\PhotonNetworkConnectManually.cs,Reset,The following statement contains a magic number: port = 5055;  
Magic Number,HutongGames.PlayMaker.Actions,PhotonNetworkCreateRoom,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\Photon Unity Networking\PlayMaker\Actions\PhotonNetworkCreateRoom.cs,Reset,The following statement contains a magic number: maxNumberOfPLayers = 100;  
Magic Number,HutongGames.PlayMaker.Actions,PhotonNetworkCreateRoomAdvanced,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\Photon Unity Networking\PlayMaker\Actions\PhotonNetworkCreateRoomAdvanced.cs,Reset,The following statement contains a magic number: maxNumberOfPLayers = 100;  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnEnter,The following statement contains a magic number: resultFloats = new float[4];  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnEnter,The following statement contains a magic number: fromFloats = new float[4];  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnEnter,The following statement contains a magic number: fromFloats [2] = colorVariable.IsNone ? 0f : colorVariable.Value.b;  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnEnter,The following statement contains a magic number: fromFloats [3] = colorVariable.IsNone ? 0f : colorVariable.Value.a;  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnEnter,The following statement contains a magic number: curves = new AnimationCurve[4];  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnEnter,The following statement contains a magic number: curves [2] = curveB.curve;  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnEnter,The following statement contains a magic number: curves [3] = curveA.curve;  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnEnter,The following statement contains a magic number: calculations = new Calculation[4];  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnEnter,The following statement contains a magic number: calculations [2] = calculationB;  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnEnter,The following statement contains a magic number: calculations [3] = calculationA;  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnUpdate,The following statement contains a magic number: if (!colorVariable.IsNone && isRunning) {  	clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  	colorVariable.Value = clr;  }  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnUpdate,The following statement contains a magic number: if (!colorVariable.IsNone && isRunning) {  	clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  	colorVariable.Value = clr;  }  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnUpdate,The following statement contains a magic number: clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnUpdate,The following statement contains a magic number: clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnUpdate,The following statement contains a magic number: if (finishAction && !finishInNextStep) {  	if (!colorVariable.IsNone) {  		clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  		colorVariable.Value = clr;  	}  	finishInNextStep = true;  }  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnUpdate,The following statement contains a magic number: if (finishAction && !finishInNextStep) {  	if (!colorVariable.IsNone) {  		clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  		colorVariable.Value = clr;  	}  	finishInNextStep = true;  }  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnUpdate,The following statement contains a magic number: if (!colorVariable.IsNone) {  	clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  	colorVariable.Value = clr;  }  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnUpdate,The following statement contains a magic number: if (!colorVariable.IsNone) {  	clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  	colorVariable.Value = clr;  }  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnUpdate,The following statement contains a magic number: clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,AnimateColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateColor.cs,OnUpdate,The following statement contains a magic number: clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnEnter,The following statement contains a magic number: resultFloats = new float[4];  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnEnter,The following statement contains a magic number: fromFloats = new float[4];  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnEnter,The following statement contains a magic number: fromFloats [2] = rectVariable.IsNone ? 0f : rectVariable.Value.width;  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnEnter,The following statement contains a magic number: fromFloats [3] = rectVariable.IsNone ? 0f : rectVariable.Value.height;  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnEnter,The following statement contains a magic number: curves = new AnimationCurve[4];  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnEnter,The following statement contains a magic number: curves [2] = curveW.curve;  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnEnter,The following statement contains a magic number: curves [3] = curveH.curve;  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnEnter,The following statement contains a magic number: calculations = new Calculation[4];  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnEnter,The following statement contains a magic number: calculations [2] = calculationW;  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnEnter,The following statement contains a magic number: calculations [3] = calculationH;  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnUpdate,The following statement contains a magic number: if (!rectVariable.IsNone && isRunning) {  	rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  	rectVariable.Value = rct;  }  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnUpdate,The following statement contains a magic number: if (!rectVariable.IsNone && isRunning) {  	rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  	rectVariable.Value = rct;  }  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnUpdate,The following statement contains a magic number: rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnUpdate,The following statement contains a magic number: rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnUpdate,The following statement contains a magic number: if (finishAction && !finishInNextStep) {  	if (!rectVariable.IsNone) {  		rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  		rectVariable.Value = rct;  	}  	finishInNextStep = true;  }  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnUpdate,The following statement contains a magic number: if (finishAction && !finishInNextStep) {  	if (!rectVariable.IsNone) {  		rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  		rectVariable.Value = rct;  	}  	finishInNextStep = true;  }  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnUpdate,The following statement contains a magic number: if (!rectVariable.IsNone) {  	rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  	rectVariable.Value = rct;  }  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnUpdate,The following statement contains a magic number: if (!rectVariable.IsNone) {  	rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  	rectVariable.Value = rct;  }  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnUpdate,The following statement contains a magic number: rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,AnimateRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateRect.cs,OnUpdate,The following statement contains a magic number: rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,AnimateVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateVector3.cs,OnEnter,The following statement contains a magic number: resultFloats = new float[3];  
Magic Number,HutongGames.PlayMaker.Actions,AnimateVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateVector3.cs,OnEnter,The following statement contains a magic number: fromFloats = new float[3];  
Magic Number,HutongGames.PlayMaker.Actions,AnimateVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateVector3.cs,OnEnter,The following statement contains a magic number: fromFloats [2] = vectorVariable.IsNone ? 0f : vectorVariable.Value.z;  
Magic Number,HutongGames.PlayMaker.Actions,AnimateVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateVector3.cs,OnEnter,The following statement contains a magic number: curves = new AnimationCurve[3];  
Magic Number,HutongGames.PlayMaker.Actions,AnimateVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateVector3.cs,OnEnter,The following statement contains a magic number: curves [2] = curveZ.curve;  
Magic Number,HutongGames.PlayMaker.Actions,AnimateVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateVector3.cs,OnEnter,The following statement contains a magic number: calculations = new Calculation[3];  
Magic Number,HutongGames.PlayMaker.Actions,AnimateVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateVector3.cs,OnEnter,The following statement contains a magic number: calculations [2] = calculationZ;  
Magic Number,HutongGames.PlayMaker.Actions,AnimateVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateVector3.cs,OnUpdate,The following statement contains a magic number: if (!vectorVariable.IsNone && isRunning) {  	vct = new Vector3 (resultFloats [0]' resultFloats [1]' resultFloats [2]);  	vectorVariable.Value = vct;  }  
Magic Number,HutongGames.PlayMaker.Actions,AnimateVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateVector3.cs,OnUpdate,The following statement contains a magic number: vct = new Vector3 (resultFloats [0]' resultFloats [1]' resultFloats [2]);  
Magic Number,HutongGames.PlayMaker.Actions,AnimateVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateVector3.cs,OnUpdate,The following statement contains a magic number: if (finishAction && !finishInNextStep) {  	if (!vectorVariable.IsNone) {  		vct = new Vector3 (resultFloats [0]' resultFloats [1]' resultFloats [2]);  		vectorVariable.Value = vct;  	}  	finishInNextStep = true;  }  
Magic Number,HutongGames.PlayMaker.Actions,AnimateVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateVector3.cs,OnUpdate,The following statement contains a magic number: if (!vectorVariable.IsNone) {  	vct = new Vector3 (resultFloats [0]' resultFloats [1]' resultFloats [2]);  	vectorVariable.Value = vct;  }  
Magic Number,HutongGames.PlayMaker.Actions,AnimateVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateVector3.cs,OnUpdate,The following statement contains a magic number: vct = new Vector3 (resultFloats [0]' resultFloats [1]' resultFloats [2]);  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnEnter,The following statement contains a magic number: resultFloats = new float[4];  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnEnter,The following statement contains a magic number: fromFloats = new float[4];  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnEnter,The following statement contains a magic number: fromFloats [2] = fromValue.IsNone ? 0f : fromValue.Value.b;  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnEnter,The following statement contains a magic number: fromFloats [3] = fromValue.IsNone ? 0f : fromValue.Value.a;  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnEnter,The following statement contains a magic number: toFloats = new float[4];  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnEnter,The following statement contains a magic number: toFloats [2] = toValue.IsNone ? 0f : toValue.Value.b;  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnEnter,The following statement contains a magic number: toFloats [3] = toValue.IsNone ? 0f : toValue.Value.a;  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnEnter,The following statement contains a magic number: curves = new AnimationCurve[4];  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnEnter,The following statement contains a magic number: curves [2] = curveB.curve;  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnEnter,The following statement contains a magic number: curves [3] = curveA.curve;  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnEnter,The following statement contains a magic number: calculations = new Calculation[4];  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnEnter,The following statement contains a magic number: calculations [2] = calculationB;  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnEnter,The following statement contains a magic number: calculations [2] = calculationA;  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnUpdate,The following statement contains a magic number: if (!colorVariable.IsNone && isRunning) {  	clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  	colorVariable.Value = clr;  }  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnUpdate,The following statement contains a magic number: if (!colorVariable.IsNone && isRunning) {  	clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  	colorVariable.Value = clr;  }  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnUpdate,The following statement contains a magic number: clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnUpdate,The following statement contains a magic number: clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnUpdate,The following statement contains a magic number: if (finishAction && !finishInNextStep) {  	if (!colorVariable.IsNone) {  		clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  		colorVariable.Value = clr;  	}  	finishInNextStep = true;  }  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnUpdate,The following statement contains a magic number: if (finishAction && !finishInNextStep) {  	if (!colorVariable.IsNone) {  		clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  		colorVariable.Value = clr;  	}  	finishInNextStep = true;  }  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnUpdate,The following statement contains a magic number: if (!colorVariable.IsNone) {  	clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  	colorVariable.Value = clr;  }  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnUpdate,The following statement contains a magic number: if (!colorVariable.IsNone) {  	clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  	colorVariable.Value = clr;  }  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnUpdate,The following statement contains a magic number: clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,CurveColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveColor.cs,OnUpdate,The following statement contains a magic number: clr = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,CurveFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveFsmAction.cs,Init,The following statement contains a magic number: for (int i = 0; i < fromFloats.Length; i++) {  	distances [i] = Mathf.Sqrt (Mathf.Pow (fromFloats [i] - toFloats [i]' 2));  }  
Magic Number,HutongGames.PlayMaker.Actions,CurveFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveFsmAction.cs,Init,The following statement contains a magic number: distances [i] = Mathf.Sqrt (Mathf.Pow (fromFloats [i] - toFloats [i]' 2));  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnEnter,The following statement contains a magic number: resultFloats = new float[4];  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnEnter,The following statement contains a magic number: fromFloats = new float[4];  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnEnter,The following statement contains a magic number: fromFloats [2] = fromValue.IsNone ? 0f : fromValue.Value.width;  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnEnter,The following statement contains a magic number: fromFloats [3] = fromValue.IsNone ? 0f : fromValue.Value.height;  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnEnter,The following statement contains a magic number: toFloats = new float[4];  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnEnter,The following statement contains a magic number: toFloats [2] = toValue.IsNone ? 0f : toValue.Value.width;  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnEnter,The following statement contains a magic number: toFloats [3] = toValue.IsNone ? 0f : toValue.Value.height;  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnEnter,The following statement contains a magic number: curves = new AnimationCurve[4];  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnEnter,The following statement contains a magic number: curves [2] = curveW.curve;  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnEnter,The following statement contains a magic number: curves [3] = curveH.curve;  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnEnter,The following statement contains a magic number: calculations = new Calculation[4];  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnEnter,The following statement contains a magic number: calculations [2] = calculationW;  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnEnter,The following statement contains a magic number: calculations [2] = calculationH;  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnUpdate,The following statement contains a magic number: if (!rectVariable.IsNone && isRunning) {  	rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  	rectVariable.Value = rct;  }  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnUpdate,The following statement contains a magic number: if (!rectVariable.IsNone && isRunning) {  	rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  	rectVariable.Value = rct;  }  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnUpdate,The following statement contains a magic number: rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnUpdate,The following statement contains a magic number: rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnUpdate,The following statement contains a magic number: if (finishAction && !finishInNextStep) {  	if (!rectVariable.IsNone) {  		rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  		rectVariable.Value = rct;  	}  	finishInNextStep = true;  }  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnUpdate,The following statement contains a magic number: if (finishAction && !finishInNextStep) {  	if (!rectVariable.IsNone) {  		rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  		rectVariable.Value = rct;  	}  	finishInNextStep = true;  }  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnUpdate,The following statement contains a magic number: if (!rectVariable.IsNone) {  	rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  	rectVariable.Value = rct;  }  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnUpdate,The following statement contains a magic number: if (!rectVariable.IsNone) {  	rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  	rectVariable.Value = rct;  }  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnUpdate,The following statement contains a magic number: rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,CurveRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveRect.cs,OnUpdate,The following statement contains a magic number: rct = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,CurveVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveVector3.cs,OnEnter,The following statement contains a magic number: resultFloats = new float[3];  
Magic Number,HutongGames.PlayMaker.Actions,CurveVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveVector3.cs,OnEnter,The following statement contains a magic number: fromFloats = new float[3];  
Magic Number,HutongGames.PlayMaker.Actions,CurveVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveVector3.cs,OnEnter,The following statement contains a magic number: fromFloats [2] = fromValue.IsNone ? 0f : fromValue.Value.z;  
Magic Number,HutongGames.PlayMaker.Actions,CurveVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveVector3.cs,OnEnter,The following statement contains a magic number: toFloats = new float[3];  
Magic Number,HutongGames.PlayMaker.Actions,CurveVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveVector3.cs,OnEnter,The following statement contains a magic number: toFloats [2] = toValue.IsNone ? 0f : toValue.Value.z;  
Magic Number,HutongGames.PlayMaker.Actions,CurveVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveVector3.cs,OnEnter,The following statement contains a magic number: curves = new AnimationCurve[3];  
Magic Number,HutongGames.PlayMaker.Actions,CurveVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveVector3.cs,OnEnter,The following statement contains a magic number: curves [2] = curveZ.curve;  
Magic Number,HutongGames.PlayMaker.Actions,CurveVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveVector3.cs,OnEnter,The following statement contains a magic number: calculations = new Calculation[3];  
Magic Number,HutongGames.PlayMaker.Actions,CurveVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveVector3.cs,OnEnter,The following statement contains a magic number: calculations [2] = calculationZ;  
Magic Number,HutongGames.PlayMaker.Actions,CurveVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveVector3.cs,OnUpdate,The following statement contains a magic number: if (!vectorVariable.IsNone && isRunning) {  	vct = new Vector3 (resultFloats [0]' resultFloats [1]' resultFloats [2]);  	vectorVariable.Value = vct;  }  
Magic Number,HutongGames.PlayMaker.Actions,CurveVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveVector3.cs,OnUpdate,The following statement contains a magic number: vct = new Vector3 (resultFloats [0]' resultFloats [1]' resultFloats [2]);  
Magic Number,HutongGames.PlayMaker.Actions,CurveVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveVector3.cs,OnUpdate,The following statement contains a magic number: if (finishAction && !finishInNextStep) {  	if (!vectorVariable.IsNone) {  		vct = new Vector3 (resultFloats [0]' resultFloats [1]' resultFloats [2]);  		vectorVariable.Value = vct;  	}  	finishInNextStep = true;  }  
Magic Number,HutongGames.PlayMaker.Actions,CurveVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveVector3.cs,OnUpdate,The following statement contains a magic number: if (!vectorVariable.IsNone) {  	vct = new Vector3 (resultFloats [0]' resultFloats [1]' resultFloats [2]);  	vectorVariable.Value = vct;  }  
Magic Number,HutongGames.PlayMaker.Actions,CurveVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveVector3.cs,OnUpdate,The following statement contains a magic number: vct = new Vector3 (resultFloats [0]' resultFloats [1]' resultFloats [2]);  
Magic Number,HutongGames.PlayMaker.Actions,EaseColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseColor.cs,OnEnter,The following statement contains a magic number: fromFloats = new float[4];  
Magic Number,HutongGames.PlayMaker.Actions,EaseColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseColor.cs,OnEnter,The following statement contains a magic number: fromFloats [2] = fromValue.Value.b;  
Magic Number,HutongGames.PlayMaker.Actions,EaseColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseColor.cs,OnEnter,The following statement contains a magic number: fromFloats [3] = fromValue.Value.a;  
Magic Number,HutongGames.PlayMaker.Actions,EaseColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseColor.cs,OnEnter,The following statement contains a magic number: toFloats = new float[4];  
Magic Number,HutongGames.PlayMaker.Actions,EaseColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseColor.cs,OnEnter,The following statement contains a magic number: toFloats [2] = toValue.Value.b;  
Magic Number,HutongGames.PlayMaker.Actions,EaseColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseColor.cs,OnEnter,The following statement contains a magic number: toFloats [3] = toValue.Value.a;  
Magic Number,HutongGames.PlayMaker.Actions,EaseColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseColor.cs,OnEnter,The following statement contains a magic number: resultFloats = new float[4];  
Magic Number,HutongGames.PlayMaker.Actions,EaseColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseColor.cs,OnUpdate,The following statement contains a magic number: if (!colorVariable.IsNone && isRunning) {  	colorVariable.Value = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  }  
Magic Number,HutongGames.PlayMaker.Actions,EaseColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseColor.cs,OnUpdate,The following statement contains a magic number: if (!colorVariable.IsNone && isRunning) {  	colorVariable.Value = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  }  
Magic Number,HutongGames.PlayMaker.Actions,EaseColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseColor.cs,OnUpdate,The following statement contains a magic number: colorVariable.Value = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,EaseColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseColor.cs,OnUpdate,The following statement contains a magic number: colorVariable.Value = new Color (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeOutQuad,The following statement contains a magic number: return -end * value * (value - 2) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutQuad,The following statement contains a magic number: if (value < 1)  	return end / 2 * value * value + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutQuad,The following statement contains a magic number: return end / 2 * value * value + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutQuad,The following statement contains a magic number: return -end / 2 * (value * (value - 2) - 1) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutQuad,The following statement contains a magic number: return -end / 2 * (value * (value - 2) - 1) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutCubic,The following statement contains a magic number: if (value < 1)  	return end / 2 * value * value * value + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutCubic,The following statement contains a magic number: return end / 2 * value * value * value + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutCubic,The following statement contains a magic number: value -= 2;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutCubic,The following statement contains a magic number: return end / 2 * (value * value * value + 2) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutCubic,The following statement contains a magic number: return end / 2 * (value * value * value + 2) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutQuart,The following statement contains a magic number: if (value < 1)  	return end / 2 * value * value * value * value + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutQuart,The following statement contains a magic number: return end / 2 * value * value * value * value + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutQuart,The following statement contains a magic number: value -= 2;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutQuart,The following statement contains a magic number: return -end / 2 * (value * value * value * value - 2) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutQuart,The following statement contains a magic number: return -end / 2 * (value * value * value * value - 2) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutQuint,The following statement contains a magic number: if (value < 1)  	return end / 2 * value * value * value * value * value + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutQuint,The following statement contains a magic number: return end / 2 * value * value * value * value * value + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutQuint,The following statement contains a magic number: value -= 2;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutQuint,The following statement contains a magic number: return end / 2 * (value * value * value * value * value + 2) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutQuint,The following statement contains a magic number: return end / 2 * (value * value * value * value * value + 2) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInSine,The following statement contains a magic number: return -end * Mathf.Cos (value / 1 * (Mathf.PI / 2)) + end + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeOutSine,The following statement contains a magic number: return end * Mathf.Sin (value / 1 * (Mathf.PI / 2)) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutSine,The following statement contains a magic number: return -end / 2 * (Mathf.Cos (Mathf.PI * value / 1) - 1) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInExpo,The following statement contains a magic number: return end * Mathf.Pow (2' 10 * (value / 1 - 1)) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInExpo,The following statement contains a magic number: return end * Mathf.Pow (2' 10 * (value / 1 - 1)) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeOutExpo,The following statement contains a magic number: return end * (-Mathf.Pow (2' -10 * value / 1) + 1) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeOutExpo,The following statement contains a magic number: return end * (-Mathf.Pow (2' -10 * value / 1) + 1) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutExpo,The following statement contains a magic number: if (value < 1)  	return end / 2 * Mathf.Pow (2' 10 * (value - 1)) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutExpo,The following statement contains a magic number: if (value < 1)  	return end / 2 * Mathf.Pow (2' 10 * (value - 1)) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutExpo,The following statement contains a magic number: if (value < 1)  	return end / 2 * Mathf.Pow (2' 10 * (value - 1)) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutExpo,The following statement contains a magic number: return end / 2 * Mathf.Pow (2' 10 * (value - 1)) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutExpo,The following statement contains a magic number: return end / 2 * Mathf.Pow (2' 10 * (value - 1)) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutExpo,The following statement contains a magic number: return end / 2 * Mathf.Pow (2' 10 * (value - 1)) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutExpo,The following statement contains a magic number: return end / 2 * (-Mathf.Pow (2' -10 * value) + 2) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutExpo,The following statement contains a magic number: return end / 2 * (-Mathf.Pow (2' -10 * value) + 2) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutExpo,The following statement contains a magic number: return end / 2 * (-Mathf.Pow (2' -10 * value) + 2) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutExpo,The following statement contains a magic number: return end / 2 * (-Mathf.Pow (2' -10 * value) + 2) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutCirc,The following statement contains a magic number: if (value < 1)  	return -end / 2 * (Mathf.Sqrt (1 - value * value) - 1) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutCirc,The following statement contains a magic number: return -end / 2 * (Mathf.Sqrt (1 - value * value) - 1) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutCirc,The following statement contains a magic number: value -= 2;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutCirc,The following statement contains a magic number: return end / 2 * (Mathf.Sqrt (1 - value * value) + 1) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,bounce,The following statement contains a magic number: if (value < (1 / 2.75f)) {  	return end * (7.5625f * value * value) + start;  }  else if (value < (2 / 2.75f)) {  	value -= (1.5f / 2.75f);  	return end * (7.5625f * (value) * value + .75f) + start;  }  else if (value < (2.5 / 2.75)) {  	value -= (2.25f / 2.75f);  	return end * (7.5625f * (value) * value + .9375f) + start;  }  else {  	value -= (2.625f / 2.75f);  	return end * (7.5625f * (value) * value + .984375f) + start;  }  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,bounce,The following statement contains a magic number: if (value < (1 / 2.75f)) {  	return end * (7.5625f * value * value) + start;  }  else if (value < (2 / 2.75f)) {  	value -= (1.5f / 2.75f);  	return end * (7.5625f * (value) * value + .75f) + start;  }  else if (value < (2.5 / 2.75)) {  	value -= (2.25f / 2.75f);  	return end * (7.5625f * (value) * value + .9375f) + start;  }  else {  	value -= (2.625f / 2.75f);  	return end * (7.5625f * (value) * value + .984375f) + start;  }  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,bounce,The following statement contains a magic number: if (value < (1 / 2.75f)) {  	return end * (7.5625f * value * value) + start;  }  else if (value < (2 / 2.75f)) {  	value -= (1.5f / 2.75f);  	return end * (7.5625f * (value) * value + .75f) + start;  }  else if (value < (2.5 / 2.75)) {  	value -= (2.25f / 2.75f);  	return end * (7.5625f * (value) * value + .9375f) + start;  }  else {  	value -= (2.625f / 2.75f);  	return end * (7.5625f * (value) * value + .984375f) + start;  }  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,bounce,The following statement contains a magic number: if (value < (2 / 2.75f)) {  	value -= (1.5f / 2.75f);  	return end * (7.5625f * (value) * value + .75f) + start;  }  else if (value < (2.5 / 2.75)) {  	value -= (2.25f / 2.75f);  	return end * (7.5625f * (value) * value + .9375f) + start;  }  else {  	value -= (2.625f / 2.75f);  	return end * (7.5625f * (value) * value + .984375f) + start;  }  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,bounce,The following statement contains a magic number: if (value < (2 / 2.75f)) {  	value -= (1.5f / 2.75f);  	return end * (7.5625f * (value) * value + .75f) + start;  }  else if (value < (2.5 / 2.75)) {  	value -= (2.25f / 2.75f);  	return end * (7.5625f * (value) * value + .9375f) + start;  }  else {  	value -= (2.625f / 2.75f);  	return end * (7.5625f * (value) * value + .984375f) + start;  }  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,bounce,The following statement contains a magic number: if (value < (2 / 2.75f)) {  	value -= (1.5f / 2.75f);  	return end * (7.5625f * (value) * value + .75f) + start;  }  else if (value < (2.5 / 2.75)) {  	value -= (2.25f / 2.75f);  	return end * (7.5625f * (value) * value + .9375f) + start;  }  else {  	value -= (2.625f / 2.75f);  	return end * (7.5625f * (value) * value + .984375f) + start;  }  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,bounce,The following statement contains a magic number: if (value < (2.5 / 2.75)) {  	value -= (2.25f / 2.75f);  	return end * (7.5625f * (value) * value + .9375f) + start;  }  else {  	value -= (2.625f / 2.75f);  	return end * (7.5625f * (value) * value + .984375f) + start;  }  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,bounce,The following statement contains a magic number: if (value < (2.5 / 2.75)) {  	value -= (2.25f / 2.75f);  	return end * (7.5625f * (value) * value + .9375f) + start;  }  else {  	value -= (2.625f / 2.75f);  	return end * (7.5625f * (value) * value + .984375f) + start;  }  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutBack,The following statement contains a magic number: if ((value) < 1) {  	s *= (1.525f);  	return end / 2 * (value * value * (((s) + 1) * value - s)) + start;  }  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutBack,The following statement contains a magic number: return end / 2 * (value * value * (((s) + 1) * value - s)) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutBack,The following statement contains a magic number: value -= 2;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutBack,The following statement contains a magic number: return end / 2 * ((value) * value * (((s) + 1) * value + s) + 2) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,easeInOutBack,The following statement contains a magic number: return end / 2 * ((value) * value * (((s) + 1) * value + s) + 2) + start;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,punch,The following statement contains a magic number: s = period / (2 * Mathf.PI) * Mathf.Asin (0);  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,punch,The following statement contains a magic number: return (amplitude * Mathf.Pow (2' -10 * value) * Mathf.Sin ((value * 1 - s) * (2 * Mathf.PI) / period));  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,punch,The following statement contains a magic number: return (amplitude * Mathf.Pow (2' -10 * value) * Mathf.Sin ((value * 1 - s) * (2 * Mathf.PI) / period));  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,punch,The following statement contains a magic number: return (amplitude * Mathf.Pow (2' -10 * value) * Mathf.Sin ((value * 1 - s) * (2 * Mathf.PI) / period));  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,elastic,The following statement contains a magic number: if (a == 0f || a < Mathf.Abs (end)) {  	a = end;  	s = p / 4;  }  else {  	s = p / (2 * Mathf.PI) * Mathf.Asin (end / a);  }  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,elastic,The following statement contains a magic number: if (a == 0f || a < Mathf.Abs (end)) {  	a = end;  	s = p / 4;  }  else {  	s = p / (2 * Mathf.PI) * Mathf.Asin (end / a);  }  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,elastic,The following statement contains a magic number: s = p / 4;  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,elastic,The following statement contains a magic number: s = p / (2 * Mathf.PI) * Mathf.Asin (end / a);  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,elastic,The following statement contains a magic number: return (a * Mathf.Pow (2' -10 * value) * Mathf.Sin ((value * d - s) * (2 * Mathf.PI) / p) + end + start);  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,elastic,The following statement contains a magic number: return (a * Mathf.Pow (2' -10 * value) * Mathf.Sin ((value * d - s) * (2 * Mathf.PI) / p) + end + start);  
Magic Number,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,elastic,The following statement contains a magic number: return (a * Mathf.Pow (2' -10 * value) * Mathf.Sin ((value * d - s) * (2 * Mathf.PI) / p) + end + start);  
Magic Number,HutongGames.PlayMaker.Actions,EaseRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseRect.cs,OnEnter,The following statement contains a magic number: fromFloats = new float[4];  
Magic Number,HutongGames.PlayMaker.Actions,EaseRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseRect.cs,OnEnter,The following statement contains a magic number: fromFloats [2] = fromValue.Value.width;  
Magic Number,HutongGames.PlayMaker.Actions,EaseRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseRect.cs,OnEnter,The following statement contains a magic number: fromFloats [3] = fromValue.Value.height;  
Magic Number,HutongGames.PlayMaker.Actions,EaseRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseRect.cs,OnEnter,The following statement contains a magic number: toFloats = new float[4];  
Magic Number,HutongGames.PlayMaker.Actions,EaseRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseRect.cs,OnEnter,The following statement contains a magic number: toFloats [2] = toValue.Value.width;  
Magic Number,HutongGames.PlayMaker.Actions,EaseRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseRect.cs,OnEnter,The following statement contains a magic number: toFloats [3] = toValue.Value.height;  
Magic Number,HutongGames.PlayMaker.Actions,EaseRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseRect.cs,OnEnter,The following statement contains a magic number: resultFloats = new float[4];  
Magic Number,HutongGames.PlayMaker.Actions,EaseRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseRect.cs,OnUpdate,The following statement contains a magic number: if (!rectVariable.IsNone && isRunning) {  	rectVariable.Value = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  }  
Magic Number,HutongGames.PlayMaker.Actions,EaseRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseRect.cs,OnUpdate,The following statement contains a magic number: if (!rectVariable.IsNone && isRunning) {  	rectVariable.Value = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  }  
Magic Number,HutongGames.PlayMaker.Actions,EaseRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseRect.cs,OnUpdate,The following statement contains a magic number: rectVariable.Value = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,EaseRect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseRect.cs,OnUpdate,The following statement contains a magic number: rectVariable.Value = new Rect (resultFloats [0]' resultFloats [1]' resultFloats [2]' resultFloats [3]);  
Magic Number,HutongGames.PlayMaker.Actions,EaseVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseVector3.cs,OnEnter,The following statement contains a magic number: fromFloats = new float[3];  
Magic Number,HutongGames.PlayMaker.Actions,EaseVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseVector3.cs,OnEnter,The following statement contains a magic number: fromFloats [2] = fromValue.Value.z;  
Magic Number,HutongGames.PlayMaker.Actions,EaseVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseVector3.cs,OnEnter,The following statement contains a magic number: toFloats = new float[3];  
Magic Number,HutongGames.PlayMaker.Actions,EaseVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseVector3.cs,OnEnter,The following statement contains a magic number: toFloats [2] = toValue.Value.z;  
Magic Number,HutongGames.PlayMaker.Actions,EaseVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseVector3.cs,OnEnter,The following statement contains a magic number: resultFloats = new float[3];  
Magic Number,HutongGames.PlayMaker.Actions,EaseVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseVector3.cs,OnUpdate,The following statement contains a magic number: if (!vector3Variable.IsNone && isRunning) {  	vector3Variable.Value = new Vector3 (resultFloats [0]' resultFloats [1]' resultFloats [2]);  }  
Magic Number,HutongGames.PlayMaker.Actions,EaseVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseVector3.cs,OnUpdate,The following statement contains a magic number: vector3Variable.Value = new Vector3 (resultFloats [0]' resultFloats [1]' resultFloats [2]);  
Magic Number,HutongGames.PlayMaker.Actions,AxisEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AxisEvent.cs,OnUpdate,The following statement contains a magic number: if (direction == 0 && rightEvent != null) {  	Fsm.Event (rightEvent);  	//Debug.Log("Right");  }  else if (direction == 1 && upEvent != null) {  	Fsm.Event (upEvent);  	//Debug.Log("Up");  }  else if (direction == 2 && leftEvent != null) {  	Fsm.Event (leftEvent);  	//Debug.Log("Left");  }  else if (direction == 3 && downEvent != null) {  	Fsm.Event (downEvent);  	//Debug.Log("Down");  }  else if (anyDirection != null) {  	// since we already no offset > 0  	Fsm.Event (anyDirection);  	//Debug.Log("AnyDirection");  }  
Magic Number,HutongGames.PlayMaker.Actions,AxisEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AxisEvent.cs,OnUpdate,The following statement contains a magic number: if (direction == 0 && rightEvent != null) {  	Fsm.Event (rightEvent);  	//Debug.Log("Right");  }  else if (direction == 1 && upEvent != null) {  	Fsm.Event (upEvent);  	//Debug.Log("Up");  }  else if (direction == 2 && leftEvent != null) {  	Fsm.Event (leftEvent);  	//Debug.Log("Left");  }  else if (direction == 3 && downEvent != null) {  	Fsm.Event (downEvent);  	//Debug.Log("Down");  }  else if (anyDirection != null) {  	// since we already no offset > 0  	Fsm.Event (anyDirection);  	//Debug.Log("AnyDirection");  }  
Magic Number,HutongGames.PlayMaker.Actions,AxisEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AxisEvent.cs,OnUpdate,The following statement contains a magic number: if (direction == 1 && upEvent != null) {  	Fsm.Event (upEvent);  	//Debug.Log("Up");  }  else if (direction == 2 && leftEvent != null) {  	Fsm.Event (leftEvent);  	//Debug.Log("Left");  }  else if (direction == 3 && downEvent != null) {  	Fsm.Event (downEvent);  	//Debug.Log("Down");  }  else if (anyDirection != null) {  	// since we already no offset > 0  	Fsm.Event (anyDirection);  	//Debug.Log("AnyDirection");  }  
Magic Number,HutongGames.PlayMaker.Actions,AxisEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AxisEvent.cs,OnUpdate,The following statement contains a magic number: if (direction == 1 && upEvent != null) {  	Fsm.Event (upEvent);  	//Debug.Log("Up");  }  else if (direction == 2 && leftEvent != null) {  	Fsm.Event (leftEvent);  	//Debug.Log("Left");  }  else if (direction == 3 && downEvent != null) {  	Fsm.Event (downEvent);  	//Debug.Log("Down");  }  else if (anyDirection != null) {  	// since we already no offset > 0  	Fsm.Event (anyDirection);  	//Debug.Log("AnyDirection");  }  
Magic Number,HutongGames.PlayMaker.Actions,AxisEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AxisEvent.cs,OnUpdate,The following statement contains a magic number: if (direction == 2 && leftEvent != null) {  	Fsm.Event (leftEvent);  	//Debug.Log("Left");  }  else if (direction == 3 && downEvent != null) {  	Fsm.Event (downEvent);  	//Debug.Log("Down");  }  else if (anyDirection != null) {  	// since we already no offset > 0  	Fsm.Event (anyDirection);  	//Debug.Log("AnyDirection");  }  
Magic Number,HutongGames.PlayMaker.Actions,AxisEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AxisEvent.cs,OnUpdate,The following statement contains a magic number: if (direction == 2 && leftEvent != null) {  	Fsm.Event (leftEvent);  	//Debug.Log("Left");  }  else if (direction == 3 && downEvent != null) {  	Fsm.Event (downEvent);  	//Debug.Log("Down");  }  else if (anyDirection != null) {  	// since we already no offset > 0  	Fsm.Event (anyDirection);  	//Debug.Log("AnyDirection");  }  
Magic Number,HutongGames.PlayMaker.Actions,AxisEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AxisEvent.cs,OnUpdate,The following statement contains a magic number: if (direction == 3 && downEvent != null) {  	Fsm.Event (downEvent);  	//Debug.Log("Down");  }  else if (anyDirection != null) {  	// since we already no offset > 0  	Fsm.Event (anyDirection);  	//Debug.Log("AnyDirection");  }  
Magic Number,HutongGames.PlayMaker.Actions,BuildString,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\BuildString.cs,Reset,The following statement contains a magic number: stringParts = new FsmString[3];  
Magic Number,HutongGames.PlayMaker.Actions,ColorInterpolate,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\ColorInterpolate.cs,Reset,The following statement contains a magic number: colors = new FsmColor[3];  
Magic Number,HutongGames.PlayMaker.Actions,ColorInterpolate,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\ColorInterpolate.cs,OnEnter,The following statement contains a magic number: if (colors.Length < 2) {  	if (colors.Length == 1) {  		storeColor.Value = colors [0].Value;  	}  	Finish ();  }  else {  	storeColor.Value = colors [0].Value;  }  
Magic Number,HutongGames.PlayMaker.Actions,ColorInterpolate,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\ColorInterpolate.cs,ErrorCheck,The following statement contains a magic number: return colors.Length < 2 ? "Define at least 2 colors to make a gradient." : null;  
Magic Number,HutongGames.PlayMaker.Actions,ColorRamp,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\ColorRamp.cs,Reset,The following statement contains a magic number: colors = new FsmColor[3];  
Magic Number,HutongGames.PlayMaker.Actions,ColorRamp,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\ColorRamp.cs,ErrorCheck,The following statement contains a magic number: if (colors.Length < 2) {  	return "Define at least 2 colors to make a gradient.";  }  
Magic Number,HutongGames.PlayMaker.Actions,GUILayoutConfirmPasswordField,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GUILayoutConfirmPasswordField.cs,Reset,The following statement contains a magic number: maxLength = 25;  
Magic Number,HutongGames.PlayMaker.Actions,GUILayoutEmailField,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GUILayoutEmailField.cs,Reset,The following statement contains a magic number: maxLength = 25;  
Magic Number,HutongGames.PlayMaker.Actions,GUILayoutHorizontalSlider,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GUILayoutHorizontalSlider.cs,Reset,The following statement contains a magic number: rightValue = 100;  
Magic Number,HutongGames.PlayMaker.Actions,GUILayoutPasswordField,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GUILayoutPasswordField.cs,Reset,The following statement contains a magic number: maxLength = 25;  
Magic Number,HutongGames.PlayMaker.Actions,GUILayoutSpace,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GUILayoutSpace.cs,Reset,The following statement contains a magic number: space = 10;  
Magic Number,HutongGames.PlayMaker.Actions,GUILayoutTextField,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GUILayoutTextField.cs,Reset,The following statement contains a magic number: maxLength = 25;  
Magic Number,HutongGames.PlayMaker.Actions,GUILayoutVerticalSlider,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GUILayoutVerticalSlider.cs,Reset,The following statement contains a magic number: topValue = 100;  
Magic Number,HutongGames.PlayMaker.Actions,MasterServerSetProperties,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Network\MasterServerSetProperties.cs,Reset,The following statement contains a magic number: port = 10002;  
Magic Number,HutongGames.PlayMaker.Actions,MasterServerSetProperties,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Network\MasterServerSetProperties.cs,Reset,The following statement contains a magic number: updateRate = 60;  
Magic Number,HutongGames.PlayMaker.Actions,NetworkConnect,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Network\NetworkConnect.cs,Reset,The following statement contains a magic number: remotePort = 25001;  
Magic Number,HutongGames.PlayMaker.Actions,NetworkInitializeServer,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Network\NetworkInitializeServer.cs,Reset,The following statement contains a magic number: connections = 32;  
Magic Number,HutongGames.PlayMaker.Actions,NetworkInitializeServer,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Network\NetworkInitializeServer.cs,Reset,The following statement contains a magic number: listenPort = 25001;  
Magic Number,HutongGames.PlayMaker.Actions,NetworkSetMaximumConnections,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Network\NetworkSetMaxConnections.cs,Reset,The following statement contains a magic number: maximumConnections = 32;  
Magic Number,HutongGames.PlayMaker.Actions,NetworkSetMinimumAllocatableViewIDs,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Network\NetworkSetMinimumAllocatableViewIDs.cs,Reset,The following statement contains a magic number: minimumViewIDs = 100;  
Magic Number,HutongGames.PlayMaker.Actions,StartServer,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Network\StartServer.cs,Reset,The following statement contains a magic number: connections = 32;  
Magic Number,HutongGames.PlayMaker.Actions,StartServer,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Network\StartServer.cs,Reset,The following statement contains a magic number: listenPort = 25001;  
Magic Number,HutongGames.PlayMaker.Actions,PlayRandomSound,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\PlayRandomSound.cs,Reset,The following statement contains a magic number: audioClips = new AudioClip[3];  
Magic Number,HutongGames.PlayMaker.Actions,RandomBool,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\RandomBool.cs,OnEnter,The following statement contains a magic number: storeResult.Value = Random.Range (0' 100) < 50;  
Magic Number,HutongGames.PlayMaker.Actions,RandomBool,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\RandomBool.cs,OnEnter,The following statement contains a magic number: storeResult.Value = Random.Range (0' 100) < 50;  
Magic Number,HutongGames.PlayMaker.Actions,RandomInt,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\RandomInt.cs,Reset,The following statement contains a magic number: max = 100;  
Magic Number,HutongGames.PlayMaker.Actions,Raycast,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Raycast.cs,Reset,The following statement contains a magic number: distance = 100;  
Magic Number,HutongGames.PlayMaker.Actions,Raycast,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Raycast.cs,DoRaycast,The following statement contains a magic number: if (debug.Value) {  	var debugRayLength = Mathf.Min (rayLength' 1000);  	Debug.DrawLine (originPos' originPos + dirVector * debugRayLength' debugColor.Value);  }  
Magic Number,HutongGames.PlayMaker.Actions,SelectRandomColor,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SelectRandomColor.cs,Reset,The following statement contains a magic number: colors = new FsmColor[3];  
Magic Number,HutongGames.PlayMaker.Actions,SelectRandomGameObject,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SelectRandomGameObject.cs,Reset,The following statement contains a magic number: gameObjects = new FsmGameObject[3];  
Magic Number,HutongGames.PlayMaker.Actions,SelectRandomString,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SelectRandomString.cs,Reset,The following statement contains a magic number: strings = new FsmString[3];  
Magic Number,HutongGames.PlayMaker.Actions,SelectRandomVector3,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SelectRandomVector3.cs,Reset,The following statement contains a magic number: vector3Array = new FsmVector3[3];  
Magic Number,HutongGames.PlayMaker.Actions,SendEventToFsm,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SendEventToFsm.cs,OnEnter,The following statement contains a magic number: if (delay.Value < 0.001) {  	sendToFsm.Fsm.Event (sendEvent.Value);  	Finish ();  }  else {  	delayedEvent = sendToFsm.Fsm.DelayedEvent (FsmEvent.GetFsmEvent (sendEvent.Value)' delay.Value);  }  
Magic Number,HutongGames.PlayMaker.Actions,SendRandomEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SendRandomEvent.cs,Reset,The following statement contains a magic number: events = new FsmEvent[3];  
Magic Number,HutongGames.PlayMaker.Actions,SetRandomMaterial,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SetRandomMaterial.cs,Reset,The following statement contains a magic number: materials = new FsmMaterial[3];  
Magic Number,HutongGames.PlayMaker.Actions,SetRandomRotation,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SetRandomRotation.cs,DoRandomRotation,The following statement contains a magic number: if (x.Value)  	xAngle = Random.Range (0' 360);  
Magic Number,HutongGames.PlayMaker.Actions,SetRandomRotation,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SetRandomRotation.cs,DoRandomRotation,The following statement contains a magic number: xAngle = Random.Range (0' 360);  
Magic Number,HutongGames.PlayMaker.Actions,SetRandomRotation,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SetRandomRotation.cs,DoRandomRotation,The following statement contains a magic number: if (y.Value)  	yAngle = Random.Range (0' 360);  
Magic Number,HutongGames.PlayMaker.Actions,SetRandomRotation,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SetRandomRotation.cs,DoRandomRotation,The following statement contains a magic number: yAngle = Random.Range (0' 360);  
Magic Number,HutongGames.PlayMaker.Actions,SetRandomRotation,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SetRandomRotation.cs,DoRandomRotation,The following statement contains a magic number: if (z.Value)  	zAngle = Random.Range (0' 360);  
Magic Number,HutongGames.PlayMaker.Actions,SetRandomRotation,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SetRandomRotation.cs,DoRandomRotation,The following statement contains a magic number: zAngle = Random.Range (0' 360);  
Magic Number,HutongGames.PlayMaker.Actions,SmoothLookAt,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SmoothLookAt.cs,Reset,The following statement contains a magic number: speed = 5;  
Magic Number,HutongGames.PlayMaker.Actions,SmoothLookAtDirection,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SmoothLookAtDirection.cs,Reset,The following statement contains a magic number: speed = 5;  
Magic Number,HutongGames.PlayMaker.Actions,StartLocationServiceUpdates,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\StartLocationServiceUpdates.cs,Reset,The following statement contains a magic number: maxWait = 20;  
Magic Number,HutongGames.PlayMaker.Actions,StartLocationServiceUpdates,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\StartLocationServiceUpdates.cs,Reset,The following statement contains a magic number: desiredAccuracy = 10;  
Magic Number,HutongGames.PlayMaker.Actions,StartLocationServiceUpdates,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\StartLocationServiceUpdates.cs,Reset,The following statement contains a magic number: updateDistance = 10;  
Magic Number,HutongGames.PlayMaker.Actions,SwipeGestureEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SwipeGestureEvent.cs,TestForSwipeGesture,The following statement contains a magic number: if (distance > minSwipeDistancePixels) {  	float dy = lastPos.y - touchStartPos.y;  	float dx = lastPos.x - touchStartPos.x;  	float angle = Mathf.Rad2Deg * Mathf.Atan2 (dx' dy);  	angle = (360 + angle - 45) % 360;  	Debug.Log (angle);  	if (angle < 90) {  		Fsm.Event (swipeRightEvent);  	}  	else if (angle < 180) {  		Fsm.Event (swipeDownEvent);  	}  	else if (angle < 270) {  		Fsm.Event (swipeLeftEvent);  	}  	else {  		Fsm.Event (swipeUpEvent);  	}  }  
Magic Number,HutongGames.PlayMaker.Actions,SwipeGestureEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SwipeGestureEvent.cs,TestForSwipeGesture,The following statement contains a magic number: if (distance > minSwipeDistancePixels) {  	float dy = lastPos.y - touchStartPos.y;  	float dx = lastPos.x - touchStartPos.x;  	float angle = Mathf.Rad2Deg * Mathf.Atan2 (dx' dy);  	angle = (360 + angle - 45) % 360;  	Debug.Log (angle);  	if (angle < 90) {  		Fsm.Event (swipeRightEvent);  	}  	else if (angle < 180) {  		Fsm.Event (swipeDownEvent);  	}  	else if (angle < 270) {  		Fsm.Event (swipeLeftEvent);  	}  	else {  		Fsm.Event (swipeUpEvent);  	}  }  
Magic Number,HutongGames.PlayMaker.Actions,SwipeGestureEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SwipeGestureEvent.cs,TestForSwipeGesture,The following statement contains a magic number: if (distance > minSwipeDistancePixels) {  	float dy = lastPos.y - touchStartPos.y;  	float dx = lastPos.x - touchStartPos.x;  	float angle = Mathf.Rad2Deg * Mathf.Atan2 (dx' dy);  	angle = (360 + angle - 45) % 360;  	Debug.Log (angle);  	if (angle < 90) {  		Fsm.Event (swipeRightEvent);  	}  	else if (angle < 180) {  		Fsm.Event (swipeDownEvent);  	}  	else if (angle < 270) {  		Fsm.Event (swipeLeftEvent);  	}  	else {  		Fsm.Event (swipeUpEvent);  	}  }  
Magic Number,HutongGames.PlayMaker.Actions,SwipeGestureEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SwipeGestureEvent.cs,TestForSwipeGesture,The following statement contains a magic number: if (distance > minSwipeDistancePixels) {  	float dy = lastPos.y - touchStartPos.y;  	float dx = lastPos.x - touchStartPos.x;  	float angle = Mathf.Rad2Deg * Mathf.Atan2 (dx' dy);  	angle = (360 + angle - 45) % 360;  	Debug.Log (angle);  	if (angle < 90) {  		Fsm.Event (swipeRightEvent);  	}  	else if (angle < 180) {  		Fsm.Event (swipeDownEvent);  	}  	else if (angle < 270) {  		Fsm.Event (swipeLeftEvent);  	}  	else {  		Fsm.Event (swipeUpEvent);  	}  }  
Magic Number,HutongGames.PlayMaker.Actions,SwipeGestureEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SwipeGestureEvent.cs,TestForSwipeGesture,The following statement contains a magic number: if (distance > minSwipeDistancePixels) {  	float dy = lastPos.y - touchStartPos.y;  	float dx = lastPos.x - touchStartPos.x;  	float angle = Mathf.Rad2Deg * Mathf.Atan2 (dx' dy);  	angle = (360 + angle - 45) % 360;  	Debug.Log (angle);  	if (angle < 90) {  		Fsm.Event (swipeRightEvent);  	}  	else if (angle < 180) {  		Fsm.Event (swipeDownEvent);  	}  	else if (angle < 270) {  		Fsm.Event (swipeLeftEvent);  	}  	else {  		Fsm.Event (swipeUpEvent);  	}  }  
Magic Number,HutongGames.PlayMaker.Actions,SwipeGestureEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SwipeGestureEvent.cs,TestForSwipeGesture,The following statement contains a magic number: if (distance > minSwipeDistancePixels) {  	float dy = lastPos.y - touchStartPos.y;  	float dx = lastPos.x - touchStartPos.x;  	float angle = Mathf.Rad2Deg * Mathf.Atan2 (dx' dy);  	angle = (360 + angle - 45) % 360;  	Debug.Log (angle);  	if (angle < 90) {  		Fsm.Event (swipeRightEvent);  	}  	else if (angle < 180) {  		Fsm.Event (swipeDownEvent);  	}  	else if (angle < 270) {  		Fsm.Event (swipeLeftEvent);  	}  	else {  		Fsm.Event (swipeUpEvent);  	}  }  
Magic Number,HutongGames.PlayMaker.Actions,SwipeGestureEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SwipeGestureEvent.cs,TestForSwipeGesture,The following statement contains a magic number: angle = (360 + angle - 45) % 360;  
Magic Number,HutongGames.PlayMaker.Actions,SwipeGestureEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SwipeGestureEvent.cs,TestForSwipeGesture,The following statement contains a magic number: angle = (360 + angle - 45) % 360;  
Magic Number,HutongGames.PlayMaker.Actions,SwipeGestureEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SwipeGestureEvent.cs,TestForSwipeGesture,The following statement contains a magic number: angle = (360 + angle - 45) % 360;  
Magic Number,HutongGames.PlayMaker.Actions,SwipeGestureEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SwipeGestureEvent.cs,TestForSwipeGesture,The following statement contains a magic number: if (angle < 90) {  	Fsm.Event (swipeRightEvent);  }  else if (angle < 180) {  	Fsm.Event (swipeDownEvent);  }  else if (angle < 270) {  	Fsm.Event (swipeLeftEvent);  }  else {  	Fsm.Event (swipeUpEvent);  }  
Magic Number,HutongGames.PlayMaker.Actions,SwipeGestureEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SwipeGestureEvent.cs,TestForSwipeGesture,The following statement contains a magic number: if (angle < 90) {  	Fsm.Event (swipeRightEvent);  }  else if (angle < 180) {  	Fsm.Event (swipeDownEvent);  }  else if (angle < 270) {  	Fsm.Event (swipeLeftEvent);  }  else {  	Fsm.Event (swipeUpEvent);  }  
Magic Number,HutongGames.PlayMaker.Actions,SwipeGestureEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SwipeGestureEvent.cs,TestForSwipeGesture,The following statement contains a magic number: if (angle < 90) {  	Fsm.Event (swipeRightEvent);  }  else if (angle < 180) {  	Fsm.Event (swipeDownEvent);  }  else if (angle < 270) {  	Fsm.Event (swipeLeftEvent);  }  else {  	Fsm.Event (swipeUpEvent);  }  
Magic Number,HutongGames.PlayMaker.Actions,SwipeGestureEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SwipeGestureEvent.cs,TestForSwipeGesture,The following statement contains a magic number: if (angle < 180) {  	Fsm.Event (swipeDownEvent);  }  else if (angle < 270) {  	Fsm.Event (swipeLeftEvent);  }  else {  	Fsm.Event (swipeUpEvent);  }  
Magic Number,HutongGames.PlayMaker.Actions,SwipeGestureEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SwipeGestureEvent.cs,TestForSwipeGesture,The following statement contains a magic number: if (angle < 180) {  	Fsm.Event (swipeDownEvent);  }  else if (angle < 270) {  	Fsm.Event (swipeLeftEvent);  }  else {  	Fsm.Event (swipeUpEvent);  }  
Magic Number,HutongGames.PlayMaker.Actions,SwipeGestureEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SwipeGestureEvent.cs,TestForSwipeGesture,The following statement contains a magic number: if (angle < 270) {  	Fsm.Event (swipeLeftEvent);  }  else {  	Fsm.Event (swipeUpEvent);  }  
Magic Number,HutongGames.PlayMaker.Actions,TouchObjectEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\TouchObjectEvent.cs,Reset,The following statement contains a magic number: pickDistance = 100;  
Magic Number,HutongGames.PlayMaker.Actions,Vector3RotateTowards,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Vector3RotateTowards.cs,Reset,The following statement contains a magic number: rotateSpeed = 360;  
Magic Number,HutongGames.PlayMaker.Actions,iTweenMoveTo,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenMoveTo.cs,OnDrawGizmos,The following statement contains a magic number: if (transforms.Length >= 2) {  	tempVct3 = new Vector3[transforms.Length];  	for (int i = 0; i < transforms.Length; i++) {  		if (transforms [i].IsNone)  			tempVct3 [i] = vectors [i].IsNone ? Vector3.zero : vectors [i].Value;  		else {  			if (transforms [i].Value == null)  				tempVct3 [i] = vectors [i].IsNone ? Vector3.zero : vectors [i].Value;  			else  				tempVct3 [i] = transforms [i].Value.transform.position + (vectors [i].IsNone ? Vector3.zero : vectors [i].Value);  		}  	}  	iTween.DrawPathGizmos (tempVct3' Color.yellow);  }  
Magic Number,HutongGames.PlayMaker.Actions,iTweenMoveTo,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\iTween\iTweenMoveTo.cs,DoiTween,The following statement contains a magic number: if (transforms.Length >= 2) {  	tempVct3 = new Vector3[transforms.Length];  	if (reverse.IsNone ? false : reverse.Value) {  		for (int i = 0; i < transforms.Length; i++) {  			if (transforms [i].IsNone)  				tempVct3 [tempVct3.Length - 1 - i] = vectors [i].IsNone ? Vector3.zero : vectors [i].Value;  			else {  				if (transforms [i].Value == null)  					tempVct3 [tempVct3.Length - 1 - i] = vectors [i].IsNone ? Vector3.zero : vectors [i].Value;  				else  					tempVct3 [tempVct3.Length - 1 - i] = (space == Space.World ? transforms [i].Value.transform.position : transforms [i].Value.transform.localPosition) + (vectors [i].IsNone ? Vector3.zero : vectors [i].Value);  			}  		}  	}  	else {  		for (int i = 0; i < transforms.Length; i++) {  			if (transforms [i].IsNone)  				tempVct3 [i] = vectors [i].IsNone ? Vector3.zero : vectors [i].Value;  			else {  				if (transforms [i].Value == null)  					tempVct3 [i] = vectors [i].IsNone ? Vector3.zero : vectors [i].Value;  				else  					tempVct3 [i] = (space == Space.World ? transforms [i].Value.transform.position : go.transform.parent.InverseTransformPoint (transforms [i].Value.transform.position)) + (vectors [i].IsNone ? Vector3.zero : vectors [i].Value);  			}  		}  	}  	hash.Add ("path"' tempVct3);  	hash.Add ("movetopath"' moveToPath.IsNone ? true : moveToPath.Value);  	hash.Add ("lookahead"' lookAhead.IsNone ? 1f : lookAhead.Value);  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.indices = new int[] {  	0'  	3'  	1'  	2'  	3'  	0  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.indices = new int[] {  	0'  	3'  	1'  	2'  	3'  	0  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.indices = new int[] {  	0'  	3'  	1'  	2'  	3'  	0  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.boundsData = new Vector3[2] {  	(boundsMax + boundsMin) / 2.0f'  	(boundsMax - boundsMin)  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.untrimmedBoundsData = new Vector3[2] {  	(boundsMax + boundsMin) / 2.0f'  	(boundsMax - boundsMin)  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'i':  	break;  // ignore version field for now  case 'w':  	textureDimensions.x = Int32.Parse (line.Substring (2));  	break;  case 'h':  	textureDimensions.y = Int32.Parse (line.Substring (2));  	break;  // total number of sprites would be ideal to statically allocate  case '~':  	state++;  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'i':  	break;  // ignore version field for now  case 'w':  	textureDimensions.x = Int32.Parse (line.Substring (2));  	break;  case 'h':  	textureDimensions.y = Int32.Parse (line.Substring (2));  	break;  // total number of sprites would be ideal to statically allocate  case '~':  	state++;  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: textureDimensions.x = Int32.Parse (line.Substring (2));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: textureDimensions.y = Int32.Parse (line.Substring (2));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryName = line.Substring (2);  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRotated = Int32.Parse (line.Substring (2)) == 1;  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildForChunk,The following statement contains a magic number: if (localMeshIndices.Length > 6) {  	// Remove duplicate verts  	localMeshVertices = WeldVertices (localMeshVertices' ref localMeshIndices);  	// Remove duplicate and back-to-back faces  	// Removes inside faces  	localMeshIndices = RemoveDuplicateFaces (localMeshIndices);  	// Merge coplanar faces  	// Optimize (remove unused vertices' reindex)  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [2] = new Vector3 (max.x' min.y' min.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [3] = new Vector3 (max.x' min.y' max.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [4] = new Vector3 (min.x' max.y' min.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [5] = new Vector3 (min.x' max.y' max.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [6] = new Vector3 (max.x' max.y' min.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [7] = new Vector3 (max.x' max.y' max.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {  	Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  	vertexList.Add (flippedPos + currentPos);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,CompareDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < 3; ++i) {  	int d = indices [face0index + i] - indices [face1index + i];  	if (d != 0)  		return d;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: i += 3
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: sortedFaceIndices [i + 2] = faceIndices [2];  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: sortedFaceIndices [i + 2] = faceIndices [2];  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	sortIndex [i / 3] = i;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	sortIndex [i / 3] = i;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: i += 3
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: sortIndex [i / 3] = i;  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < sortIndex.Length; ++i) {  	if (i != sortIndex.Length - 1 && CompareDuplicateFaces (sortedFaceIndices' sortIndex [i]' sortIndex [i + 1]) == 0) {  		// skip both faces  		// this will fail in the case where there are 3 coplanar faces  		// but that is probably likely user error / intentional  		i++;  		continue;  	}  	for (int j = 0; j < 3; ++j)  		newIndices.Add (indices [sortIndex [i] + j]);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int j = 0; j < 3; ++j)  	newIndices.Add (indices [sortIndex [i] + j]);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildForChunk,The following statement contains a magic number: if (localIndices.Length > 4) {  	// Remove duplicate verts' reindex  	localVerts = WeldVertices (localVerts' ref localIndices);  	// Remove duplicate and back-to-back edges  	// Removes inside edges  	localIndices = RemoveDuplicateEdges (localIndices);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = verts.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			boxPos [0] = new Vector2 (min.x' min.y);  			boxPos [1] = new Vector2 (max.x' min.y);  			boxPos [2] = new Vector2 (max.x' max.y);  			boxPos [3] = new Vector2 (min.x' max.y);  			for (int i = 0; i < 4; ++i) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  			}  			int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  			for (int i = 0; i < 8; ++i) {  				inds.Add (baseVertexIndex + boxIndices [i]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  				baseVertexIndex = verts.Count;  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts - 1; i > 0; --i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts - 1; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i + 1);  					}  				}  			}  			foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  				baseVertexIndex = verts.Count;  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts; i > 0; --i) {  						inds.Add (baseVertexIndex + (i % numVerts));  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + (i + 1) % numVerts);  					}  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = verts.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			boxPos [0] = new Vector2 (min.x' min.y);  			boxPos [1] = new Vector2 (max.x' min.y);  			boxPos [2] = new Vector2 (max.x' max.y);  			boxPos [3] = new Vector2 (min.x' max.y);  			for (int i = 0; i < 4; ++i) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  			}  			int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  			for (int i = 0; i < 8; ++i) {  				inds.Add (baseVertexIndex + boxIndices [i]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  				baseVertexIndex = verts.Count;  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts - 1; i > 0; --i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts - 1; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i + 1);  					}  				}  			}  			foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  				baseVertexIndex = verts.Count;  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts; i > 0; --i) {  						inds.Add (baseVertexIndex + (i % numVerts));  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + (i + 1) % numVerts);  					}  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = verts.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			boxPos [0] = new Vector2 (min.x' min.y);  			boxPos [1] = new Vector2 (max.x' min.y);  			boxPos [2] = new Vector2 (max.x' max.y);  			boxPos [3] = new Vector2 (min.x' max.y);  			for (int i = 0; i < 4; ++i) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  			}  			int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  			for (int i = 0; i < 8; ++i) {  				inds.Add (baseVertexIndex + boxIndices [i]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  				baseVertexIndex = verts.Count;  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts - 1; i > 0; --i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts - 1; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i + 1);  					}  				}  			}  			foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  				baseVertexIndex = verts.Count;  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts; i > 0; --i) {  						inds.Add (baseVertexIndex + (i % numVerts));  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + (i + 1) % numVerts);  					}  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = verts.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			boxPos [0] = new Vector2 (min.x' min.y);  			boxPos [1] = new Vector2 (max.x' min.y);  			boxPos [2] = new Vector2 (max.x' max.y);  			boxPos [3] = new Vector2 (min.x' max.y);  			for (int i = 0; i < 4; ++i) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  			}  			int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  			for (int i = 0; i < 8; ++i) {  				inds.Add (baseVertexIndex + boxIndices [i]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  				baseVertexIndex = verts.Count;  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts - 1; i > 0; --i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts - 1; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i + 1);  					}  				}  			}  			foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  				baseVertexIndex = verts.Count;  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts; i > 0; --i) {  						inds.Add (baseVertexIndex + (i % numVerts));  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + (i + 1) % numVerts);  					}  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = verts.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		boxPos [0] = new Vector2 (min.x' min.y);  		boxPos [1] = new Vector2 (max.x' min.y);  		boxPos [2] = new Vector2 (max.x' max.y);  		boxPos [3] = new Vector2 (min.x' max.y);  		for (int i = 0; i < 4; ++i) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  		}  		int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  		for (int i = 0; i < 8; ++i) {  			inds.Add (baseVertexIndex + boxIndices [i]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  			baseVertexIndex = verts.Count;  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts - 1; i > 0; --i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts - 1; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i + 1);  				}  			}  		}  		foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  			baseVertexIndex = verts.Count;  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts; i > 0; --i) {  					inds.Add (baseVertexIndex + (i % numVerts));  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + (i + 1) % numVerts);  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = verts.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		boxPos [0] = new Vector2 (min.x' min.y);  		boxPos [1] = new Vector2 (max.x' min.y);  		boxPos [2] = new Vector2 (max.x' max.y);  		boxPos [3] = new Vector2 (min.x' max.y);  		for (int i = 0; i < 4; ++i) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  		}  		int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  		for (int i = 0; i < 8; ++i) {  			inds.Add (baseVertexIndex + boxIndices [i]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  			baseVertexIndex = verts.Count;  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts - 1; i > 0; --i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts - 1; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i + 1);  				}  			}  		}  		foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  			baseVertexIndex = verts.Count;  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts; i > 0; --i) {  					inds.Add (baseVertexIndex + (i % numVerts));  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + (i + 1) % numVerts);  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = verts.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		boxPos [0] = new Vector2 (min.x' min.y);  		boxPos [1] = new Vector2 (max.x' min.y);  		boxPos [2] = new Vector2 (max.x' max.y);  		boxPos [3] = new Vector2 (min.x' max.y);  		for (int i = 0; i < 4; ++i) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  		}  		int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  		for (int i = 0; i < 8; ++i) {  			inds.Add (baseVertexIndex + boxIndices [i]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  			baseVertexIndex = verts.Count;  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts - 1; i > 0; --i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts - 1; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i + 1);  				}  			}  		}  		foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  			baseVertexIndex = verts.Count;  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts; i > 0; --i) {  					inds.Add (baseVertexIndex + (i % numVerts));  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + (i + 1) % numVerts);  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = verts.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		boxPos [0] = new Vector2 (min.x' min.y);  		boxPos [1] = new Vector2 (max.x' min.y);  		boxPos [2] = new Vector2 (max.x' max.y);  		boxPos [3] = new Vector2 (min.x' max.y);  		for (int i = 0; i < 4; ++i) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  		}  		int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  		for (int i = 0; i < 8; ++i) {  			inds.Add (baseVertexIndex + boxIndices [i]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  			baseVertexIndex = verts.Count;  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts - 1; i > 0; --i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts - 1; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i + 1);  				}  			}  		}  		foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  			baseVertexIndex = verts.Count;  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts; i > 0; --i) {  					inds.Add (baseVertexIndex + (i % numVerts));  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + (i + 1) % numVerts);  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	boxPos [0] = new Vector2 (min.x' min.y);  	boxPos [1] = new Vector2 (max.x' min.y);  	boxPos [2] = new Vector2 (max.x' max.y);  	boxPos [3] = new Vector2 (min.x' max.y);  	for (int i = 0; i < 4; ++i) {  		verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  	}  	int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  	for (int i = 0; i < 8; ++i) {  		inds.Add (baseVertexIndex + boxIndices [i]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  		baseVertexIndex = verts.Count;  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts - 1; i > 0; --i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts - 1; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i + 1);  			}  		}  	}  	foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  		baseVertexIndex = verts.Count;  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts; i > 0; --i) {  				inds.Add (baseVertexIndex + (i % numVerts));  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + (i + 1) % numVerts);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	boxPos [0] = new Vector2 (min.x' min.y);  	boxPos [1] = new Vector2 (max.x' min.y);  	boxPos [2] = new Vector2 (max.x' max.y);  	boxPos [3] = new Vector2 (min.x' max.y);  	for (int i = 0; i < 4; ++i) {  		verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  	}  	int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  	for (int i = 0; i < 8; ++i) {  		inds.Add (baseVertexIndex + boxIndices [i]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  		baseVertexIndex = verts.Count;  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts - 1; i > 0; --i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts - 1; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i + 1);  			}  		}  	}  	foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  		baseVertexIndex = verts.Count;  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts; i > 0; --i) {  				inds.Add (baseVertexIndex + (i % numVerts));  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + (i + 1) % numVerts);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	boxPos [0] = new Vector2 (min.x' min.y);  	boxPos [1] = new Vector2 (max.x' min.y);  	boxPos [2] = new Vector2 (max.x' max.y);  	boxPos [3] = new Vector2 (min.x' max.y);  	for (int i = 0; i < 4; ++i) {  		verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  	}  	int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  	for (int i = 0; i < 8; ++i) {  		inds.Add (baseVertexIndex + boxIndices [i]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  		baseVertexIndex = verts.Count;  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts - 1; i > 0; --i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts - 1; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i + 1);  			}  		}  	}  	foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  		baseVertexIndex = verts.Count;  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts; i > 0; --i) {  				inds.Add (baseVertexIndex + (i % numVerts));  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + (i + 1) % numVerts);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	boxPos [0] = new Vector2 (min.x' min.y);  	boxPos [1] = new Vector2 (max.x' min.y);  	boxPos [2] = new Vector2 (max.x' max.y);  	boxPos [3] = new Vector2 (min.x' max.y);  	for (int i = 0; i < 4; ++i) {  		verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  	}  	int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  	for (int i = 0; i < 8; ++i) {  		inds.Add (baseVertexIndex + boxIndices [i]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  		baseVertexIndex = verts.Count;  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts - 1; i > 0; --i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts - 1; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i + 1);  			}  		}  	}  	foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  		baseVertexIndex = verts.Count;  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts; i > 0; --i) {  				inds.Add (baseVertexIndex + (i % numVerts));  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + (i + 1) % numVerts);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: boxPos [2] = new Vector2 (max.x' max.y);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: boxPos [3] = new Vector2 (min.x' max.y);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int i = 0; i < 4; ++i) {  	verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {  	inds.Add (baseVertexIndex + boxIndices [i]);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,CompareDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {  	int d = indices [face0index + i] - indices [face1index + i];  	if (d != 0)  		return d;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 2) {  	if (indices [i] > indices [i + 1]) {  		sortedFaceIndices [i] = indices [i + 1];  		sortedFaceIndices [i + 1] = indices [i];  	}  	else {  		sortedFaceIndices [i] = indices [i];  		sortedFaceIndices [i + 1] = indices [i + 1];  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: i += 2
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 2) {  	sortIndex [i / 2] = i;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 2) {  	sortIndex [i / 2] = i;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: i += 2
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: sortIndex [i / 2] = i;  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: for (int i = 0; i < sortIndex.Length; ++i) {  	if (i != sortIndex.Length - 1 && CompareDuplicateFaces (sortedFaceIndices' sortIndex [i]' sortIndex [i + 1]) == 0) {  		// skip both faces  		// this will fail in the case where there are 3 coplanar faces  		// but that is probably likely user error / intentional  		i++;  		continue;  	}  	for (int j = 0; j < 2; ++j)  		newIndices.Add (indices [sortIndex [i] + j]);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: for (int j = 0; j < 2; ++j)  	newIndices.Add (indices [sortIndex [i] + j]);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: while (processedEdge) {  	processedEdge = false;  	for (int i = 0; i < edgeUsed.Length; ++i) {  		if (!edgeUsed [i]) {  			edgeUsed [i] = true;  			int v0 = indices [i * 2 + 0];  			int v1 = indices [i * 2 + 1];  			d0 = (verts [v1] - verts [v0]).normalized;  			edgeIndices.Add (v0);  			edgeIndices.Add (v1);  			// The connecting vertex for this edge list  			for (int k = i + 1; k < edgeUsed.Length; ++k) {  				if (edgeUsed [k]) {  					continue;  				}  				int w0 = indices [k * 2 + 0];  				if (w0 == v1) {  					int w1 = indices [k * 2 + 1];  					d1 = (verts [w1] - verts [w0]).normalized;  					// Same direction?  					if (Vector2.Dot (d1' d0) > 0.999f) {  						edgeIndices.RemoveAt (edgeIndices.Count - 1);  						// remove last  					}  					edgeIndices.Add (w1);  					edgeUsed [k] = true;  					d0 = d1;  					// new normal  					k = i;  					// restart the loop  					v1 = w1;  					// continuing from the end of the loop  					continue;  				}  			}  			processedEdge = true;  			break;  		}  	}  	if (processedEdge) {  		edgeVerts.Clear ();  		edgeVerts.Capacity = Mathf.Max (edgeVerts.Capacity' edgeIndices.Count);  		for (int i = 0; i < edgeIndices.Count; ++i) {  			edgeVerts.Add (verts [edgeIndices [i]]);  		}  		edges.Add (edgeVerts.ToArray ());  		edgeIndices.Clear ();  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: while (processedEdge) {  	processedEdge = false;  	for (int i = 0; i < edgeUsed.Length; ++i) {  		if (!edgeUsed [i]) {  			edgeUsed [i] = true;  			int v0 = indices [i * 2 + 0];  			int v1 = indices [i * 2 + 1];  			d0 = (verts [v1] - verts [v0]).normalized;  			edgeIndices.Add (v0);  			edgeIndices.Add (v1);  			// The connecting vertex for this edge list  			for (int k = i + 1; k < edgeUsed.Length; ++k) {  				if (edgeUsed [k]) {  					continue;  				}  				int w0 = indices [k * 2 + 0];  				if (w0 == v1) {  					int w1 = indices [k * 2 + 1];  					d1 = (verts [w1] - verts [w0]).normalized;  					// Same direction?  					if (Vector2.Dot (d1' d0) > 0.999f) {  						edgeIndices.RemoveAt (edgeIndices.Count - 1);  						// remove last  					}  					edgeIndices.Add (w1);  					edgeUsed [k] = true;  					d0 = d1;  					// new normal  					k = i;  					// restart the loop  					v1 = w1;  					// continuing from the end of the loop  					continue;  				}  			}  			processedEdge = true;  			break;  		}  	}  	if (processedEdge) {  		edgeVerts.Clear ();  		edgeVerts.Capacity = Mathf.Max (edgeVerts.Capacity' edgeIndices.Count);  		for (int i = 0; i < edgeIndices.Count; ++i) {  			edgeVerts.Add (verts [edgeIndices [i]]);  		}  		edges.Add (edgeVerts.ToArray ());  		edgeIndices.Clear ();  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: while (processedEdge) {  	processedEdge = false;  	for (int i = 0; i < edgeUsed.Length; ++i) {  		if (!edgeUsed [i]) {  			edgeUsed [i] = true;  			int v0 = indices [i * 2 + 0];  			int v1 = indices [i * 2 + 1];  			d0 = (verts [v1] - verts [v0]).normalized;  			edgeIndices.Add (v0);  			edgeIndices.Add (v1);  			// The connecting vertex for this edge list  			for (int k = i + 1; k < edgeUsed.Length; ++k) {  				if (edgeUsed [k]) {  					continue;  				}  				int w0 = indices [k * 2 + 0];  				if (w0 == v1) {  					int w1 = indices [k * 2 + 1];  					d1 = (verts [w1] - verts [w0]).normalized;  					// Same direction?  					if (Vector2.Dot (d1' d0) > 0.999f) {  						edgeIndices.RemoveAt (edgeIndices.Count - 1);  						// remove last  					}  					edgeIndices.Add (w1);  					edgeUsed [k] = true;  					d0 = d1;  					// new normal  					k = i;  					// restart the loop  					v1 = w1;  					// continuing from the end of the loop  					continue;  				}  			}  			processedEdge = true;  			break;  		}  	}  	if (processedEdge) {  		edgeVerts.Clear ();  		edgeVerts.Capacity = Mathf.Max (edgeVerts.Capacity' edgeIndices.Count);  		for (int i = 0; i < edgeIndices.Count; ++i) {  			edgeVerts.Add (verts [edgeIndices [i]]);  		}  		edges.Add (edgeVerts.ToArray ());  		edgeIndices.Clear ();  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: while (processedEdge) {  	processedEdge = false;  	for (int i = 0; i < edgeUsed.Length; ++i) {  		if (!edgeUsed [i]) {  			edgeUsed [i] = true;  			int v0 = indices [i * 2 + 0];  			int v1 = indices [i * 2 + 1];  			d0 = (verts [v1] - verts [v0]).normalized;  			edgeIndices.Add (v0);  			edgeIndices.Add (v1);  			// The connecting vertex for this edge list  			for (int k = i + 1; k < edgeUsed.Length; ++k) {  				if (edgeUsed [k]) {  					continue;  				}  				int w0 = indices [k * 2 + 0];  				if (w0 == v1) {  					int w1 = indices [k * 2 + 1];  					d1 = (verts [w1] - verts [w0]).normalized;  					// Same direction?  					if (Vector2.Dot (d1' d0) > 0.999f) {  						edgeIndices.RemoveAt (edgeIndices.Count - 1);  						// remove last  					}  					edgeIndices.Add (w1);  					edgeUsed [k] = true;  					d0 = d1;  					// new normal  					k = i;  					// restart the loop  					v1 = w1;  					// continuing from the end of the loop  					continue;  				}  			}  			processedEdge = true;  			break;  		}  	}  	if (processedEdge) {  		edgeVerts.Clear ();  		edgeVerts.Capacity = Mathf.Max (edgeVerts.Capacity' edgeIndices.Count);  		for (int i = 0; i < edgeIndices.Count; ++i) {  			edgeVerts.Add (verts [edgeIndices [i]]);  		}  		edges.Add (edgeVerts.ToArray ());  		edgeIndices.Clear ();  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: for (int i = 0; i < edgeUsed.Length; ++i) {  	if (!edgeUsed [i]) {  		edgeUsed [i] = true;  		int v0 = indices [i * 2 + 0];  		int v1 = indices [i * 2 + 1];  		d0 = (verts [v1] - verts [v0]).normalized;  		edgeIndices.Add (v0);  		edgeIndices.Add (v1);  		// The connecting vertex for this edge list  		for (int k = i + 1; k < edgeUsed.Length; ++k) {  			if (edgeUsed [k]) {  				continue;  			}  			int w0 = indices [k * 2 + 0];  			if (w0 == v1) {  				int w1 = indices [k * 2 + 1];  				d1 = (verts [w1] - verts [w0]).normalized;  				// Same direction?  				if (Vector2.Dot (d1' d0) > 0.999f) {  					edgeIndices.RemoveAt (edgeIndices.Count - 1);  					// remove last  				}  				edgeIndices.Add (w1);  				edgeUsed [k] = true;  				d0 = d1;  				// new normal  				k = i;  				// restart the loop  				v1 = w1;  				// continuing from the end of the loop  				continue;  			}  		}  		processedEdge = true;  		break;  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: for (int i = 0; i < edgeUsed.Length; ++i) {  	if (!edgeUsed [i]) {  		edgeUsed [i] = true;  		int v0 = indices [i * 2 + 0];  		int v1 = indices [i * 2 + 1];  		d0 = (verts [v1] - verts [v0]).normalized;  		edgeIndices.Add (v0);  		edgeIndices.Add (v1);  		// The connecting vertex for this edge list  		for (int k = i + 1; k < edgeUsed.Length; ++k) {  			if (edgeUsed [k]) {  				continue;  			}  			int w0 = indices [k * 2 + 0];  			if (w0 == v1) {  				int w1 = indices [k * 2 + 1];  				d1 = (verts [w1] - verts [w0]).normalized;  				// Same direction?  				if (Vector2.Dot (d1' d0) > 0.999f) {  					edgeIndices.RemoveAt (edgeIndices.Count - 1);  					// remove last  				}  				edgeIndices.Add (w1);  				edgeUsed [k] = true;  				d0 = d1;  				// new normal  				k = i;  				// restart the loop  				v1 = w1;  				// continuing from the end of the loop  				continue;  			}  		}  		processedEdge = true;  		break;  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: for (int i = 0; i < edgeUsed.Length; ++i) {  	if (!edgeUsed [i]) {  		edgeUsed [i] = true;  		int v0 = indices [i * 2 + 0];  		int v1 = indices [i * 2 + 1];  		d0 = (verts [v1] - verts [v0]).normalized;  		edgeIndices.Add (v0);  		edgeIndices.Add (v1);  		// The connecting vertex for this edge list  		for (int k = i + 1; k < edgeUsed.Length; ++k) {  			if (edgeUsed [k]) {  				continue;  			}  			int w0 = indices [k * 2 + 0];  			if (w0 == v1) {  				int w1 = indices [k * 2 + 1];  				d1 = (verts [w1] - verts [w0]).normalized;  				// Same direction?  				if (Vector2.Dot (d1' d0) > 0.999f) {  					edgeIndices.RemoveAt (edgeIndices.Count - 1);  					// remove last  				}  				edgeIndices.Add (w1);  				edgeUsed [k] = true;  				d0 = d1;  				// new normal  				k = i;  				// restart the loop  				v1 = w1;  				// continuing from the end of the loop  				continue;  			}  		}  		processedEdge = true;  		break;  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: for (int i = 0; i < edgeUsed.Length; ++i) {  	if (!edgeUsed [i]) {  		edgeUsed [i] = true;  		int v0 = indices [i * 2 + 0];  		int v1 = indices [i * 2 + 1];  		d0 = (verts [v1] - verts [v0]).normalized;  		edgeIndices.Add (v0);  		edgeIndices.Add (v1);  		// The connecting vertex for this edge list  		for (int k = i + 1; k < edgeUsed.Length; ++k) {  			if (edgeUsed [k]) {  				continue;  			}  			int w0 = indices [k * 2 + 0];  			if (w0 == v1) {  				int w1 = indices [k * 2 + 1];  				d1 = (verts [w1] - verts [w0]).normalized;  				// Same direction?  				if (Vector2.Dot (d1' d0) > 0.999f) {  					edgeIndices.RemoveAt (edgeIndices.Count - 1);  					// remove last  				}  				edgeIndices.Add (w1);  				edgeUsed [k] = true;  				d0 = d1;  				// new normal  				k = i;  				// restart the loop  				v1 = w1;  				// continuing from the end of the loop  				continue;  			}  		}  		processedEdge = true;  		break;  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: if (!edgeUsed [i]) {  	edgeUsed [i] = true;  	int v0 = indices [i * 2 + 0];  	int v1 = indices [i * 2 + 1];  	d0 = (verts [v1] - verts [v0]).normalized;  	edgeIndices.Add (v0);  	edgeIndices.Add (v1);  	// The connecting vertex for this edge list  	for (int k = i + 1; k < edgeUsed.Length; ++k) {  		if (edgeUsed [k]) {  			continue;  		}  		int w0 = indices [k * 2 + 0];  		if (w0 == v1) {  			int w1 = indices [k * 2 + 1];  			d1 = (verts [w1] - verts [w0]).normalized;  			// Same direction?  			if (Vector2.Dot (d1' d0) > 0.999f) {  				edgeIndices.RemoveAt (edgeIndices.Count - 1);  				// remove last  			}  			edgeIndices.Add (w1);  			edgeUsed [k] = true;  			d0 = d1;  			// new normal  			k = i;  			// restart the loop  			v1 = w1;  			// continuing from the end of the loop  			continue;  		}  	}  	processedEdge = true;  	break;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: if (!edgeUsed [i]) {  	edgeUsed [i] = true;  	int v0 = indices [i * 2 + 0];  	int v1 = indices [i * 2 + 1];  	d0 = (verts [v1] - verts [v0]).normalized;  	edgeIndices.Add (v0);  	edgeIndices.Add (v1);  	// The connecting vertex for this edge list  	for (int k = i + 1; k < edgeUsed.Length; ++k) {  		if (edgeUsed [k]) {  			continue;  		}  		int w0 = indices [k * 2 + 0];  		if (w0 == v1) {  			int w1 = indices [k * 2 + 1];  			d1 = (verts [w1] - verts [w0]).normalized;  			// Same direction?  			if (Vector2.Dot (d1' d0) > 0.999f) {  				edgeIndices.RemoveAt (edgeIndices.Count - 1);  				// remove last  			}  			edgeIndices.Add (w1);  			edgeUsed [k] = true;  			d0 = d1;  			// new normal  			k = i;  			// restart the loop  			v1 = w1;  			// continuing from the end of the loop  			continue;  		}  	}  	processedEdge = true;  	break;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: if (!edgeUsed [i]) {  	edgeUsed [i] = true;  	int v0 = indices [i * 2 + 0];  	int v1 = indices [i * 2 + 1];  	d0 = (verts [v1] - verts [v0]).normalized;  	edgeIndices.Add (v0);  	edgeIndices.Add (v1);  	// The connecting vertex for this edge list  	for (int k = i + 1; k < edgeUsed.Length; ++k) {  		if (edgeUsed [k]) {  			continue;  		}  		int w0 = indices [k * 2 + 0];  		if (w0 == v1) {  			int w1 = indices [k * 2 + 1];  			d1 = (verts [w1] - verts [w0]).normalized;  			// Same direction?  			if (Vector2.Dot (d1' d0) > 0.999f) {  				edgeIndices.RemoveAt (edgeIndices.Count - 1);  				// remove last  			}  			edgeIndices.Add (w1);  			edgeUsed [k] = true;  			d0 = d1;  			// new normal  			k = i;  			// restart the loop  			v1 = w1;  			// continuing from the end of the loop  			continue;  		}  	}  	processedEdge = true;  	break;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: if (!edgeUsed [i]) {  	edgeUsed [i] = true;  	int v0 = indices [i * 2 + 0];  	int v1 = indices [i * 2 + 1];  	d0 = (verts [v1] - verts [v0]).normalized;  	edgeIndices.Add (v0);  	edgeIndices.Add (v1);  	// The connecting vertex for this edge list  	for (int k = i + 1; k < edgeUsed.Length; ++k) {  		if (edgeUsed [k]) {  			continue;  		}  		int w0 = indices [k * 2 + 0];  		if (w0 == v1) {  			int w1 = indices [k * 2 + 1];  			d1 = (verts [w1] - verts [w0]).normalized;  			// Same direction?  			if (Vector2.Dot (d1' d0) > 0.999f) {  				edgeIndices.RemoveAt (edgeIndices.Count - 1);  				// remove last  			}  			edgeIndices.Add (w1);  			edgeUsed [k] = true;  			d0 = d1;  			// new normal  			k = i;  			// restart the loop  			v1 = w1;  			// continuing from the end of the loop  			continue;  		}  	}  	processedEdge = true;  	break;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: for (int k = i + 1; k < edgeUsed.Length; ++k) {  	if (edgeUsed [k]) {  		continue;  	}  	int w0 = indices [k * 2 + 0];  	if (w0 == v1) {  		int w1 = indices [k * 2 + 1];  		d1 = (verts [w1] - verts [w0]).normalized;  		// Same direction?  		if (Vector2.Dot (d1' d0) > 0.999f) {  			edgeIndices.RemoveAt (edgeIndices.Count - 1);  			// remove last  		}  		edgeIndices.Add (w1);  		edgeUsed [k] = true;  		d0 = d1;  		// new normal  		k = i;  		// restart the loop  		v1 = w1;  		// continuing from the end of the loop  		continue;  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: for (int k = i + 1; k < edgeUsed.Length; ++k) {  	if (edgeUsed [k]) {  		continue;  	}  	int w0 = indices [k * 2 + 0];  	if (w0 == v1) {  		int w1 = indices [k * 2 + 1];  		d1 = (verts [w1] - verts [w0]).normalized;  		// Same direction?  		if (Vector2.Dot (d1' d0) > 0.999f) {  			edgeIndices.RemoveAt (edgeIndices.Count - 1);  			// remove last  		}  		edgeIndices.Add (w1);  		edgeUsed [k] = true;  		d0 = d1;  		// new normal  		k = i;  		// restart the loop  		v1 = w1;  		// continuing from the end of the loop  		continue;  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: if (w0 == v1) {  	int w1 = indices [k * 2 + 1];  	d1 = (verts [w1] - verts [w0]).normalized;  	// Same direction?  	if (Vector2.Dot (d1' d0) > 0.999f) {  		edgeIndices.RemoveAt (edgeIndices.Count - 1);  		// remove last  	}  	edgeIndices.Add (w1);  	edgeUsed [k] = true;  	d0 = d1;  	// new normal  	k = i;  	// restart the loop  	v1 = w1;  	// continuing from the end of the loop  	continue;  }  
Magic Number,Spine,CurveTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,SetCurve,The following statement contains a magic number: for (int n = i + BEZIER_SIZE - 1; i < n; i += 2) {  	curves [i] = x;  	curves [i + 1] = y;  	dfx += ddfx;  	dfy += ddfy;  	ddfx += dddfx;  	ddfy += dddfy;  	x += dfx;  	y += dfy;  }  
Magic Number,Spine,CurveTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,SetCurve,The following statement contains a magic number: i += 2
Magic Number,Spine,CurveTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,GetCurvePercent,The following statement contains a magic number: for (int start = i' n = i + BEZIER_SIZE - 1; i < n; i += 2) {  	x = curves [i];  	if (x >= percent) {  		float prevX' prevY;  		if (i == start) {  			prevX = 0;  			prevY = 0;  		}  		else {  			prevX = curves [i - 2];  			prevY = curves [i - 1];  		}  		return prevY + (curves [i + 1] - prevY) * (percent - prevX) / (x - prevX);  	}  }  
Magic Number,Spine,CurveTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,GetCurvePercent,The following statement contains a magic number: for (int start = i' n = i + BEZIER_SIZE - 1; i < n; i += 2) {  	x = curves [i];  	if (x >= percent) {  		float prevX' prevY;  		if (i == start) {  			prevX = 0;  			prevY = 0;  		}  		else {  			prevX = curves [i - 2];  			prevY = curves [i - 1];  		}  		return prevY + (curves [i + 1] - prevY) * (percent - prevX) / (x - prevX);  	}  }  
Magic Number,Spine,CurveTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,GetCurvePercent,The following statement contains a magic number: i += 2
Magic Number,Spine,CurveTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,GetCurvePercent,The following statement contains a magic number: if (x >= percent) {  	float prevX' prevY;  	if (i == start) {  		prevX = 0;  		prevY = 0;  	}  	else {  		prevX = curves [i - 2];  		prevY = curves [i - 1];  	}  	return prevY + (curves [i + 1] - prevY) * (percent - prevX) / (x - prevX);  }  
Magic Number,Spine,CurveTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,GetCurvePercent,The following statement contains a magic number: if (i == start) {  	prevX = 0;  	prevY = 0;  }  else {  	prevX = curves [i - 2];  	prevY = curves [i - 1];  }  
Magic Number,Spine,CurveTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,GetCurvePercent,The following statement contains a magic number: prevX = curves [i - 2];  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,RotateTimeline,The following statement contains a magic number: frames = new float[frameCount * 2];  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,SetFrame,The following statement contains a magic number: frameIndex *= 2;  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 2]) {  	// Time is after last frame.  	amount = bone.data.rotation + frames [frames.Length - 1] - bone.rotation;  	while (amount > 180)  		amount -= 360;  	while (amount < -180)  		amount += 360;  	bone.rotation += amount * alpha;  	return;  }  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 2]) {  	// Time is after last frame.  	amount = bone.data.rotation + frames [frames.Length - 1] - bone.rotation;  	while (amount > 180)  		amount -= 360;  	while (amount < -180)  		amount += 360;  	bone.rotation += amount * alpha;  	return;  }  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 2]) {  	// Time is after last frame.  	amount = bone.data.rotation + frames [frames.Length - 1] - bone.rotation;  	while (amount > 180)  		amount -= 360;  	while (amount < -180)  		amount += 360;  	bone.rotation += amount * alpha;  	return;  }  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 2]) {  	// Time is after last frame.  	amount = bone.data.rotation + frames [frames.Length - 1] - bone.rotation;  	while (amount > 180)  		amount -= 360;  	while (amount < -180)  		amount += 360;  	bone.rotation += amount * alpha;  	return;  }  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 2]) {  	// Time is after last frame.  	amount = bone.data.rotation + frames [frames.Length - 1] - bone.rotation;  	while (amount > 180)  		amount -= 360;  	while (amount < -180)  		amount += 360;  	bone.rotation += amount * alpha;  	return;  }  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount > 180)  	amount -= 360;  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount > 180)  	amount -= 360;  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: amount -= 360;  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount < -180)  	amount += 360;  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount < -180)  	amount += 360;  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: amount += 360;  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount > 180)  	amount -= 360;  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount > 180)  	amount -= 360;  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: amount -= 360;  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount < -180)  	amount += 360;  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount < -180)  	amount += 360;  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: amount += 360;  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount > 180)  	amount -= 360;  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount > 180)  	amount -= 360;  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: amount -= 360;  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount < -180)  	amount += 360;  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount < -180)  	amount += 360;  
Magic Number,Spine,RotateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: amount += 360;  
Magic Number,Spine,TranslateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,TranslateTimeline,The following statement contains a magic number: frames = new float[frameCount * 3];  
Magic Number,Spine,TranslateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,SetFrame,The following statement contains a magic number: frameIndex *= 3;  
Magic Number,Spine,TranslateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,SetFrame,The following statement contains a magic number: frames [frameIndex + 2] = y;  
Magic Number,Spine,TranslateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 3]) {  	// Time is after last frame.  	bone.x += (bone.data.x + frames [frames.Length - 2] - bone.x) * alpha;  	bone.y += (bone.data.y + frames [frames.Length - 1] - bone.y) * alpha;  	return;  }  
Magic Number,Spine,TranslateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 3]) {  	// Time is after last frame.  	bone.x += (bone.data.x + frames [frames.Length - 2] - bone.x) * alpha;  	bone.y += (bone.data.y + frames [frames.Length - 1] - bone.y) * alpha;  	return;  }  
Magic Number,Spine,TranslateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: bone.x += (bone.data.x + frames [frames.Length - 2] - bone.x) * alpha;  
Magic Number,Spine,TranslateTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: percent = GetCurvePercent (frameIndex / 3 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));  
Magic Number,Spine,ScaleTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 3]) {  	// Time is after last frame.  	bone.scaleX += (bone.data.scaleX - 1 + frames [frames.Length - 2] - bone.scaleX) * alpha;  	bone.scaleY += (bone.data.scaleY - 1 + frames [frames.Length - 1] - bone.scaleY) * alpha;  	return;  }  
Magic Number,Spine,ScaleTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 3]) {  	// Time is after last frame.  	bone.scaleX += (bone.data.scaleX - 1 + frames [frames.Length - 2] - bone.scaleX) * alpha;  	bone.scaleY += (bone.data.scaleY - 1 + frames [frames.Length - 1] - bone.scaleY) * alpha;  	return;  }  
Magic Number,Spine,ScaleTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: bone.scaleX += (bone.data.scaleX - 1 + frames [frames.Length - 2] - bone.scaleX) * alpha;  
Magic Number,Spine,ScaleTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: percent = GetCurvePercent (frameIndex / 3 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));  
Magic Number,Spine,ColorTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,ColorTimeline,The following statement contains a magic number: frames = new float[frameCount * 5];  
Magic Number,Spine,ColorTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,setFrame,The following statement contains a magic number: frameIndex *= 5;  
Magic Number,Spine,ColorTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,setFrame,The following statement contains a magic number: frames [frameIndex + 2] = g;  
Magic Number,Spine,ColorTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,setFrame,The following statement contains a magic number: frames [frameIndex + 3] = b;  
Magic Number,Spine,ColorTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,setFrame,The following statement contains a magic number: frames [frameIndex + 4] = a;  
Magic Number,Spine,ColorTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 5]) {  	// Time is after last frame.  	int i = frames.Length - 1;  	r = frames [i - 3];  	g = frames [i - 2];  	b = frames [i - 1];  	a = frames [i];  }  else {  	// Interpolate between the last frame and the current frame.  	int frameIndex = Animation.binarySearch (frames' time' 5);  	float lastFrameR = frames [frameIndex - 4];  	float lastFrameG = frames [frameIndex - 3];  	float lastFrameB = frames [frameIndex - 2];  	float lastFrameA = frames [frameIndex - 1];  	float frameTime = frames [frameIndex];  	float percent = 1 - (time - frameTime) / (frames [frameIndex + LAST_FRAME_TIME] - frameTime);  	percent = GetCurvePercent (frameIndex / 5 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));  	r = lastFrameR + (frames [frameIndex + FRAME_R] - lastFrameR) * percent;  	g = lastFrameG + (frames [frameIndex + FRAME_G] - lastFrameG) * percent;  	b = lastFrameB + (frames [frameIndex + FRAME_B] - lastFrameB) * percent;  	a = lastFrameA + (frames [frameIndex + FRAME_A] - lastFrameA) * percent;  }  
Magic Number,Spine,ColorTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 5]) {  	// Time is after last frame.  	int i = frames.Length - 1;  	r = frames [i - 3];  	g = frames [i - 2];  	b = frames [i - 1];  	a = frames [i];  }  else {  	// Interpolate between the last frame and the current frame.  	int frameIndex = Animation.binarySearch (frames' time' 5);  	float lastFrameR = frames [frameIndex - 4];  	float lastFrameG = frames [frameIndex - 3];  	float lastFrameB = frames [frameIndex - 2];  	float lastFrameA = frames [frameIndex - 1];  	float frameTime = frames [frameIndex];  	float percent = 1 - (time - frameTime) / (frames [frameIndex + LAST_FRAME_TIME] - frameTime);  	percent = GetCurvePercent (frameIndex / 5 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));  	r = lastFrameR + (frames [frameIndex + FRAME_R] - lastFrameR) * percent;  	g = lastFrameG + (frames [frameIndex + FRAME_G] - lastFrameG) * percent;  	b = lastFrameB + (frames [frameIndex + FRAME_B] - lastFrameB) * percent;  	a = lastFrameA + (frames [frameIndex + FRAME_A] - lastFrameA) * percent;  }  
Magic Number,Spine,ColorTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 5]) {  	// Time is after last frame.  	int i = frames.Length - 1;  	r = frames [i - 3];  	g = frames [i - 2];  	b = frames [i - 1];  	a = frames [i];  }  else {  	// Interpolate between the last frame and the current frame.  	int frameIndex = Animation.binarySearch (frames' time' 5);  	float lastFrameR = frames [frameIndex - 4];  	float lastFrameG = frames [frameIndex - 3];  	float lastFrameB = frames [frameIndex - 2];  	float lastFrameA = frames [frameIndex - 1];  	float frameTime = frames [frameIndex];  	float percent = 1 - (time - frameTime) / (frames [frameIndex + LAST_FRAME_TIME] - frameTime);  	percent = GetCurvePercent (frameIndex / 5 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));  	r = lastFrameR + (frames [frameIndex + FRAME_R] - lastFrameR) * percent;  	g = lastFrameG + (frames [frameIndex + FRAME_G] - lastFrameG) * percent;  	b = lastFrameB + (frames [frameIndex + FRAME_B] - lastFrameB) * percent;  	a = lastFrameA + (frames [frameIndex + FRAME_A] - lastFrameA) * percent;  }  
Magic Number,Spine,ColorTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 5]) {  	// Time is after last frame.  	int i = frames.Length - 1;  	r = frames [i - 3];  	g = frames [i - 2];  	b = frames [i - 1];  	a = frames [i];  }  else {  	// Interpolate between the last frame and the current frame.  	int frameIndex = Animation.binarySearch (frames' time' 5);  	float lastFrameR = frames [frameIndex - 4];  	float lastFrameG = frames [frameIndex - 3];  	float lastFrameB = frames [frameIndex - 2];  	float lastFrameA = frames [frameIndex - 1];  	float frameTime = frames [frameIndex];  	float percent = 1 - (time - frameTime) / (frames [frameIndex + LAST_FRAME_TIME] - frameTime);  	percent = GetCurvePercent (frameIndex / 5 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));  	r = lastFrameR + (frames [frameIndex + FRAME_R] - lastFrameR) * percent;  	g = lastFrameG + (frames [frameIndex + FRAME_G] - lastFrameG) * percent;  	b = lastFrameB + (frames [frameIndex + FRAME_B] - lastFrameB) * percent;  	a = lastFrameA + (frames [frameIndex + FRAME_A] - lastFrameA) * percent;  }  
Magic Number,Spine,ColorTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 5]) {  	// Time is after last frame.  	int i = frames.Length - 1;  	r = frames [i - 3];  	g = frames [i - 2];  	b = frames [i - 1];  	a = frames [i];  }  else {  	// Interpolate between the last frame and the current frame.  	int frameIndex = Animation.binarySearch (frames' time' 5);  	float lastFrameR = frames [frameIndex - 4];  	float lastFrameG = frames [frameIndex - 3];  	float lastFrameB = frames [frameIndex - 2];  	float lastFrameA = frames [frameIndex - 1];  	float frameTime = frames [frameIndex];  	float percent = 1 - (time - frameTime) / (frames [frameIndex + LAST_FRAME_TIME] - frameTime);  	percent = GetCurvePercent (frameIndex / 5 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));  	r = lastFrameR + (frames [frameIndex + FRAME_R] - lastFrameR) * percent;  	g = lastFrameG + (frames [frameIndex + FRAME_G] - lastFrameG) * percent;  	b = lastFrameB + (frames [frameIndex + FRAME_B] - lastFrameB) * percent;  	a = lastFrameA + (frames [frameIndex + FRAME_A] - lastFrameA) * percent;  }  
Magic Number,Spine,ColorTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 5]) {  	// Time is after last frame.  	int i = frames.Length - 1;  	r = frames [i - 3];  	g = frames [i - 2];  	b = frames [i - 1];  	a = frames [i];  }  else {  	// Interpolate between the last frame and the current frame.  	int frameIndex = Animation.binarySearch (frames' time' 5);  	float lastFrameR = frames [frameIndex - 4];  	float lastFrameG = frames [frameIndex - 3];  	float lastFrameB = frames [frameIndex - 2];  	float lastFrameA = frames [frameIndex - 1];  	float frameTime = frames [frameIndex];  	float percent = 1 - (time - frameTime) / (frames [frameIndex + LAST_FRAME_TIME] - frameTime);  	percent = GetCurvePercent (frameIndex / 5 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));  	r = lastFrameR + (frames [frameIndex + FRAME_R] - lastFrameR) * percent;  	g = lastFrameG + (frames [frameIndex + FRAME_G] - lastFrameG) * percent;  	b = lastFrameB + (frames [frameIndex + FRAME_B] - lastFrameB) * percent;  	a = lastFrameA + (frames [frameIndex + FRAME_A] - lastFrameA) * percent;  }  
Magic Number,Spine,ColorTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 5]) {  	// Time is after last frame.  	int i = frames.Length - 1;  	r = frames [i - 3];  	g = frames [i - 2];  	b = frames [i - 1];  	a = frames [i];  }  else {  	// Interpolate between the last frame and the current frame.  	int frameIndex = Animation.binarySearch (frames' time' 5);  	float lastFrameR = frames [frameIndex - 4];  	float lastFrameG = frames [frameIndex - 3];  	float lastFrameB = frames [frameIndex - 2];  	float lastFrameA = frames [frameIndex - 1];  	float frameTime = frames [frameIndex];  	float percent = 1 - (time - frameTime) / (frames [frameIndex + LAST_FRAME_TIME] - frameTime);  	percent = GetCurvePercent (frameIndex / 5 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));  	r = lastFrameR + (frames [frameIndex + FRAME_R] - lastFrameR) * percent;  	g = lastFrameG + (frames [frameIndex + FRAME_G] - lastFrameG) * percent;  	b = lastFrameB + (frames [frameIndex + FRAME_B] - lastFrameB) * percent;  	a = lastFrameA + (frames [frameIndex + FRAME_A] - lastFrameA) * percent;  }  
Magic Number,Spine,ColorTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 5]) {  	// Time is after last frame.  	int i = frames.Length - 1;  	r = frames [i - 3];  	g = frames [i - 2];  	b = frames [i - 1];  	a = frames [i];  }  else {  	// Interpolate between the last frame and the current frame.  	int frameIndex = Animation.binarySearch (frames' time' 5);  	float lastFrameR = frames [frameIndex - 4];  	float lastFrameG = frames [frameIndex - 3];  	float lastFrameB = frames [frameIndex - 2];  	float lastFrameA = frames [frameIndex - 1];  	float frameTime = frames [frameIndex];  	float percent = 1 - (time - frameTime) / (frames [frameIndex + LAST_FRAME_TIME] - frameTime);  	percent = GetCurvePercent (frameIndex / 5 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));  	r = lastFrameR + (frames [frameIndex + FRAME_R] - lastFrameR) * percent;  	g = lastFrameG + (frames [frameIndex + FRAME_G] - lastFrameG) * percent;  	b = lastFrameB + (frames [frameIndex + FRAME_B] - lastFrameB) * percent;  	a = lastFrameA + (frames [frameIndex + FRAME_A] - lastFrameA) * percent;  }  
Magic Number,Spine,ColorTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: r = frames [i - 3];  
Magic Number,Spine,ColorTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: g = frames [i - 2];  
Magic Number,Spine,ColorTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: percent = GetCurvePercent (frameIndex / 5 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));  
Magic Number,Spine,IkConstraintTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,IkConstraintTimeline,The following statement contains a magic number: frames = new float[frameCount * 3];  
Magic Number,Spine,IkConstraintTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,setFrame,The following statement contains a magic number: frameIndex *= 3;  
Magic Number,Spine,IkConstraintTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,setFrame,The following statement contains a magic number: frames [frameIndex + 2] = bendDirection;  
Magic Number,Spine,IkConstraintTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 3]) {  	// Time is after last frame.  	ikConstraint.mix += (frames [frames.Length - 2] - ikConstraint.mix) * alpha;  	ikConstraint.bendDirection = (int)frames [frames.Length - 1];  	return;  }  
Magic Number,Spine,IkConstraintTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 3]) {  	// Time is after last frame.  	ikConstraint.mix += (frames [frames.Length - 2] - ikConstraint.mix) * alpha;  	ikConstraint.bendDirection = (int)frames [frames.Length - 1];  	return;  }  
Magic Number,Spine,IkConstraintTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: ikConstraint.mix += (frames [frames.Length - 2] - ikConstraint.mix) * alpha;  
Magic Number,Spine,IkConstraintTimeline,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: percent = GetCurvePercent (frameIndex / 3 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: while (true) {  	String line = reader.ReadLine ();  	if (line == null)  		break;  	if (line.Trim ().Length == 0)  		page = null;  	else if (page == null) {  		page = new AtlasPage ();  		page.name = line;  		if (readTuple (reader' tuple) == 2) {  			// size is only optional for an atlas packed with an old TexturePacker.  			page.width = int.Parse (tuple [0]);  			page.height = int.Parse (tuple [1]);  			readTuple (reader' tuple);  		}  		page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  		readTuple (reader' tuple);  		page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  		page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  		String direction = readValue (reader);  		page.uWrap = TextureWrap.ClampToEdge;  		page.vWrap = TextureWrap.ClampToEdge;  		if (direction == "x")  			page.uWrap = TextureWrap.Repeat;  		else if (direction == "y")  			page.vWrap = TextureWrap.Repeat;  		else if (direction == "xy")  			page.uWrap = page.vWrap = TextureWrap.Repeat;  		textureLoader.Load (page' Path.Combine (imagesDir' line));  		pages.Add (page);  	}  	else {  		AtlasRegion region = new AtlasRegion ();  		region.name = line;  		region.page = page;  		region.rotate = Boolean.Parse (readValue (reader));  		readTuple (reader' tuple);  		int x = int.Parse (tuple [0]);  		int y = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		int width = int.Parse (tuple [0]);  		int height = int.Parse (tuple [1]);  		region.u = x / (float)page.width;  		region.v = y / (float)page.height;  		if (region.rotate) {  			region.u2 = (x + height) / (float)page.width;  			region.v2 = (y + width) / (float)page.height;  		}  		else {  			region.u2 = (x + width) / (float)page.width;  			region.v2 = (y + height) / (float)page.height;  		}  		region.x = x;  		region.y = y;  		region.width = Math.Abs (width);  		region.height = Math.Abs (height);  		if (readTuple (reader' tuple) == 4) {  			// split is optional  			region.splits = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			if (readTuple (reader' tuple) == 4) {  				// pad is optional' but only present with splits  				region.pads = new int[] {  					int.Parse (tuple [0])'  					int.Parse (tuple [1])'  					int.Parse (tuple [2])'  					int.Parse (tuple [3])  				};  				readTuple (reader' tuple);  			}  		}  		region.originalWidth = int.Parse (tuple [0]);  		region.originalHeight = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		region.offsetX = int.Parse (tuple [0]);  		region.offsetY = int.Parse (tuple [1]);  		region.index = int.Parse (readValue (reader));  		regions.Add (region);  	}  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: while (true) {  	String line = reader.ReadLine ();  	if (line == null)  		break;  	if (line.Trim ().Length == 0)  		page = null;  	else if (page == null) {  		page = new AtlasPage ();  		page.name = line;  		if (readTuple (reader' tuple) == 2) {  			// size is only optional for an atlas packed with an old TexturePacker.  			page.width = int.Parse (tuple [0]);  			page.height = int.Parse (tuple [1]);  			readTuple (reader' tuple);  		}  		page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  		readTuple (reader' tuple);  		page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  		page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  		String direction = readValue (reader);  		page.uWrap = TextureWrap.ClampToEdge;  		page.vWrap = TextureWrap.ClampToEdge;  		if (direction == "x")  			page.uWrap = TextureWrap.Repeat;  		else if (direction == "y")  			page.vWrap = TextureWrap.Repeat;  		else if (direction == "xy")  			page.uWrap = page.vWrap = TextureWrap.Repeat;  		textureLoader.Load (page' Path.Combine (imagesDir' line));  		pages.Add (page);  	}  	else {  		AtlasRegion region = new AtlasRegion ();  		region.name = line;  		region.page = page;  		region.rotate = Boolean.Parse (readValue (reader));  		readTuple (reader' tuple);  		int x = int.Parse (tuple [0]);  		int y = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		int width = int.Parse (tuple [0]);  		int height = int.Parse (tuple [1]);  		region.u = x / (float)page.width;  		region.v = y / (float)page.height;  		if (region.rotate) {  			region.u2 = (x + height) / (float)page.width;  			region.v2 = (y + width) / (float)page.height;  		}  		else {  			region.u2 = (x + width) / (float)page.width;  			region.v2 = (y + height) / (float)page.height;  		}  		region.x = x;  		region.y = y;  		region.width = Math.Abs (width);  		region.height = Math.Abs (height);  		if (readTuple (reader' tuple) == 4) {  			// split is optional  			region.splits = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			if (readTuple (reader' tuple) == 4) {  				// pad is optional' but only present with splits  				region.pads = new int[] {  					int.Parse (tuple [0])'  					int.Parse (tuple [1])'  					int.Parse (tuple [2])'  					int.Parse (tuple [3])  				};  				readTuple (reader' tuple);  			}  		}  		region.originalWidth = int.Parse (tuple [0]);  		region.originalHeight = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		region.offsetX = int.Parse (tuple [0]);  		region.offsetY = int.Parse (tuple [1]);  		region.index = int.Parse (readValue (reader));  		regions.Add (region);  	}  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: while (true) {  	String line = reader.ReadLine ();  	if (line == null)  		break;  	if (line.Trim ().Length == 0)  		page = null;  	else if (page == null) {  		page = new AtlasPage ();  		page.name = line;  		if (readTuple (reader' tuple) == 2) {  			// size is only optional for an atlas packed with an old TexturePacker.  			page.width = int.Parse (tuple [0]);  			page.height = int.Parse (tuple [1]);  			readTuple (reader' tuple);  		}  		page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  		readTuple (reader' tuple);  		page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  		page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  		String direction = readValue (reader);  		page.uWrap = TextureWrap.ClampToEdge;  		page.vWrap = TextureWrap.ClampToEdge;  		if (direction == "x")  			page.uWrap = TextureWrap.Repeat;  		else if (direction == "y")  			page.vWrap = TextureWrap.Repeat;  		else if (direction == "xy")  			page.uWrap = page.vWrap = TextureWrap.Repeat;  		textureLoader.Load (page' Path.Combine (imagesDir' line));  		pages.Add (page);  	}  	else {  		AtlasRegion region = new AtlasRegion ();  		region.name = line;  		region.page = page;  		region.rotate = Boolean.Parse (readValue (reader));  		readTuple (reader' tuple);  		int x = int.Parse (tuple [0]);  		int y = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		int width = int.Parse (tuple [0]);  		int height = int.Parse (tuple [1]);  		region.u = x / (float)page.width;  		region.v = y / (float)page.height;  		if (region.rotate) {  			region.u2 = (x + height) / (float)page.width;  			region.v2 = (y + width) / (float)page.height;  		}  		else {  			region.u2 = (x + width) / (float)page.width;  			region.v2 = (y + height) / (float)page.height;  		}  		region.x = x;  		region.y = y;  		region.width = Math.Abs (width);  		region.height = Math.Abs (height);  		if (readTuple (reader' tuple) == 4) {  			// split is optional  			region.splits = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			if (readTuple (reader' tuple) == 4) {  				// pad is optional' but only present with splits  				region.pads = new int[] {  					int.Parse (tuple [0])'  					int.Parse (tuple [1])'  					int.Parse (tuple [2])'  					int.Parse (tuple [3])  				};  				readTuple (reader' tuple);  			}  		}  		region.originalWidth = int.Parse (tuple [0]);  		region.originalHeight = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		region.offsetX = int.Parse (tuple [0]);  		region.offsetY = int.Parse (tuple [1]);  		region.index = int.Parse (readValue (reader));  		regions.Add (region);  	}  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: while (true) {  	String line = reader.ReadLine ();  	if (line == null)  		break;  	if (line.Trim ().Length == 0)  		page = null;  	else if (page == null) {  		page = new AtlasPage ();  		page.name = line;  		if (readTuple (reader' tuple) == 2) {  			// size is only optional for an atlas packed with an old TexturePacker.  			page.width = int.Parse (tuple [0]);  			page.height = int.Parse (tuple [1]);  			readTuple (reader' tuple);  		}  		page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  		readTuple (reader' tuple);  		page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  		page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  		String direction = readValue (reader);  		page.uWrap = TextureWrap.ClampToEdge;  		page.vWrap = TextureWrap.ClampToEdge;  		if (direction == "x")  			page.uWrap = TextureWrap.Repeat;  		else if (direction == "y")  			page.vWrap = TextureWrap.Repeat;  		else if (direction == "xy")  			page.uWrap = page.vWrap = TextureWrap.Repeat;  		textureLoader.Load (page' Path.Combine (imagesDir' line));  		pages.Add (page);  	}  	else {  		AtlasRegion region = new AtlasRegion ();  		region.name = line;  		region.page = page;  		region.rotate = Boolean.Parse (readValue (reader));  		readTuple (reader' tuple);  		int x = int.Parse (tuple [0]);  		int y = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		int width = int.Parse (tuple [0]);  		int height = int.Parse (tuple [1]);  		region.u = x / (float)page.width;  		region.v = y / (float)page.height;  		if (region.rotate) {  			region.u2 = (x + height) / (float)page.width;  			region.v2 = (y + width) / (float)page.height;  		}  		else {  			region.u2 = (x + width) / (float)page.width;  			region.v2 = (y + height) / (float)page.height;  		}  		region.x = x;  		region.y = y;  		region.width = Math.Abs (width);  		region.height = Math.Abs (height);  		if (readTuple (reader' tuple) == 4) {  			// split is optional  			region.splits = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			if (readTuple (reader' tuple) == 4) {  				// pad is optional' but only present with splits  				region.pads = new int[] {  					int.Parse (tuple [0])'  					int.Parse (tuple [1])'  					int.Parse (tuple [2])'  					int.Parse (tuple [3])  				};  				readTuple (reader' tuple);  			}  		}  		region.originalWidth = int.Parse (tuple [0]);  		region.originalHeight = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		region.offsetX = int.Parse (tuple [0]);  		region.offsetY = int.Parse (tuple [1]);  		region.index = int.Parse (readValue (reader));  		regions.Add (region);  	}  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: while (true) {  	String line = reader.ReadLine ();  	if (line == null)  		break;  	if (line.Trim ().Length == 0)  		page = null;  	else if (page == null) {  		page = new AtlasPage ();  		page.name = line;  		if (readTuple (reader' tuple) == 2) {  			// size is only optional for an atlas packed with an old TexturePacker.  			page.width = int.Parse (tuple [0]);  			page.height = int.Parse (tuple [1]);  			readTuple (reader' tuple);  		}  		page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  		readTuple (reader' tuple);  		page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  		page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  		String direction = readValue (reader);  		page.uWrap = TextureWrap.ClampToEdge;  		page.vWrap = TextureWrap.ClampToEdge;  		if (direction == "x")  			page.uWrap = TextureWrap.Repeat;  		else if (direction == "y")  			page.vWrap = TextureWrap.Repeat;  		else if (direction == "xy")  			page.uWrap = page.vWrap = TextureWrap.Repeat;  		textureLoader.Load (page' Path.Combine (imagesDir' line));  		pages.Add (page);  	}  	else {  		AtlasRegion region = new AtlasRegion ();  		region.name = line;  		region.page = page;  		region.rotate = Boolean.Parse (readValue (reader));  		readTuple (reader' tuple);  		int x = int.Parse (tuple [0]);  		int y = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		int width = int.Parse (tuple [0]);  		int height = int.Parse (tuple [1]);  		region.u = x / (float)page.width;  		region.v = y / (float)page.height;  		if (region.rotate) {  			region.u2 = (x + height) / (float)page.width;  			region.v2 = (y + width) / (float)page.height;  		}  		else {  			region.u2 = (x + width) / (float)page.width;  			region.v2 = (y + height) / (float)page.height;  		}  		region.x = x;  		region.y = y;  		region.width = Math.Abs (width);  		region.height = Math.Abs (height);  		if (readTuple (reader' tuple) == 4) {  			// split is optional  			region.splits = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			if (readTuple (reader' tuple) == 4) {  				// pad is optional' but only present with splits  				region.pads = new int[] {  					int.Parse (tuple [0])'  					int.Parse (tuple [1])'  					int.Parse (tuple [2])'  					int.Parse (tuple [3])  				};  				readTuple (reader' tuple);  			}  		}  		region.originalWidth = int.Parse (tuple [0]);  		region.originalHeight = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		region.offsetX = int.Parse (tuple [0]);  		region.offsetY = int.Parse (tuple [1]);  		region.index = int.Parse (readValue (reader));  		regions.Add (region);  	}  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: while (true) {  	String line = reader.ReadLine ();  	if (line == null)  		break;  	if (line.Trim ().Length == 0)  		page = null;  	else if (page == null) {  		page = new AtlasPage ();  		page.name = line;  		if (readTuple (reader' tuple) == 2) {  			// size is only optional for an atlas packed with an old TexturePacker.  			page.width = int.Parse (tuple [0]);  			page.height = int.Parse (tuple [1]);  			readTuple (reader' tuple);  		}  		page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  		readTuple (reader' tuple);  		page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  		page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  		String direction = readValue (reader);  		page.uWrap = TextureWrap.ClampToEdge;  		page.vWrap = TextureWrap.ClampToEdge;  		if (direction == "x")  			page.uWrap = TextureWrap.Repeat;  		else if (direction == "y")  			page.vWrap = TextureWrap.Repeat;  		else if (direction == "xy")  			page.uWrap = page.vWrap = TextureWrap.Repeat;  		textureLoader.Load (page' Path.Combine (imagesDir' line));  		pages.Add (page);  	}  	else {  		AtlasRegion region = new AtlasRegion ();  		region.name = line;  		region.page = page;  		region.rotate = Boolean.Parse (readValue (reader));  		readTuple (reader' tuple);  		int x = int.Parse (tuple [0]);  		int y = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		int width = int.Parse (tuple [0]);  		int height = int.Parse (tuple [1]);  		region.u = x / (float)page.width;  		region.v = y / (float)page.height;  		if (region.rotate) {  			region.u2 = (x + height) / (float)page.width;  			region.v2 = (y + width) / (float)page.height;  		}  		else {  			region.u2 = (x + width) / (float)page.width;  			region.v2 = (y + height) / (float)page.height;  		}  		region.x = x;  		region.y = y;  		region.width = Math.Abs (width);  		region.height = Math.Abs (height);  		if (readTuple (reader' tuple) == 4) {  			// split is optional  			region.splits = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			if (readTuple (reader' tuple) == 4) {  				// pad is optional' but only present with splits  				region.pads = new int[] {  					int.Parse (tuple [0])'  					int.Parse (tuple [1])'  					int.Parse (tuple [2])'  					int.Parse (tuple [3])  				};  				readTuple (reader' tuple);  			}  		}  		region.originalWidth = int.Parse (tuple [0]);  		region.originalHeight = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		region.offsetX = int.Parse (tuple [0]);  		region.offsetY = int.Parse (tuple [1]);  		region.index = int.Parse (readValue (reader));  		regions.Add (region);  	}  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: while (true) {  	String line = reader.ReadLine ();  	if (line == null)  		break;  	if (line.Trim ().Length == 0)  		page = null;  	else if (page == null) {  		page = new AtlasPage ();  		page.name = line;  		if (readTuple (reader' tuple) == 2) {  			// size is only optional for an atlas packed with an old TexturePacker.  			page.width = int.Parse (tuple [0]);  			page.height = int.Parse (tuple [1]);  			readTuple (reader' tuple);  		}  		page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  		readTuple (reader' tuple);  		page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  		page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  		String direction = readValue (reader);  		page.uWrap = TextureWrap.ClampToEdge;  		page.vWrap = TextureWrap.ClampToEdge;  		if (direction == "x")  			page.uWrap = TextureWrap.Repeat;  		else if (direction == "y")  			page.vWrap = TextureWrap.Repeat;  		else if (direction == "xy")  			page.uWrap = page.vWrap = TextureWrap.Repeat;  		textureLoader.Load (page' Path.Combine (imagesDir' line));  		pages.Add (page);  	}  	else {  		AtlasRegion region = new AtlasRegion ();  		region.name = line;  		region.page = page;  		region.rotate = Boolean.Parse (readValue (reader));  		readTuple (reader' tuple);  		int x = int.Parse (tuple [0]);  		int y = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		int width = int.Parse (tuple [0]);  		int height = int.Parse (tuple [1]);  		region.u = x / (float)page.width;  		region.v = y / (float)page.height;  		if (region.rotate) {  			region.u2 = (x + height) / (float)page.width;  			region.v2 = (y + width) / (float)page.height;  		}  		else {  			region.u2 = (x + width) / (float)page.width;  			region.v2 = (y + height) / (float)page.height;  		}  		region.x = x;  		region.y = y;  		region.width = Math.Abs (width);  		region.height = Math.Abs (height);  		if (readTuple (reader' tuple) == 4) {  			// split is optional  			region.splits = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			if (readTuple (reader' tuple) == 4) {  				// pad is optional' but only present with splits  				region.pads = new int[] {  					int.Parse (tuple [0])'  					int.Parse (tuple [1])'  					int.Parse (tuple [2])'  					int.Parse (tuple [3])  				};  				readTuple (reader' tuple);  			}  		}  		region.originalWidth = int.Parse (tuple [0]);  		region.originalHeight = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		region.offsetX = int.Parse (tuple [0]);  		region.offsetY = int.Parse (tuple [1]);  		region.index = int.Parse (readValue (reader));  		regions.Add (region);  	}  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (line.Trim ().Length == 0)  	page = null;  else if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	if (readTuple (reader' tuple) == 2) {  		// size is only optional for an atlas packed with an old TexturePacker.  		page.width = int.Parse (tuple [0]);  		page.height = int.Parse (tuple [1]);  		readTuple (reader' tuple);  	}  	page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (line.Trim ().Length == 0)  	page = null;  else if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	if (readTuple (reader' tuple) == 2) {  		// size is only optional for an atlas packed with an old TexturePacker.  		page.width = int.Parse (tuple [0]);  		page.height = int.Parse (tuple [1]);  		readTuple (reader' tuple);  	}  	page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (line.Trim ().Length == 0)  	page = null;  else if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	if (readTuple (reader' tuple) == 2) {  		// size is only optional for an atlas packed with an old TexturePacker.  		page.width = int.Parse (tuple [0]);  		page.height = int.Parse (tuple [1]);  		readTuple (reader' tuple);  	}  	page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (line.Trim ().Length == 0)  	page = null;  else if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	if (readTuple (reader' tuple) == 2) {  		// size is only optional for an atlas packed with an old TexturePacker.  		page.width = int.Parse (tuple [0]);  		page.height = int.Parse (tuple [1]);  		readTuple (reader' tuple);  	}  	page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (line.Trim ().Length == 0)  	page = null;  else if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	if (readTuple (reader' tuple) == 2) {  		// size is only optional for an atlas packed with an old TexturePacker.  		page.width = int.Parse (tuple [0]);  		page.height = int.Parse (tuple [1]);  		readTuple (reader' tuple);  	}  	page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (line.Trim ().Length == 0)  	page = null;  else if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	if (readTuple (reader' tuple) == 2) {  		// size is only optional for an atlas packed with an old TexturePacker.  		page.width = int.Parse (tuple [0]);  		page.height = int.Parse (tuple [1]);  		readTuple (reader' tuple);  	}  	page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (line.Trim ().Length == 0)  	page = null;  else if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	if (readTuple (reader' tuple) == 2) {  		// size is only optional for an atlas packed with an old TexturePacker.  		page.width = int.Parse (tuple [0]);  		page.height = int.Parse (tuple [1]);  		readTuple (reader' tuple);  	}  	page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	if (readTuple (reader' tuple) == 2) {  		// size is only optional for an atlas packed with an old TexturePacker.  		page.width = int.Parse (tuple [0]);  		page.height = int.Parse (tuple [1]);  		readTuple (reader' tuple);  	}  	page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	if (readTuple (reader' tuple) == 2) {  		// size is only optional for an atlas packed with an old TexturePacker.  		page.width = int.Parse (tuple [0]);  		page.height = int.Parse (tuple [1]);  		readTuple (reader' tuple);  	}  	page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	if (readTuple (reader' tuple) == 2) {  		// size is only optional for an atlas packed with an old TexturePacker.  		page.width = int.Parse (tuple [0]);  		page.height = int.Parse (tuple [1]);  		readTuple (reader' tuple);  	}  	page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	if (readTuple (reader' tuple) == 2) {  		// size is only optional for an atlas packed with an old TexturePacker.  		page.width = int.Parse (tuple [0]);  		page.height = int.Parse (tuple [1]);  		readTuple (reader' tuple);  	}  	page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	if (readTuple (reader' tuple) == 2) {  		// size is only optional for an atlas packed with an old TexturePacker.  		page.width = int.Parse (tuple [0]);  		page.height = int.Parse (tuple [1]);  		readTuple (reader' tuple);  	}  	page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	if (readTuple (reader' tuple) == 2) {  		// size is only optional for an atlas packed with an old TexturePacker.  		page.width = int.Parse (tuple [0]);  		page.height = int.Parse (tuple [1]);  		readTuple (reader' tuple);  	}  	page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	if (readTuple (reader' tuple) == 2) {  		// size is only optional for an atlas packed with an old TexturePacker.  		page.width = int.Parse (tuple [0]);  		page.height = int.Parse (tuple [1]);  		readTuple (reader' tuple);  	}  	page.format = (Format)Enum.Parse (typeof(Format)' tuple [0]' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (readTuple (reader' tuple) == 2) {  	// size is only optional for an atlas packed with an old TexturePacker.  	page.width = int.Parse (tuple [0]);  	page.height = int.Parse (tuple [1]);  	readTuple (reader' tuple);  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (readTuple (reader' tuple) == 4) {  	// split is optional  	region.splits = new int[] {  		int.Parse (tuple [0])'  		int.Parse (tuple [1])'  		int.Parse (tuple [2])'  		int.Parse (tuple [3])  	};  	if (readTuple (reader' tuple) == 4) {  		// pad is optional' but only present with splits  		region.pads = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		readTuple (reader' tuple);  	}  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (readTuple (reader' tuple) == 4) {  	// split is optional  	region.splits = new int[] {  		int.Parse (tuple [0])'  		int.Parse (tuple [1])'  		int.Parse (tuple [2])'  		int.Parse (tuple [3])  	};  	if (readTuple (reader' tuple) == 4) {  		// pad is optional' but only present with splits  		region.pads = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		readTuple (reader' tuple);  	}  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (readTuple (reader' tuple) == 4) {  	// split is optional  	region.splits = new int[] {  		int.Parse (tuple [0])'  		int.Parse (tuple [1])'  		int.Parse (tuple [2])'  		int.Parse (tuple [3])  	};  	if (readTuple (reader' tuple) == 4) {  		// pad is optional' but only present with splits  		region.pads = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		readTuple (reader' tuple);  	}  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (readTuple (reader' tuple) == 4) {  	// split is optional  	region.splits = new int[] {  		int.Parse (tuple [0])'  		int.Parse (tuple [1])'  		int.Parse (tuple [2])'  		int.Parse (tuple [3])  	};  	if (readTuple (reader' tuple) == 4) {  		// pad is optional' but only present with splits  		region.pads = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		readTuple (reader' tuple);  	}  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (readTuple (reader' tuple) == 4) {  	// split is optional  	region.splits = new int[] {  		int.Parse (tuple [0])'  		int.Parse (tuple [1])'  		int.Parse (tuple [2])'  		int.Parse (tuple [3])  	};  	if (readTuple (reader' tuple) == 4) {  		// pad is optional' but only present with splits  		region.pads = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		readTuple (reader' tuple);  	}  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (readTuple (reader' tuple) == 4) {  	// split is optional  	region.splits = new int[] {  		int.Parse (tuple [0])'  		int.Parse (tuple [1])'  		int.Parse (tuple [2])'  		int.Parse (tuple [3])  	};  	if (readTuple (reader' tuple) == 4) {  		// pad is optional' but only present with splits  		region.pads = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		readTuple (reader' tuple);  	}  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: region.splits = new int[] {  	int.Parse (tuple [0])'  	int.Parse (tuple [1])'  	int.Parse (tuple [2])'  	int.Parse (tuple [3])  };  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: region.splits = new int[] {  	int.Parse (tuple [0])'  	int.Parse (tuple [1])'  	int.Parse (tuple [2])'  	int.Parse (tuple [3])  };  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (readTuple (reader' tuple) == 4) {  	// pad is optional' but only present with splits  	region.pads = new int[] {  		int.Parse (tuple [0])'  		int.Parse (tuple [1])'  		int.Parse (tuple [2])'  		int.Parse (tuple [3])  	};  	readTuple (reader' tuple);  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (readTuple (reader' tuple) == 4) {  	// pad is optional' but only present with splits  	region.pads = new int[] {  		int.Parse (tuple [0])'  		int.Parse (tuple [1])'  		int.Parse (tuple [2])'  		int.Parse (tuple [3])  	};  	readTuple (reader' tuple);  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (readTuple (reader' tuple) == 4) {  	// pad is optional' but only present with splits  	region.pads = new int[] {  		int.Parse (tuple [0])'  		int.Parse (tuple [1])'  		int.Parse (tuple [2])'  		int.Parse (tuple [3])  	};  	readTuple (reader' tuple);  }  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: region.pads = new int[] {  	int.Parse (tuple [0])'  	int.Parse (tuple [1])'  	int.Parse (tuple [2])'  	int.Parse (tuple [3])  };  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: region.pads = new int[] {  	int.Parse (tuple [0])'  	int.Parse (tuple [1])'  	int.Parse (tuple [2])'  	int.Parse (tuple [3])  };  
Magic Number,Spine,Atlas,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Atlas.cs,readTuple,The following statement contains a magic number: for (; i < 3; i++) {  	int comma = line.IndexOf ('''' lastMatch);  	if (comma == -1)  		break;  	tuple [i] = line.Substring (lastMatch' comma - lastMatch).Trim ();  	lastMatch = comma + 1;  }  
Magic Number,Spine,BoundingBoxAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\BoundingBoxAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: for (int i = 0' n = vertices.Length; i < n; i += 2) {  	float px = vertices [i];  	float py = vertices [i + 1];  	worldVertices [i] = px * m00 + py * m01 + x;  	worldVertices [i + 1] = px * m10 + py * m11 + y;  }  
Magic Number,Spine,BoundingBoxAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\BoundingBoxAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: i += 2
Magic Number,Spine,MeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\MeshAttachment.cs,UpdateUVs,The following statement contains a magic number: if (RegionRotate) {  	for (int i = 0' n = uvs.Length; i < n; i += 2) {  		uvs [i] = u + regionUVs [i + 1] * width;  		uvs [i + 1] = v + height - regionUVs [i] * height;  	}  }  else {  	for (int i = 0' n = uvs.Length; i < n; i += 2) {  		uvs [i] = u + regionUVs [i] * width;  		uvs [i + 1] = v + regionUVs [i + 1] * height;  	}  }  
Magic Number,Spine,MeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\MeshAttachment.cs,UpdateUVs,The following statement contains a magic number: if (RegionRotate) {  	for (int i = 0' n = uvs.Length; i < n; i += 2) {  		uvs [i] = u + regionUVs [i + 1] * width;  		uvs [i + 1] = v + height - regionUVs [i] * height;  	}  }  else {  	for (int i = 0' n = uvs.Length; i < n; i += 2) {  		uvs [i] = u + regionUVs [i] * width;  		uvs [i + 1] = v + regionUVs [i + 1] * height;  	}  }  
Magic Number,Spine,MeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\MeshAttachment.cs,UpdateUVs,The following statement contains a magic number: for (int i = 0' n = uvs.Length; i < n; i += 2) {  	uvs [i] = u + regionUVs [i + 1] * width;  	uvs [i + 1] = v + height - regionUVs [i] * height;  }  
Magic Number,Spine,MeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\MeshAttachment.cs,UpdateUVs,The following statement contains a magic number: i += 2
Magic Number,Spine,MeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\MeshAttachment.cs,UpdateUVs,The following statement contains a magic number: for (int i = 0' n = uvs.Length; i < n; i += 2) {  	uvs [i] = u + regionUVs [i] * width;  	uvs [i + 1] = v + regionUVs [i + 1] * height;  }  
Magic Number,Spine,MeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\MeshAttachment.cs,UpdateUVs,The following statement contains a magic number: i += 2
Magic Number,Spine,MeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\MeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: for (int i = 0; i < verticesCount; i += 2) {  	float vx = vertices [i];  	float vy = vertices [i + 1];  	worldVertices [i] = vx * m00 + vy * m01 + x;  	worldVertices [i + 1] = vx * m10 + vy * m11 + y;  }  
Magic Number,Spine,MeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\MeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: i += 2
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,UpdateUVs,The following statement contains a magic number: if (RegionRotate) {  	for (int i = 0' n = uvs.Length; i < n; i += 2) {  		uvs [i] = u + regionUVs [i + 1] * width;  		uvs [i + 1] = v + height - regionUVs [i] * height;  	}  }  else {  	for (int i = 0' n = uvs.Length; i < n; i += 2) {  		uvs [i] = u + regionUVs [i] * width;  		uvs [i + 1] = v + regionUVs [i + 1] * height;  	}  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,UpdateUVs,The following statement contains a magic number: if (RegionRotate) {  	for (int i = 0' n = uvs.Length; i < n; i += 2) {  		uvs [i] = u + regionUVs [i + 1] * width;  		uvs [i + 1] = v + height - regionUVs [i] * height;  	}  }  else {  	for (int i = 0' n = uvs.Length; i < n; i += 2) {  		uvs [i] = u + regionUVs [i] * width;  		uvs [i + 1] = v + regionUVs [i + 1] * height;  	}  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,UpdateUVs,The following statement contains a magic number: for (int i = 0' n = uvs.Length; i < n; i += 2) {  	uvs [i] = u + regionUVs [i + 1] * width;  	uvs [i + 1] = v + height - regionUVs [i] * height;  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,UpdateUVs,The following statement contains a magic number: i += 2
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,UpdateUVs,The following statement contains a magic number: for (int i = 0' n = uvs.Length; i < n; i += 2) {  	uvs [i] = u + regionUVs [i] * width;  	uvs [i + 1] = v + regionUVs [i + 1] * height;  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,UpdateUVs,The following statement contains a magic number: i += 2
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: if (slot.attachmentVerticesCount == 0) {  	for (int w = 0' v = 0' b = 0' n = bones.Length; v < n; w += 2) {  		float wx = 0' wy = 0;  		int nn = bones [v++] + v;  		for (; v < nn; v++' b += 3) {  			Bone bone = skeletonBones [bones [v]];  			float vx = weights [b]' vy = weights [b + 1]' weight = weights [b + 2];  			wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  			wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  		}  		worldVertices [w] = wx + x;  		worldVertices [w + 1] = wy + y;  	}  }  else {  	float[] ffd = slot.AttachmentVertices;  	for (int w = 0' v = 0' b = 0' f = 0' n = bones.Length; v < n; w += 2) {  		float wx = 0' wy = 0;  		int nn = bones [v++] + v;  		for (; v < nn; v++' b += 3' f += 2) {  			Bone bone = skeletonBones [bones [v]];  			float vx = weights [b] + ffd [f]' vy = weights [b + 1] + ffd [f + 1]' weight = weights [b + 2];  			wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  			wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  		}  		worldVertices [w] = wx + x;  		worldVertices [w + 1] = wy + y;  	}  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: if (slot.attachmentVerticesCount == 0) {  	for (int w = 0' v = 0' b = 0' n = bones.Length; v < n; w += 2) {  		float wx = 0' wy = 0;  		int nn = bones [v++] + v;  		for (; v < nn; v++' b += 3) {  			Bone bone = skeletonBones [bones [v]];  			float vx = weights [b]' vy = weights [b + 1]' weight = weights [b + 2];  			wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  			wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  		}  		worldVertices [w] = wx + x;  		worldVertices [w + 1] = wy + y;  	}  }  else {  	float[] ffd = slot.AttachmentVertices;  	for (int w = 0' v = 0' b = 0' f = 0' n = bones.Length; v < n; w += 2) {  		float wx = 0' wy = 0;  		int nn = bones [v++] + v;  		for (; v < nn; v++' b += 3' f += 2) {  			Bone bone = skeletonBones [bones [v]];  			float vx = weights [b] + ffd [f]' vy = weights [b + 1] + ffd [f + 1]' weight = weights [b + 2];  			wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  			wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  		}  		worldVertices [w] = wx + x;  		worldVertices [w + 1] = wy + y;  	}  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: if (slot.attachmentVerticesCount == 0) {  	for (int w = 0' v = 0' b = 0' n = bones.Length; v < n; w += 2) {  		float wx = 0' wy = 0;  		int nn = bones [v++] + v;  		for (; v < nn; v++' b += 3) {  			Bone bone = skeletonBones [bones [v]];  			float vx = weights [b]' vy = weights [b + 1]' weight = weights [b + 2];  			wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  			wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  		}  		worldVertices [w] = wx + x;  		worldVertices [w + 1] = wy + y;  	}  }  else {  	float[] ffd = slot.AttachmentVertices;  	for (int w = 0' v = 0' b = 0' f = 0' n = bones.Length; v < n; w += 2) {  		float wx = 0' wy = 0;  		int nn = bones [v++] + v;  		for (; v < nn; v++' b += 3' f += 2) {  			Bone bone = skeletonBones [bones [v]];  			float vx = weights [b] + ffd [f]' vy = weights [b + 1] + ffd [f + 1]' weight = weights [b + 2];  			wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  			wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  		}  		worldVertices [w] = wx + x;  		worldVertices [w + 1] = wy + y;  	}  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: if (slot.attachmentVerticesCount == 0) {  	for (int w = 0' v = 0' b = 0' n = bones.Length; v < n; w += 2) {  		float wx = 0' wy = 0;  		int nn = bones [v++] + v;  		for (; v < nn; v++' b += 3) {  			Bone bone = skeletonBones [bones [v]];  			float vx = weights [b]' vy = weights [b + 1]' weight = weights [b + 2];  			wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  			wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  		}  		worldVertices [w] = wx + x;  		worldVertices [w + 1] = wy + y;  	}  }  else {  	float[] ffd = slot.AttachmentVertices;  	for (int w = 0' v = 0' b = 0' f = 0' n = bones.Length; v < n; w += 2) {  		float wx = 0' wy = 0;  		int nn = bones [v++] + v;  		for (; v < nn; v++' b += 3' f += 2) {  			Bone bone = skeletonBones [bones [v]];  			float vx = weights [b] + ffd [f]' vy = weights [b + 1] + ffd [f + 1]' weight = weights [b + 2];  			wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  			wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  		}  		worldVertices [w] = wx + x;  		worldVertices [w + 1] = wy + y;  	}  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: if (slot.attachmentVerticesCount == 0) {  	for (int w = 0' v = 0' b = 0' n = bones.Length; v < n; w += 2) {  		float wx = 0' wy = 0;  		int nn = bones [v++] + v;  		for (; v < nn; v++' b += 3) {  			Bone bone = skeletonBones [bones [v]];  			float vx = weights [b]' vy = weights [b + 1]' weight = weights [b + 2];  			wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  			wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  		}  		worldVertices [w] = wx + x;  		worldVertices [w + 1] = wy + y;  	}  }  else {  	float[] ffd = slot.AttachmentVertices;  	for (int w = 0' v = 0' b = 0' f = 0' n = bones.Length; v < n; w += 2) {  		float wx = 0' wy = 0;  		int nn = bones [v++] + v;  		for (; v < nn; v++' b += 3' f += 2) {  			Bone bone = skeletonBones [bones [v]];  			float vx = weights [b] + ffd [f]' vy = weights [b + 1] + ffd [f + 1]' weight = weights [b + 2];  			wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  			wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  		}  		worldVertices [w] = wx + x;  		worldVertices [w + 1] = wy + y;  	}  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: if (slot.attachmentVerticesCount == 0) {  	for (int w = 0' v = 0' b = 0' n = bones.Length; v < n; w += 2) {  		float wx = 0' wy = 0;  		int nn = bones [v++] + v;  		for (; v < nn; v++' b += 3) {  			Bone bone = skeletonBones [bones [v]];  			float vx = weights [b]' vy = weights [b + 1]' weight = weights [b + 2];  			wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  			wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  		}  		worldVertices [w] = wx + x;  		worldVertices [w + 1] = wy + y;  	}  }  else {  	float[] ffd = slot.AttachmentVertices;  	for (int w = 0' v = 0' b = 0' f = 0' n = bones.Length; v < n; w += 2) {  		float wx = 0' wy = 0;  		int nn = bones [v++] + v;  		for (; v < nn; v++' b += 3' f += 2) {  			Bone bone = skeletonBones [bones [v]];  			float vx = weights [b] + ffd [f]' vy = weights [b + 1] + ffd [f + 1]' weight = weights [b + 2];  			wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  			wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  		}  		worldVertices [w] = wx + x;  		worldVertices [w + 1] = wy + y;  	}  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: if (slot.attachmentVerticesCount == 0) {  	for (int w = 0' v = 0' b = 0' n = bones.Length; v < n; w += 2) {  		float wx = 0' wy = 0;  		int nn = bones [v++] + v;  		for (; v < nn; v++' b += 3) {  			Bone bone = skeletonBones [bones [v]];  			float vx = weights [b]' vy = weights [b + 1]' weight = weights [b + 2];  			wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  			wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  		}  		worldVertices [w] = wx + x;  		worldVertices [w + 1] = wy + y;  	}  }  else {  	float[] ffd = slot.AttachmentVertices;  	for (int w = 0' v = 0' b = 0' f = 0' n = bones.Length; v < n; w += 2) {  		float wx = 0' wy = 0;  		int nn = bones [v++] + v;  		for (; v < nn; v++' b += 3' f += 2) {  			Bone bone = skeletonBones [bones [v]];  			float vx = weights [b] + ffd [f]' vy = weights [b + 1] + ffd [f + 1]' weight = weights [b + 2];  			wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  			wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  		}  		worldVertices [w] = wx + x;  		worldVertices [w + 1] = wy + y;  	}  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: for (int w = 0' v = 0' b = 0' n = bones.Length; v < n; w += 2) {  	float wx = 0' wy = 0;  	int nn = bones [v++] + v;  	for (; v < nn; v++' b += 3) {  		Bone bone = skeletonBones [bones [v]];  		float vx = weights [b]' vy = weights [b + 1]' weight = weights [b + 2];  		wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  		wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  	}  	worldVertices [w] = wx + x;  	worldVertices [w + 1] = wy + y;  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: for (int w = 0' v = 0' b = 0' n = bones.Length; v < n; w += 2) {  	float wx = 0' wy = 0;  	int nn = bones [v++] + v;  	for (; v < nn; v++' b += 3) {  		Bone bone = skeletonBones [bones [v]];  		float vx = weights [b]' vy = weights [b + 1]' weight = weights [b + 2];  		wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  		wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  	}  	worldVertices [w] = wx + x;  	worldVertices [w + 1] = wy + y;  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: for (int w = 0' v = 0' b = 0' n = bones.Length; v < n; w += 2) {  	float wx = 0' wy = 0;  	int nn = bones [v++] + v;  	for (; v < nn; v++' b += 3) {  		Bone bone = skeletonBones [bones [v]];  		float vx = weights [b]' vy = weights [b + 1]' weight = weights [b + 2];  		wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  		wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  	}  	worldVertices [w] = wx + x;  	worldVertices [w + 1] = wy + y;  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: w += 2
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: for (; v < nn; v++' b += 3) {  	Bone bone = skeletonBones [bones [v]];  	float vx = weights [b]' vy = weights [b + 1]' weight = weights [b + 2];  	wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  	wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: for (; v < nn; v++' b += 3) {  	Bone bone = skeletonBones [bones [v]];  	float vx = weights [b]' vy = weights [b + 1]' weight = weights [b + 2];  	wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  	wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: b += 3
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: for (int w = 0' v = 0' b = 0' f = 0' n = bones.Length; v < n; w += 2) {  	float wx = 0' wy = 0;  	int nn = bones [v++] + v;  	for (; v < nn; v++' b += 3' f += 2) {  		Bone bone = skeletonBones [bones [v]];  		float vx = weights [b] + ffd [f]' vy = weights [b + 1] + ffd [f + 1]' weight = weights [b + 2];  		wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  		wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  	}  	worldVertices [w] = wx + x;  	worldVertices [w + 1] = wy + y;  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: for (int w = 0' v = 0' b = 0' f = 0' n = bones.Length; v < n; w += 2) {  	float wx = 0' wy = 0;  	int nn = bones [v++] + v;  	for (; v < nn; v++' b += 3' f += 2) {  		Bone bone = skeletonBones [bones [v]];  		float vx = weights [b] + ffd [f]' vy = weights [b + 1] + ffd [f + 1]' weight = weights [b + 2];  		wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  		wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  	}  	worldVertices [w] = wx + x;  	worldVertices [w + 1] = wy + y;  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: for (int w = 0' v = 0' b = 0' f = 0' n = bones.Length; v < n; w += 2) {  	float wx = 0' wy = 0;  	int nn = bones [v++] + v;  	for (; v < nn; v++' b += 3' f += 2) {  		Bone bone = skeletonBones [bones [v]];  		float vx = weights [b] + ffd [f]' vy = weights [b + 1] + ffd [f + 1]' weight = weights [b + 2];  		wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  		wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  	}  	worldVertices [w] = wx + x;  	worldVertices [w + 1] = wy + y;  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: for (int w = 0' v = 0' b = 0' f = 0' n = bones.Length; v < n; w += 2) {  	float wx = 0' wy = 0;  	int nn = bones [v++] + v;  	for (; v < nn; v++' b += 3' f += 2) {  		Bone bone = skeletonBones [bones [v]];  		float vx = weights [b] + ffd [f]' vy = weights [b + 1] + ffd [f + 1]' weight = weights [b + 2];  		wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  		wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  	}  	worldVertices [w] = wx + x;  	worldVertices [w + 1] = wy + y;  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: w += 2
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: for (; v < nn; v++' b += 3' f += 2) {  	Bone bone = skeletonBones [bones [v]];  	float vx = weights [b] + ffd [f]' vy = weights [b + 1] + ffd [f + 1]' weight = weights [b + 2];  	wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  	wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: for (; v < nn; v++' b += 3' f += 2) {  	Bone bone = skeletonBones [bones [v]];  	float vx = weights [b] + ffd [f]' vy = weights [b + 1] + ffd [f + 1]' weight = weights [b + 2];  	wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  	wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: for (; v < nn; v++' b += 3' f += 2) {  	Bone bone = skeletonBones [bones [v]];  	float vx = weights [b] + ffd [f]' vy = weights [b + 1] + ffd [f + 1]' weight = weights [b + 2];  	wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;  	wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;  }  
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: b += 3
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: f += 2
Magic Number,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The following statement contains a magic number: switch (bones.Count) {  case 1:  	apply (bones [0]' target.worldX' target.worldY' mix);  	break;  case 2:  	apply (bones [0]' bones [1]' target.worldX' target.worldY' bendDirection' mix);  	break;  }  
Magic Number,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The following statement contains a magic number: if (rotation > 180)  	rotation -= 360;  else if (rotation < -180)  	//  	rotation += 360;  
Magic Number,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The following statement contains a magic number: if (rotation > 180)  	rotation -= 360;  else if (rotation < -180)  	//  	rotation += 360;  
Magic Number,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The following statement contains a magic number: if (rotation > 180)  	rotation -= 360;  else if (rotation < -180)  	//  	rotation += 360;  
Magic Number,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The following statement contains a magic number: if (rotation > 180)  	rotation -= 360;  else if (rotation < -180)  	//  	rotation += 360;  
Magic Number,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The following statement contains a magic number: rotation -= 360;  
Magic Number,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The following statement contains a magic number: if (rotation < -180)  	//  	rotation += 360;  
Magic Number,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The following statement contains a magic number: if (rotation < -180)  	//  	rotation += 360;  
Magic Number,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The following statement contains a magic number: rotation += 360;  
Magic Number,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The following statement contains a magic number: if (rotation > 180)  	rotation -= 360;  else if (rotation < -180)  	//  	rotation += 360;  
Magic Number,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The following statement contains a magic number: if (rotation > 180)  	rotation -= 360;  else if (rotation < -180)  	//  	rotation += 360;  
Magic Number,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The following statement contains a magic number: if (rotation > 180)  	rotation -= 360;  else if (rotation < -180)  	//  	rotation += 360;  
Magic Number,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The following statement contains a magic number: if (rotation > 180)  	rotation -= 360;  else if (rotation < -180)  	//  	rotation += 360;  
Magic Number,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The following statement contains a magic number: rotation -= 360;  
Magic Number,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The following statement contains a magic number: if (rotation < -180)  	//  	rotation += 360;  
Magic Number,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The following statement contains a magic number: if (rotation < -180)  	//  	rotation += 360;  
Magic Number,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The following statement contains a magic number: rotation += 360;  
Magic Number,Spine,SkeletonBounds,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonBounds.cs,aabbCompute,The following statement contains a magic number: for (int i = 0' n = polygons.Count; i < n; i++) {  	Polygon polygon = polygons [i];  	float[] vertices = polygon.Vertices;  	for (int ii = 0' nn = polygon.Count; ii < nn; ii += 2) {  		float x = vertices [ii];  		float y = vertices [ii + 1];  		minX = Math.Min (minX' x);  		minY = Math.Min (minY' y);  		maxX = Math.Max (maxX' x);  		maxY = Math.Max (maxY' y);  	}  }  
Magic Number,Spine,SkeletonBounds,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonBounds.cs,aabbCompute,The following statement contains a magic number: for (int ii = 0' nn = polygon.Count; ii < nn; ii += 2) {  	float x = vertices [ii];  	float y = vertices [ii + 1];  	minX = Math.Min (minX' x);  	minY = Math.Min (minY' y);  	maxX = Math.Max (maxX' x);  	maxY = Math.Max (maxY' y);  }  
Magic Number,Spine,SkeletonBounds,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonBounds.cs,aabbCompute,The following statement contains a magic number: ii += 2
Magic Number,Spine,SkeletonBounds,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonBounds.cs,ContainsPoint,The following statement contains a magic number: for (int ii = 0; ii < nn; ii += 2) {  	float vertexY = vertices [ii + 1];  	float prevY = vertices [prevIndex + 1];  	if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {  		float vertexX = vertices [ii];  		if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices [prevIndex] - vertexX) < x)  			inside = !inside;  	}  	prevIndex = ii;  }  
Magic Number,Spine,SkeletonBounds,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonBounds.cs,ContainsPoint,The following statement contains a magic number: ii += 2
Magic Number,Spine,SkeletonBounds,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonBounds.cs,IntersectsSegment,The following statement contains a magic number: for (int ii = 0; ii < nn; ii += 2) {  	float x4 = vertices [ii]' y4 = vertices [ii + 1];  	float det2 = x3 * y4 - y3 * x4;  	float width34 = x3 - x4' height34 = y3 - y4;  	float det3 = width12 * height34 - height12 * width34;  	float x = (det1 * width34 - width12 * det2) / det3;  	if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {  		float y = (det1 * height34 - height12 * det2) / det3;  		if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1)))  			return true;  	}  	x3 = x4;  	y3 = y4;  }  
Magic Number,Spine,SkeletonBounds,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonBounds.cs,IntersectsSegment,The following statement contains a magic number: ii += 2
Magic Number,Spine,Polygon,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonBounds.cs,Polygon,The following statement contains a magic number: Vertices = new float[16];  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: if (root.ContainsKey ("slots")) {  	foreach (Dictionary<String' Object> slotMap in (List<Object>)root ["slots"]) {  		var slotName = (String)slotMap ["name"];  		var boneName = (String)slotMap ["bone"];  		BoneData boneData = skeletonData.FindBone (boneName);  		if (boneData == null)  			throw new Exception ("Slot bone not found: " + boneName);  		var slotData = new SlotData (slotName' boneData);  		if (slotMap.ContainsKey ("color")) {  			var color = (String)slotMap ["color"];  			slotData.r = ToColor (color' 0);  			slotData.g = ToColor (color' 1);  			slotData.b = ToColor (color' 2);  			slotData.a = ToColor (color' 3);  		}  		if (slotMap.ContainsKey ("attachment"))  			slotData.attachmentName = (String)slotMap ["attachment"];  		if (slotMap.ContainsKey ("additive"))  			slotData.additiveBlending = (bool)slotMap ["additive"];  		skeletonData.slots.Add (slotData);  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: if (root.ContainsKey ("slots")) {  	foreach (Dictionary<String' Object> slotMap in (List<Object>)root ["slots"]) {  		var slotName = (String)slotMap ["name"];  		var boneName = (String)slotMap ["bone"];  		BoneData boneData = skeletonData.FindBone (boneName);  		if (boneData == null)  			throw new Exception ("Slot bone not found: " + boneName);  		var slotData = new SlotData (slotName' boneData);  		if (slotMap.ContainsKey ("color")) {  			var color = (String)slotMap ["color"];  			slotData.r = ToColor (color' 0);  			slotData.g = ToColor (color' 1);  			slotData.b = ToColor (color' 2);  			slotData.a = ToColor (color' 3);  		}  		if (slotMap.ContainsKey ("attachment"))  			slotData.attachmentName = (String)slotMap ["attachment"];  		if (slotMap.ContainsKey ("additive"))  			slotData.additiveBlending = (bool)slotMap ["additive"];  		skeletonData.slots.Add (slotData);  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: foreach (Dictionary<String' Object> slotMap in (List<Object>)root ["slots"]) {  	var slotName = (String)slotMap ["name"];  	var boneName = (String)slotMap ["bone"];  	BoneData boneData = skeletonData.FindBone (boneName);  	if (boneData == null)  		throw new Exception ("Slot bone not found: " + boneName);  	var slotData = new SlotData (slotName' boneData);  	if (slotMap.ContainsKey ("color")) {  		var color = (String)slotMap ["color"];  		slotData.r = ToColor (color' 0);  		slotData.g = ToColor (color' 1);  		slotData.b = ToColor (color' 2);  		slotData.a = ToColor (color' 3);  	}  	if (slotMap.ContainsKey ("attachment"))  		slotData.attachmentName = (String)slotMap ["attachment"];  	if (slotMap.ContainsKey ("additive"))  		slotData.additiveBlending = (bool)slotMap ["additive"];  	skeletonData.slots.Add (slotData);  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: foreach (Dictionary<String' Object> slotMap in (List<Object>)root ["slots"]) {  	var slotName = (String)slotMap ["name"];  	var boneName = (String)slotMap ["bone"];  	BoneData boneData = skeletonData.FindBone (boneName);  	if (boneData == null)  		throw new Exception ("Slot bone not found: " + boneName);  	var slotData = new SlotData (slotName' boneData);  	if (slotMap.ContainsKey ("color")) {  		var color = (String)slotMap ["color"];  		slotData.r = ToColor (color' 0);  		slotData.g = ToColor (color' 1);  		slotData.b = ToColor (color' 2);  		slotData.a = ToColor (color' 3);  	}  	if (slotMap.ContainsKey ("attachment"))  		slotData.attachmentName = (String)slotMap ["attachment"];  	if (slotMap.ContainsKey ("additive"))  		slotData.additiveBlending = (bool)slotMap ["additive"];  	skeletonData.slots.Add (slotData);  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: if (slotMap.ContainsKey ("color")) {  	var color = (String)slotMap ["color"];  	slotData.r = ToColor (color' 0);  	slotData.g = ToColor (color' 1);  	slotData.b = ToColor (color' 2);  	slotData.a = ToColor (color' 3);  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: if (slotMap.ContainsKey ("color")) {  	var color = (String)slotMap ["color"];  	slotData.r = ToColor (color' 0);  	slotData.g = ToColor (color' 1);  	slotData.b = ToColor (color' 2);  	slotData.a = ToColor (color' 3);  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: slotData.b = ToColor (color' 2);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: slotData.a = ToColor (color' 3);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  case AttachmentType.region:  	RegionAttachment region = attachmentLoader.NewRegionAttachment (skin' name' path);  	if (region == null)  		return null;  	region.Path = path;  	region.x = GetFloat (map' "x"' 0) * Scale;  	region.y = GetFloat (map' "y"' 0) * Scale;  	region.scaleX = GetFloat (map' "scaleX"' 1);  	region.scaleY = GetFloat (map' "scaleY"' 1);  	region.rotation = GetFloat (map' "rotation"' 0);  	region.width = GetFloat (map' "width"' 32) * Scale;  	region.height = GetFloat (map' "height"' 32) * Scale;  	region.UpdateOffset ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		region.r = ToColor (color' 0);  		region.g = ToColor (color' 1);  		region.b = ToColor (color' 2);  		region.a = ToColor (color' 3);  	}  	return region;  case AttachmentType.mesh: {  	MeshAttachment mesh = attachmentLoader.NewMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	mesh.vertices = GetFloatArray (map' "vertices"' Scale);  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = GetFloatArray (map' "uvs"' 1);  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.skinnedmesh: {  	SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	float[] uvs = GetFloatArray (map' "uvs"' 1);  	float[] vertices = GetFloatArray (map' "vertices"' 1);  	var weights = new List<float> (uvs.Length * 3 * 3);  	var bones = new List<int> (uvs.Length * 3);  	float scale = Scale;  	for (int i = 0' n = vertices.Length; i < n;) {  		int boneCount = (int)vertices [i++];  		bones.Add (boneCount);  		for (int nn = i + boneCount * 4; i < nn;) {  			bones.Add ((int)vertices [i]);  			weights.Add (vertices [i + 1] * scale);  			weights.Add (vertices [i + 2] * scale);  			weights.Add (vertices [i + 3]);  			i += 4;  		}  	}  	mesh.bones = bones.ToArray ();  	mesh.weights = weights.ToArray ();  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = uvs;  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.boundingbox:  	BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment (skin' name);  	if (box == null)  		return null;  	box.vertices = GetFloatArray (map' "vertices"' Scale);  	return box;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  case AttachmentType.region:  	RegionAttachment region = attachmentLoader.NewRegionAttachment (skin' name' path);  	if (region == null)  		return null;  	region.Path = path;  	region.x = GetFloat (map' "x"' 0) * Scale;  	region.y = GetFloat (map' "y"' 0) * Scale;  	region.scaleX = GetFloat (map' "scaleX"' 1);  	region.scaleY = GetFloat (map' "scaleY"' 1);  	region.rotation = GetFloat (map' "rotation"' 0);  	region.width = GetFloat (map' "width"' 32) * Scale;  	region.height = GetFloat (map' "height"' 32) * Scale;  	region.UpdateOffset ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		region.r = ToColor (color' 0);  		region.g = ToColor (color' 1);  		region.b = ToColor (color' 2);  		region.a = ToColor (color' 3);  	}  	return region;  case AttachmentType.mesh: {  	MeshAttachment mesh = attachmentLoader.NewMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	mesh.vertices = GetFloatArray (map' "vertices"' Scale);  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = GetFloatArray (map' "uvs"' 1);  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.skinnedmesh: {  	SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	float[] uvs = GetFloatArray (map' "uvs"' 1);  	float[] vertices = GetFloatArray (map' "vertices"' 1);  	var weights = new List<float> (uvs.Length * 3 * 3);  	var bones = new List<int> (uvs.Length * 3);  	float scale = Scale;  	for (int i = 0' n = vertices.Length; i < n;) {  		int boneCount = (int)vertices [i++];  		bones.Add (boneCount);  		for (int nn = i + boneCount * 4; i < nn;) {  			bones.Add ((int)vertices [i]);  			weights.Add (vertices [i + 1] * scale);  			weights.Add (vertices [i + 2] * scale);  			weights.Add (vertices [i + 3]);  			i += 4;  		}  	}  	mesh.bones = bones.ToArray ();  	mesh.weights = weights.ToArray ();  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = uvs;  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.boundingbox:  	BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment (skin' name);  	if (box == null)  		return null;  	box.vertices = GetFloatArray (map' "vertices"' Scale);  	return box;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  case AttachmentType.region:  	RegionAttachment region = attachmentLoader.NewRegionAttachment (skin' name' path);  	if (region == null)  		return null;  	region.Path = path;  	region.x = GetFloat (map' "x"' 0) * Scale;  	region.y = GetFloat (map' "y"' 0) * Scale;  	region.scaleX = GetFloat (map' "scaleX"' 1);  	region.scaleY = GetFloat (map' "scaleY"' 1);  	region.rotation = GetFloat (map' "rotation"' 0);  	region.width = GetFloat (map' "width"' 32) * Scale;  	region.height = GetFloat (map' "height"' 32) * Scale;  	region.UpdateOffset ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		region.r = ToColor (color' 0);  		region.g = ToColor (color' 1);  		region.b = ToColor (color' 2);  		region.a = ToColor (color' 3);  	}  	return region;  case AttachmentType.mesh: {  	MeshAttachment mesh = attachmentLoader.NewMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	mesh.vertices = GetFloatArray (map' "vertices"' Scale);  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = GetFloatArray (map' "uvs"' 1);  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.skinnedmesh: {  	SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	float[] uvs = GetFloatArray (map' "uvs"' 1);  	float[] vertices = GetFloatArray (map' "vertices"' 1);  	var weights = new List<float> (uvs.Length * 3 * 3);  	var bones = new List<int> (uvs.Length * 3);  	float scale = Scale;  	for (int i = 0' n = vertices.Length; i < n;) {  		int boneCount = (int)vertices [i++];  		bones.Add (boneCount);  		for (int nn = i + boneCount * 4; i < nn;) {  			bones.Add ((int)vertices [i]);  			weights.Add (vertices [i + 1] * scale);  			weights.Add (vertices [i + 2] * scale);  			weights.Add (vertices [i + 3]);  			i += 4;  		}  	}  	mesh.bones = bones.ToArray ();  	mesh.weights = weights.ToArray ();  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = uvs;  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.boundingbox:  	BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment (skin' name);  	if (box == null)  		return null;  	box.vertices = GetFloatArray (map' "vertices"' Scale);  	return box;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  case AttachmentType.region:  	RegionAttachment region = attachmentLoader.NewRegionAttachment (skin' name' path);  	if (region == null)  		return null;  	region.Path = path;  	region.x = GetFloat (map' "x"' 0) * Scale;  	region.y = GetFloat (map' "y"' 0) * Scale;  	region.scaleX = GetFloat (map' "scaleX"' 1);  	region.scaleY = GetFloat (map' "scaleY"' 1);  	region.rotation = GetFloat (map' "rotation"' 0);  	region.width = GetFloat (map' "width"' 32) * Scale;  	region.height = GetFloat (map' "height"' 32) * Scale;  	region.UpdateOffset ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		region.r = ToColor (color' 0);  		region.g = ToColor (color' 1);  		region.b = ToColor (color' 2);  		region.a = ToColor (color' 3);  	}  	return region;  case AttachmentType.mesh: {  	MeshAttachment mesh = attachmentLoader.NewMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	mesh.vertices = GetFloatArray (map' "vertices"' Scale);  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = GetFloatArray (map' "uvs"' 1);  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.skinnedmesh: {  	SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	float[] uvs = GetFloatArray (map' "uvs"' 1);  	float[] vertices = GetFloatArray (map' "vertices"' 1);  	var weights = new List<float> (uvs.Length * 3 * 3);  	var bones = new List<int> (uvs.Length * 3);  	float scale = Scale;  	for (int i = 0' n = vertices.Length; i < n;) {  		int boneCount = (int)vertices [i++];  		bones.Add (boneCount);  		for (int nn = i + boneCount * 4; i < nn;) {  			bones.Add ((int)vertices [i]);  			weights.Add (vertices [i + 1] * scale);  			weights.Add (vertices [i + 2] * scale);  			weights.Add (vertices [i + 3]);  			i += 4;  		}  	}  	mesh.bones = bones.ToArray ();  	mesh.weights = weights.ToArray ();  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = uvs;  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.boundingbox:  	BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment (skin' name);  	if (box == null)  		return null;  	box.vertices = GetFloatArray (map' "vertices"' Scale);  	return box;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  case AttachmentType.region:  	RegionAttachment region = attachmentLoader.NewRegionAttachment (skin' name' path);  	if (region == null)  		return null;  	region.Path = path;  	region.x = GetFloat (map' "x"' 0) * Scale;  	region.y = GetFloat (map' "y"' 0) * Scale;  	region.scaleX = GetFloat (map' "scaleX"' 1);  	region.scaleY = GetFloat (map' "scaleY"' 1);  	region.rotation = GetFloat (map' "rotation"' 0);  	region.width = GetFloat (map' "width"' 32) * Scale;  	region.height = GetFloat (map' "height"' 32) * Scale;  	region.UpdateOffset ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		region.r = ToColor (color' 0);  		region.g = ToColor (color' 1);  		region.b = ToColor (color' 2);  		region.a = ToColor (color' 3);  	}  	return region;  case AttachmentType.mesh: {  	MeshAttachment mesh = attachmentLoader.NewMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	mesh.vertices = GetFloatArray (map' "vertices"' Scale);  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = GetFloatArray (map' "uvs"' 1);  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.skinnedmesh: {  	SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	float[] uvs = GetFloatArray (map' "uvs"' 1);  	float[] vertices = GetFloatArray (map' "vertices"' 1);  	var weights = new List<float> (uvs.Length * 3 * 3);  	var bones = new List<int> (uvs.Length * 3);  	float scale = Scale;  	for (int i = 0' n = vertices.Length; i < n;) {  		int boneCount = (int)vertices [i++];  		bones.Add (boneCount);  		for (int nn = i + boneCount * 4; i < nn;) {  			bones.Add ((int)vertices [i]);  			weights.Add (vertices [i + 1] * scale);  			weights.Add (vertices [i + 2] * scale);  			weights.Add (vertices [i + 3]);  			i += 4;  		}  	}  	mesh.bones = bones.ToArray ();  	mesh.weights = weights.ToArray ();  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = uvs;  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.boundingbox:  	BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment (skin' name);  	if (box == null)  		return null;  	box.vertices = GetFloatArray (map' "vertices"' Scale);  	return box;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  case AttachmentType.region:  	RegionAttachment region = attachmentLoader.NewRegionAttachment (skin' name' path);  	if (region == null)  		return null;  	region.Path = path;  	region.x = GetFloat (map' "x"' 0) * Scale;  	region.y = GetFloat (map' "y"' 0) * Scale;  	region.scaleX = GetFloat (map' "scaleX"' 1);  	region.scaleY = GetFloat (map' "scaleY"' 1);  	region.rotation = GetFloat (map' "rotation"' 0);  	region.width = GetFloat (map' "width"' 32) * Scale;  	region.height = GetFloat (map' "height"' 32) * Scale;  	region.UpdateOffset ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		region.r = ToColor (color' 0);  		region.g = ToColor (color' 1);  		region.b = ToColor (color' 2);  		region.a = ToColor (color' 3);  	}  	return region;  case AttachmentType.mesh: {  	MeshAttachment mesh = attachmentLoader.NewMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	mesh.vertices = GetFloatArray (map' "vertices"' Scale);  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = GetFloatArray (map' "uvs"' 1);  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.skinnedmesh: {  	SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	float[] uvs = GetFloatArray (map' "uvs"' 1);  	float[] vertices = GetFloatArray (map' "vertices"' 1);  	var weights = new List<float> (uvs.Length * 3 * 3);  	var bones = new List<int> (uvs.Length * 3);  	float scale = Scale;  	for (int i = 0' n = vertices.Length; i < n;) {  		int boneCount = (int)vertices [i++];  		bones.Add (boneCount);  		for (int nn = i + boneCount * 4; i < nn;) {  			bones.Add ((int)vertices [i]);  			weights.Add (vertices [i + 1] * scale);  			weights.Add (vertices [i + 2] * scale);  			weights.Add (vertices [i + 3]);  			i += 4;  		}  	}  	mesh.bones = bones.ToArray ();  	mesh.weights = weights.ToArray ();  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = uvs;  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.boundingbox:  	BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment (skin' name);  	if (box == null)  		return null;  	box.vertices = GetFloatArray (map' "vertices"' Scale);  	return box;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  case AttachmentType.region:  	RegionAttachment region = attachmentLoader.NewRegionAttachment (skin' name' path);  	if (region == null)  		return null;  	region.Path = path;  	region.x = GetFloat (map' "x"' 0) * Scale;  	region.y = GetFloat (map' "y"' 0) * Scale;  	region.scaleX = GetFloat (map' "scaleX"' 1);  	region.scaleY = GetFloat (map' "scaleY"' 1);  	region.rotation = GetFloat (map' "rotation"' 0);  	region.width = GetFloat (map' "width"' 32) * Scale;  	region.height = GetFloat (map' "height"' 32) * Scale;  	region.UpdateOffset ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		region.r = ToColor (color' 0);  		region.g = ToColor (color' 1);  		region.b = ToColor (color' 2);  		region.a = ToColor (color' 3);  	}  	return region;  case AttachmentType.mesh: {  	MeshAttachment mesh = attachmentLoader.NewMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	mesh.vertices = GetFloatArray (map' "vertices"' Scale);  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = GetFloatArray (map' "uvs"' 1);  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.skinnedmesh: {  	SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	float[] uvs = GetFloatArray (map' "uvs"' 1);  	float[] vertices = GetFloatArray (map' "vertices"' 1);  	var weights = new List<float> (uvs.Length * 3 * 3);  	var bones = new List<int> (uvs.Length * 3);  	float scale = Scale;  	for (int i = 0' n = vertices.Length; i < n;) {  		int boneCount = (int)vertices [i++];  		bones.Add (boneCount);  		for (int nn = i + boneCount * 4; i < nn;) {  			bones.Add ((int)vertices [i]);  			weights.Add (vertices [i + 1] * scale);  			weights.Add (vertices [i + 2] * scale);  			weights.Add (vertices [i + 3]);  			i += 4;  		}  	}  	mesh.bones = bones.ToArray ();  	mesh.weights = weights.ToArray ();  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = uvs;  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.boundingbox:  	BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment (skin' name);  	if (box == null)  		return null;  	box.vertices = GetFloatArray (map' "vertices"' Scale);  	return box;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  case AttachmentType.region:  	RegionAttachment region = attachmentLoader.NewRegionAttachment (skin' name' path);  	if (region == null)  		return null;  	region.Path = path;  	region.x = GetFloat (map' "x"' 0) * Scale;  	region.y = GetFloat (map' "y"' 0) * Scale;  	region.scaleX = GetFloat (map' "scaleX"' 1);  	region.scaleY = GetFloat (map' "scaleY"' 1);  	region.rotation = GetFloat (map' "rotation"' 0);  	region.width = GetFloat (map' "width"' 32) * Scale;  	region.height = GetFloat (map' "height"' 32) * Scale;  	region.UpdateOffset ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		region.r = ToColor (color' 0);  		region.g = ToColor (color' 1);  		region.b = ToColor (color' 2);  		region.a = ToColor (color' 3);  	}  	return region;  case AttachmentType.mesh: {  	MeshAttachment mesh = attachmentLoader.NewMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	mesh.vertices = GetFloatArray (map' "vertices"' Scale);  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = GetFloatArray (map' "uvs"' 1);  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.skinnedmesh: {  	SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	float[] uvs = GetFloatArray (map' "uvs"' 1);  	float[] vertices = GetFloatArray (map' "vertices"' 1);  	var weights = new List<float> (uvs.Length * 3 * 3);  	var bones = new List<int> (uvs.Length * 3);  	float scale = Scale;  	for (int i = 0' n = vertices.Length; i < n;) {  		int boneCount = (int)vertices [i++];  		bones.Add (boneCount);  		for (int nn = i + boneCount * 4; i < nn;) {  			bones.Add ((int)vertices [i]);  			weights.Add (vertices [i + 1] * scale);  			weights.Add (vertices [i + 2] * scale);  			weights.Add (vertices [i + 3]);  			i += 4;  		}  	}  	mesh.bones = bones.ToArray ();  	mesh.weights = weights.ToArray ();  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = uvs;  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.boundingbox:  	BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment (skin' name);  	if (box == null)  		return null;  	box.vertices = GetFloatArray (map' "vertices"' Scale);  	return box;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  case AttachmentType.region:  	RegionAttachment region = attachmentLoader.NewRegionAttachment (skin' name' path);  	if (region == null)  		return null;  	region.Path = path;  	region.x = GetFloat (map' "x"' 0) * Scale;  	region.y = GetFloat (map' "y"' 0) * Scale;  	region.scaleX = GetFloat (map' "scaleX"' 1);  	region.scaleY = GetFloat (map' "scaleY"' 1);  	region.rotation = GetFloat (map' "rotation"' 0);  	region.width = GetFloat (map' "width"' 32) * Scale;  	region.height = GetFloat (map' "height"' 32) * Scale;  	region.UpdateOffset ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		region.r = ToColor (color' 0);  		region.g = ToColor (color' 1);  		region.b = ToColor (color' 2);  		region.a = ToColor (color' 3);  	}  	return region;  case AttachmentType.mesh: {  	MeshAttachment mesh = attachmentLoader.NewMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	mesh.vertices = GetFloatArray (map' "vertices"' Scale);  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = GetFloatArray (map' "uvs"' 1);  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.skinnedmesh: {  	SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	float[] uvs = GetFloatArray (map' "uvs"' 1);  	float[] vertices = GetFloatArray (map' "vertices"' 1);  	var weights = new List<float> (uvs.Length * 3 * 3);  	var bones = new List<int> (uvs.Length * 3);  	float scale = Scale;  	for (int i = 0' n = vertices.Length; i < n;) {  		int boneCount = (int)vertices [i++];  		bones.Add (boneCount);  		for (int nn = i + boneCount * 4; i < nn;) {  			bones.Add ((int)vertices [i]);  			weights.Add (vertices [i + 1] * scale);  			weights.Add (vertices [i + 2] * scale);  			weights.Add (vertices [i + 3]);  			i += 4;  		}  	}  	mesh.bones = bones.ToArray ();  	mesh.weights = weights.ToArray ();  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = uvs;  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.boundingbox:  	BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment (skin' name);  	if (box == null)  		return null;  	box.vertices = GetFloatArray (map' "vertices"' Scale);  	return box;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  case AttachmentType.region:  	RegionAttachment region = attachmentLoader.NewRegionAttachment (skin' name' path);  	if (region == null)  		return null;  	region.Path = path;  	region.x = GetFloat (map' "x"' 0) * Scale;  	region.y = GetFloat (map' "y"' 0) * Scale;  	region.scaleX = GetFloat (map' "scaleX"' 1);  	region.scaleY = GetFloat (map' "scaleY"' 1);  	region.rotation = GetFloat (map' "rotation"' 0);  	region.width = GetFloat (map' "width"' 32) * Scale;  	region.height = GetFloat (map' "height"' 32) * Scale;  	region.UpdateOffset ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		region.r = ToColor (color' 0);  		region.g = ToColor (color' 1);  		region.b = ToColor (color' 2);  		region.a = ToColor (color' 3);  	}  	return region;  case AttachmentType.mesh: {  	MeshAttachment mesh = attachmentLoader.NewMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	mesh.vertices = GetFloatArray (map' "vertices"' Scale);  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = GetFloatArray (map' "uvs"' 1);  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.skinnedmesh: {  	SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	float[] uvs = GetFloatArray (map' "uvs"' 1);  	float[] vertices = GetFloatArray (map' "vertices"' 1);  	var weights = new List<float> (uvs.Length * 3 * 3);  	var bones = new List<int> (uvs.Length * 3);  	float scale = Scale;  	for (int i = 0' n = vertices.Length; i < n;) {  		int boneCount = (int)vertices [i++];  		bones.Add (boneCount);  		for (int nn = i + boneCount * 4; i < nn;) {  			bones.Add ((int)vertices [i]);  			weights.Add (vertices [i + 1] * scale);  			weights.Add (vertices [i + 2] * scale);  			weights.Add (vertices [i + 3]);  			i += 4;  		}  	}  	mesh.bones = bones.ToArray ();  	mesh.weights = weights.ToArray ();  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = uvs;  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.boundingbox:  	BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment (skin' name);  	if (box == null)  		return null;  	box.vertices = GetFloatArray (map' "vertices"' Scale);  	return box;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  case AttachmentType.region:  	RegionAttachment region = attachmentLoader.NewRegionAttachment (skin' name' path);  	if (region == null)  		return null;  	region.Path = path;  	region.x = GetFloat (map' "x"' 0) * Scale;  	region.y = GetFloat (map' "y"' 0) * Scale;  	region.scaleX = GetFloat (map' "scaleX"' 1);  	region.scaleY = GetFloat (map' "scaleY"' 1);  	region.rotation = GetFloat (map' "rotation"' 0);  	region.width = GetFloat (map' "width"' 32) * Scale;  	region.height = GetFloat (map' "height"' 32) * Scale;  	region.UpdateOffset ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		region.r = ToColor (color' 0);  		region.g = ToColor (color' 1);  		region.b = ToColor (color' 2);  		region.a = ToColor (color' 3);  	}  	return region;  case AttachmentType.mesh: {  	MeshAttachment mesh = attachmentLoader.NewMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	mesh.vertices = GetFloatArray (map' "vertices"' Scale);  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = GetFloatArray (map' "uvs"' 1);  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.skinnedmesh: {  	SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	float[] uvs = GetFloatArray (map' "uvs"' 1);  	float[] vertices = GetFloatArray (map' "vertices"' 1);  	var weights = new List<float> (uvs.Length * 3 * 3);  	var bones = new List<int> (uvs.Length * 3);  	float scale = Scale;  	for (int i = 0' n = vertices.Length; i < n;) {  		int boneCount = (int)vertices [i++];  		bones.Add (boneCount);  		for (int nn = i + boneCount * 4; i < nn;) {  			bones.Add ((int)vertices [i]);  			weights.Add (vertices [i + 1] * scale);  			weights.Add (vertices [i + 2] * scale);  			weights.Add (vertices [i + 3]);  			i += 4;  		}  	}  	mesh.bones = bones.ToArray ();  	mesh.weights = weights.ToArray ();  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = uvs;  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.boundingbox:  	BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment (skin' name);  	if (box == null)  		return null;  	box.vertices = GetFloatArray (map' "vertices"' Scale);  	return box;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  case AttachmentType.region:  	RegionAttachment region = attachmentLoader.NewRegionAttachment (skin' name' path);  	if (region == null)  		return null;  	region.Path = path;  	region.x = GetFloat (map' "x"' 0) * Scale;  	region.y = GetFloat (map' "y"' 0) * Scale;  	region.scaleX = GetFloat (map' "scaleX"' 1);  	region.scaleY = GetFloat (map' "scaleY"' 1);  	region.rotation = GetFloat (map' "rotation"' 0);  	region.width = GetFloat (map' "width"' 32) * Scale;  	region.height = GetFloat (map' "height"' 32) * Scale;  	region.UpdateOffset ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		region.r = ToColor (color' 0);  		region.g = ToColor (color' 1);  		region.b = ToColor (color' 2);  		region.a = ToColor (color' 3);  	}  	return region;  case AttachmentType.mesh: {  	MeshAttachment mesh = attachmentLoader.NewMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	mesh.vertices = GetFloatArray (map' "vertices"' Scale);  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = GetFloatArray (map' "uvs"' 1);  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.skinnedmesh: {  	SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	float[] uvs = GetFloatArray (map' "uvs"' 1);  	float[] vertices = GetFloatArray (map' "vertices"' 1);  	var weights = new List<float> (uvs.Length * 3 * 3);  	var bones = new List<int> (uvs.Length * 3);  	float scale = Scale;  	for (int i = 0' n = vertices.Length; i < n;) {  		int boneCount = (int)vertices [i++];  		bones.Add (boneCount);  		for (int nn = i + boneCount * 4; i < nn;) {  			bones.Add ((int)vertices [i]);  			weights.Add (vertices [i + 1] * scale);  			weights.Add (vertices [i + 2] * scale);  			weights.Add (vertices [i + 3]);  			i += 4;  		}  	}  	mesh.bones = bones.ToArray ();  	mesh.weights = weights.ToArray ();  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = uvs;  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.boundingbox:  	BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment (skin' name);  	if (box == null)  		return null;  	box.vertices = GetFloatArray (map' "vertices"' Scale);  	return box;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  case AttachmentType.region:  	RegionAttachment region = attachmentLoader.NewRegionAttachment (skin' name' path);  	if (region == null)  		return null;  	region.Path = path;  	region.x = GetFloat (map' "x"' 0) * Scale;  	region.y = GetFloat (map' "y"' 0) * Scale;  	region.scaleX = GetFloat (map' "scaleX"' 1);  	region.scaleY = GetFloat (map' "scaleY"' 1);  	region.rotation = GetFloat (map' "rotation"' 0);  	region.width = GetFloat (map' "width"' 32) * Scale;  	region.height = GetFloat (map' "height"' 32) * Scale;  	region.UpdateOffset ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		region.r = ToColor (color' 0);  		region.g = ToColor (color' 1);  		region.b = ToColor (color' 2);  		region.a = ToColor (color' 3);  	}  	return region;  case AttachmentType.mesh: {  	MeshAttachment mesh = attachmentLoader.NewMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	mesh.vertices = GetFloatArray (map' "vertices"' Scale);  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = GetFloatArray (map' "uvs"' 1);  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.skinnedmesh: {  	SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	float[] uvs = GetFloatArray (map' "uvs"' 1);  	float[] vertices = GetFloatArray (map' "vertices"' 1);  	var weights = new List<float> (uvs.Length * 3 * 3);  	var bones = new List<int> (uvs.Length * 3);  	float scale = Scale;  	for (int i = 0' n = vertices.Length; i < n;) {  		int boneCount = (int)vertices [i++];  		bones.Add (boneCount);  		for (int nn = i + boneCount * 4; i < nn;) {  			bones.Add ((int)vertices [i]);  			weights.Add (vertices [i + 1] * scale);  			weights.Add (vertices [i + 2] * scale);  			weights.Add (vertices [i + 3]);  			i += 4;  		}  	}  	mesh.bones = bones.ToArray ();  	mesh.weights = weights.ToArray ();  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = uvs;  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.boundingbox:  	BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment (skin' name);  	if (box == null)  		return null;  	box.vertices = GetFloatArray (map' "vertices"' Scale);  	return box;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  case AttachmentType.region:  	RegionAttachment region = attachmentLoader.NewRegionAttachment (skin' name' path);  	if (region == null)  		return null;  	region.Path = path;  	region.x = GetFloat (map' "x"' 0) * Scale;  	region.y = GetFloat (map' "y"' 0) * Scale;  	region.scaleX = GetFloat (map' "scaleX"' 1);  	region.scaleY = GetFloat (map' "scaleY"' 1);  	region.rotation = GetFloat (map' "rotation"' 0);  	region.width = GetFloat (map' "width"' 32) * Scale;  	region.height = GetFloat (map' "height"' 32) * Scale;  	region.UpdateOffset ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		region.r = ToColor (color' 0);  		region.g = ToColor (color' 1);  		region.b = ToColor (color' 2);  		region.a = ToColor (color' 3);  	}  	return region;  case AttachmentType.mesh: {  	MeshAttachment mesh = attachmentLoader.NewMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	mesh.vertices = GetFloatArray (map' "vertices"' Scale);  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = GetFloatArray (map' "uvs"' 1);  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.skinnedmesh: {  	SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	float[] uvs = GetFloatArray (map' "uvs"' 1);  	float[] vertices = GetFloatArray (map' "vertices"' 1);  	var weights = new List<float> (uvs.Length * 3 * 3);  	var bones = new List<int> (uvs.Length * 3);  	float scale = Scale;  	for (int i = 0' n = vertices.Length; i < n;) {  		int boneCount = (int)vertices [i++];  		bones.Add (boneCount);  		for (int nn = i + boneCount * 4; i < nn;) {  			bones.Add ((int)vertices [i]);  			weights.Add (vertices [i + 1] * scale);  			weights.Add (vertices [i + 2] * scale);  			weights.Add (vertices [i + 3]);  			i += 4;  		}  	}  	mesh.bones = bones.ToArray ();  	mesh.weights = weights.ToArray ();  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = uvs;  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.boundingbox:  	BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment (skin' name);  	if (box == null)  		return null;  	box.vertices = GetFloatArray (map' "vertices"' Scale);  	return box;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  case AttachmentType.region:  	RegionAttachment region = attachmentLoader.NewRegionAttachment (skin' name' path);  	if (region == null)  		return null;  	region.Path = path;  	region.x = GetFloat (map' "x"' 0) * Scale;  	region.y = GetFloat (map' "y"' 0) * Scale;  	region.scaleX = GetFloat (map' "scaleX"' 1);  	region.scaleY = GetFloat (map' "scaleY"' 1);  	region.rotation = GetFloat (map' "rotation"' 0);  	region.width = GetFloat (map' "width"' 32) * Scale;  	region.height = GetFloat (map' "height"' 32) * Scale;  	region.UpdateOffset ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		region.r = ToColor (color' 0);  		region.g = ToColor (color' 1);  		region.b = ToColor (color' 2);  		region.a = ToColor (color' 3);  	}  	return region;  case AttachmentType.mesh: {  	MeshAttachment mesh = attachmentLoader.NewMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	mesh.vertices = GetFloatArray (map' "vertices"' Scale);  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = GetFloatArray (map' "uvs"' 1);  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.skinnedmesh: {  	SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	float[] uvs = GetFloatArray (map' "uvs"' 1);  	float[] vertices = GetFloatArray (map' "vertices"' 1);  	var weights = new List<float> (uvs.Length * 3 * 3);  	var bones = new List<int> (uvs.Length * 3);  	float scale = Scale;  	for (int i = 0' n = vertices.Length; i < n;) {  		int boneCount = (int)vertices [i++];  		bones.Add (boneCount);  		for (int nn = i + boneCount * 4; i < nn;) {  			bones.Add ((int)vertices [i]);  			weights.Add (vertices [i + 1] * scale);  			weights.Add (vertices [i + 2] * scale);  			weights.Add (vertices [i + 3]);  			i += 4;  		}  	}  	mesh.bones = bones.ToArray ();  	mesh.weights = weights.ToArray ();  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = uvs;  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.boundingbox:  	BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment (skin' name);  	if (box == null)  		return null;  	box.vertices = GetFloatArray (map' "vertices"' Scale);  	return box;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  case AttachmentType.region:  	RegionAttachment region = attachmentLoader.NewRegionAttachment (skin' name' path);  	if (region == null)  		return null;  	region.Path = path;  	region.x = GetFloat (map' "x"' 0) * Scale;  	region.y = GetFloat (map' "y"' 0) * Scale;  	region.scaleX = GetFloat (map' "scaleX"' 1);  	region.scaleY = GetFloat (map' "scaleY"' 1);  	region.rotation = GetFloat (map' "rotation"' 0);  	region.width = GetFloat (map' "width"' 32) * Scale;  	region.height = GetFloat (map' "height"' 32) * Scale;  	region.UpdateOffset ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		region.r = ToColor (color' 0);  		region.g = ToColor (color' 1);  		region.b = ToColor (color' 2);  		region.a = ToColor (color' 3);  	}  	return region;  case AttachmentType.mesh: {  	MeshAttachment mesh = attachmentLoader.NewMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	mesh.vertices = GetFloatArray (map' "vertices"' Scale);  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = GetFloatArray (map' "uvs"' 1);  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.skinnedmesh: {  	SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	float[] uvs = GetFloatArray (map' "uvs"' 1);  	float[] vertices = GetFloatArray (map' "vertices"' 1);  	var weights = new List<float> (uvs.Length * 3 * 3);  	var bones = new List<int> (uvs.Length * 3);  	float scale = Scale;  	for (int i = 0' n = vertices.Length; i < n;) {  		int boneCount = (int)vertices [i++];  		bones.Add (boneCount);  		for (int nn = i + boneCount * 4; i < nn;) {  			bones.Add ((int)vertices [i]);  			weights.Add (vertices [i + 1] * scale);  			weights.Add (vertices [i + 2] * scale);  			weights.Add (vertices [i + 3]);  			i += 4;  		}  	}  	mesh.bones = bones.ToArray ();  	mesh.weights = weights.ToArray ();  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = uvs;  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.boundingbox:  	BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment (skin' name);  	if (box == null)  		return null;  	box.vertices = GetFloatArray (map' "vertices"' Scale);  	return box;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  case AttachmentType.region:  	RegionAttachment region = attachmentLoader.NewRegionAttachment (skin' name' path);  	if (region == null)  		return null;  	region.Path = path;  	region.x = GetFloat (map' "x"' 0) * Scale;  	region.y = GetFloat (map' "y"' 0) * Scale;  	region.scaleX = GetFloat (map' "scaleX"' 1);  	region.scaleY = GetFloat (map' "scaleY"' 1);  	region.rotation = GetFloat (map' "rotation"' 0);  	region.width = GetFloat (map' "width"' 32) * Scale;  	region.height = GetFloat (map' "height"' 32) * Scale;  	region.UpdateOffset ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		region.r = ToColor (color' 0);  		region.g = ToColor (color' 1);  		region.b = ToColor (color' 2);  		region.a = ToColor (color' 3);  	}  	return region;  case AttachmentType.mesh: {  	MeshAttachment mesh = attachmentLoader.NewMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	mesh.vertices = GetFloatArray (map' "vertices"' Scale);  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = GetFloatArray (map' "uvs"' 1);  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.skinnedmesh: {  	SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	float[] uvs = GetFloatArray (map' "uvs"' 1);  	float[] vertices = GetFloatArray (map' "vertices"' 1);  	var weights = new List<float> (uvs.Length * 3 * 3);  	var bones = new List<int> (uvs.Length * 3);  	float scale = Scale;  	for (int i = 0' n = vertices.Length; i < n;) {  		int boneCount = (int)vertices [i++];  		bones.Add (boneCount);  		for (int nn = i + boneCount * 4; i < nn;) {  			bones.Add ((int)vertices [i]);  			weights.Add (vertices [i + 1] * scale);  			weights.Add (vertices [i + 2] * scale);  			weights.Add (vertices [i + 3]);  			i += 4;  		}  	}  	mesh.bones = bones.ToArray ();  	mesh.weights = weights.ToArray ();  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = uvs;  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.boundingbox:  	BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment (skin' name);  	if (box == null)  		return null;  	box.vertices = GetFloatArray (map' "vertices"' Scale);  	return box;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: region.width = GetFloat (map' "width"' 32) * Scale;  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: region.height = GetFloat (map' "height"' 32) * Scale;  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: if (map.ContainsKey ("color")) {  	var color = (String)map ["color"];  	region.r = ToColor (color' 0);  	region.g = ToColor (color' 1);  	region.b = ToColor (color' 2);  	region.a = ToColor (color' 3);  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: if (map.ContainsKey ("color")) {  	var color = (String)map ["color"];  	region.r = ToColor (color' 0);  	region.g = ToColor (color' 1);  	region.b = ToColor (color' 2);  	region.a = ToColor (color' 3);  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: region.b = ToColor (color' 2);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: region.a = ToColor (color' 3);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: if (map.ContainsKey ("color")) {  	var color = (String)map ["color"];  	mesh.r = ToColor (color' 0);  	mesh.g = ToColor (color' 1);  	mesh.b = ToColor (color' 2);  	mesh.a = ToColor (color' 3);  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: if (map.ContainsKey ("color")) {  	var color = (String)map ["color"];  	mesh.r = ToColor (color' 0);  	mesh.g = ToColor (color' 1);  	mesh.b = ToColor (color' 2);  	mesh.a = ToColor (color' 3);  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: mesh.b = ToColor (color' 2);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: mesh.a = ToColor (color' 3);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: mesh.HullLength = GetInt (map' "hull"' 0) * 2;  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: for (int i = 0' n = vertices.Length; i < n;) {  	int boneCount = (int)vertices [i++];  	bones.Add (boneCount);  	for (int nn = i + boneCount * 4; i < nn;) {  		bones.Add ((int)vertices [i]);  		weights.Add (vertices [i + 1] * scale);  		weights.Add (vertices [i + 2] * scale);  		weights.Add (vertices [i + 3]);  		i += 4;  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: for (int i = 0' n = vertices.Length; i < n;) {  	int boneCount = (int)vertices [i++];  	bones.Add (boneCount);  	for (int nn = i + boneCount * 4; i < nn;) {  		bones.Add ((int)vertices [i]);  		weights.Add (vertices [i + 1] * scale);  		weights.Add (vertices [i + 2] * scale);  		weights.Add (vertices [i + 3]);  		i += 4;  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: for (int i = 0' n = vertices.Length; i < n;) {  	int boneCount = (int)vertices [i++];  	bones.Add (boneCount);  	for (int nn = i + boneCount * 4; i < nn;) {  		bones.Add ((int)vertices [i]);  		weights.Add (vertices [i + 1] * scale);  		weights.Add (vertices [i + 2] * scale);  		weights.Add (vertices [i + 3]);  		i += 4;  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: for (int i = 0' n = vertices.Length; i < n;) {  	int boneCount = (int)vertices [i++];  	bones.Add (boneCount);  	for (int nn = i + boneCount * 4; i < nn;) {  		bones.Add ((int)vertices [i]);  		weights.Add (vertices [i + 1] * scale);  		weights.Add (vertices [i + 2] * scale);  		weights.Add (vertices [i + 3]);  		i += 4;  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: for (int nn = i + boneCount * 4; i < nn;) {  	bones.Add ((int)vertices [i]);  	weights.Add (vertices [i + 1] * scale);  	weights.Add (vertices [i + 2] * scale);  	weights.Add (vertices [i + 3]);  	i += 4;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: for (int nn = i + boneCount * 4; i < nn;) {  	bones.Add ((int)vertices [i]);  	weights.Add (vertices [i + 1] * scale);  	weights.Add (vertices [i + 2] * scale);  	weights.Add (vertices [i + 3]);  	i += 4;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: for (int nn = i + boneCount * 4; i < nn;) {  	bones.Add ((int)vertices [i]);  	weights.Add (vertices [i + 1] * scale);  	weights.Add (vertices [i + 2] * scale);  	weights.Add (vertices [i + 3]);  	i += 4;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: for (int nn = i + boneCount * 4; i < nn;) {  	bones.Add ((int)vertices [i]);  	weights.Add (vertices [i + 1] * scale);  	weights.Add (vertices [i + 2] * scale);  	weights.Add (vertices [i + 3]);  	i += 4;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: weights.Add (vertices [i + 2] * scale);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: weights.Add (vertices [i + 3]);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: i += 4;  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: if (map.ContainsKey ("color")) {  	var color = (String)map ["color"];  	mesh.r = ToColor (color' 0);  	mesh.g = ToColor (color' 1);  	mesh.b = ToColor (color' 2);  	mesh.a = ToColor (color' 3);  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: if (map.ContainsKey ("color")) {  	var color = (String)map ["color"];  	mesh.r = ToColor (color' 0);  	mesh.g = ToColor (color' 1);  	mesh.b = ToColor (color' 2);  	mesh.a = ToColor (color' 3);  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: mesh.b = ToColor (color' 2);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: mesh.a = ToColor (color' 3);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: mesh.HullLength = GetInt (map' "hull"' 0) * 2;  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ToColor,The following statement contains a magic number: if (hexString.Length != 8)  	throw new ArgumentException ("Color hexidecimal length must be 8' recieved: " + hexString);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ToColor,The following statement contains a magic number: return Convert.ToInt32 (hexString.Substring (colorIndex * 2' 2)' 16) / (float)255;  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ToColor,The following statement contains a magic number: return Convert.ToInt32 (hexString.Substring (colorIndex * 2' 2)' 16) / (float)255;  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ToColor,The following statement contains a magic number: return Convert.ToInt32 (hexString.Substring (colorIndex * 2' 2)' 16) / (float)255;  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ToColor,The following statement contains a magic number: return Convert.ToInt32 (hexString.Substring (colorIndex * 2' 2)' 16) / (float)255;  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("slots")) {  	foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["slots"]) {  		String slotName = entry.Key;  		int slotIndex = skeletonData.FindSlotIndex (slotName);  		var timelineMap = (Dictionary<String' Object>)entry.Value;  		foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  			var values = (List<Object>)timelineEntry.Value;  			var timelineName = (String)timelineEntry.Key;  			if (timelineName.Equals ("color")) {  				var timeline = new ColorTimeline (values.Count);  				timeline.slotIndex = slotIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					String c = (String)valueMap ["color"];  					timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  			}  			else if (timelineName.Equals ("attachment")) {  				var timeline = new AttachmentTimeline (values.Count);  				timeline.slotIndex = slotIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  			}  			else  				throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("slots")) {  	foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["slots"]) {  		String slotName = entry.Key;  		int slotIndex = skeletonData.FindSlotIndex (slotName);  		var timelineMap = (Dictionary<String' Object>)entry.Value;  		foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  			var values = (List<Object>)timelineEntry.Value;  			var timelineName = (String)timelineEntry.Key;  			if (timelineName.Equals ("color")) {  				var timeline = new ColorTimeline (values.Count);  				timeline.slotIndex = slotIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					String c = (String)valueMap ["color"];  					timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  			}  			else if (timelineName.Equals ("attachment")) {  				var timeline = new AttachmentTimeline (values.Count);  				timeline.slotIndex = slotIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  			}  			else  				throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("slots")) {  	foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["slots"]) {  		String slotName = entry.Key;  		int slotIndex = skeletonData.FindSlotIndex (slotName);  		var timelineMap = (Dictionary<String' Object>)entry.Value;  		foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  			var values = (List<Object>)timelineEntry.Value;  			var timelineName = (String)timelineEntry.Key;  			if (timelineName.Equals ("color")) {  				var timeline = new ColorTimeline (values.Count);  				timeline.slotIndex = slotIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					String c = (String)valueMap ["color"];  					timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  			}  			else if (timelineName.Equals ("attachment")) {  				var timeline = new AttachmentTimeline (values.Count);  				timeline.slotIndex = slotIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  			}  			else  				throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("slots")) {  	foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["slots"]) {  		String slotName = entry.Key;  		int slotIndex = skeletonData.FindSlotIndex (slotName);  		var timelineMap = (Dictionary<String' Object>)entry.Value;  		foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  			var values = (List<Object>)timelineEntry.Value;  			var timelineName = (String)timelineEntry.Key;  			if (timelineName.Equals ("color")) {  				var timeline = new ColorTimeline (values.Count);  				timeline.slotIndex = slotIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					String c = (String)valueMap ["color"];  					timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  			}  			else if (timelineName.Equals ("attachment")) {  				var timeline = new AttachmentTimeline (values.Count);  				timeline.slotIndex = slotIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  			}  			else  				throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["slots"]) {  	String slotName = entry.Key;  	int slotIndex = skeletonData.FindSlotIndex (slotName);  	var timelineMap = (Dictionary<String' Object>)entry.Value;  	foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  		var values = (List<Object>)timelineEntry.Value;  		var timelineName = (String)timelineEntry.Key;  		if (timelineName.Equals ("color")) {  			var timeline = new ColorTimeline (values.Count);  			timeline.slotIndex = slotIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				String c = (String)valueMap ["color"];  				timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  		}  		else if (timelineName.Equals ("attachment")) {  			var timeline = new AttachmentTimeline (values.Count);  			timeline.slotIndex = slotIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  		}  		else  			throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["slots"]) {  	String slotName = entry.Key;  	int slotIndex = skeletonData.FindSlotIndex (slotName);  	var timelineMap = (Dictionary<String' Object>)entry.Value;  	foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  		var values = (List<Object>)timelineEntry.Value;  		var timelineName = (String)timelineEntry.Key;  		if (timelineName.Equals ("color")) {  			var timeline = new ColorTimeline (values.Count);  			timeline.slotIndex = slotIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				String c = (String)valueMap ["color"];  				timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  		}  		else if (timelineName.Equals ("attachment")) {  			var timeline = new AttachmentTimeline (values.Count);  			timeline.slotIndex = slotIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  		}  		else  			throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["slots"]) {  	String slotName = entry.Key;  	int slotIndex = skeletonData.FindSlotIndex (slotName);  	var timelineMap = (Dictionary<String' Object>)entry.Value;  	foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  		var values = (List<Object>)timelineEntry.Value;  		var timelineName = (String)timelineEntry.Key;  		if (timelineName.Equals ("color")) {  			var timeline = new ColorTimeline (values.Count);  			timeline.slotIndex = slotIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				String c = (String)valueMap ["color"];  				timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  		}  		else if (timelineName.Equals ("attachment")) {  			var timeline = new AttachmentTimeline (values.Count);  			timeline.slotIndex = slotIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  		}  		else  			throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["slots"]) {  	String slotName = entry.Key;  	int slotIndex = skeletonData.FindSlotIndex (slotName);  	var timelineMap = (Dictionary<String' Object>)entry.Value;  	foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  		var values = (List<Object>)timelineEntry.Value;  		var timelineName = (String)timelineEntry.Key;  		if (timelineName.Equals ("color")) {  			var timeline = new ColorTimeline (values.Count);  			timeline.slotIndex = slotIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				String c = (String)valueMap ["color"];  				timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  		}  		else if (timelineName.Equals ("attachment")) {  			var timeline = new AttachmentTimeline (values.Count);  			timeline.slotIndex = slotIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  		}  		else  			throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  	var values = (List<Object>)timelineEntry.Value;  	var timelineName = (String)timelineEntry.Key;  	if (timelineName.Equals ("color")) {  		var timeline = new ColorTimeline (values.Count);  		timeline.slotIndex = slotIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			String c = (String)valueMap ["color"];  			timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  	}  	else if (timelineName.Equals ("attachment")) {  		var timeline = new AttachmentTimeline (values.Count);  		timeline.slotIndex = slotIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  	}  	else  		throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  	var values = (List<Object>)timelineEntry.Value;  	var timelineName = (String)timelineEntry.Key;  	if (timelineName.Equals ("color")) {  		var timeline = new ColorTimeline (values.Count);  		timeline.slotIndex = slotIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			String c = (String)valueMap ["color"];  			timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  	}  	else if (timelineName.Equals ("attachment")) {  		var timeline = new AttachmentTimeline (values.Count);  		timeline.slotIndex = slotIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  	}  	else  		throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  	var values = (List<Object>)timelineEntry.Value;  	var timelineName = (String)timelineEntry.Key;  	if (timelineName.Equals ("color")) {  		var timeline = new ColorTimeline (values.Count);  		timeline.slotIndex = slotIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			String c = (String)valueMap ["color"];  			timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  	}  	else if (timelineName.Equals ("attachment")) {  		var timeline = new AttachmentTimeline (values.Count);  		timeline.slotIndex = slotIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  	}  	else  		throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  	var values = (List<Object>)timelineEntry.Value;  	var timelineName = (String)timelineEntry.Key;  	if (timelineName.Equals ("color")) {  		var timeline = new ColorTimeline (values.Count);  		timeline.slotIndex = slotIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			String c = (String)valueMap ["color"];  			timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  	}  	else if (timelineName.Equals ("attachment")) {  		var timeline = new AttachmentTimeline (values.Count);  		timeline.slotIndex = slotIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  	}  	else  		throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("color")) {  	var timeline = new ColorTimeline (values.Count);  	timeline.slotIndex = slotIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		String c = (String)valueMap ["color"];  		timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  }  else if (timelineName.Equals ("attachment")) {  	var timeline = new AttachmentTimeline (values.Count);  	timeline.slotIndex = slotIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  }  else  	throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("color")) {  	var timeline = new ColorTimeline (values.Count);  	timeline.slotIndex = slotIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		String c = (String)valueMap ["color"];  		timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  }  else if (timelineName.Equals ("attachment")) {  	var timeline = new AttachmentTimeline (values.Count);  	timeline.slotIndex = slotIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  }  else  	throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("color")) {  	var timeline = new ColorTimeline (values.Count);  	timeline.slotIndex = slotIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		String c = (String)valueMap ["color"];  		timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  }  else if (timelineName.Equals ("attachment")) {  	var timeline = new AttachmentTimeline (values.Count);  	timeline.slotIndex = slotIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  }  else  	throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("color")) {  	var timeline = new ColorTimeline (values.Count);  	timeline.slotIndex = slotIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		String c = (String)valueMap ["color"];  		timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  }  else if (timelineName.Equals ("attachment")) {  	var timeline = new AttachmentTimeline (values.Count);  	timeline.slotIndex = slotIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  }  else  	throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (Dictionary<String' Object> valueMap in values) {  	float time = (float)valueMap ["time"];  	String c = (String)valueMap ["color"];  	timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  	ReadCurve (timeline' frameIndex' valueMap);  	frameIndex++;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (Dictionary<String' Object> valueMap in values) {  	float time = (float)valueMap ["time"];  	String c = (String)valueMap ["color"];  	timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  	ReadCurve (timeline' frameIndex' valueMap);  	frameIndex++;  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("bones")) {  	foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["bones"]) {  		String boneName = entry.Key;  		int boneIndex = skeletonData.FindBoneIndex (boneName);  		if (boneIndex == -1)  			throw new Exception ("Bone not found: " + boneName);  		var timelineMap = (Dictionary<String' Object>)entry.Value;  		foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  			var values = (List<Object>)timelineEntry.Value;  			var timelineName = (String)timelineEntry.Key;  			if (timelineName.Equals ("rotate")) {  				var timeline = new RotateTimeline (values.Count);  				timeline.boneIndex = boneIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  			}  			else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  				TranslateTimeline timeline;  				float timelineScale = 1;  				if (timelineName.Equals ("scale"))  					timeline = new ScaleTimeline (values.Count);  				else {  					timeline = new TranslateTimeline (values.Count);  					timelineScale = scale;  				}  				timeline.boneIndex = boneIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  					float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  					timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  			}  			else  				throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("bones")) {  	foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["bones"]) {  		String boneName = entry.Key;  		int boneIndex = skeletonData.FindBoneIndex (boneName);  		if (boneIndex == -1)  			throw new Exception ("Bone not found: " + boneName);  		var timelineMap = (Dictionary<String' Object>)entry.Value;  		foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  			var values = (List<Object>)timelineEntry.Value;  			var timelineName = (String)timelineEntry.Key;  			if (timelineName.Equals ("rotate")) {  				var timeline = new RotateTimeline (values.Count);  				timeline.boneIndex = boneIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  			}  			else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  				TranslateTimeline timeline;  				float timelineScale = 1;  				if (timelineName.Equals ("scale"))  					timeline = new ScaleTimeline (values.Count);  				else {  					timeline = new TranslateTimeline (values.Count);  					timelineScale = scale;  				}  				timeline.boneIndex = boneIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  					float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  					timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  			}  			else  				throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("bones")) {  	foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["bones"]) {  		String boneName = entry.Key;  		int boneIndex = skeletonData.FindBoneIndex (boneName);  		if (boneIndex == -1)  			throw new Exception ("Bone not found: " + boneName);  		var timelineMap = (Dictionary<String' Object>)entry.Value;  		foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  			var values = (List<Object>)timelineEntry.Value;  			var timelineName = (String)timelineEntry.Key;  			if (timelineName.Equals ("rotate")) {  				var timeline = new RotateTimeline (values.Count);  				timeline.boneIndex = boneIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  			}  			else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  				TranslateTimeline timeline;  				float timelineScale = 1;  				if (timelineName.Equals ("scale"))  					timeline = new ScaleTimeline (values.Count);  				else {  					timeline = new TranslateTimeline (values.Count);  					timelineScale = scale;  				}  				timeline.boneIndex = boneIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  					float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  					timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  			}  			else  				throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("bones")) {  	foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["bones"]) {  		String boneName = entry.Key;  		int boneIndex = skeletonData.FindBoneIndex (boneName);  		if (boneIndex == -1)  			throw new Exception ("Bone not found: " + boneName);  		var timelineMap = (Dictionary<String' Object>)entry.Value;  		foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  			var values = (List<Object>)timelineEntry.Value;  			var timelineName = (String)timelineEntry.Key;  			if (timelineName.Equals ("rotate")) {  				var timeline = new RotateTimeline (values.Count);  				timeline.boneIndex = boneIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  			}  			else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  				TranslateTimeline timeline;  				float timelineScale = 1;  				if (timelineName.Equals ("scale"))  					timeline = new ScaleTimeline (values.Count);  				else {  					timeline = new TranslateTimeline (values.Count);  					timelineScale = scale;  				}  				timeline.boneIndex = boneIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  					float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  					timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  			}  			else  				throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["bones"]) {  	String boneName = entry.Key;  	int boneIndex = skeletonData.FindBoneIndex (boneName);  	if (boneIndex == -1)  		throw new Exception ("Bone not found: " + boneName);  	var timelineMap = (Dictionary<String' Object>)entry.Value;  	foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  		var values = (List<Object>)timelineEntry.Value;  		var timelineName = (String)timelineEntry.Key;  		if (timelineName.Equals ("rotate")) {  			var timeline = new RotateTimeline (values.Count);  			timeline.boneIndex = boneIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  		}  		else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  			TranslateTimeline timeline;  			float timelineScale = 1;  			if (timelineName.Equals ("scale"))  				timeline = new ScaleTimeline (values.Count);  			else {  				timeline = new TranslateTimeline (values.Count);  				timelineScale = scale;  			}  			timeline.boneIndex = boneIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  				float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  				timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  		}  		else  			throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["bones"]) {  	String boneName = entry.Key;  	int boneIndex = skeletonData.FindBoneIndex (boneName);  	if (boneIndex == -1)  		throw new Exception ("Bone not found: " + boneName);  	var timelineMap = (Dictionary<String' Object>)entry.Value;  	foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  		var values = (List<Object>)timelineEntry.Value;  		var timelineName = (String)timelineEntry.Key;  		if (timelineName.Equals ("rotate")) {  			var timeline = new RotateTimeline (values.Count);  			timeline.boneIndex = boneIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  		}  		else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  			TranslateTimeline timeline;  			float timelineScale = 1;  			if (timelineName.Equals ("scale"))  				timeline = new ScaleTimeline (values.Count);  			else {  				timeline = new TranslateTimeline (values.Count);  				timelineScale = scale;  			}  			timeline.boneIndex = boneIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  				float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  				timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  		}  		else  			throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["bones"]) {  	String boneName = entry.Key;  	int boneIndex = skeletonData.FindBoneIndex (boneName);  	if (boneIndex == -1)  		throw new Exception ("Bone not found: " + boneName);  	var timelineMap = (Dictionary<String' Object>)entry.Value;  	foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  		var values = (List<Object>)timelineEntry.Value;  		var timelineName = (String)timelineEntry.Key;  		if (timelineName.Equals ("rotate")) {  			var timeline = new RotateTimeline (values.Count);  			timeline.boneIndex = boneIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  		}  		else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  			TranslateTimeline timeline;  			float timelineScale = 1;  			if (timelineName.Equals ("scale"))  				timeline = new ScaleTimeline (values.Count);  			else {  				timeline = new TranslateTimeline (values.Count);  				timelineScale = scale;  			}  			timeline.boneIndex = boneIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  				float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  				timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  		}  		else  			throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["bones"]) {  	String boneName = entry.Key;  	int boneIndex = skeletonData.FindBoneIndex (boneName);  	if (boneIndex == -1)  		throw new Exception ("Bone not found: " + boneName);  	var timelineMap = (Dictionary<String' Object>)entry.Value;  	foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  		var values = (List<Object>)timelineEntry.Value;  		var timelineName = (String)timelineEntry.Key;  		if (timelineName.Equals ("rotate")) {  			var timeline = new RotateTimeline (values.Count);  			timeline.boneIndex = boneIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  		}  		else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  			TranslateTimeline timeline;  			float timelineScale = 1;  			if (timelineName.Equals ("scale"))  				timeline = new ScaleTimeline (values.Count);  			else {  				timeline = new TranslateTimeline (values.Count);  				timelineScale = scale;  			}  			timeline.boneIndex = boneIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  				float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  				timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  		}  		else  			throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  	var values = (List<Object>)timelineEntry.Value;  	var timelineName = (String)timelineEntry.Key;  	if (timelineName.Equals ("rotate")) {  		var timeline = new RotateTimeline (values.Count);  		timeline.boneIndex = boneIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  	}  	else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  		TranslateTimeline timeline;  		float timelineScale = 1;  		if (timelineName.Equals ("scale"))  			timeline = new ScaleTimeline (values.Count);  		else {  			timeline = new TranslateTimeline (values.Count);  			timelineScale = scale;  		}  		timeline.boneIndex = boneIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  			float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  			timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  	}  	else  		throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  	var values = (List<Object>)timelineEntry.Value;  	var timelineName = (String)timelineEntry.Key;  	if (timelineName.Equals ("rotate")) {  		var timeline = new RotateTimeline (values.Count);  		timeline.boneIndex = boneIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  	}  	else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  		TranslateTimeline timeline;  		float timelineScale = 1;  		if (timelineName.Equals ("scale"))  			timeline = new ScaleTimeline (values.Count);  		else {  			timeline = new TranslateTimeline (values.Count);  			timelineScale = scale;  		}  		timeline.boneIndex = boneIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  			float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  			timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  	}  	else  		throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  	var values = (List<Object>)timelineEntry.Value;  	var timelineName = (String)timelineEntry.Key;  	if (timelineName.Equals ("rotate")) {  		var timeline = new RotateTimeline (values.Count);  		timeline.boneIndex = boneIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  	}  	else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  		TranslateTimeline timeline;  		float timelineScale = 1;  		if (timelineName.Equals ("scale"))  			timeline = new ScaleTimeline (values.Count);  		else {  			timeline = new TranslateTimeline (values.Count);  			timelineScale = scale;  		}  		timeline.boneIndex = boneIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  			float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  			timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  	}  	else  		throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  	var values = (List<Object>)timelineEntry.Value;  	var timelineName = (String)timelineEntry.Key;  	if (timelineName.Equals ("rotate")) {  		var timeline = new RotateTimeline (values.Count);  		timeline.boneIndex = boneIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  	}  	else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  		TranslateTimeline timeline;  		float timelineScale = 1;  		if (timelineName.Equals ("scale"))  			timeline = new ScaleTimeline (values.Count);  		else {  			timeline = new TranslateTimeline (values.Count);  			timelineScale = scale;  		}  		timeline.boneIndex = boneIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  			float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  			timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  	}  	else  		throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("rotate")) {  	var timeline = new RotateTimeline (values.Count);  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  }  else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  	TranslateTimeline timeline;  	float timelineScale = 1;  	if (timelineName.Equals ("scale"))  		timeline = new ScaleTimeline (values.Count);  	else {  		timeline = new TranslateTimeline (values.Count);  		timelineScale = scale;  	}  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  		float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  		timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  }  else  	throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("rotate")) {  	var timeline = new RotateTimeline (values.Count);  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  }  else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  	TranslateTimeline timeline;  	float timelineScale = 1;  	if (timelineName.Equals ("scale"))  		timeline = new ScaleTimeline (values.Count);  	else {  		timeline = new TranslateTimeline (values.Count);  		timelineScale = scale;  	}  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  		float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  		timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  }  else  	throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("rotate")) {  	var timeline = new RotateTimeline (values.Count);  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  }  else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  	TranslateTimeline timeline;  	float timelineScale = 1;  	if (timelineName.Equals ("scale"))  		timeline = new ScaleTimeline (values.Count);  	else {  		timeline = new TranslateTimeline (values.Count);  		timelineScale = scale;  	}  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  		float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  		timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  }  else  	throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("rotate")) {  	var timeline = new RotateTimeline (values.Count);  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  }  else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  	TranslateTimeline timeline;  	float timelineScale = 1;  	if (timelineName.Equals ("scale"))  		timeline = new ScaleTimeline (values.Count);  	else {  		timeline = new TranslateTimeline (values.Count);  		timelineScale = scale;  	}  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  		float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  		timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  }  else  	throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  	TranslateTimeline timeline;  	float timelineScale = 1;  	if (timelineName.Equals ("scale"))  		timeline = new ScaleTimeline (values.Count);  	else {  		timeline = new TranslateTimeline (values.Count);  		timelineScale = scale;  	}  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  		float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  		timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  }  else  	throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  	TranslateTimeline timeline;  	float timelineScale = 1;  	if (timelineName.Equals ("scale"))  		timeline = new ScaleTimeline (values.Count);  	else {  		timeline = new TranslateTimeline (values.Count);  		timelineScale = scale;  	}  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  		float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  		timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  }  else  	throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("ik")) {  	foreach (KeyValuePair<String' Object> ikMap in (Dictionary<String' Object>)map ["ik"]) {  		IkConstraintData ikConstraint = skeletonData.FindIkConstraint (ikMap.Key);  		var values = (List<Object>)ikMap.Value;  		var timeline = new IkConstraintTimeline (values.Count);  		timeline.ikConstraintIndex = skeletonData.ikConstraints.IndexOf (ikConstraint);  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			float mix = valueMap.ContainsKey ("mix") ? (float)valueMap ["mix"] : 1;  			bool bendPositive = valueMap.ContainsKey ("bendPositive") ? (bool)valueMap ["bendPositive"] : true;  			timeline.setFrame (frameIndex' time' mix' bendPositive ? 1 : -1);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("ik")) {  	foreach (KeyValuePair<String' Object> ikMap in (Dictionary<String' Object>)map ["ik"]) {  		IkConstraintData ikConstraint = skeletonData.FindIkConstraint (ikMap.Key);  		var values = (List<Object>)ikMap.Value;  		var timeline = new IkConstraintTimeline (values.Count);  		timeline.ikConstraintIndex = skeletonData.ikConstraints.IndexOf (ikConstraint);  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			float mix = valueMap.ContainsKey ("mix") ? (float)valueMap ["mix"] : 1;  			bool bendPositive = valueMap.ContainsKey ("bendPositive") ? (bool)valueMap ["bendPositive"] : true;  			timeline.setFrame (frameIndex' time' mix' bendPositive ? 1 : -1);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> ikMap in (Dictionary<String' Object>)map ["ik"]) {  	IkConstraintData ikConstraint = skeletonData.FindIkConstraint (ikMap.Key);  	var values = (List<Object>)ikMap.Value;  	var timeline = new IkConstraintTimeline (values.Count);  	timeline.ikConstraintIndex = skeletonData.ikConstraints.IndexOf (ikConstraint);  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		float mix = valueMap.ContainsKey ("mix") ? (float)valueMap ["mix"] : 1;  		bool bendPositive = valueMap.ContainsKey ("bendPositive") ? (bool)valueMap ["bendPositive"] : true;  		timeline.setFrame (frameIndex' time' mix' bendPositive ? 1 : -1);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> ikMap in (Dictionary<String' Object>)map ["ik"]) {  	IkConstraintData ikConstraint = skeletonData.FindIkConstraint (ikMap.Key);  	var values = (List<Object>)ikMap.Value;  	var timeline = new IkConstraintTimeline (values.Count);  	timeline.ikConstraintIndex = skeletonData.ikConstraints.IndexOf (ikConstraint);  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		float mix = valueMap.ContainsKey ("mix") ? (float)valueMap ["mix"] : 1;  		bool bendPositive = valueMap.ContainsKey ("bendPositive") ? (bool)valueMap ["bendPositive"] : true;  		timeline.setFrame (frameIndex' time' mix' bendPositive ? 1 : -1);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("ffd")) {  	foreach (KeyValuePair<String' Object> ffdMap in (Dictionary<String' Object>)map ["ffd"]) {  		Skin skin = skeletonData.FindSkin (ffdMap.Key);  		foreach (KeyValuePair<String' Object> slotMap in (Dictionary<String' Object>)ffdMap.Value) {  			int slotIndex = skeletonData.FindSlotIndex (slotMap.Key);  			foreach (KeyValuePair<String' Object> meshMap in (Dictionary<String' Object>)slotMap.Value) {  				var values = (List<Object>)meshMap.Value;  				var timeline = new FFDTimeline (values.Count);  				Attachment attachment = skin.GetAttachment (slotIndex' meshMap.Key);  				if (attachment == null)  					throw new Exception ("FFD attachment not found: " + meshMap.Key);  				timeline.slotIndex = slotIndex;  				timeline.attachment = attachment;  				int vertexCount;  				if (attachment is MeshAttachment)  					vertexCount = ((MeshAttachment)attachment).vertices.Length;  				else  					vertexCount = ((SkinnedMeshAttachment)attachment).Weights.Length / 3 * 2;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float[] vertices;  					if (!valueMap.ContainsKey ("vertices")) {  						if (attachment is MeshAttachment)  							vertices = ((MeshAttachment)attachment).vertices;  						else  							vertices = new float[vertexCount];  					}  					else {  						var verticesValue = (List<Object>)valueMap ["vertices"];  						vertices = new float[vertexCount];  						int start = GetInt (valueMap' "offset"' 0);  						if (scale == 1) {  							for (int i = 0' n = verticesValue.Count; i < n; i++)  								vertices [i + start] = (float)verticesValue [i];  						}  						else {  							for (int i = 0' n = verticesValue.Count; i < n; i++)  								vertices [i + start] = (float)verticesValue [i] * scale;  						}  						if (attachment is MeshAttachment) {  							float[] meshVertices = ((MeshAttachment)attachment).vertices;  							for (int i = 0; i < vertexCount; i++)  								vertices [i] += meshVertices [i];  						}  					}  					timeline.setFrame (frameIndex' (float)valueMap ["time"]' vertices);  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  			}  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("ffd")) {  	foreach (KeyValuePair<String' Object> ffdMap in (Dictionary<String' Object>)map ["ffd"]) {  		Skin skin = skeletonData.FindSkin (ffdMap.Key);  		foreach (KeyValuePair<String' Object> slotMap in (Dictionary<String' Object>)ffdMap.Value) {  			int slotIndex = skeletonData.FindSlotIndex (slotMap.Key);  			foreach (KeyValuePair<String' Object> meshMap in (Dictionary<String' Object>)slotMap.Value) {  				var values = (List<Object>)meshMap.Value;  				var timeline = new FFDTimeline (values.Count);  				Attachment attachment = skin.GetAttachment (slotIndex' meshMap.Key);  				if (attachment == null)  					throw new Exception ("FFD attachment not found: " + meshMap.Key);  				timeline.slotIndex = slotIndex;  				timeline.attachment = attachment;  				int vertexCount;  				if (attachment is MeshAttachment)  					vertexCount = ((MeshAttachment)attachment).vertices.Length;  				else  					vertexCount = ((SkinnedMeshAttachment)attachment).Weights.Length / 3 * 2;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float[] vertices;  					if (!valueMap.ContainsKey ("vertices")) {  						if (attachment is MeshAttachment)  							vertices = ((MeshAttachment)attachment).vertices;  						else  							vertices = new float[vertexCount];  					}  					else {  						var verticesValue = (List<Object>)valueMap ["vertices"];  						vertices = new float[vertexCount];  						int start = GetInt (valueMap' "offset"' 0);  						if (scale == 1) {  							for (int i = 0' n = verticesValue.Count; i < n; i++)  								vertices [i + start] = (float)verticesValue [i];  						}  						else {  							for (int i = 0' n = verticesValue.Count; i < n; i++)  								vertices [i + start] = (float)verticesValue [i] * scale;  						}  						if (attachment is MeshAttachment) {  							float[] meshVertices = ((MeshAttachment)attachment).vertices;  							for (int i = 0; i < vertexCount; i++)  								vertices [i] += meshVertices [i];  						}  					}  					timeline.setFrame (frameIndex' (float)valueMap ["time"]' vertices);  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  			}  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> ffdMap in (Dictionary<String' Object>)map ["ffd"]) {  	Skin skin = skeletonData.FindSkin (ffdMap.Key);  	foreach (KeyValuePair<String' Object> slotMap in (Dictionary<String' Object>)ffdMap.Value) {  		int slotIndex = skeletonData.FindSlotIndex (slotMap.Key);  		foreach (KeyValuePair<String' Object> meshMap in (Dictionary<String' Object>)slotMap.Value) {  			var values = (List<Object>)meshMap.Value;  			var timeline = new FFDTimeline (values.Count);  			Attachment attachment = skin.GetAttachment (slotIndex' meshMap.Key);  			if (attachment == null)  				throw new Exception ("FFD attachment not found: " + meshMap.Key);  			timeline.slotIndex = slotIndex;  			timeline.attachment = attachment;  			int vertexCount;  			if (attachment is MeshAttachment)  				vertexCount = ((MeshAttachment)attachment).vertices.Length;  			else  				vertexCount = ((SkinnedMeshAttachment)attachment).Weights.Length / 3 * 2;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float[] vertices;  				if (!valueMap.ContainsKey ("vertices")) {  					if (attachment is MeshAttachment)  						vertices = ((MeshAttachment)attachment).vertices;  					else  						vertices = new float[vertexCount];  				}  				else {  					var verticesValue = (List<Object>)valueMap ["vertices"];  					vertices = new float[vertexCount];  					int start = GetInt (valueMap' "offset"' 0);  					if (scale == 1) {  						for (int i = 0' n = verticesValue.Count; i < n; i++)  							vertices [i + start] = (float)verticesValue [i];  					}  					else {  						for (int i = 0' n = verticesValue.Count; i < n; i++)  							vertices [i + start] = (float)verticesValue [i] * scale;  					}  					if (attachment is MeshAttachment) {  						float[] meshVertices = ((MeshAttachment)attachment).vertices;  						for (int i = 0; i < vertexCount; i++)  							vertices [i] += meshVertices [i];  					}  				}  				timeline.setFrame (frameIndex' (float)valueMap ["time"]' vertices);  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> ffdMap in (Dictionary<String' Object>)map ["ffd"]) {  	Skin skin = skeletonData.FindSkin (ffdMap.Key);  	foreach (KeyValuePair<String' Object> slotMap in (Dictionary<String' Object>)ffdMap.Value) {  		int slotIndex = skeletonData.FindSlotIndex (slotMap.Key);  		foreach (KeyValuePair<String' Object> meshMap in (Dictionary<String' Object>)slotMap.Value) {  			var values = (List<Object>)meshMap.Value;  			var timeline = new FFDTimeline (values.Count);  			Attachment attachment = skin.GetAttachment (slotIndex' meshMap.Key);  			if (attachment == null)  				throw new Exception ("FFD attachment not found: " + meshMap.Key);  			timeline.slotIndex = slotIndex;  			timeline.attachment = attachment;  			int vertexCount;  			if (attachment is MeshAttachment)  				vertexCount = ((MeshAttachment)attachment).vertices.Length;  			else  				vertexCount = ((SkinnedMeshAttachment)attachment).Weights.Length / 3 * 2;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float[] vertices;  				if (!valueMap.ContainsKey ("vertices")) {  					if (attachment is MeshAttachment)  						vertices = ((MeshAttachment)attachment).vertices;  					else  						vertices = new float[vertexCount];  				}  				else {  					var verticesValue = (List<Object>)valueMap ["vertices"];  					vertices = new float[vertexCount];  					int start = GetInt (valueMap' "offset"' 0);  					if (scale == 1) {  						for (int i = 0' n = verticesValue.Count; i < n; i++)  							vertices [i + start] = (float)verticesValue [i];  					}  					else {  						for (int i = 0' n = verticesValue.Count; i < n; i++)  							vertices [i + start] = (float)verticesValue [i] * scale;  					}  					if (attachment is MeshAttachment) {  						float[] meshVertices = ((MeshAttachment)attachment).vertices;  						for (int i = 0; i < vertexCount; i++)  							vertices [i] += meshVertices [i];  					}  				}  				timeline.setFrame (frameIndex' (float)valueMap ["time"]' vertices);  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> slotMap in (Dictionary<String' Object>)ffdMap.Value) {  	int slotIndex = skeletonData.FindSlotIndex (slotMap.Key);  	foreach (KeyValuePair<String' Object> meshMap in (Dictionary<String' Object>)slotMap.Value) {  		var values = (List<Object>)meshMap.Value;  		var timeline = new FFDTimeline (values.Count);  		Attachment attachment = skin.GetAttachment (slotIndex' meshMap.Key);  		if (attachment == null)  			throw new Exception ("FFD attachment not found: " + meshMap.Key);  		timeline.slotIndex = slotIndex;  		timeline.attachment = attachment;  		int vertexCount;  		if (attachment is MeshAttachment)  			vertexCount = ((MeshAttachment)attachment).vertices.Length;  		else  			vertexCount = ((SkinnedMeshAttachment)attachment).Weights.Length / 3 * 2;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float[] vertices;  			if (!valueMap.ContainsKey ("vertices")) {  				if (attachment is MeshAttachment)  					vertices = ((MeshAttachment)attachment).vertices;  				else  					vertices = new float[vertexCount];  			}  			else {  				var verticesValue = (List<Object>)valueMap ["vertices"];  				vertices = new float[vertexCount];  				int start = GetInt (valueMap' "offset"' 0);  				if (scale == 1) {  					for (int i = 0' n = verticesValue.Count; i < n; i++)  						vertices [i + start] = (float)verticesValue [i];  				}  				else {  					for (int i = 0' n = verticesValue.Count; i < n; i++)  						vertices [i + start] = (float)verticesValue [i] * scale;  				}  				if (attachment is MeshAttachment) {  					float[] meshVertices = ((MeshAttachment)attachment).vertices;  					for (int i = 0; i < vertexCount; i++)  						vertices [i] += meshVertices [i];  				}  			}  			timeline.setFrame (frameIndex' (float)valueMap ["time"]' vertices);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> slotMap in (Dictionary<String' Object>)ffdMap.Value) {  	int slotIndex = skeletonData.FindSlotIndex (slotMap.Key);  	foreach (KeyValuePair<String' Object> meshMap in (Dictionary<String' Object>)slotMap.Value) {  		var values = (List<Object>)meshMap.Value;  		var timeline = new FFDTimeline (values.Count);  		Attachment attachment = skin.GetAttachment (slotIndex' meshMap.Key);  		if (attachment == null)  			throw new Exception ("FFD attachment not found: " + meshMap.Key);  		timeline.slotIndex = slotIndex;  		timeline.attachment = attachment;  		int vertexCount;  		if (attachment is MeshAttachment)  			vertexCount = ((MeshAttachment)attachment).vertices.Length;  		else  			vertexCount = ((SkinnedMeshAttachment)attachment).Weights.Length / 3 * 2;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float[] vertices;  			if (!valueMap.ContainsKey ("vertices")) {  				if (attachment is MeshAttachment)  					vertices = ((MeshAttachment)attachment).vertices;  				else  					vertices = new float[vertexCount];  			}  			else {  				var verticesValue = (List<Object>)valueMap ["vertices"];  				vertices = new float[vertexCount];  				int start = GetInt (valueMap' "offset"' 0);  				if (scale == 1) {  					for (int i = 0' n = verticesValue.Count; i < n; i++)  						vertices [i + start] = (float)verticesValue [i];  				}  				else {  					for (int i = 0' n = verticesValue.Count; i < n; i++)  						vertices [i + start] = (float)verticesValue [i] * scale;  				}  				if (attachment is MeshAttachment) {  					float[] meshVertices = ((MeshAttachment)attachment).vertices;  					for (int i = 0; i < vertexCount; i++)  						vertices [i] += meshVertices [i];  				}  			}  			timeline.setFrame (frameIndex' (float)valueMap ["time"]' vertices);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> meshMap in (Dictionary<String' Object>)slotMap.Value) {  	var values = (List<Object>)meshMap.Value;  	var timeline = new FFDTimeline (values.Count);  	Attachment attachment = skin.GetAttachment (slotIndex' meshMap.Key);  	if (attachment == null)  		throw new Exception ("FFD attachment not found: " + meshMap.Key);  	timeline.slotIndex = slotIndex;  	timeline.attachment = attachment;  	int vertexCount;  	if (attachment is MeshAttachment)  		vertexCount = ((MeshAttachment)attachment).vertices.Length;  	else  		vertexCount = ((SkinnedMeshAttachment)attachment).Weights.Length / 3 * 2;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float[] vertices;  		if (!valueMap.ContainsKey ("vertices")) {  			if (attachment is MeshAttachment)  				vertices = ((MeshAttachment)attachment).vertices;  			else  				vertices = new float[vertexCount];  		}  		else {  			var verticesValue = (List<Object>)valueMap ["vertices"];  			vertices = new float[vertexCount];  			int start = GetInt (valueMap' "offset"' 0);  			if (scale == 1) {  				for (int i = 0' n = verticesValue.Count; i < n; i++)  					vertices [i + start] = (float)verticesValue [i];  			}  			else {  				for (int i = 0' n = verticesValue.Count; i < n; i++)  					vertices [i + start] = (float)verticesValue [i] * scale;  			}  			if (attachment is MeshAttachment) {  				float[] meshVertices = ((MeshAttachment)attachment).vertices;  				for (int i = 0; i < vertexCount; i++)  					vertices [i] += meshVertices [i];  			}  		}  		timeline.setFrame (frameIndex' (float)valueMap ["time"]' vertices);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> meshMap in (Dictionary<String' Object>)slotMap.Value) {  	var values = (List<Object>)meshMap.Value;  	var timeline = new FFDTimeline (values.Count);  	Attachment attachment = skin.GetAttachment (slotIndex' meshMap.Key);  	if (attachment == null)  		throw new Exception ("FFD attachment not found: " + meshMap.Key);  	timeline.slotIndex = slotIndex;  	timeline.attachment = attachment;  	int vertexCount;  	if (attachment is MeshAttachment)  		vertexCount = ((MeshAttachment)attachment).vertices.Length;  	else  		vertexCount = ((SkinnedMeshAttachment)attachment).Weights.Length / 3 * 2;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float[] vertices;  		if (!valueMap.ContainsKey ("vertices")) {  			if (attachment is MeshAttachment)  				vertices = ((MeshAttachment)attachment).vertices;  			else  				vertices = new float[vertexCount];  		}  		else {  			var verticesValue = (List<Object>)valueMap ["vertices"];  			vertices = new float[vertexCount];  			int start = GetInt (valueMap' "offset"' 0);  			if (scale == 1) {  				for (int i = 0' n = verticesValue.Count; i < n; i++)  					vertices [i + start] = (float)verticesValue [i];  			}  			else {  				for (int i = 0' n = verticesValue.Count; i < n; i++)  					vertices [i + start] = (float)verticesValue [i] * scale;  			}  			if (attachment is MeshAttachment) {  				float[] meshVertices = ((MeshAttachment)attachment).vertices;  				for (int i = 0; i < vertexCount; i++)  					vertices [i] += meshVertices [i];  			}  		}  		timeline.setFrame (frameIndex' (float)valueMap ["time"]' vertices);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (attachment is MeshAttachment)  	vertexCount = ((MeshAttachment)attachment).vertices.Length;  else  	vertexCount = ((SkinnedMeshAttachment)attachment).Weights.Length / 3 * 2;  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (attachment is MeshAttachment)  	vertexCount = ((MeshAttachment)attachment).vertices.Length;  else  	vertexCount = ((SkinnedMeshAttachment)attachment).Weights.Length / 3 * 2;  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: vertexCount = ((SkinnedMeshAttachment)attachment).Weights.Length / 3 * 2;  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: vertexCount = ((SkinnedMeshAttachment)attachment).Weights.Length / 3 * 2;  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadCurve,The following statement contains a magic number: if (curveObject.Equals ("stepped"))  	timeline.SetStepped (frameIndex);  else if (curveObject is List<Object>) {  	var curve = (List<Object>)curveObject;  	timeline.SetCurve (frameIndex' (float)curve [0]' (float)curve [1]' (float)curve [2]' (float)curve [3]);  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadCurve,The following statement contains a magic number: if (curveObject.Equals ("stepped"))  	timeline.SetStepped (frameIndex);  else if (curveObject is List<Object>) {  	var curve = (List<Object>)curveObject;  	timeline.SetCurve (frameIndex' (float)curve [0]' (float)curve [1]' (float)curve [2]' (float)curve [3]);  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadCurve,The following statement contains a magic number: if (curveObject is List<Object>) {  	var curve = (List<Object>)curveObject;  	timeline.SetCurve (frameIndex' (float)curve [0]' (float)curve [1]' (float)curve [2]' (float)curve [3]);  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadCurve,The following statement contains a magic number: if (curveObject is List<Object>) {  	var curve = (List<Object>)curveObject;  	timeline.SetCurve (frameIndex' (float)curve [0]' (float)curve [1]' (float)curve [2]' (float)curve [3]);  }  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadCurve,The following statement contains a magic number: timeline.SetCurve (frameIndex' (float)curve [0]' (float)curve [1]' (float)curve [2]' (float)curve [3]);  
Magic Number,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadCurve,The following statement contains a magic number: timeline.SetCurve (frameIndex' (float)curve [0]' (float)curve [1]' (float)curve [2]' (float)curve [3]);  
Missing Default,HutongGames.PlayMaker.Actions,PhotonNetworkGetConnectionState,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\Photon Unity Networking\PlayMaker\Actions\PhotonNetworkGetConnectionState.cs,DoPhotonNetworkStateSwitch,The following switch statement is missing a default case: switch (PhotonNetwork.connectionState) {  case ConnectionState.Connected:  	Fsm.Event (isConnectedEvent);  	break;  case ConnectionState.Connecting:  	Fsm.Event (isConnectingEvent);  	break;  case ConnectionState.Disconnected:  	Fsm.Event (isDisconnectingEvent);  	break;  case ConnectionState.Disconnecting:  	Fsm.Event (isDisconnectingEvent);  	break;  case ConnectionState.InitializingApplication:  	Fsm.Event (isInitializingApplicationEvent);  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,PhotonViewRpcBroadcastFsmEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\Photon Unity Networking\PlayMaker\Actions\PhotonViewRpcBroadcastFsmEvent.cs,getPhotonTargets,The following switch statement is missing a default case: switch (_target) {  case "all":  	return PhotonTargets.All;  case "allbuffered":  	return PhotonTargets.AllBuffered;  case "masterclient":  	return PhotonTargets.MasterClient;  case "others":  	return PhotonTargets.Others;  case "othersbuffered":  	return PhotonTargets.OthersBuffered;  }  
Missing Default,HutongGames.PlayMaker.Actions,PhotonViewRpcBroadcastFsmEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\Photon Unity Networking\PlayMaker\Actions\PhotonViewRpcBroadcastFsmEvent.cs,ErrorCheck,The following switch statement is missing a default case: switch (_target) {  case "all":  	return "";  case "allbuffered":  	return "";  case "masterclient":  	return "";  case "others":  	return "";  case "othersbuffered":  	return "";  }  
Missing Default,HutongGames.PlayMaker.Actions,AnimateFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\AnimateFsmAction.cs,OnUpdate,The following switch statement is missing a default case: switch (calculations [k]) {  case Calculation.SetValue:  	if (!time.IsNone)  		resultFloats [k] = curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time);  	else  		resultFloats [k] = curves [k].Evaluate (currentTime);  	break;  case Calculation.AddToValue:  	if (!time.IsNone)  		resultFloats [k] = fromFloats [k] + curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time);  	else  		resultFloats [k] = fromFloats [k] + curves [k].Evaluate (currentTime);  	break;  case Calculation.SubtractFromValue:  	if (!time.IsNone)  		resultFloats [k] = fromFloats [k] - curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time);  	else  		resultFloats [k] = fromFloats [k] - curves [k].Evaluate (currentTime);  	break;  case Calculation.SubtractValueFromCurve:  	if (!time.IsNone)  		resultFloats [k] = curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) - fromFloats [k];  	else  		resultFloats [k] = curves [k].Evaluate (currentTime) - fromFloats [k];  	break;  case Calculation.MultiplyValue:  	if (!time.IsNone)  		resultFloats [k] = curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) * fromFloats [k];  	else  		resultFloats [k] = curves [k].Evaluate (currentTime) * fromFloats [k];  	break;  case Calculation.DivideValue:  	if (!time.IsNone)  		resultFloats [k] = curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) != 0f ? fromFloats [k] / curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) : float.MaxValue;  	else  		resultFloats [k] = curves [k].Evaluate (currentTime) != 0 ? fromFloats [k] / curves [k].Evaluate (currentTime) : float.MaxValue;  	break;  case Calculation.DivideCurveByValue:  	if (!time.IsNone)  		resultFloats [k] = fromFloats [k] != 0f ? curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) / fromFloats [k] : float.MaxValue;  	else  		resultFloats [k] = fromFloats [k] != 0 ? curves [k].Evaluate (currentTime) / fromFloats [k] : float.MaxValue;  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,CurveFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\CurveFsmAction.cs,OnUpdate,The following switch statement is missing a default case: switch (calculations [k]) {  case Calculation.AddToValue:  	if (!time.IsNone)  		resultFloats [k] = fromFloats [k] + (distances [k] * (currentTime / time.Value) + curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time));  	else  		resultFloats [k] = fromFloats [k] + (distances [k] * (currentTime / endTimes [k]) + curves [k].Evaluate (currentTime));  	break;  case Calculation.SubtractFromValue:  	if (!time.IsNone)  		resultFloats [k] = fromFloats [k] + (distances [k] * (currentTime / time.Value) - curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time));  	else  		resultFloats [k] = fromFloats [k] + (distances [k] * (currentTime / endTimes [k]) - curves [k].Evaluate (currentTime));  	break;  case Calculation.SubtractValueFromCurve:  	if (!time.IsNone)  		resultFloats [k] = (curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) - distances [k] * (currentTime / time.Value)) + fromFloats [k];  	else  		resultFloats [k] = (curves [k].Evaluate (currentTime) - distances [k] * (currentTime / endTimes [k])) + fromFloats [k];  	break;  case Calculation.MultiplyValue:  	if (!time.IsNone)  		resultFloats [k] = (curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) * distances [k] * (currentTime / time.Value)) + fromFloats [k];  	else  		resultFloats [k] = (curves [k].Evaluate (currentTime) * distances [k] * (currentTime / endTimes [k])) + fromFloats [k];  	break;  case Calculation.DivideValue:  	if (!time.IsNone)  		resultFloats [k] = curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) != 0f ? fromFloats [k] + (distances [k] * (currentTime / time.Value)) / curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) : float.MaxValue;  	else  		resultFloats [k] = curves [k].Evaluate (currentTime) != 0 ? fromFloats [k] + (distances [k] * (currentTime / endTimes [k])) / curves [k].Evaluate (currentTime) : float.MaxValue;  	break;  case Calculation.DivideCurveByValue:  	if (!time.IsNone)  		resultFloats [k] = fromFloats [k] != 0f ? curves [k].Evaluate ((currentTime / time.Value) * curves [k].keys [curves [k].length - 1].time) / (distances [k] * (currentTime / time.Value)) + fromFloats [k] : float.MaxValue;  	else  		resultFloats [k] = fromFloats [k] != 0 ? curves [k].Evaluate (currentTime) / (distances [k] * (currentTime / endTimes [k])) + fromFloats [k] : float.MaxValue;  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,EaseFsmAction,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\AnimateVariables\EaseFsmAction.cs,SetEasingFunction,The following switch statement is missing a default case: switch (easeType) {  case EaseType.easeInQuad:  	ease = new EasingFunction (easeInQuad);  	break;  case EaseType.easeOutQuad:  	ease = new EasingFunction (easeOutQuad);  	break;  case EaseType.easeInOutQuad:  	ease = new EasingFunction (easeInOutQuad);  	break;  case EaseType.easeInCubic:  	ease = new EasingFunction (easeInCubic);  	break;  case EaseType.easeOutCubic:  	ease = new EasingFunction (easeOutCubic);  	break;  case EaseType.easeInOutCubic:  	ease = new EasingFunction (easeInOutCubic);  	break;  case EaseType.easeInQuart:  	ease = new EasingFunction (easeInQuart);  	break;  case EaseType.easeOutQuart:  	ease = new EasingFunction (easeOutQuart);  	break;  case EaseType.easeInOutQuart:  	ease = new EasingFunction (easeInOutQuart);  	break;  case EaseType.easeInQuint:  	ease = new EasingFunction (easeInQuint);  	break;  case EaseType.easeOutQuint:  	ease = new EasingFunction (easeOutQuint);  	break;  case EaseType.easeInOutQuint:  	ease = new EasingFunction (easeInOutQuint);  	break;  case EaseType.easeInSine:  	ease = new EasingFunction (easeInSine);  	break;  case EaseType.easeOutSine:  	ease = new EasingFunction (easeOutSine);  	break;  case EaseType.easeInOutSine:  	ease = new EasingFunction (easeInOutSine);  	break;  case EaseType.easeInExpo:  	ease = new EasingFunction (easeInExpo);  	break;  case EaseType.easeOutExpo:  	ease = new EasingFunction (easeOutExpo);  	break;  case EaseType.easeInOutExpo:  	ease = new EasingFunction (easeInOutExpo);  	break;  case EaseType.easeInCirc:  	ease = new EasingFunction (easeInCirc);  	break;  case EaseType.easeOutCirc:  	ease = new EasingFunction (easeOutCirc);  	break;  case EaseType.easeInOutCirc:  	ease = new EasingFunction (easeInOutCirc);  	break;  case EaseType.linear:  	ease = new EasingFunction (linear);  	break;  case EaseType.spring:  	ease = new EasingFunction (spring);  	break;  case EaseType.bounce:  	ease = new EasingFunction (bounce);  	break;  case EaseType.easeInBack:  	ease = new EasingFunction (easeInBack);  	break;  case EaseType.easeOutBack:  	ease = new EasingFunction (easeOutBack);  	break;  case EaseType.easeInOutBack:  	ease = new EasingFunction (easeInOutBack);  	break;  case EaseType.elastic:  	ease = new EasingFunction (elastic);  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,BoolOperator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\BoolOperator.cs,DoBoolOperator,The following switch statement is missing a default case: switch (operation) {  case Operation.AND:  	storeResult.Value = v1 && v2;  	break;  case Operation.NAND:  	storeResult.Value = !(v1 && v2);  	break;  case Operation.OR:  	storeResult.Value = v1 || v2;  	break;  case Operation.XOR:  	storeResult.Value = v1 ^ v2;  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,CollisionEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\CollisionEvent.cs,Awake,The following switch statement is missing a default case: switch (collision) {  case CollisionType.OnCollisionEnter:  	Fsm.HandleCollisionEnter = true;  	break;  case CollisionType.OnCollisionStay:  	Fsm.HandleCollisionStay = true;  	break;  case CollisionType.OnCollisionExit:  	Fsm.HandleCollisionExit = true;  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,ConvertFloatToInt,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\ConvertFloatToInt.cs,DoConvertFloatToInt,The following switch statement is missing a default case: switch (rounding) {  case FloatRounding.Nearest:  	intVariable.Value = Mathf.RoundToInt (floatVariable.Value);  	break;  case FloatRounding.RoundDown:  	intVariable.Value = Mathf.FloorToInt (floatVariable.Value);  	break;  case FloatRounding.RoundUp:  	intVariable.Value = Mathf.CeilToInt (floatVariable.Value);  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,FloatInterpolate,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\FloatInterpolate.cs,OnUpdate,The following switch statement is missing a default case: switch (mode) {  case InterpolationType.Linear:  	storeResult.Value = Mathf.Lerp (fromFloat.Value' toFloat.Value' lerpTime);  	break;  case InterpolationType.EaseInOut:  	storeResult.Value = Mathf.SmoothStep (fromFloat.Value' toFloat.Value' lerpTime);  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,FloatOperator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\FloatOperator.cs,DoFloatOperator,The following switch statement is missing a default case: switch (operation) {  case Operation.Add:  	storeResult.Value = v1 + v2;  	break;  case Operation.Subtract:  	storeResult.Value = v1 - v2;  	break;  case Operation.Multiply:  	storeResult.Value = v1 * v2;  	break;  case Operation.Divide:  	storeResult.Value = v1 / v2;  	break;  case Operation.Min:  	storeResult.Value = Mathf.Min (v1' v2);  	break;  case Operation.Max:  	storeResult.Value = Mathf.Max (v1' v2);  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,GetAxisVector,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GetAxisVector.cs,OnUpdate,The following switch statement is missing a default case: switch (mapToPlane) {  case AxisPlane.XZ:  	forward = Vector3.forward;  	right = Vector3.right;  	break;  case AxisPlane.XY:  	forward = Vector3.up;  	right = Vector3.right;  	break;  case AxisPlane.YZ:  	forward = Vector3.up;  	right = Vector3.forward;  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,GetAxisVector,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GetAxisVector.cs,OnUpdate,The following switch statement is missing a default case: switch (mapToPlane) {  case AxisPlane.XZ:  	forward = transform.TransformDirection (Vector3.forward);  	forward.y = 0;  	forward = forward.normalized;  	right = new Vector3 (forward.z' 0' -forward.x);  	break;  case AxisPlane.XY:  case AxisPlane.YZ:  	// NOTE: in relative mode XY ans YZ are the same!  	forward = Vector3.up;  	forward.z = 0;  	forward = forward.normalized;  	right = transform.TransformDirection (Vector3.right);  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,GetDeviceRoll,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GetDeviceRoll.cs,DoGetDeviceRoll,The following switch statement is missing a default case: switch (baseOrientation) {  case BaseOrientation.Portrait:  	zAngle = -Mathf.Atan2 (x' -y);  	break;  case BaseOrientation.LandscapeLeft:  	zAngle = Mathf.Atan2 (y' -x);  	break;  case BaseOrientation.LandscapeRight:  	zAngle = -Mathf.Atan2 (y' x);  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,GetVertexPosition,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\GetVertexPosition.cs,DoGetVertexPosition,The following switch statement is missing a default case: switch (space) {  case Space.World:  	var position = meshFilter.mesh.vertices [vertexIndex.Value];  	storePosition.Value = go.transform.TransformPoint (position);  	break;  case Space.Self:  	storePosition.Value = meshFilter.mesh.vertices [vertexIndex.Value];  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,IntOperator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\IntOperator.cs,DoIntOperator,The following switch statement is missing a default case: switch (operation) {  case Operation.Add:  	storeResult.Value = v1 + v2;  	break;  case Operation.Subtract:  	storeResult.Value = v1 - v2;  	break;  case Operation.Multiply:  	storeResult.Value = v1 * v2;  	break;  case Operation.Divide:  	storeResult.Value = v1 / v2;  	break;  case Operation.Min:  	storeResult.Value = Mathf.Min (v1' v2);  	break;  case Operation.Max:  	storeResult.Value = Mathf.Max (v1' v2);  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,MouseLook,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\MouseLook.cs,DoMouseLook,The following switch statement is missing a default case: switch (axes) {  case RotationAxes.MouseXAndY:  	transform.localEulerAngles = new Vector3 (GetYRotation ()' GetXRotation ()' 0);  	break;  case RotationAxes.MouseX:  	transform.localEulerAngles = new Vector3 (transform.localEulerAngles.x' GetXRotation ()' 0);  	break;  case RotationAxes.MouseY:  	transform.localEulerAngles = new Vector3 (-GetYRotation ()' transform.localEulerAngles.y' 0);  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,MouseLook2,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\MouseLook2.cs,DoMouseLook,The following switch statement is missing a default case: switch (axes) {  case RotationAxes.MouseXAndY:  	transform.localEulerAngles = new Vector3 (GetYRotation ()' GetXRotation ()' 0);  	break;  case RotationAxes.MouseX:  	transform.localEulerAngles = new Vector3 (transform.localEulerAngles.x' GetXRotation ()' 0);  	break;  case RotationAxes.MouseY:  	transform.localEulerAngles = new Vector3 (-GetYRotation ()' transform.localEulerAngles.y' 0);  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,NetworkGetNetworkDisconnectionInfos,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Network\NetworkGetNetworkDisconnectionInfo.cs,doGetNetworkDisconnectionInfo,The following switch statement is missing a default case: switch (_networkDisconnectionInfo) {  case NetworkDisconnection.Disconnected:  	if (disConnectedEvent != null) {  		Fsm.Event (disConnectedEvent);  	}  	break;  case NetworkDisconnection.LostConnection:  	if (lostConnectionEvent != null) {  		Fsm.Event (lostConnectionEvent);  	}  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,NetworkGetOnFailedToConnectProperties,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Network\NetworkGetNetworkErrorInfo.cs,doGetNetworkErrorInfo,The following switch statement is missing a default case: switch (_networkConnectionError) {  case NetworkConnectionError.NoError:  	if (NoErrorEvent != null) {  		Fsm.Event (NoErrorEvent);  	}  	break;  case NetworkConnectionError.RSAPublicKeyMismatch:  	if (RSAPublicKeyMismatchEvent != null) {  		Fsm.Event (RSAPublicKeyMismatchEvent);  	}  	break;  case NetworkConnectionError.InvalidPassword:  	if (InvalidPasswordEvent != null) {  		Fsm.Event (InvalidPasswordEvent);  	}  	break;  case NetworkConnectionError.ConnectionFailed:  	if (ConnectionFailedEvent != null) {  		Fsm.Event (ConnectionFailedEvent);  	}  	break;  case NetworkConnectionError.TooManyConnectedPlayers:  	if (TooManyConnectedPlayersEvent != null) {  		Fsm.Event (TooManyConnectedPlayersEvent);  	}  	break;  case NetworkConnectionError.ConnectionBanned:  	if (ConnectionBannedEvent != null) {  		Fsm.Event (ConnectionBannedEvent);  	}  	break;  case NetworkConnectionError.AlreadyConnectedToServer:  	if (AlreadyConnectedToServerEvent != null) {  		Fsm.Event (AlreadyConnectedToServerEvent);  	}  	break;  case NetworkConnectionError.AlreadyConnectedToAnotherServer:  	if (AlreadyConnectedToAnotherServerEvent != null) {  		Fsm.Event (AlreadyConnectedToAnotherServerEvent);  	}  	break;  case NetworkConnectionError.CreateSocketOrThreadFailure:  	if (CreateSocketOrThreadFailureEvent != null) {  		Fsm.Event (CreateSocketOrThreadFailureEvent);  	}  	break;  case NetworkConnectionError.IncorrectParameters:  	if (IncorrectParametersEvent != null) {  		Fsm.Event (IncorrectParametersEvent);  	}  	break;  case NetworkConnectionError.EmptyConnectTarget:  	if (EmptyConnectTargetEvent != null) {  		Fsm.Event (EmptyConnectTargetEvent);  	}  	break;  case NetworkConnectionError.InternalDirectConnectFailed:  	if (InternalDirectConnectFailedEvent != null) {  		Fsm.Event (InternalDirectConnectFailedEvent);  	}  	break;  case NetworkConnectionError.NATTargetNotConnected:  	if (NATTargetNotConnectedEvent != null) {  		Fsm.Event (NATTargetNotConnectedEvent);  	}  	break;  case NetworkConnectionError.NATTargetConnectionLost:  	if (NATTargetConnectionLostEvent != null) {  		Fsm.Event (NATTargetConnectionLostEvent);  	}  	break;  case NetworkConnectionError.NATPunchthroughFailed:  	if (NATPunchthroughFailedEvent != null) {  		Fsm.Event (NoErrorEvent);  	}  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,NetworkPeerTypeSwitch,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Network\NetworkPeerTypeSwitch.cs,DoNetworkPeerTypeSwitch,The following switch statement is missing a default case: switch (Network.peerType) {  case NetworkPeerType.Disconnected:  	Fsm.Event (isDisconnected);  	break;  case NetworkPeerType.Server:  	Fsm.Event (isServer);  	break;  case NetworkPeerType.Client:  	Fsm.Event (isClient);  	break;  case NetworkPeerType.Connecting:  	Fsm.Event (isConnecting);  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,ProjectLocationToMap,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\ProjectLocationToMap.cs,DoProjectGPSLocation,The following switch statement is missing a default case: switch (mapProjection) {  case MapProjection.EquidistantCylindrical:  	DoEquidistantCylindrical ();  	break;  case MapProjection.Mercator:  	DoMercatorProjection ();  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,SendMessage,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SendMessage.cs,DoSendMessage,The following switch statement is missing a default case: switch (functionCall.ParameterType) {  case "None":  	break;  case "bool":  	parameter = functionCall.BoolParameter.Value;  	break;  case "int":  	parameter = functionCall.IntParameter.Value;  	break;  case "float":  	parameter = functionCall.FloatParameter.Value;  	break;  case "string":  	parameter = functionCall.StringParameter.Value;  	break;  case "Vector2":  	parameter = functionCall.Vector2Parameter.Value;  	break;  case "Vector3":  	parameter = functionCall.Vector3Parameter.Value;  	break;  case "Rect":  	parameter = functionCall.RectParamater.Value;  	break;  case "GameObject":  	parameter = functionCall.GameObjectParameter.Value;  	break;  case "Material":  	parameter = functionCall.MaterialParameter.Value;  	break;  case "Texture":  	parameter = functionCall.TextureParameter.Value;  	break;  case "Color":  	parameter = functionCall.ColorParameter.Value;  	break;  case "Quaternion":  	parameter = functionCall.QuaternionParameter.Value;  	break;  case "Object":  	parameter = functionCall.ObjectParameter.Value;  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,SendMessage,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SendMessage.cs,DoSendMessage,The following switch statement is missing a default case: switch (delivery) {  case MessageType.SendMessage:  	go.SendMessage (functionCall.FunctionName' parameter' options);  	return;  case MessageType.SendMessageUpwards:  	go.SendMessageUpwards (functionCall.FunctionName' parameter' options);  	return;  case MessageType.BroadcastMessage:  	go.BroadcastMessage (functionCall.FunctionName' parameter' options);  	return;  }  
Missing Default,HutongGames.PlayMaker.Actions,StartCoroutine,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\StartCoroutine.cs,DoStartCoroutine,The following switch statement is missing a default case: switch (functionCall.ParameterType) {  case "None":  	component.StartCoroutine (functionCall.FunctionName);  	return;  case "int":  	component.StartCoroutine (functionCall.FunctionName' functionCall.IntParameter.Value);  	return;  case "float":  	component.StartCoroutine (functionCall.FunctionName' functionCall.FloatParameter.Value);  	return;  case "string":  	component.StartCoroutine (functionCall.FunctionName' functionCall.StringParameter.Value);  	return;  case "bool":  	component.StartCoroutine (functionCall.FunctionName' functionCall.BoolParameter.Value);  	return;  case "Vector2":  	component.StartCoroutine (functionCall.FunctionName' functionCall.Vector2Parameter.Value);  	return;  case "Vector3":  	component.StartCoroutine (functionCall.FunctionName' functionCall.Vector3Parameter.Value);  	return;  case "Rect":  	component.StartCoroutine (functionCall.FunctionName' functionCall.RectParamater.Value);  	return;  case "GameObject":  	component.StartCoroutine (functionCall.FunctionName' functionCall.GameObjectParameter.Value);  	return;  case "Material":  	component.StartCoroutine (functionCall.FunctionName' functionCall.MaterialParameter.Value);  	break;  case "Texture":  	component.StartCoroutine (functionCall.FunctionName' functionCall.TextureParameter.Value);  	break;  case "Quaternion":  	component.StartCoroutine (functionCall.FunctionName' functionCall.QuaternionParameter.Value);  	break;  case "Object":  	component.StartCoroutine (functionCall.FunctionName' functionCall.ObjectParameter.Value);  	return;  }  
Missing Default,HutongGames.PlayMaker.Actions,SwipeGestureEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\SwipeGestureEvent.cs,OnUpdate,The following switch statement is missing a default case: switch (touch.phase) {  case TouchPhase.Began:  	touchStarted = true;  	touchStartPos = touch.position;  	//touchStartTime = FsmTime.RealtimeSinceStartup;  	break;  case TouchPhase.Ended:  	if (touchStarted) {  		TestForSwipeGesture (touch);  		touchStarted = false;  	}  	break;  case TouchPhase.Canceled:  	touchStarted = false;  	break;  case TouchPhase.Stationary:  	/*					if (touchStarted) 					{ 						// don't want idle time to count towards swipe 						 						touchStartPos = touch.position; 						touchStartTime = FsmTime.RealtimeSinceStartup; 					}*/break;  case TouchPhase.Moved:  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,TouchGUIEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\TouchGUIEvent.cs,DoTouch,The following switch statement is missing a default case: switch (touch.phase) {  case TouchPhase.Began:  	Fsm.Event (touchBegan);  	return;  case TouchPhase.Moved:  	Fsm.Event (touchMoved);  	return;  case TouchPhase.Stationary:  	Fsm.Event (touchStationary);  	return;  case TouchPhase.Ended:  	Fsm.Event (touchEnded);  	return;  case TouchPhase.Canceled:  	Fsm.Event (touchCanceled);  	return;  }  
Missing Default,HutongGames.PlayMaker.Actions,TouchGUIEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\TouchGUIEvent.cs,DoTouchOffset,The following switch statement is missing a default case: switch (relativeTo) {  case OffsetOptions.TopLeft:  	offset.x = touchPos.x - guiRect.x;  	offset.y = touchPos.y - guiRect.y;  	break;  case OffsetOptions.Center:  	var center = new Vector3 (guiRect.x + guiRect.width * 0.5f' guiRect.y + guiRect.height * 0.5f' 0);  	offset = touchPos - center;  	break;  case OffsetOptions.TouchStart:  	offset = touchPos - touchStartPos;  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,TouchObjectEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\TouchObjectEvent.cs,OnUpdate,The following switch statement is missing a default case: switch (touch.phase) {  case TouchPhase.Began:  	Fsm.Event (touchBegan);  	return;  case TouchPhase.Moved:  	Fsm.Event (touchMoved);  	return;  case TouchPhase.Stationary:  	Fsm.Event (touchStationary);  	return;  case TouchPhase.Ended:  	Fsm.Event (touchEnded);  	return;  case TouchPhase.Canceled:  	Fsm.Event (touchCanceled);  	return;  }  
Missing Default,HutongGames.PlayMaker.Actions,TransformInputToWorldSpace,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\TransformInputToWorldSpace.cs,OnUpdate,The following switch statement is missing a default case: switch (mapToPlane) {  case AxisPlane.XZ:  	forward = Vector3.forward;  	right = Vector3.right;  	break;  case AxisPlane.XY:  	forward = Vector3.up;  	right = Vector3.right;  	break;  case AxisPlane.YZ:  	forward = Vector3.up;  	right = Vector3.forward;  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,TransformInputToWorldSpace,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\TransformInputToWorldSpace.cs,OnUpdate,The following switch statement is missing a default case: switch (mapToPlane) {  case AxisPlane.XZ:  	forward = transform.TransformDirection (Vector3.forward);  	forward.y = 0;  	forward = forward.normalized;  	right = new Vector3 (forward.z' 0' -forward.x);  	break;  case AxisPlane.XY:  case AxisPlane.YZ:  	// NOTE: in relative mode XY ans YZ are the same!  	forward = Vector3.up;  	forward.z = 0;  	forward = forward.normalized;  	right = transform.TransformDirection (Vector3.right);  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,TriggerEvent,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\TriggerEvent.cs,Awake,The following switch statement is missing a default case: switch (trigger) {  case TriggerType.OnTriggerEnter:  	Fsm.HandleTriggerEnter = true;  	break;  case TriggerType.OnTriggerStay:  	Fsm.HandleTriggerStay = true;  	break;  case TriggerType.OnTriggerExit:  	Fsm.HandleTriggerExit = true;  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,Vector3Interpolate,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Vector3Interpolate.cs,OnUpdate,The following switch statement is missing a default case: switch (mode) {  case InterpolationType.Linear:  	break;  case InterpolationType.EaseInOut:  	weight = Mathf.SmoothStep (0' 1' weight);  	break;  }  
Missing Default,HutongGames.PlayMaker.Actions,Vector3Operator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\PlayMaker\Actions\Vector3Operator.cs,DoVector3Operator,The following switch statement is missing a default case: switch (operation) {  case Vector3Operation.DotProduct:  	storeFloatResult.Value = Vector3.Dot (v1' v2);  	break;  case Vector3Operation.CrossProduct:  	storeVector3Result.Value = Vector3.Cross (v1' v2);  	break;  case Vector3Operation.Distance:  	storeFloatResult.Value = Vector3.Distance (v1' v2);  	break;  case Vector3Operation.Angle:  	storeFloatResult.Value = Vector3.Angle (v1' v2);  	break;  case Vector3Operation.Project:  	storeVector3Result.Value = Vector3.Project (v1' v2);  	break;  case Vector3Operation.Reflect:  	storeVector3Result.Value = Vector3.Reflect (v1' v2);  	break;  case Vector3Operation.Add:  	storeVector3Result.Value = v1 + v2;  	break;  case Vector3Operation.Subtract:  	storeVector3Result.Value = v1 - v2;  	break;  case Vector3Operation.Multiply:  	// I know... this is a far reach and not usefull in 99% of cases.   	// I do use it when I use vector3 as arrays recipients holding something else than a position in space.  	var multResult = Vector3.zero;  	multResult.x = v1.x * v2.x;  	multResult.y = v1.y * v2.y;  	multResult.z = v1.z * v2.z;  	storeVector3Result.Value = multResult;  	break;  case Vector3Operation.Divide:  	// I know... this is a far reach and not usefull in 99% of cases.  	// I do use it when I use vector3 as arrays recipients holding something else than a position in space.  	var divResult = Vector3.zero;  	divResult.x = v1.x / v2.x;  	divResult.y = v1.y / v2.y;  	divResult.z = v1.z / v2.z;  	storeVector3Result.Value = divResult;  	break;  case Vector3Operation.Min:  	storeVector3Result.Value = Vector3.Min (v1' v2);  	break;  case Vector3Operation.Max:  	storeVector3Result.Value = Vector3.Max (v1' v2);  	break;  }  
Missing Default,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following switch statement is missing a default case: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Missing Default,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following switch statement is missing a default case: switch (cmd) {  case 'i':  	break;  // ignore version field for now  case 'w':  	textureDimensions.x = Int32.Parse (line.Substring (2));  	break;  case 'h':  	textureDimensions.y = Int32.Parse (line.Substring (2));  	break;  // total number of sprites would be ideal to statically allocate  case '~':  	state++;  	break;  }  
Missing Default,tk2dRuntime,SpriteCollectionGenerator,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following switch statement is missing a default case: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Missing Default,Spine,IkConstraint,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\IkConstraint.cs,apply,The following switch statement is missing a default case: switch (bones.Count) {  case 1:  	apply (bones [0]' target.worldX' target.worldY' mix);  	break;  case 2:  	apply (bones [0]' bones [1]' target.worldX' target.worldY' bendDirection' mix);  	break;  }  
Missing Default,Spine,SkeletonJson,C:\repos\fox1989_UnityTest\NGUI Tabs\Assets\plug-in\spine-csharp\SkeletonJson.cs,ReadAttachment,The following switch statement is missing a default case: switch (type) {  case AttachmentType.region:  	RegionAttachment region = attachmentLoader.NewRegionAttachment (skin' name' path);  	if (region == null)  		return null;  	region.Path = path;  	region.x = GetFloat (map' "x"' 0) * Scale;  	region.y = GetFloat (map' "y"' 0) * Scale;  	region.scaleX = GetFloat (map' "scaleX"' 1);  	region.scaleY = GetFloat (map' "scaleY"' 1);  	region.rotation = GetFloat (map' "rotation"' 0);  	region.width = GetFloat (map' "width"' 32) * Scale;  	region.height = GetFloat (map' "height"' 32) * Scale;  	region.UpdateOffset ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		region.r = ToColor (color' 0);  		region.g = ToColor (color' 1);  		region.b = ToColor (color' 2);  		region.a = ToColor (color' 3);  	}  	return region;  case AttachmentType.mesh: {  	MeshAttachment mesh = attachmentLoader.NewMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	mesh.vertices = GetFloatArray (map' "vertices"' Scale);  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = GetFloatArray (map' "uvs"' 1);  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.skinnedmesh: {  	SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment (skin' name' path);  	if (mesh == null)  		return null;  	mesh.Path = path;  	float[] uvs = GetFloatArray (map' "uvs"' 1);  	float[] vertices = GetFloatArray (map' "vertices"' 1);  	var weights = new List<float> (uvs.Length * 3 * 3);  	var bones = new List<int> (uvs.Length * 3);  	float scale = Scale;  	for (int i = 0' n = vertices.Length; i < n;) {  		int boneCount = (int)vertices [i++];  		bones.Add (boneCount);  		for (int nn = i + boneCount * 4; i < nn;) {  			bones.Add ((int)vertices [i]);  			weights.Add (vertices [i + 1] * scale);  			weights.Add (vertices [i + 2] * scale);  			weights.Add (vertices [i + 3]);  			i += 4;  		}  	}  	mesh.bones = bones.ToArray ();  	mesh.weights = weights.ToArray ();  	mesh.triangles = GetIntArray (map' "triangles");  	mesh.regionUVs = uvs;  	mesh.UpdateUVs ();  	if (map.ContainsKey ("color")) {  		var color = (String)map ["color"];  		mesh.r = ToColor (color' 0);  		mesh.g = ToColor (color' 1);  		mesh.b = ToColor (color' 2);  		mesh.a = ToColor (color' 3);  	}  	mesh.HullLength = GetInt (map' "hull"' 0) * 2;  	if (map.ContainsKey ("edges"))  		mesh.Edges = GetIntArray (map' "edges");  	mesh.Width = GetInt (map' "width"' 0) * Scale;  	mesh.Height = GetInt (map' "height"' 0) * Scale;  	return mesh;  }  case AttachmentType.boundingbox:  	BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment (skin' name);  	if (box == null)  		return null;  	box.vertices = GetFloatArray (map' "vertices"' Scale);  	return box;  }  
