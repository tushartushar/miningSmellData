Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Etw,Program,C:\repos\MSOpenTech_Tx\Source\EtwEventTypeGen\Program.cs,Parse,The method has 166 lines of code.
Long Statement,Microsoft.Etw,Program,C:\repos\MSOpenTech_Tx\Source\EtwEventTypeGen\Program.cs,Parse,The length of the statement  "                                        new StreamWriter(Path.Combine(outputDirectory' Path.GetFileNameWithoutExtension(etlFile) + "_" + i.ToString() + ".man"))) " is 121.
Magic Number,Microsoft.Etw,Program,C:\repos\MSOpenTech_Tx\Source\EtwEventTypeGen\Program.cs,Parse,The following statement contains a magic number: foreach (string arg in args)              {                  string name = arg.Substring(0' 3);                  string value = arg.Substring(3);                    switch (name)                  {                      case "/a:":                          if (!String.IsNullOrEmpty(assembly))                          {                              Console.WriteLine("The assembly switch /a: occurs more than once.");                              Environment.Exit(1);                          }                          assembly = value;                          break;                        case "/o:":                          if (!String.IsNullOrEmpty(outputDirectory))                          {                              Console.WriteLine("The output directory switch /o: occurs more than once.");                              Environment.Exit(1);                          }                          outputDirectory = value;                          break;                        case "/m:":                          string[] manifests;                          string manifestDir = Path.GetDirectoryName(value);                          if (String.IsNullOrEmpty(manifestDir))                          {                              manifests = Directory.GetFiles("."' value);                          }                          else                          {                              manifests = Directory.GetFiles(                                  manifestDir'                                  Path.GetFileName(value));                          }                            foreach (string manifest in manifests)                          {                              string content = File.ReadAllText(manifest);                              Dictionary<string' string> code = ManifestParser.Parse(content);                                foreach (string provider in code.Keys)                              {                                  generated.Add(provider' code[provider]);                              }                          }                          break;                        case "/e:":                          string[] etlFiles;                          string etlDir = Path.GetDirectoryName(value);                          if (String.IsNullOrEmpty(etlDir))                          {                              etlFiles = Directory.GetFiles("."' value);                          }                          else                          {                              etlFiles = Directory.GetFiles(                                  etlDir'                                  Path.GetFileName(value));                          }                            foreach (string etlFile in etlFiles)                          {                              string[] etlManifests = ManifestParser.ExtractFromTrace(etlFile);                                if (etlManifests != null && etlManifests.Length > 0)                              {                                  int i = 0;                                  foreach (string content in etlManifests)                                  {                                      Dictionary<string' string> code = ManifestParser.Parse(content);                                        foreach (string provider in code.Keys)                                      {                                          generated.Add(provider' code[provider]);                                      }                                        // Write the manifest text file                                      using (TextWriter wr =                                          new StreamWriter(Path.Combine(outputDirectory' Path.GetFileNameWithoutExtension(etlFile) + "_" + i.ToString() + ".man")))                                      {                                          wr.Write(content);                                      }                                  }                              }                              else                              {                                  Console.WriteLine("No manifest found in file:{0}"' etlFile);                              }                          }                          break;                        case "/t:":                          string[] tmfs;                          string tmfDir = Path.GetDirectoryName(value);                          if (String.IsNullOrEmpty(tmfDir))                          {                              tmfs = Directory.GetFiles("."' value);                          }                          else                          {                              tmfs = Directory.GetFiles(                                  tmfDir'                                  Path.GetFileName(value));                          }                            foreach (string tmf in tmfs)                          {                              Console.WriteLine(tmf);                              string provider = Path.GetFileNameWithoutExtension(tmf);                              string code = TmfParser.Parse(tmf);                              generated.Add(provider' code);                          }                          break;                        case "/p:":                          string[] perfTraces;                          string perfDir = Path.GetDirectoryName(value);                          if (String.IsNullOrEmpty(perfDir))                          {                              perfTraces = Directory.GetFiles("."' value);                          }                          else                          {                              perfTraces = Directory.GetFiles(                                  perfDir'                                  Path.GetFileName(value));                          }                            foreach (string perfTrace in perfTraces)                          {                              Console.WriteLine(perfTrace);                              Dictionary<string' string> code = PerfCounterParser.Parse(perfTrace);                                foreach (string provider in code.Keys)                              {                                  generated.Add(provider' code[provider]);                              }                          }                          break;                        case "/w:":                          Console.WriteLine("The WMI switch /w: is not yet implemented.");                          Environment.Exit(2);                          break;                        default:                          Console.WriteLine("Unknown switch " + arg);                          Environment.Exit(1);                          break;                  }              }
Magic Number,Microsoft.Etw,Program,C:\repos\MSOpenTech_Tx\Source\EtwEventTypeGen\Program.cs,Parse,The following statement contains a magic number: foreach (string arg in args)              {                  string name = arg.Substring(0' 3);                  string value = arg.Substring(3);                    switch (name)                  {                      case "/a:":                          if (!String.IsNullOrEmpty(assembly))                          {                              Console.WriteLine("The assembly switch /a: occurs more than once.");                              Environment.Exit(1);                          }                          assembly = value;                          break;                        case "/o:":                          if (!String.IsNullOrEmpty(outputDirectory))                          {                              Console.WriteLine("The output directory switch /o: occurs more than once.");                              Environment.Exit(1);                          }                          outputDirectory = value;                          break;                        case "/m:":                          string[] manifests;                          string manifestDir = Path.GetDirectoryName(value);                          if (String.IsNullOrEmpty(manifestDir))                          {                              manifests = Directory.GetFiles("."' value);                          }                          else                          {                              manifests = Directory.GetFiles(                                  manifestDir'                                  Path.GetFileName(value));                          }                            foreach (string manifest in manifests)                          {                              string content = File.ReadAllText(manifest);                              Dictionary<string' string> code = ManifestParser.Parse(content);                                foreach (string provider in code.Keys)                              {                                  generated.Add(provider' code[provider]);                              }                          }                          break;                        case "/e:":                          string[] etlFiles;                          string etlDir = Path.GetDirectoryName(value);                          if (String.IsNullOrEmpty(etlDir))                          {                              etlFiles = Directory.GetFiles("."' value);                          }                          else                          {                              etlFiles = Directory.GetFiles(                                  etlDir'                                  Path.GetFileName(value));                          }                            foreach (string etlFile in etlFiles)                          {                              string[] etlManifests = ManifestParser.ExtractFromTrace(etlFile);                                if (etlManifests != null && etlManifests.Length > 0)                              {                                  int i = 0;                                  foreach (string content in etlManifests)                                  {                                      Dictionary<string' string> code = ManifestParser.Parse(content);                                        foreach (string provider in code.Keys)                                      {                                          generated.Add(provider' code[provider]);                                      }                                        // Write the manifest text file                                      using (TextWriter wr =                                          new StreamWriter(Path.Combine(outputDirectory' Path.GetFileNameWithoutExtension(etlFile) + "_" + i.ToString() + ".man")))                                      {                                          wr.Write(content);                                      }                                  }                              }                              else                              {                                  Console.WriteLine("No manifest found in file:{0}"' etlFile);                              }                          }                          break;                        case "/t:":                          string[] tmfs;                          string tmfDir = Path.GetDirectoryName(value);                          if (String.IsNullOrEmpty(tmfDir))                          {                              tmfs = Directory.GetFiles("."' value);                          }                          else                          {                              tmfs = Directory.GetFiles(                                  tmfDir'                                  Path.GetFileName(value));                          }                            foreach (string tmf in tmfs)                          {                              Console.WriteLine(tmf);                              string provider = Path.GetFileNameWithoutExtension(tmf);                              string code = TmfParser.Parse(tmf);                              generated.Add(provider' code);                          }                          break;                        case "/p:":                          string[] perfTraces;                          string perfDir = Path.GetDirectoryName(value);                          if (String.IsNullOrEmpty(perfDir))                          {                              perfTraces = Directory.GetFiles("."' value);                          }                          else                          {                              perfTraces = Directory.GetFiles(                                  perfDir'                                  Path.GetFileName(value));                          }                            foreach (string perfTrace in perfTraces)                          {                              Console.WriteLine(perfTrace);                              Dictionary<string' string> code = PerfCounterParser.Parse(perfTrace);                                foreach (string provider in code.Keys)                              {                                  generated.Add(provider' code[provider]);                              }                          }                          break;                        case "/w:":                          Console.WriteLine("The WMI switch /w: is not yet implemented.");                          Environment.Exit(2);                          break;                        default:                          Console.WriteLine("Unknown switch " + arg);                          Environment.Exit(1);                          break;                  }              }
Magic Number,Microsoft.Etw,Program,C:\repos\MSOpenTech_Tx\Source\EtwEventTypeGen\Program.cs,Parse,The following statement contains a magic number: foreach (string arg in args)              {                  string name = arg.Substring(0' 3);                  string value = arg.Substring(3);                    switch (name)                  {                      case "/a:":                          if (!String.IsNullOrEmpty(assembly))                          {                              Console.WriteLine("The assembly switch /a: occurs more than once.");                              Environment.Exit(1);                          }                          assembly = value;                          break;                        case "/o:":                          if (!String.IsNullOrEmpty(outputDirectory))                          {                              Console.WriteLine("The output directory switch /o: occurs more than once.");                              Environment.Exit(1);                          }                          outputDirectory = value;                          break;                        case "/m:":                          string[] manifests;                          string manifestDir = Path.GetDirectoryName(value);                          if (String.IsNullOrEmpty(manifestDir))                          {                              manifests = Directory.GetFiles("."' value);                          }                          else                          {                              manifests = Directory.GetFiles(                                  manifestDir'                                  Path.GetFileName(value));                          }                            foreach (string manifest in manifests)                          {                              string content = File.ReadAllText(manifest);                              Dictionary<string' string> code = ManifestParser.Parse(content);                                foreach (string provider in code.Keys)                              {                                  generated.Add(provider' code[provider]);                              }                          }                          break;                        case "/e:":                          string[] etlFiles;                          string etlDir = Path.GetDirectoryName(value);                          if (String.IsNullOrEmpty(etlDir))                          {                              etlFiles = Directory.GetFiles("."' value);                          }                          else                          {                              etlFiles = Directory.GetFiles(                                  etlDir'                                  Path.GetFileName(value));                          }                            foreach (string etlFile in etlFiles)                          {                              string[] etlManifests = ManifestParser.ExtractFromTrace(etlFile);                                if (etlManifests != null && etlManifests.Length > 0)                              {                                  int i = 0;                                  foreach (string content in etlManifests)                                  {                                      Dictionary<string' string> code = ManifestParser.Parse(content);                                        foreach (string provider in code.Keys)                                      {                                          generated.Add(provider' code[provider]);                                      }                                        // Write the manifest text file                                      using (TextWriter wr =                                          new StreamWriter(Path.Combine(outputDirectory' Path.GetFileNameWithoutExtension(etlFile) + "_" + i.ToString() + ".man")))                                      {                                          wr.Write(content);                                      }                                  }                              }                              else                              {                                  Console.WriteLine("No manifest found in file:{0}"' etlFile);                              }                          }                          break;                        case "/t:":                          string[] tmfs;                          string tmfDir = Path.GetDirectoryName(value);                          if (String.IsNullOrEmpty(tmfDir))                          {                              tmfs = Directory.GetFiles("."' value);                          }                          else                          {                              tmfs = Directory.GetFiles(                                  tmfDir'                                  Path.GetFileName(value));                          }                            foreach (string tmf in tmfs)                          {                              Console.WriteLine(tmf);                              string provider = Path.GetFileNameWithoutExtension(tmf);                              string code = TmfParser.Parse(tmf);                              generated.Add(provider' code);                          }                          break;                        case "/p:":                          string[] perfTraces;                          string perfDir = Path.GetDirectoryName(value);                          if (String.IsNullOrEmpty(perfDir))                          {                              perfTraces = Directory.GetFiles("."' value);                          }                          else                          {                              perfTraces = Directory.GetFiles(                                  perfDir'                                  Path.GetFileName(value));                          }                            foreach (string perfTrace in perfTraces)                          {                              Console.WriteLine(perfTrace);                              Dictionary<string' string> code = PerfCounterParser.Parse(perfTrace);                                foreach (string provider in code.Keys)                              {                                  generated.Add(provider' code[provider]);                              }                          }                          break;                        case "/w:":                          Console.WriteLine("The WMI switch /w: is not yet implemented.");                          Environment.Exit(2);                          break;                        default:                          Console.WriteLine("Unknown switch " + arg);                          Environment.Exit(1);                          break;                  }              }
