Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,WriteManifest,Cyclomatic complexity of the method is 8
Long Parameter List,Tx.Bond,BinaryEtwObservable,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEtwObservable.cs,FromFiles,The method has 5 parameters. Parameters: providerId' useSequentialReader' startTime' endTime' files
Long Parameter List,Tx.Bond,BinaryEtwObservable,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEtwObservable.cs,BinaryManifestFromFiles,The method has 5 parameters. Parameters: providerId' useSequentialReader' startTime' endTime' files
Long Parameter List,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,Write,The method has 6 parameters. Parameters: occurenceTime' receiveTime' protocol' source' eventData' manifestId
Long Parameter List,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,WriteManifest,The method has 6 parameters. Parameters: occurenceTime' receiveTime' protocol' source' manifestId' manifestData
Long Parameter List,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,WriteManifestInternal,The method has 6 parameters. Parameters: occurenceTime' receiveTime' inputProtocol' source' manifestId' manifestData
Long Parameter List,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,WriteInternal,The method has 6 parameters. Parameters: occurenceTime' receiveTime' inputProtocol' source' manifestId' eventPayload
Long Parameter List,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,WriteBinaryPayload,The method has 7 parameters. Parameters: occurenceFileTimeUtc' receiveFileTimeUtc' inputProtocol' source' manifestId' eventPayloadLength' eventPayload
Long Parameter List,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,WriteChunkedBinaryPayload,The method has 10 parameters. Parameters: packageId' occurenceFileTimeUtc' receiveFileTimeUtc' inputProtocol' source' manifestId' chunkCount' currentChunkNumber' payloadLength' payload
Long Parameter List,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,WriteManifestPayload,The method has 6 parameters. Parameters: occurenceFileTimeUtc' receiveFileTimeUtc' inputProtocol' source' manifestId' manifestPayload
Long Parameter List,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,WriteChunkedManifestPayload,The method has 9 parameters. Parameters: packageId' occurenceFileTimeUtc' receiveFileTimeUtc' inputProtocol' source' manifestId' chunkCount' currentChunkNumber' manifestPayload
Long Identifier,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,,The length of the parameter writeChuckedBinaryPayloadGuard is 30.
Long Identifier,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,,The length of the parameter writeChuckedManifestPayloadGuard is 32.
Long Identifier,Tx.Bond,BinaryEtwParser,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\Internal\BinaryEtwParser.cs,,The length of the parameter EtwBinaryEventManifestProviderId is 32.
Long Statement,Tx.Bond,BondCompactBinaryWriter<T>,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BondCompactBinaryTransformBuilder.cs,Transform,The length of the statement  "                var envelope = new Envelope(now' now' this.protocol' null' this.manifestId' this.outputBuffer.Data.ToByteArray()' null); " is 120.
Long Statement,Tx.Bond,BinaryEtwParser,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\Internal\BinaryEtwParser.cs,ParseV1,The length of the statement  "            uint eventPayloadLength = etwNativeEvent.ReadUInt32(); // There is a side-effect being used here with the binary length. " is 120.
Long Statement,Tx.Bond,BinaryEtwParser,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\Internal\BinaryEtwParser.cs,ParseV1,The length of the statement  "            etwNativeEvent.ReadInt32(); // EventSource based byte array writer actually stores the byte array length here. Skip 4 bytes to account for it. " is 142.
Long Statement,Tx.Bond,BinaryEtwParser,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\Internal\BinaryEtwParser.cs,ParseV2,The length of the statement  "            uint eventPayloadLength = etwNativeEvent.ReadUInt32(); // There is a side-effect being used here with the binary length. " is 120.
Empty Catch Block,Tx.Bond,TypeExtensions,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\Internal\TypeExtensions.cs,TryGetManifestData,The method has an empty catch block.
Magic Number,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,WriteManifestInternal,The following statement contains a magic number: var maxPayloadSize = (MaxPayloadSize / 2) - (manifestId.Length + source.Length + inputProtocol.Length) * 2;
Magic Number,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,WriteManifestInternal,The following statement contains a magic number: var maxPayloadSize = (MaxPayloadSize / 2) - (manifestId.Length + source.Length + inputProtocol.Length) * 2;
Magic Number,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,WriteManifestInternal,The following statement contains a magic number: if (manifestData.Length <= maxPayloadSize)              {                  this.WriteManifestPayload(                      occurenceFileTimeUtc'                      receiveFileTimeUtc'                      inputProtocol'                      source'                      manifestId'                      manifestData);              }              else              {                  // User data for chunked event is 12 bytes greather than non-chunked event                  maxPayloadSize -= 12;                    List<string> chunks = new List<string>(manifestData.WholeChunks(maxPayloadSize));                    lock (this.writeChuckedManifestPayloadGuard)                  {                      var packageId = unchecked(this.currentManifestPackageId++);                      int i = 0;                        foreach (string chunk in chunks)                      {                          this.WriteChunkedManifestPayload(                              packageId'                              occurenceFileTimeUtc'                              receiveFileTimeUtc'                              inputProtocol'                              source'                              manifestId'                              chunks.Count'                              i++'                              chunk);                      }                  }              }
Magic Number,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,WriteInternal,The following statement contains a magic number: var maxPayloadSize = MaxPayloadSize - (typeId.Length + source.Length + protocol.Length) * 2;
Magic Number,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,WriteInternal,The following statement contains a magic number: if (envelope.Payload.Length <= maxPayloadSize)              {                  this.WriteBinaryPayload(                      occurenceFileTimeUtc'                      receiveFileTimeUtc'                      protocol'                      source'                      typeId'                      unchecked((uint)(envelope.Payload.Length))'                      envelope.Payload);              }              else              {                  // User data for chunked event is 12 bytes greather than non-chunked event                  maxPayloadSize -= 12;                    var chunks = envelope.Payload.Split(maxPayloadSize);                    lock (this.writeChuckedBinaryPayloadGuard)                  {                      var packageId = unchecked(this.currentPackageId++);                        for (uint i = 0; i < chunks.Length; i++)                      {                          this.WriteChunkedBinaryPayload(                              packageId'                              occurenceFileTimeUtc'                              receiveFileTimeUtc'                              protocol'                              source'                              typeId'                              unchecked((uint)(chunks.Length))'                              i'                              unchecked((uint)(chunks[i].Length))'                              chunks[i]);                      }                  }              }
Magic Number,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,WriteInternal,The following statement contains a magic number: var maxPayloadSize = MaxPayloadSize - (manifestId.Length + source.Length + inputProtocol.Length) * 2;
Magic Number,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,WriteInternal,The following statement contains a magic number: if (eventPayload.Length <= maxPayloadSize)              {                  this.WriteBinaryPayload(                      occurenceFileTimeUtc'                      receiveFileTimeUtc'                      inputProtocol'                      source'                      manifestId'                      unchecked((uint)(eventPayload.Length))'                      eventPayload);              }              else              {                  // User data for chunked event is 12 bytes greather than non-chunked event                  maxPayloadSize -= 12;                    var chunks = eventPayload.Split(maxPayloadSize);                    lock (this.writeChuckedBinaryPayloadGuard)                  {                      var packageId = unchecked(this.currentPackageId++);                        for (uint i = 0; i < chunks.Length; i++)                      {                          this.WriteChunkedBinaryPayload(                              packageId'                              occurenceFileTimeUtc'                              receiveFileTimeUtc'                              inputProtocol'                              source'                              manifestId'                              unchecked((uint)(chunks.Length))'                              i'                              unchecked((uint)(chunks[i].Length))'                              chunks[i]);                      }                  }              }
Magic Number,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,WriteChunkedBinaryPayload,The following statement contains a magic number: this.WriteEvent(                  2'                  packageId'                  occurenceFileTimeUtc'                  receiveFileTimeUtc'                  inputProtocol'                  source'                  manifestId'                  chunkCount'                  currentChunkNumber'                  payloadLength'                  payload);
Magic Number,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,WriteManifestPayload,The following statement contains a magic number: this.WriteEvent(                  3'                  occurenceFileTimeUtc'                  receiveFileTimeUtc'                  inputProtocol'                  source'                  manifestId'                  manifestPayload);
Magic Number,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,WriteChunkedManifestPayload,The following statement contains a magic number: this.WriteEvent(                  4'                  packageId'                  occurenceFileTimeUtc'                  receiveFileTimeUtc'                  inputProtocol'                  source'                  manifestId'                  chunkCount'                  currentChunkNumber'                  manifestPayload);
Magic Number,Tx.Bond,BinaryEventSource,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BinaryEventSource.cs,Error,The following statement contains a magic number: this.WriteEvent(5' error);
Magic Number,Tx.Bond,BondJsonEnvelopeTypeMap,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\BondJsonEnvelopeTypeMap.cs,BuildDeserializers,The following statement contains a magic number: if (outputType.IsBondStruct())              {                  var deserializer = new Deserializer<CompactBinaryReader<InputBuffer>>(outputType);                    deserializerMap.Add(Protocol.CompactBinaryV1' e => DeserializeCompactBinary(1' e' deserializer));                  deserializerMap.Add(Protocol.CompactBinaryV2' e => DeserializeCompactBinary(2' e' deserializer));              }
Magic Number,Tx.Bond,BinaryEtwParser,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\Internal\BinaryEtwParser.cs,Parse,The following statement contains a magic number: if (etwNativeEvent.ProviderId == this.etwProviderId)              {                  switch (etwNativeEvent.Id)                  {                      case 0:                          result = ParseV0(etwNativeEvent);                          break;                      case 1:                          result = ParseV1(etwNativeEvent);                          break;                      case 2:                          result = this.ParseV2(etwNativeEvent);                          break;                  }              }
Magic Number,Tx.Bond,BinaryEtwParser,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\Internal\BinaryEtwParser.cs,ParseManifest,The following statement contains a magic number: if (etwNativeEvent.ProviderId == this.etwProviderId)              {                  switch (etwNativeEvent.Id)                  {                      case 3:                          result = ParseRegularManifest(etwNativeEvent);                          break;                      case 4:                          result = this.ParseChunkedManifest(etwNativeEvent);                          break;                  }              }
Magic Number,Tx.Bond,BinaryEtwParser,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\Internal\BinaryEtwParser.cs,ParseManifest,The following statement contains a magic number: if (etwNativeEvent.ProviderId == this.etwProviderId)              {                  switch (etwNativeEvent.Id)                  {                      case 3:                          result = ParseRegularManifest(etwNativeEvent);                          break;                      case 4:                          result = this.ParseChunkedManifest(etwNativeEvent);                          break;                  }              }
Magic Number,Tx.Bond,BinaryEtwParser,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\Internal\BinaryEtwParser.cs,ParseV0,The following statement contains a magic number: if (isValid)              {                  source = etwNativeEvent.ReadUnicodeString();                  manifestId = etwNativeEvent.ReadUnicodeString();                  eventPayloadLength = etwNativeEvent.ReadUInt32(); // There is a side-effect being used here with the binary length.                                  // Payload overflow events also could be saved with event Id 0                  eventPayload = (eventPayloadLength < 65000) ? etwNativeEvent.ReadBytes() : new byte[0];              }              else              {                  protocol = string.Empty;                  source = string.Empty;                  manifestId = string.Empty;                  eventPayloadLength = 0;                  eventPayload = new byte[0];              }
Missing Default,Tx.Bond,BinaryEtwParser,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\Internal\BinaryEtwParser.cs,Parse,The following switch statement is missing a default case: switch (etwNativeEvent.Id)                  {                      case 0:                          result = ParseV0(etwNativeEvent);                          break;                      case 1:                          result = ParseV1(etwNativeEvent);                          break;                      case 2:                          result = this.ParseV2(etwNativeEvent);                          break;                  }
Missing Default,Tx.Bond,BinaryEtwParser,C:\repos\MSOpenTech_Tx\Source\Tx.Bond\Internal\BinaryEtwParser.cs,ParseManifest,The following switch statement is missing a default case: switch (etwNativeEvent.Id)                  {                      case 3:                          result = ParseRegularManifest(etwNativeEvent);                          break;                      case 4:                          result = this.ParseChunkedManifest(etwNativeEvent);                          break;                  }
