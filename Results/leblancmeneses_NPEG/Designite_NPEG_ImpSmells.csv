Implementation smell,Namespace,Class,File,Method,Description
Long Method,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,VisitLeave,The method has 81 lines of code.
Long Method,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,VisitLeave,The method has 69 lines of code.
Long Method,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The method has 150 lines of code.
Long Method,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The method has 230 lines of code.
Long Method,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mSuffix,The method has 68 lines of code.
Long Method,NPEG.GrammarInterpreter,LimitingRepetitionVariableLengthExpressionSolver,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\LimitingRepetitionVariableLengthExpressionSolver.cs,VisitLeave,The method has 61 lines of code.
Complex Method,NPEG.Algorithms,WriteRuleVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\Algorithms\WriteRuleVisitor.cs,VisitLeave,Cyclomatic complexity of the method is 8
Complex Method,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,Cyclomatic complexity of the method is 70
Complex Method,NPEG.GrammarInterpreter,LimitingRepetitionVariableLengthExpressionSolver,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\LimitingRepetitionVariableLengthExpressionSolver.cs,VisitEnter,Cyclomatic complexity of the method is 23
Complex Method,NPEG.GrammarInterpreter,LimitingRepetitionVariableLengthExpressionSolver,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\LimitingRepetitionVariableLengthExpressionSolver.cs,VisitLeave,Cyclomatic complexity of the method is 17
Long Statement,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,VisitLeave,The length of the statement  "				var varLengthSolver = new LimitingRepetitionVariableLengthExpressionSolver (varLengthIterator' iterator' variableValues); " is 121.
Long Statement,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,VisitLeave,The length of the statement  "				throw new ArgumentNullException ("Second constructor overload is required during instantiation.  astNodeFactory requires to be set with this parser implementation."); " is 166.
Long Statement,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,VisitLeave,The length of the statement  "					// Warn terminal does not consume and ast should not be created for it' yet it should return that it was successful match. " is 122.
Long Statement,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,VisitLeave,The length of the statement  "					// logic inside astnodereplacement is to create properties' business names' that internally check Children collection to mine data. " is 131.
Long Statement,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The length of the statement  "							if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) { " is 499.
Long Statement,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The length of the statement  "					throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32"); " is 124.
Long Statement,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The length of the statement  "			matchBytes = _xmlDisableBackReferencePop.Count <= 0 ? _xmlBackReferenceLookup [backreferencename].Pop () : _xmlBackReferenceLookup [backreferencename].Peek (); " is 159.
Long Statement,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The length of the statement  "				if (statement.Children [0].Children [0].Children.Any (child => child.Token.Name == "OptionalFlags") && statement.Children [0].Children [0].Children [1].Children.Any (child => child.Token.Name == "ReplaceBySingleChild")) { " is 221.
Long Statement,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The length of the statement  "				MatchText = Regex.Replace (Regex.Replace (node.Children [0].Token.ValueAsString (_inputIterator)' @"\\(?<quote>""|')"' @"${quote}")' @"\\\\"' @"\")' " is 148.
Long Statement,NPEG.GrammarInterpreter.AstNodes,PeGrammarAstNodeFactory,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\PeGrammarAstNodeFactory.cs,Create,The length of the statement  "	throw new ArgumentOutOfRangeException (String.Format ("PeGrammarAstNodeFactory does not define replacement node for: {0}"' original.Token.Name)); " is 145.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mDynamicBackReference,The length of the statement  "	}' new Sequence (new ZeroOrMore (mWhiteSpace ())' mLabel ()).Sequence (new ZeroOrMore (mWhiteSpace ()))).Sequence (new Optional (new Sequence (new Sequence (new Literal { " is 170.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mFATAL,The length of the statement  "	new Sequence (new Optional (mSpace ())' new CapturingGroup ("Message"' new OneOrMore (new Sequence (new NotPredicate (new Sequence (new Optional (mSpace ())' new Literal { " is 171.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mWARN,The length of the statement  "	new Sequence (new Optional (mSpace ())' new CapturingGroup ("Message"' new OneOrMore (new Sequence (new NotPredicate (new Sequence (new Optional (mSpace ())' new Literal { " is 171.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mCapturingGroup,The length of the statement  "	AExpression CG_Options = new CapturingGroup ("OptionalFlags"' new OneOrMore (new Sequence (new ZeroOrMore (mWhiteSpace ())' new PrioritizedChoice (CG_ReplaceBySingleChild' CG_ReplacementNode)).Sequence (new ZeroOrMore (mWhiteSpace ())))); " is 238.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mCapturingGroup,The length of the statement  "	}).Sequence (new ZeroOrMore (mSpace ())).Sequence (mLabel ()).Sequence (new Optional (CG_Options)).Sequence (new Sequence (new ZeroOrMore (mSpace ())' new Literal { " is 164.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mCapturingGroup,The length of the statement  "	})).Sequence (new ZeroOrMore (mWhiteSpace ())).Sequence (new RecursionCall ("ExpressionRoot")).Sequence (new ZeroOrMore (mWhiteSpace ())).Sequence (new Literal { " is 161.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mTerminalReference,The length of the statement  "	AExpression CG_Options = new CapturingGroup ("OptionalFlags"' new OneOrMore (new Sequence (new ZeroOrMore (mWhiteSpace ())' new PrioritizedChoice (CG_ReplaceBySingleChild' CG_ReplacementNode)).Sequence (new ZeroOrMore (mWhiteSpace ())))); " is 238.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mTerminalReference,The length of the statement  "	}).Sequence (new ZeroOrMore (mSpace ())).Sequence (mLabel ()).Sequence (new Optional (CG_Options)).Sequence (new Sequence (new ZeroOrMore (mSpace ())' new Literal { " is 164.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mGroup,The length of the statement  "	}' new ZeroOrMore (mWhiteSpace ()))' new RecursionCall ("ExpressionRoot")).Sequence (new ZeroOrMore (mWhiteSpace ())).Sequence (new Literal { " is 141.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mTerminal,The length of the statement  "	return new PrioritizedChoice (mAnyCharacter ()' mCharacterClass ()).Or (mCodePoint ()).Or (mFATAL ()).Or (mWARN ()).Or (mLiteral ()).Or (mDynamicBackReference ()).Or (mRecursionCall ()).Or (mCapturingGroup ()).Or (mGroup ()); " is 225.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mPrefix,The length of the statement  "	return new CapturingGroup ("Prefix"' new PrioritizedChoice (new CapturingGroup ("AndPredicate"' new Sequence (new Literal { " is 123.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mPrefix,The length of the statement  "	}' new ZeroOrMore (mSpace ())).Sequence (mTerminal ()))' new CapturingGroup ("NotPredicate"' new Sequence (new Literal { " is 120.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mSuffix,The length of the statement  "	}' new ZeroOrMore (mSpace ())).Sequence (new RecursionCall ("VariableLengthExpressionFunction")).Sequence (new ZeroOrMore (mSpace ())).Sequence (new Literal { " is 158.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mSuffix,The length of the statement  "	var product = new CapturingGroup ("PRODUCT"' new Sequence (new Sequence (value' new ZeroOrMore (mSpace ()))' new Sequence (new CapturingGroup ("SYMBOL"' new PrioritizedChoice (new Literal { " is 189.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mSuffix,The length of the statement  "	var sum = new CapturingGroup ("SUM"' new Sequence (new Sequence (product' new ZeroOrMore (mSpace ()))' new Sequence (new CapturingGroup ("SYMBOL"' new PrioritizedChoice (new Literal { " is 183.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mSuffix,The length of the statement  "	AExpression variableLengthExpression = new RecursionCreate ("VariableLengthExpressionFunction"' new CapturingGroup ("VariableLength"' new Sequence (new ZeroOrMore (mSpace ())' sum).Sequence (new ZeroOrMore (mSpace ())))); " is 221.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mSuffix,The length of the statement  "	return new CapturingGroup ("Suffix"' new PrioritizedChoice (new CapturingGroup ("ZeroOrMore"' new Sequence (mTerminal ()' new ZeroOrMore (mSpace ())).Sequence (new Literal { " is 173.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mSuffix,The length of the statement  "	}))).Or (new CapturingGroup ("Optional"' new Sequence (mTerminal ()' new ZeroOrMore (mSpace ())).Sequence (new Literal { " is 120.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mSuffix,The length of the statement  "	}))).Or (new CapturingGroup ("LimitingRepetition"' new Sequence (mTerminal ()' new ZeroOrMore (mSpace ())).Sequence (new Sequence (new Sequence (new Literal { " is 158.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mSuffix,The length of the statement  "	new CapturingGroup ("ATLEAST"' new Sequence (new Sequence (new ZeroOrMore (mSpace ())' new CapturingGroup ("Min"' new OneOrMore (new CharacterClass { " is 149.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mPrioritizedChoice,The length of the statement  "	return new CapturingGroup ("PrioritizedChoice"' new Sequence (mSequence ()' // Sequence consumes whitespace before / .. so no need to add it here again. " is 152.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mPrioritizedChoice,The length of the statement  "	}).Sequence (new ZeroOrMore (mWhiteSpace ())).Sequence (mSequence ()).Sequence (new ZeroOrMore (new Sequence (new ZeroOrMore (mWhiteSpace ())' new Literal { " is 156.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mStatement,The length of the statement  "	return new CapturingGroup ("Statement"' new Sequence (new CapturingGroup ("NodeDefinition"' new PrioritizedChoice (mLabel ()' mTerminalReference ()))' new Literal { " is 164.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mStatement,The length of the statement  "	}).Sequence (new ZeroOrMore (mWhiteSpace ())).Sequence (mExpressionRoot ()).Sequence (new ZeroOrMore (mWhiteSpace ())).Sequence (new Literal { " is 142.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,RootPegExpression,The length of the statement  "	return new CapturingGroup ("PEG"' new Sequence (new Sequence (new ZeroOrMore (mWhiteSpace ())' mStatement ()).Sequence (new ZeroOrMore (mWhiteSpace ())).Plus ()' new NotPredicate (new AnyCharacter ()))) { " is 204.
Long Statement,NPEG.GrammarInterpreter,LimitingRepetitionVariableLengthExpressionSolver,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\LimitingRepetitionVariableLengthExpressionSolver.cs,VisitEnter,The length of the statement  "		foreach (var b in _variableValues.First (x => x.Token.Name.Equals (key' StringComparison.InvariantCultureIgnoreCase)).Token.ValueAsBytes (_inputIterator).Reverse ()) { " is 167.
Long Statement,NPEG.GrammarInterpreter,LimitingRepetitionVariableLengthExpressionSolver,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\LimitingRepetitionVariableLengthExpressionSolver.cs,VisitLeave,The length of the statement  "		if (node.Token.ValueAsString (_userExpressionIterator).StartsWith ("cos"' StringComparison.InvariantCultureIgnoreCase)) { " is 121.
Long Statement,NPEG.GrammarInterpreter,LimitingRepetitionVariableLengthExpressionSolver,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\LimitingRepetitionVariableLengthExpressionSolver.cs,VisitLeave,The length of the statement  "		} else if (node.Token.ValueAsString (_userExpressionIterator).StartsWith ("sin"' StringComparison.InvariantCultureIgnoreCase)) { " is 128.
Complex Conditional,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The conditional expression  "((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)"  is complex.
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push (delegate (IInputIterator iterator) {  	return LogTerminal (expression' iterator' () => {  		if (matchtext.StartsWith ("#x")) {  			//hexadecimal evaluation  			String hexinput = matchtext.Substring (2);  			if (hexinput == String.Empty)  				throw new ArgumentException ("Hex value specified is empty.");  			if (hexinput.Length % 2 != 0)  				hexinput = "0" + hexinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = hexinput.Length / 2;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 2; j++) {  					// low nibble comparison  					Int32 nibbleOffset = 0;  					if (j == 0) {  						// high nibble comparison  						nibbleOffset = 4;  					}  					// j == 0 == high nibble  					// j == 1 == low nibble  					var tmp = (Byte)hexinput [i * 2 + j];  					if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  						tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  					} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  						tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Hex value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else if (matchtext.StartsWith ("#b")) {  			// binary evaluation  			String binaryinput = matchtext.Substring (2);  			if (binaryinput == String.Empty)  				throw new ArgumentException ("Binary value specified is empty.");  			if (binaryinput.Length % 8 != 0)  				binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  			// on incomplete byte boundaries shift right  			int total_compare_bytes = binaryinput.Length / 8;  			for (int i = 0; i < total_compare_bytes; i++) {  				if (iterator.Current () == -1)  					return false;  				var compareWith = (Byte)iterator.Current ();  				for (Int32 j = 0; j < 8; j++) {  					var tmp = (Byte)binaryinput [i * 8 + j];  					if (tmp == (Byte)'0') {  						tmp = 0x00;  					} else if (tmp == (Byte)'1') {  						tmp = 0x01;  					} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  						// don't care ignore nibble comparison  					} else {  						throw new ArgumentException ("Binary value specified contains invalid characters.");  					}  					if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  						Int32 bit2compare = 7 - j;  						if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  							return false;  						}  					}  				}  				iterator.Next ();  			}  		} else {  			// decimal codepoint evaluation  			String decimalinput = matchtext.Substring (1);  			if (decimalinput == String.Empty)  				throw new ArgumentException ("Decimal codepoint value specified is empty.");  			if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  				throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  			if (decimalinput.Length > 10)  				// 4'294'967'295  				throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  			UInt32 codepoint = UInt32.Parse (decimalinput);  			var c4 = (Byte)(codepoint >> 24);  			var c3 = (Byte)(codepoint >> 16);  			var c2 = (Byte)(codepoint >> 8);  			var c1 = (Byte)(codepoint);  			if (c4 != 0x00) {  				// consumes 4 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c4) {  					return false;  				}  				iterator.Next ();  			} else if (c3 != 0x00) {  				// consumes 3 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c3) {  					return false;  				}  				iterator.Next ();  			} else if (c2 != 0x00) {  				// consumes 2 bytes  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  				if (iterator.Current () == -1 || iterator.Current () != c2) {  					return false;  				}  				iterator.Next ();  			} else {  				// user must want to match null \0  				// (c1 != 0x00)  				// consumes 1 byte  				if (iterator.Current () == -1 || iterator.Current () != c1) {  					return false;  				}  				iterator.Next ();  			}  		}  		return true;  	});  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: return LogTerminal (expression' iterator' () => {  	if (matchtext.StartsWith ("#x")) {  		//hexadecimal evaluation  		String hexinput = matchtext.Substring (2);  		if (hexinput == String.Empty)  			throw new ArgumentException ("Hex value specified is empty.");  		if (hexinput.Length % 2 != 0)  			hexinput = "0" + hexinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = hexinput.Length / 2;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 2; j++) {  				// low nibble comparison  				Int32 nibbleOffset = 0;  				if (j == 0) {  					// high nibble comparison  					nibbleOffset = 4;  				}  				// j == 0 == high nibble  				// j == 1 == low nibble  				var tmp = (Byte)hexinput [i * 2 + j];  				if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  					tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  				} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  					tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Hex value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else if (matchtext.StartsWith ("#b")) {  		// binary evaluation  		String binaryinput = matchtext.Substring (2);  		if (binaryinput == String.Empty)  			throw new ArgumentException ("Binary value specified is empty.");  		if (binaryinput.Length % 8 != 0)  			binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  		// on incomplete byte boundaries shift right  		int total_compare_bytes = binaryinput.Length / 8;  		for (int i = 0; i < total_compare_bytes; i++) {  			if (iterator.Current () == -1)  				return false;  			var compareWith = (Byte)iterator.Current ();  			for (Int32 j = 0; j < 8; j++) {  				var tmp = (Byte)binaryinput [i * 8 + j];  				if (tmp == (Byte)'0') {  					tmp = 0x00;  				} else if (tmp == (Byte)'1') {  					tmp = 0x01;  				} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  					// don't care ignore nibble comparison  				} else {  					throw new ArgumentException ("Binary value specified contains invalid characters.");  				}  				if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  					Int32 bit2compare = 7 - j;  					if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  						return false;  					}  				}  			}  			iterator.Next ();  		}  	} else {  		// decimal codepoint evaluation  		String decimalinput = matchtext.Substring (1);  		if (decimalinput == String.Empty)  			throw new ArgumentException ("Decimal codepoint value specified is empty.");  		if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  			throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  		if (decimalinput.Length > 10)  			// 4'294'967'295  			throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  		UInt32 codepoint = UInt32.Parse (decimalinput);  		var c4 = (Byte)(codepoint >> 24);  		var c3 = (Byte)(codepoint >> 16);  		var c2 = (Byte)(codepoint >> 8);  		var c1 = (Byte)(codepoint);  		if (c4 != 0x00) {  			// consumes 4 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c4) {  				return false;  			}  			iterator.Next ();  		} else if (c3 != 0x00) {  			// consumes 3 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c3) {  				return false;  			}  			iterator.Next ();  		} else if (c2 != 0x00) {  			// consumes 2 bytes  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  			if (iterator.Current () == -1 || iterator.Current () != c2) {  				return false;  			}  			iterator.Next ();  		} else {  			// user must want to match null \0  			// (c1 != 0x00)  			// consumes 1 byte  			if (iterator.Current () == -1 || iterator.Current () != c1) {  				return false;  			}  			iterator.Next ();  		}  	}  	return true;  });  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#x")) {  	//hexadecimal evaluation  	String hexinput = matchtext.Substring (2);  	if (hexinput == String.Empty)  		throw new ArgumentException ("Hex value specified is empty.");  	if (hexinput.Length % 2 != 0)  		hexinput = "0" + hexinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = hexinput.Length / 2;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 2; j++) {  			// low nibble comparison  			Int32 nibbleOffset = 0;  			if (j == 0) {  				// high nibble comparison  				nibbleOffset = 4;  			}  			// j == 0 == high nibble  			// j == 1 == low nibble  			var tmp = (Byte)hexinput [i * 2 + j];  			if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  				tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  			} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  				tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Hex value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (hexinput.Length % 2 != 0)  	hexinput = "0" + hexinput;  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (int i = 0; i < total_compare_bytes; i++) {  	if (iterator.Current () == -1)  		return false;  	var compareWith = (Byte)iterator.Current ();  	for (Int32 j = 0; j < 2; j++) {  		// low nibble comparison  		Int32 nibbleOffset = 0;  		if (j == 0) {  			// high nibble comparison  			nibbleOffset = 4;  		}  		// j == 0 == high nibble  		// j == 1 == low nibble  		var tmp = (Byte)hexinput [i * 2 + j];  		if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  			tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  		} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  			// don't care ignore nibble comparison  		} else {  			throw new ArgumentException ("Hex value specified contains invalid characters.");  		}  		if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  			if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  				return false;  			}  		}  	}  	iterator.Next ();  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (int i = 0; i < total_compare_bytes; i++) {  	if (iterator.Current () == -1)  		return false;  	var compareWith = (Byte)iterator.Current ();  	for (Int32 j = 0; j < 2; j++) {  		// low nibble comparison  		Int32 nibbleOffset = 0;  		if (j == 0) {  			// high nibble comparison  			nibbleOffset = 4;  		}  		// j == 0 == high nibble  		// j == 1 == low nibble  		var tmp = (Byte)hexinput [i * 2 + j];  		if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  			tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  		} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  			// don't care ignore nibble comparison  		} else {  			throw new ArgumentException ("Hex value specified contains invalid characters.");  		}  		if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  			if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  				return false;  			}  		}  	}  	iterator.Next ();  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (int i = 0; i < total_compare_bytes; i++) {  	if (iterator.Current () == -1)  		return false;  	var compareWith = (Byte)iterator.Current ();  	for (Int32 j = 0; j < 2; j++) {  		// low nibble comparison  		Int32 nibbleOffset = 0;  		if (j == 0) {  			// high nibble comparison  			nibbleOffset = 4;  		}  		// j == 0 == high nibble  		// j == 1 == low nibble  		var tmp = (Byte)hexinput [i * 2 + j];  		if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  			tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  		} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  			// don't care ignore nibble comparison  		} else {  			throw new ArgumentException ("Hex value specified contains invalid characters.");  		}  		if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  			if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  				return false;  			}  		}  	}  	iterator.Next ();  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (int i = 0; i < total_compare_bytes; i++) {  	if (iterator.Current () == -1)  		return false;  	var compareWith = (Byte)iterator.Current ();  	for (Int32 j = 0; j < 2; j++) {  		// low nibble comparison  		Int32 nibbleOffset = 0;  		if (j == 0) {  			// high nibble comparison  			nibbleOffset = 4;  		}  		// j == 0 == high nibble  		// j == 1 == low nibble  		var tmp = (Byte)hexinput [i * 2 + j];  		if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  			tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  		} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  			// don't care ignore nibble comparison  		} else {  			throw new ArgumentException ("Hex value specified contains invalid characters.");  		}  		if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  			if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  				return false;  			}  		}  	}  	iterator.Next ();  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (int i = 0; i < total_compare_bytes; i++) {  	if (iterator.Current () == -1)  		return false;  	var compareWith = (Byte)iterator.Current ();  	for (Int32 j = 0; j < 2; j++) {  		// low nibble comparison  		Int32 nibbleOffset = 0;  		if (j == 0) {  			// high nibble comparison  			nibbleOffset = 4;  		}  		// j == 0 == high nibble  		// j == 1 == low nibble  		var tmp = (Byte)hexinput [i * 2 + j];  		if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  			tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  		} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  			// don't care ignore nibble comparison  		} else {  			throw new ArgumentException ("Hex value specified contains invalid characters.");  		}  		if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  			if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  				return false;  			}  		}  	}  	iterator.Next ();  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (int i = 0; i < total_compare_bytes; i++) {  	if (iterator.Current () == -1)  		return false;  	var compareWith = (Byte)iterator.Current ();  	for (Int32 j = 0; j < 2; j++) {  		// low nibble comparison  		Int32 nibbleOffset = 0;  		if (j == 0) {  			// high nibble comparison  			nibbleOffset = 4;  		}  		// j == 0 == high nibble  		// j == 1 == low nibble  		var tmp = (Byte)hexinput [i * 2 + j];  		if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  			tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  		} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  			// don't care ignore nibble comparison  		} else {  			throw new ArgumentException ("Hex value specified contains invalid characters.");  		}  		if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  			if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  				return false;  			}  		}  	}  	iterator.Next ();  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (int i = 0; i < total_compare_bytes; i++) {  	if (iterator.Current () == -1)  		return false;  	var compareWith = (Byte)iterator.Current ();  	for (Int32 j = 0; j < 2; j++) {  		// low nibble comparison  		Int32 nibbleOffset = 0;  		if (j == 0) {  			// high nibble comparison  			nibbleOffset = 4;  		}  		// j == 0 == high nibble  		// j == 1 == low nibble  		var tmp = (Byte)hexinput [i * 2 + j];  		if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  			tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  		} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  			// don't care ignore nibble comparison  		} else {  			throw new ArgumentException ("Hex value specified contains invalid characters.");  		}  		if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  			if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  				return false;  			}  		}  	}  	iterator.Next ();  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (int i = 0; i < total_compare_bytes; i++) {  	if (iterator.Current () == -1)  		return false;  	var compareWith = (Byte)iterator.Current ();  	for (Int32 j = 0; j < 2; j++) {  		// low nibble comparison  		Int32 nibbleOffset = 0;  		if (j == 0) {  			// high nibble comparison  			nibbleOffset = 4;  		}  		// j == 0 == high nibble  		// j == 1 == low nibble  		var tmp = (Byte)hexinput [i * 2 + j];  		if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  			tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  		} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  			// don't care ignore nibble comparison  		} else {  			throw new ArgumentException ("Hex value specified contains invalid characters.");  		}  		if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  			if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  				return false;  			}  		}  	}  	iterator.Next ();  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (int i = 0; i < total_compare_bytes; i++) {  	if (iterator.Current () == -1)  		return false;  	var compareWith = (Byte)iterator.Current ();  	for (Int32 j = 0; j < 2; j++) {  		// low nibble comparison  		Int32 nibbleOffset = 0;  		if (j == 0) {  			// high nibble comparison  			nibbleOffset = 4;  		}  		// j == 0 == high nibble  		// j == 1 == low nibble  		var tmp = (Byte)hexinput [i * 2 + j];  		if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  			tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  		} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  			// don't care ignore nibble comparison  		} else {  			throw new ArgumentException ("Hex value specified contains invalid characters.");  		}  		if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  			if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  				return false;  			}  		}  	}  	iterator.Next ();  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (int i = 0; i < total_compare_bytes; i++) {  	if (iterator.Current () == -1)  		return false;  	var compareWith = (Byte)iterator.Current ();  	for (Int32 j = 0; j < 2; j++) {  		// low nibble comparison  		Int32 nibbleOffset = 0;  		if (j == 0) {  			// high nibble comparison  			nibbleOffset = 4;  		}  		// j == 0 == high nibble  		// j == 1 == low nibble  		var tmp = (Byte)hexinput [i * 2 + j];  		if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  			tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  		} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  			// don't care ignore nibble comparison  		} else {  			throw new ArgumentException ("Hex value specified contains invalid characters.");  		}  		if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  			if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  				return false;  			}  		}  	}  	iterator.Next ();  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (int i = 0; i < total_compare_bytes; i++) {  	if (iterator.Current () == -1)  		return false;  	var compareWith = (Byte)iterator.Current ();  	for (Int32 j = 0; j < 2; j++) {  		// low nibble comparison  		Int32 nibbleOffset = 0;  		if (j == 0) {  			// high nibble comparison  			nibbleOffset = 4;  		}  		// j == 0 == high nibble  		// j == 1 == low nibble  		var tmp = (Byte)hexinput [i * 2 + j];  		if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  			tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  		} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  			// don't care ignore nibble comparison  		} else {  			throw new ArgumentException ("Hex value specified contains invalid characters.");  		}  		if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  			if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  				return false;  			}  		}  	}  	iterator.Next ();  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (int i = 0; i < total_compare_bytes; i++) {  	if (iterator.Current () == -1)  		return false;  	var compareWith = (Byte)iterator.Current ();  	for (Int32 j = 0; j < 2; j++) {  		// low nibble comparison  		Int32 nibbleOffset = 0;  		if (j == 0) {  			// high nibble comparison  			nibbleOffset = 4;  		}  		// j == 0 == high nibble  		// j == 1 == low nibble  		var tmp = (Byte)hexinput [i * 2 + j];  		if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  			tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  		} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  			// don't care ignore nibble comparison  		} else {  			throw new ArgumentException ("Hex value specified contains invalid characters.");  		}  		if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  			if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  				return false;  			}  		}  	}  	iterator.Next ();  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (int i = 0; i < total_compare_bytes; i++) {  	if (iterator.Current () == -1)  		return false;  	var compareWith = (Byte)iterator.Current ();  	for (Int32 j = 0; j < 2; j++) {  		// low nibble comparison  		Int32 nibbleOffset = 0;  		if (j == 0) {  			// high nibble comparison  			nibbleOffset = 4;  		}  		// j == 0 == high nibble  		// j == 1 == low nibble  		var tmp = (Byte)hexinput [i * 2 + j];  		if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  			tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  		} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  			tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  		} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  			// don't care ignore nibble comparison  		} else {  			throw new ArgumentException ("Hex value specified contains invalid characters.");  		}  		if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  			if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  				return false;  			}  		}  	}  	iterator.Next ();  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (Int32 j = 0; j < 2; j++) {  	// low nibble comparison  	Int32 nibbleOffset = 0;  	if (j == 0) {  		// high nibble comparison  		nibbleOffset = 4;  	}  	// j == 0 == high nibble  	// j == 1 == low nibble  	var tmp = (Byte)hexinput [i * 2 + j];  	if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  		tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  	} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  		// don't care ignore nibble comparison  	} else {  		throw new ArgumentException ("Hex value specified contains invalid characters.");  	}  	if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  		if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  			return false;  		}  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (Int32 j = 0; j < 2; j++) {  	// low nibble comparison  	Int32 nibbleOffset = 0;  	if (j == 0) {  		// high nibble comparison  		nibbleOffset = 4;  	}  	// j == 0 == high nibble  	// j == 1 == low nibble  	var tmp = (Byte)hexinput [i * 2 + j];  	if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  		tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  	} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  		// don't care ignore nibble comparison  	} else {  		throw new ArgumentException ("Hex value specified contains invalid characters.");  	}  	if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  		if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  			return false;  		}  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (Int32 j = 0; j < 2; j++) {  	// low nibble comparison  	Int32 nibbleOffset = 0;  	if (j == 0) {  		// high nibble comparison  		nibbleOffset = 4;  	}  	// j == 0 == high nibble  	// j == 1 == low nibble  	var tmp = (Byte)hexinput [i * 2 + j];  	if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  		tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  	} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  		// don't care ignore nibble comparison  	} else {  		throw new ArgumentException ("Hex value specified contains invalid characters.");  	}  	if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  		if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  			return false;  		}  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (Int32 j = 0; j < 2; j++) {  	// low nibble comparison  	Int32 nibbleOffset = 0;  	if (j == 0) {  		// high nibble comparison  		nibbleOffset = 4;  	}  	// j == 0 == high nibble  	// j == 1 == low nibble  	var tmp = (Byte)hexinput [i * 2 + j];  	if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  		tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  	} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  		// don't care ignore nibble comparison  	} else {  		throw new ArgumentException ("Hex value specified contains invalid characters.");  	}  	if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  		if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  			return false;  		}  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (Int32 j = 0; j < 2; j++) {  	// low nibble comparison  	Int32 nibbleOffset = 0;  	if (j == 0) {  		// high nibble comparison  		nibbleOffset = 4;  	}  	// j == 0 == high nibble  	// j == 1 == low nibble  	var tmp = (Byte)hexinput [i * 2 + j];  	if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  		tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  	} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  		// don't care ignore nibble comparison  	} else {  		throw new ArgumentException ("Hex value specified contains invalid characters.");  	}  	if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  		if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  			return false;  		}  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (Int32 j = 0; j < 2; j++) {  	// low nibble comparison  	Int32 nibbleOffset = 0;  	if (j == 0) {  		// high nibble comparison  		nibbleOffset = 4;  	}  	// j == 0 == high nibble  	// j == 1 == low nibble  	var tmp = (Byte)hexinput [i * 2 + j];  	if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  		tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  	} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  		// don't care ignore nibble comparison  	} else {  		throw new ArgumentException ("Hex value specified contains invalid characters.");  	}  	if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  		if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  			return false;  		}  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (Int32 j = 0; j < 2; j++) {  	// low nibble comparison  	Int32 nibbleOffset = 0;  	if (j == 0) {  		// high nibble comparison  		nibbleOffset = 4;  	}  	// j == 0 == high nibble  	// j == 1 == low nibble  	var tmp = (Byte)hexinput [i * 2 + j];  	if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  		tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  	} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  		// don't care ignore nibble comparison  	} else {  		throw new ArgumentException ("Hex value specified contains invalid characters.");  	}  	if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  		if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  			return false;  		}  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (Int32 j = 0; j < 2; j++) {  	// low nibble comparison  	Int32 nibbleOffset = 0;  	if (j == 0) {  		// high nibble comparison  		nibbleOffset = 4;  	}  	// j == 0 == high nibble  	// j == 1 == low nibble  	var tmp = (Byte)hexinput [i * 2 + j];  	if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  		tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  	} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  		// don't care ignore nibble comparison  	} else {  		throw new ArgumentException ("Hex value specified contains invalid characters.");  	}  	if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  		if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  			return false;  		}  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (Int32 j = 0; j < 2; j++) {  	// low nibble comparison  	Int32 nibbleOffset = 0;  	if (j == 0) {  		// high nibble comparison  		nibbleOffset = 4;  	}  	// j == 0 == high nibble  	// j == 1 == low nibble  	var tmp = (Byte)hexinput [i * 2 + j];  	if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  		tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  	} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  		// don't care ignore nibble comparison  	} else {  		throw new ArgumentException ("Hex value specified contains invalid characters.");  	}  	if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  		if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  			return false;  		}  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (Int32 j = 0; j < 2; j++) {  	// low nibble comparison  	Int32 nibbleOffset = 0;  	if (j == 0) {  		// high nibble comparison  		nibbleOffset = 4;  	}  	// j == 0 == high nibble  	// j == 1 == low nibble  	var tmp = (Byte)hexinput [i * 2 + j];  	if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  		tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  	} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  		// don't care ignore nibble comparison  	} else {  		throw new ArgumentException ("Hex value specified contains invalid characters.");  	}  	if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  		if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  			return false;  		}  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (Int32 j = 0; j < 2; j++) {  	// low nibble comparison  	Int32 nibbleOffset = 0;  	if (j == 0) {  		// high nibble comparison  		nibbleOffset = 4;  	}  	// j == 0 == high nibble  	// j == 1 == low nibble  	var tmp = (Byte)hexinput [i * 2 + j];  	if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  		tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  	} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  		// don't care ignore nibble comparison  	} else {  		throw new ArgumentException ("Hex value specified contains invalid characters.");  	}  	if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  		if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  			return false;  		}  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (Int32 j = 0; j < 2; j++) {  	// low nibble comparison  	Int32 nibbleOffset = 0;  	if (j == 0) {  		// high nibble comparison  		nibbleOffset = 4;  	}  	// j == 0 == high nibble  	// j == 1 == low nibble  	var tmp = (Byte)hexinput [i * 2 + j];  	if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  		tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  	} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  		// don't care ignore nibble comparison  	} else {  		throw new ArgumentException ("Hex value specified contains invalid characters.");  	}  	if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  		if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  			return false;  		}  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (Int32 j = 0; j < 2; j++) {  	// low nibble comparison  	Int32 nibbleOffset = 0;  	if (j == 0) {  		// high nibble comparison  		nibbleOffset = 4;  	}  	// j == 0 == high nibble  	// j == 1 == low nibble  	var tmp = (Byte)hexinput [i * 2 + j];  	if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  		tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  	} else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  		tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  	} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  		// don't care ignore nibble comparison  	} else {  		throw new ArgumentException ("Hex value specified contains invalid characters.");  	}  	if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  		if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  			return false;  		}  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (j == 0) {  	// high nibble comparison  	nibbleOffset = 4;  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: nibbleOffset = 4;  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  	tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  } else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  	tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  } else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  	tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  } else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  	// don't care ignore nibble comparison  } else {  	throw new ArgumentException ("Hex value specified contains invalid characters.");  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (tmp >= (Byte)'0' && tmp <= (Byte)'9') {  	tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  } else if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  	tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  } else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  	tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  } else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  	// don't care ignore nibble comparison  } else {  	throw new ArgumentException ("Hex value specified contains invalid characters.");  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  	tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  } else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  	tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  } else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  	// don't care ignore nibble comparison  } else {  	throw new ArgumentException ("Hex value specified contains invalid characters.");  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (tmp >= (Byte)'a' && tmp <= (Byte)'f') {  	tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  } else if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  	tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  } else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  	// don't care ignore nibble comparison  } else {  	throw new ArgumentException ("Hex value specified contains invalid characters.");  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (tmp >= (Byte)'A' && tmp <= (Byte)'F') {  	tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  } else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  	// don't care ignore nibble comparison  } else {  	throw new ArgumentException ("Hex value specified contains invalid characters.");  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  	if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  		return false;  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  	if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  		return false;  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  	if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  		return false;  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  	if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  		return false;  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  	if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  		return false;  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  	if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  		return false;  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  	if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  		return false;  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  	if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  		return false;  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  	return false;  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  	return false;  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  	return false;  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  	return false;  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  	return false;  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  	return false;  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  	return false;  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) != ((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) || ((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) != ((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) || ((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) != ((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) || ((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)) {  	return false;  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (matchtext.StartsWith ("#b")) {  	// binary evaluation  	String binaryinput = matchtext.Substring (2);  	if (binaryinput == String.Empty)  		throw new ArgumentException ("Binary value specified is empty.");  	if (binaryinput.Length % 8 != 0)  		binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  	// on incomplete byte boundaries shift right  	int total_compare_bytes = binaryinput.Length / 8;  	for (int i = 0; i < total_compare_bytes; i++) {  		if (iterator.Current () == -1)  			return false;  		var compareWith = (Byte)iterator.Current ();  		for (Int32 j = 0; j < 8; j++) {  			var tmp = (Byte)binaryinput [i * 8 + j];  			if (tmp == (Byte)'0') {  				tmp = 0x00;  			} else if (tmp == (Byte)'1') {  				tmp = 0x01;  			} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  				// don't care ignore nibble comparison  			} else {  				throw new ArgumentException ("Binary value specified contains invalid characters.");  			}  			if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  				Int32 bit2compare = 7 - j;  				if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  					return false;  				}  			}  		}  		iterator.Next ();  	}  } else {  	// decimal codepoint evaluation  	String decimalinput = matchtext.Substring (1);  	if (decimalinput == String.Empty)  		throw new ArgumentException ("Decimal codepoint value specified is empty.");  	if (!Regex.IsMatch (decimalinput' @"^[0-9]+$"))  		throw new ArgumentException ("Decimal codepoint value specified contains invalid characters.");  	if (decimalinput.Length > 10)  		// 4'294'967'295  		throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  	UInt32 codepoint = UInt32.Parse (decimalinput);  	var c4 = (Byte)(codepoint >> 24);  	var c3 = (Byte)(codepoint >> 16);  	var c2 = (Byte)(codepoint >> 8);  	var c1 = (Byte)(codepoint);  	if (c4 != 0x00) {  		// consumes 4 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c4) {  			return false;  		}  		iterator.Next ();  	} else if (c3 != 0x00) {  		// consumes 3 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c3) {  			return false;  		}  		iterator.Next ();  	} else if (c2 != 0x00) {  		// consumes 2 bytes  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  		if (iterator.Current () == -1 || iterator.Current () != c2) {  			return false;  		}  		iterator.Next ();  	} else {  		// user must want to match null \0  		// (c1 != 0x00)  		// consumes 1 byte  		if (iterator.Current () == -1 || iterator.Current () != c1) {  			return false;  		}  		iterator.Next ();  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (binaryinput.Length % 8 != 0)  	binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (binaryinput.Length % 8 != 0)  	binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (binaryinput.Length % 8 != 0)  	binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: binaryinput = "".PadLeft (8 - (binaryinput.Length % 8)' '0') + binaryinput;  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (int i = 0; i < total_compare_bytes; i++) {  	if (iterator.Current () == -1)  		return false;  	var compareWith = (Byte)iterator.Current ();  	for (Int32 j = 0; j < 8; j++) {  		var tmp = (Byte)binaryinput [i * 8 + j];  		if (tmp == (Byte)'0') {  			tmp = 0x00;  		} else if (tmp == (Byte)'1') {  			tmp = 0x01;  		} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  			// don't care ignore nibble comparison  		} else {  			throw new ArgumentException ("Binary value specified contains invalid characters.");  		}  		if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  			Int32 bit2compare = 7 - j;  			if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  				return false;  			}  		}  	}  	iterator.Next ();  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (int i = 0; i < total_compare_bytes; i++) {  	if (iterator.Current () == -1)  		return false;  	var compareWith = (Byte)iterator.Current ();  	for (Int32 j = 0; j < 8; j++) {  		var tmp = (Byte)binaryinput [i * 8 + j];  		if (tmp == (Byte)'0') {  			tmp = 0x00;  		} else if (tmp == (Byte)'1') {  			tmp = 0x01;  		} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  			// don't care ignore nibble comparison  		} else {  			throw new ArgumentException ("Binary value specified contains invalid characters.");  		}  		if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  			Int32 bit2compare = 7 - j;  			if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  				return false;  			}  		}  	}  	iterator.Next ();  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (int i = 0; i < total_compare_bytes; i++) {  	if (iterator.Current () == -1)  		return false;  	var compareWith = (Byte)iterator.Current ();  	for (Int32 j = 0; j < 8; j++) {  		var tmp = (Byte)binaryinput [i * 8 + j];  		if (tmp == (Byte)'0') {  			tmp = 0x00;  		} else if (tmp == (Byte)'1') {  			tmp = 0x01;  		} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  			// don't care ignore nibble comparison  		} else {  			throw new ArgumentException ("Binary value specified contains invalid characters.");  		}  		if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  			Int32 bit2compare = 7 - j;  			if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  				return false;  			}  		}  	}  	iterator.Next ();  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (Int32 j = 0; j < 8; j++) {  	var tmp = (Byte)binaryinput [i * 8 + j];  	if (tmp == (Byte)'0') {  		tmp = 0x00;  	} else if (tmp == (Byte)'1') {  		tmp = 0x01;  	} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  		// don't care ignore nibble comparison  	} else {  		throw new ArgumentException ("Binary value specified contains invalid characters.");  	}  	if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  		Int32 bit2compare = 7 - j;  		if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  			return false;  		}  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (Int32 j = 0; j < 8; j++) {  	var tmp = (Byte)binaryinput [i * 8 + j];  	if (tmp == (Byte)'0') {  		tmp = 0x00;  	} else if (tmp == (Byte)'1') {  		tmp = 0x01;  	} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  		// don't care ignore nibble comparison  	} else {  		throw new ArgumentException ("Binary value specified contains invalid characters.");  	}  	if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  		Int32 bit2compare = 7 - j;  		if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  			return false;  		}  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: for (Int32 j = 0; j < 8; j++) {  	var tmp = (Byte)binaryinput [i * 8 + j];  	if (tmp == (Byte)'0') {  		tmp = 0x00;  	} else if (tmp == (Byte)'1') {  		tmp = 0x01;  	} else if (tmp == (Byte)'x' || tmp == (Byte)'X') {  		// don't care ignore nibble comparison  	} else {  		throw new ArgumentException ("Binary value specified contains invalid characters.");  	}  	if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  		Int32 bit2compare = 7 - j;  		if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  			return false;  		}  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (!(tmp == (Byte)'x' || tmp == (Byte)'X')) {  	Int32 bit2compare = 7 - j;  	if (((compareWith & (1 << bit2compare)) >> bit2compare) != tmp) {  		return false;  	}  }  
Magic Number,NPEG,NpegParserVisitor,D:\newReposJune17\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: if (decimalinput.Length > 10)  	// 4'294'967'295  	throw new ArgumentException ("Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");  
Magic Number,NPEG.Extensions,StringExtensions,D:\newReposJune17\leblancmeneses_NPEG\NPEG\Extensions\StringExtensions.cs,ToBytesFromHexString,The following statement contains a magic number: return (from Match item in items  select Convert.ToByte (item.Groups ["Hex"].Value' 16)).ToList ();  
Magic Number,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The following statement contains a magic number: if (hasPassedNodeDefinition) {  	switch (node.Token.Name) {  	case "Statement":  		hasPassedNodeDefinition = false;  		var statement = (StatementAstNode)node;  		if (statement.IsCaptured) {  			var captureStatement = new CapturingGroup (statement.Name' expressionStack.Pop ()) {  				RuleStart = node.Token.Start'  				RuleEnd = node.Token.End  			};  			if (statement.Children [0].Children [0].Children.Any (child => child.Token.Name == "OptionalFlags") && statement.Children [0].Children [0].Children [1].Children.Any (child => child.Token.Name == "ReplaceBySingleChild")) {  				captureStatement.DoReplaceBySingleChildNode = true;  				// default is false  			}  			expression = captureStatement;  		} else {  			expression = expressionStack.Pop ();  		}  		// Assumes Terminals are at the top of the file and   		// final root non terminal expression is at the bottom.  		if (wrapWithRecursionRule.Contains (statement.Name)) {  			expression = new RecursionCreate (statement.Name' expression) {  				RuleStart = node.Token.Start'  				RuleEnd = node.Token.End  			};  		}  		completedStatements.Add (statement.Name' expression);  		break;  	case "Sequence":  		var reverse = new Stack<AExpression> ();  		for (int i = 0; i < node.Children.Count; i++) {  			reverse.Push (expressionStack.Pop ());  		}  		Decimal sequence_cnt = (decimal)node.Children.Count - 1;  		for (; sequence_cnt > 0; sequence_cnt--) {  			left = reverse.Pop ();  			right = reverse.Pop ();  			reverse.Push (new Sequence (left' right) {  				RuleStart = node.Token.Start'  				RuleEnd = node.Token.End  			});  		}  		expressionStack.Push (reverse.Pop ());  		break;  	case "PrioritizedChoice":  		Int32 cnt = node.Children.Count - 1;  		for (Int32 i = 0; i < cnt; i++) {  			right = expressionStack.Pop ();  			left = expressionStack.Pop ();  			expressionStack.Push (new PrioritizedChoice (left' right) {  				RuleStart = node.Token.Start'  				RuleEnd = node.Token.End  			});  		}  		break;  	case "Prefix":  		switch (node.Token.ValueAsString (_inputIterator) [0].ToString ()) {  		case "!":  			expressionStack.Push (new NotPredicate (expressionStack.Pop ()) {  				RuleStart = node.Token.Start'  				RuleEnd = node.Token.End  			});  			break;  		case "&":  			expressionStack.Push (new AndPredicate (expressionStack.Pop ()) {  				RuleStart = node.Token.Start'  				RuleEnd = node.Token.End  			});  			break;  		default:  			throw new Exception ("Unsupported PEG Prefix.");  		}  		break;  	case "Suffix":  		switch (node.Children [0].Token.Name) {  		case "ZeroOrMore":  			expressionStack.Push (new ZeroOrMore (expressionStack.Pop ()) {  				RuleStart = node.Token.Start'  				RuleEnd = node.Token.End  			});  			break;  		case "OneOrMore":  			expressionStack.Push (new OneOrMore (expressionStack.Pop ()) {  				RuleStart = node.Token.Start'  				RuleEnd = node.Token.End  			});  			break;  		case "Optional":  			expressionStack.Push (new Optional (expressionStack.Pop ()) {  				RuleStart = node.Token.Start'  				RuleEnd = node.Token.End  			});  			break;  		case "LimitingRepetition":  			switch (node.Children [0].Children [1].Token.Name) {  			case "BETWEEN":  				expressionStack.Push (new LimitingRepetition (expressionStack.Pop ()) {  					Min = Int32.Parse (node.Children [0].Children [1].Children [0].Token.ValueAsString (_inputIterator))'  					Max = Int32.Parse (node.Children [0].Children [1].Children [1].Token.ValueAsString (_inputIterator))'  					RuleStart = node.Token.Start'  					RuleEnd = node.Token.End  				});  				break;  			case "ATMOST":  				expressionStack.Push (new LimitingRepetition (expressionStack.Pop ()) {  					Min = null'  					Max = Int32.Parse (node.Children [0].Children [1].Children [0].Token.ValueAsString (_inputIterator))'  					RuleStart = node.Token.Start'  					RuleEnd = node.Token.End  				});  				break;  			case "ATLEAST":  				expressionStack.Push (new LimitingRepetition (expressionStack.Pop ()) {  					Min = Int32.Parse (node.Children [0].Children [1].Children [0].Token.ValueAsString (_inputIterator))'  					Max = null'  					RuleStart = node.Token.Start'  					RuleEnd = node.Token.End  				});  				break;  			case "EXACT":  				Int32 exactcount = Int32.Parse (node.Children [0].Children [1].Token.ValueAsString (_inputIterator));  				expressionStack.Push (new LimitingRepetition (expressionStack.Pop ()) {  					Min = exactcount'  					Max = exactcount'  					RuleStart = node.Token.Start'  					RuleEnd = node.Token.End  				});  				break;  			case "VariableLength":  				var variableLengthExpression = node.Children [0].Children [1].Token.ValueAsString (_inputIterator);  				expressionStack.Push (new LimitingRepetition (expressionStack.Pop ()) {  					VariableLengthExpression = variableLengthExpression'  					RuleStart = node.Token.Start'  					RuleEnd = node.Token.End  				});  				break;  			}  			break;  		default:  			throw new Exception ("Unsupported PEG Suffix.");  		}  		break;  	case "CapturingGroup":  		var capture = new CapturingGroup (node.Children [0].Token.ValueAsString (_inputIterator)' expressionStack.Pop ()) {  			RuleStart = node.Token.Start'  			RuleEnd = node.Token.End  		};  		if (node.Children.Any (child => child.Token.Name == "OptionalFlags")) {  			if (node.Children [1].Children.Any (child => child.Token.Name == "ReplaceBySingleChild")) {  				capture.DoReplaceBySingleChildNode = true;  				// default is false  			}  			if (node.Children [1].Children.Any (child => child.Token.Name == "ReplacementNode")) {  				capture.DoCreateCustomAstNode = true;  				// default is false  			}  		}  		expressionStack.Push (capture);  		break;  	case "Group":  		break;  	case "AnyCharacter":  		expressionStack.Push (new AnyCharacter () {  			RuleStart = node.Token.Start'  			RuleEnd = node.Token.End  		});  		break;  	case "Literal":  		Boolean isCaseSensitive = true;  		if (node.Children.Count == 2)  			isCaseSensitive = false;  		expressionStack.Push (new Literal {  			IsCaseSensitive = isCaseSensitive'  			MatchText = Regex.Replace (Regex.Replace (node.Children [0].Token.ValueAsString (_inputIterator)' @"\\(?<quote>""|')"' @"${quote}")' @"\\\\"' @"\")'  			RuleStart = node.Token.Start'  			RuleEnd = node.Token.End  		});  		break;  	case "CharacterClass":  		expressionStack.Push (new CharacterClass {  			ClassExpression = node.Token.ValueAsString (_inputIterator)'  			RuleStart = node.Token.Start'  			RuleEnd = node.Token.End  		});  		break;  	case "RecursionCall":  		expressionStack.Push ((this) [node.Children [0].Token.ValueAsString (_inputIterator)]);  		break;  	case "CodePoint":  		expressionStack.Push (new CodePoint {  			Match = "#" + node.Children [0].Token.ValueAsString (_inputIterator)'  			RuleStart = node.Token.Start'  			RuleEnd = node.Token.End  		});  		break;  	case "Fatal":  		expressionStack.Push (new Fatal {  			Message = node.Children [0].Token.ValueAsString (_inputIterator)'  			RuleStart = node.Token.Start'  			RuleEnd = node.Token.End  		});  		break;  	case "Warn":  		expressionStack.Push (new Warn {  			Message = node.Children [0].Token.ValueAsString (_inputIterator)'  			RuleStart = node.Token.Start'  			RuleEnd = node.Token.End  		});  		break;  	case "DynamicBackReferencing":  		if (node.Children.Count == 1) {  			// no options specified only tag name.  			expressionStack.Push (new DynamicBackReference {  				BackReferenceName = node.Children [0].Token.ValueAsString (_inputIterator)'  				RuleStart = node.Token.Start'  				RuleEnd = node.Token.End  			});  		} else {  			throw new NotImplementedException ("Add IsCaseSensitive using children[1].Token.Name == IsCasesensitive");  		}  		break;  	}  }  
Magic Number,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The following statement contains a magic number: switch (node.Token.Name) {  case "Statement":  	hasPassedNodeDefinition = false;  	var statement = (StatementAstNode)node;  	if (statement.IsCaptured) {  		var captureStatement = new CapturingGroup (statement.Name' expressionStack.Pop ()) {  			RuleStart = node.Token.Start'  			RuleEnd = node.Token.End  		};  		if (statement.Children [0].Children [0].Children.Any (child => child.Token.Name == "OptionalFlags") && statement.Children [0].Children [0].Children [1].Children.Any (child => child.Token.Name == "ReplaceBySingleChild")) {  			captureStatement.DoReplaceBySingleChildNode = true;  			// default is false  		}  		expression = captureStatement;  	} else {  		expression = expressionStack.Pop ();  	}  	// Assumes Terminals are at the top of the file and   	// final root non terminal expression is at the bottom.  	if (wrapWithRecursionRule.Contains (statement.Name)) {  		expression = new RecursionCreate (statement.Name' expression) {  			RuleStart = node.Token.Start'  			RuleEnd = node.Token.End  		};  	}  	completedStatements.Add (statement.Name' expression);  	break;  case "Sequence":  	var reverse = new Stack<AExpression> ();  	for (int i = 0; i < node.Children.Count; i++) {  		reverse.Push (expressionStack.Pop ());  	}  	Decimal sequence_cnt = (decimal)node.Children.Count - 1;  	for (; sequence_cnt > 0; sequence_cnt--) {  		left = reverse.Pop ();  		right = reverse.Pop ();  		reverse.Push (new Sequence (left' right) {  			RuleStart = node.Token.Start'  			RuleEnd = node.Token.End  		});  	}  	expressionStack.Push (reverse.Pop ());  	break;  case "PrioritizedChoice":  	Int32 cnt = node.Children.Count - 1;  	for (Int32 i = 0; i < cnt; i++) {  		right = expressionStack.Pop ();  		left = expressionStack.Pop ();  		expressionStack.Push (new PrioritizedChoice (left' right) {  			RuleStart = node.Token.Start'  			RuleEnd = node.Token.End  		});  	}  	break;  case "Prefix":  	switch (node.Token.ValueAsString (_inputIterator) [0].ToString ()) {  	case "!":  		expressionStack.Push (new NotPredicate (expressionStack.Pop ()) {  			RuleStart = node.Token.Start'  			RuleEnd = node.Token.End  		});  		break;  	case "&":  		expressionStack.Push (new AndPredicate (expressionStack.Pop ()) {  			RuleStart = node.Token.Start'  			RuleEnd = node.Token.End  		});  		break;  	default:  		throw new Exception ("Unsupported PEG Prefix.");  	}  	break;  case "Suffix":  	switch (node.Children [0].Token.Name) {  	case "ZeroOrMore":  		expressionStack.Push (new ZeroOrMore (expressionStack.Pop ()) {  			RuleStart = node.Token.Start'  			RuleEnd = node.Token.End  		});  		break;  	case "OneOrMore":  		expressionStack.Push (new OneOrMore (expressionStack.Pop ()) {  			RuleStart = node.Token.Start'  			RuleEnd = node.Token.End  		});  		break;  	case "Optional":  		expressionStack.Push (new Optional (expressionStack.Pop ()) {  			RuleStart = node.Token.Start'  			RuleEnd = node.Token.End  		});  		break;  	case "LimitingRepetition":  		switch (node.Children [0].Children [1].Token.Name) {  		case "BETWEEN":  			expressionStack.Push (new LimitingRepetition (expressionStack.Pop ()) {  				Min = Int32.Parse (node.Children [0].Children [1].Children [0].Token.ValueAsString (_inputIterator))'  				Max = Int32.Parse (node.Children [0].Children [1].Children [1].Token.ValueAsString (_inputIterator))'  				RuleStart = node.Token.Start'  				RuleEnd = node.Token.End  			});  			break;  		case "ATMOST":  			expressionStack.Push (new LimitingRepetition (expressionStack.Pop ()) {  				Min = null'  				Max = Int32.Parse (node.Children [0].Children [1].Children [0].Token.ValueAsString (_inputIterator))'  				RuleStart = node.Token.Start'  				RuleEnd = node.Token.End  			});  			break;  		case "ATLEAST":  			expressionStack.Push (new LimitingRepetition (expressionStack.Pop ()) {  				Min = Int32.Parse (node.Children [0].Children [1].Children [0].Token.ValueAsString (_inputIterator))'  				Max = null'  				RuleStart = node.Token.Start'  				RuleEnd = node.Token.End  			});  			break;  		case "EXACT":  			Int32 exactcount = Int32.Parse (node.Children [0].Children [1].Token.ValueAsString (_inputIterator));  			expressionStack.Push (new LimitingRepetition (expressionStack.Pop ()) {  				Min = exactcount'  				Max = exactcount'  				RuleStart = node.Token.Start'  				RuleEnd = node.Token.End  			});  			break;  		case "VariableLength":  			var variableLengthExpression = node.Children [0].Children [1].Token.ValueAsString (_inputIterator);  			expressionStack.Push (new LimitingRepetition (expressionStack.Pop ()) {  				VariableLengthExpression = variableLengthExpression'  				RuleStart = node.Token.Start'  				RuleEnd = node.Token.End  			});  			break;  		}  		break;  	default:  		throw new Exception ("Unsupported PEG Suffix.");  	}  	break;  case "CapturingGroup":  	var capture = new CapturingGroup (node.Children [0].Token.ValueAsString (_inputIterator)' expressionStack.Pop ()) {  		RuleStart = node.Token.Start'  		RuleEnd = node.Token.End  	};  	if (node.Children.Any (child => child.Token.Name == "OptionalFlags")) {  		if (node.Children [1].Children.Any (child => child.Token.Name == "ReplaceBySingleChild")) {  			capture.DoReplaceBySingleChildNode = true;  			// default is false  		}  		if (node.Children [1].Children.Any (child => child.Token.Name == "ReplacementNode")) {  			capture.DoCreateCustomAstNode = true;  			// default is false  		}  	}  	expressionStack.Push (capture);  	break;  case "Group":  	break;  case "AnyCharacter":  	expressionStack.Push (new AnyCharacter () {  		RuleStart = node.Token.Start'  		RuleEnd = node.Token.End  	});  	break;  case "Literal":  	Boolean isCaseSensitive = true;  	if (node.Children.Count == 2)  		isCaseSensitive = false;  	expressionStack.Push (new Literal {  		IsCaseSensitive = isCaseSensitive'  		MatchText = Regex.Replace (Regex.Replace (node.Children [0].Token.ValueAsString (_inputIterator)' @"\\(?<quote>""|')"' @"${quote}")' @"\\\\"' @"\")'  		RuleStart = node.Token.Start'  		RuleEnd = node.Token.End  	});  	break;  case "CharacterClass":  	expressionStack.Push (new CharacterClass {  		ClassExpression = node.Token.ValueAsString (_inputIterator)'  		RuleStart = node.Token.Start'  		RuleEnd = node.Token.End  	});  	break;  case "RecursionCall":  	expressionStack.Push ((this) [node.Children [0].Token.ValueAsString (_inputIterator)]);  	break;  case "CodePoint":  	expressionStack.Push (new CodePoint {  		Match = "#" + node.Children [0].Token.ValueAsString (_inputIterator)'  		RuleStart = node.Token.Start'  		RuleEnd = node.Token.End  	});  	break;  case "Fatal":  	expressionStack.Push (new Fatal {  		Message = node.Children [0].Token.ValueAsString (_inputIterator)'  		RuleStart = node.Token.Start'  		RuleEnd = node.Token.End  	});  	break;  case "Warn":  	expressionStack.Push (new Warn {  		Message = node.Children [0].Token.ValueAsString (_inputIterator)'  		RuleStart = node.Token.Start'  		RuleEnd = node.Token.End  	});  	break;  case "DynamicBackReferencing":  	if (node.Children.Count == 1) {  		// no options specified only tag name.  		expressionStack.Push (new DynamicBackReference {  			BackReferenceName = node.Children [0].Token.ValueAsString (_inputIterator)'  			RuleStart = node.Token.Start'  			RuleEnd = node.Token.End  		});  	} else {  		throw new NotImplementedException ("Add IsCaseSensitive using children[1].Token.Name == IsCasesensitive");  	}  	break;  }  
Magic Number,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The following statement contains a magic number: if (node.Children.Count == 2)  	isCaseSensitive = false;  
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mFATAL,The following statement contains a magic number: return new CapturingGroup ("Fatal"' new Sequence (new Literal {  	MatchText = "Fatal"'  	IsCaseSensitive = false  }' new Sequence (new Sequence (new Literal {  	MatchText = "<"  }' new Optional (mSpace ()))' new PrioritizedChoice (// with single quotes  new Sequence (new Literal {  	MatchText = "'"  }' new CapturingGroup ("Message"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\'"  })' new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = @"[^']"  })))).Sequence (new Literal {  	MatchText = "'"  })' // without double quotes  new Sequence (new Literal {  	MatchText = "\""  }' new CapturingGroup ("Message"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\"""  })' new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = @"[^""]"  })))).Sequence (new Literal {  	MatchText = "\""  })).Or (// no quotes  new Sequence (new Optional (mSpace ())' new CapturingGroup ("Message"' new OneOrMore (new Sequence (new NotPredicate (new Sequence (new Optional (mSpace ())' new Literal {  	MatchText = ">"  }))' new CharacterClass {  	ClassExpression = @"[^>]"  }))))))).Sequence (new Sequence (new Optional (mSpace ())' new Literal {  	MatchText = ">"  })));  
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mFATAL,The following statement contains a magic number: return new CapturingGroup ("Fatal"' new Sequence (new Literal {  	MatchText = "Fatal"'  	IsCaseSensitive = false  }' new Sequence (new Sequence (new Literal {  	MatchText = "<"  }' new Optional (mSpace ()))' new PrioritizedChoice (// with single quotes  new Sequence (new Literal {  	MatchText = "'"  }' new CapturingGroup ("Message"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\'"  })' new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = @"[^']"  })))).Sequence (new Literal {  	MatchText = "'"  })' // without double quotes  new Sequence (new Literal {  	MatchText = "\""  }' new CapturingGroup ("Message"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\"""  })' new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = @"[^""]"  })))).Sequence (new Literal {  	MatchText = "\""  })).Or (// no quotes  new Sequence (new Optional (mSpace ())' new CapturingGroup ("Message"' new OneOrMore (new Sequence (new NotPredicate (new Sequence (new Optional (mSpace ())' new Literal {  	MatchText = ">"  }))' new CharacterClass {  	ClassExpression = @"[^>]"  }))))))).Sequence (new Sequence (new Optional (mSpace ())' new Literal {  	MatchText = ">"  })));  
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mFATAL,The following statement contains a magic number: return new CapturingGroup ("Fatal"' new Sequence (new Literal {  	MatchText = "Fatal"'  	IsCaseSensitive = false  }' new Sequence (new Sequence (new Literal {  	MatchText = "<"  }' new Optional (mSpace ()))' new PrioritizedChoice (// with single quotes  new Sequence (new Literal {  	MatchText = "'"  }' new CapturingGroup ("Message"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\'"  })' new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = @"[^']"  })))).Sequence (new Literal {  	MatchText = "'"  })' // without double quotes  new Sequence (new Literal {  	MatchText = "\""  }' new CapturingGroup ("Message"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\"""  })' new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = @"[^""]"  })))).Sequence (new Literal {  	MatchText = "\""  })).Or (// no quotes  new Sequence (new Optional (mSpace ())' new CapturingGroup ("Message"' new OneOrMore (new Sequence (new NotPredicate (new Sequence (new Optional (mSpace ())' new Literal {  	MatchText = ">"  }))' new CharacterClass {  	ClassExpression = @"[^>]"  }))))))).Sequence (new Sequence (new Optional (mSpace ())' new Literal {  	MatchText = ">"  })));  
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mFATAL,The following statement contains a magic number: return new CapturingGroup ("Fatal"' new Sequence (new Literal {  	MatchText = "Fatal"'  	IsCaseSensitive = false  }' new Sequence (new Sequence (new Literal {  	MatchText = "<"  }' new Optional (mSpace ()))' new PrioritizedChoice (// with single quotes  new Sequence (new Literal {  	MatchText = "'"  }' new CapturingGroup ("Message"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\'"  })' new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = @"[^']"  })))).Sequence (new Literal {  	MatchText = "'"  })' // without double quotes  new Sequence (new Literal {  	MatchText = "\""  }' new CapturingGroup ("Message"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\"""  })' new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = @"[^""]"  })))).Sequence (new Literal {  	MatchText = "\""  })).Or (// no quotes  new Sequence (new Optional (mSpace ())' new CapturingGroup ("Message"' new OneOrMore (new Sequence (new NotPredicate (new Sequence (new Optional (mSpace ())' new Literal {  	MatchText = ">"  }))' new CharacterClass {  	ClassExpression = @"[^>]"  }))))))).Sequence (new Sequence (new Optional (mSpace ())' new Literal {  	MatchText = ">"  })));  
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mLiteral,The following statement contains a magic number: return new CapturingGroup ("Literal"' new Sequence (new PrioritizedChoice (new Sequence (new Literal {  	MatchText = "\""  }' new CapturingGroup ("MatchText"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\\"  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\"""  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = "[^\"]"  }))))).Sequence (new Literal {  	MatchText = "\""  })' new Sequence (new Literal {  	MatchText = "'"  }' new CapturingGroup ("MatchText"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\\"  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\'"  })' // consumes to characters \' until it finds ' not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = "[^']"  }))))).Sequence (new Literal {  	MatchText = "'"  }))' // optional do case-insensitive pattern matching.   new Optional (new CapturingGroup ("CaseInsensitive"' new Literal {  	MatchText = @"\i"  }))));  
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mLiteral,The following statement contains a magic number: return new CapturingGroup ("Literal"' new Sequence (new PrioritizedChoice (new Sequence (new Literal {  	MatchText = "\""  }' new CapturingGroup ("MatchText"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\\"  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\"""  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = "[^\"]"  }))))).Sequence (new Literal {  	MatchText = "\""  })' new Sequence (new Literal {  	MatchText = "'"  }' new CapturingGroup ("MatchText"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\\"  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\'"  })' // consumes to characters \' until it finds ' not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = "[^']"  }))))).Sequence (new Literal {  	MatchText = "'"  }))' // optional do case-insensitive pattern matching.   new Optional (new CapturingGroup ("CaseInsensitive"' new Literal {  	MatchText = @"\i"  }))));  
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mLiteral,The following statement contains a magic number: return new CapturingGroup ("Literal"' new Sequence (new PrioritizedChoice (new Sequence (new Literal {  	MatchText = "\""  }' new CapturingGroup ("MatchText"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\\"  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\"""  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = "[^\"]"  }))))).Sequence (new Literal {  	MatchText = "\""  })' new Sequence (new Literal {  	MatchText = "'"  }' new CapturingGroup ("MatchText"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\\"  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\'"  })' // consumes to characters \' until it finds ' not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = "[^']"  }))))).Sequence (new Literal {  	MatchText = "'"  }))' // optional do case-insensitive pattern matching.   new Optional (new CapturingGroup ("CaseInsensitive"' new Literal {  	MatchText = @"\i"  }))));  
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mLiteral,The following statement contains a magic number: return new CapturingGroup ("Literal"' new Sequence (new PrioritizedChoice (new Sequence (new Literal {  	MatchText = "\""  }' new CapturingGroup ("MatchText"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\\"  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\"""  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = "[^\"]"  }))))).Sequence (new Literal {  	MatchText = "\""  })' new Sequence (new Literal {  	MatchText = "'"  }' new CapturingGroup ("MatchText"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\\"  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\'"  })' // consumes to characters \' until it finds ' not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = "[^']"  }))))).Sequence (new Literal {  	MatchText = "'"  }))' // optional do case-insensitive pattern matching.   new Optional (new CapturingGroup ("CaseInsensitive"' new Literal {  	MatchText = @"\i"  }))));  
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mLiteral,The following statement contains a magic number: return new CapturingGroup ("Literal"' new Sequence (new PrioritizedChoice (new Sequence (new Literal {  	MatchText = "\""  }' new CapturingGroup ("MatchText"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\\"  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\"""  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = "[^\"]"  }))))).Sequence (new Literal {  	MatchText = "\""  })' new Sequence (new Literal {  	MatchText = "'"  }' new CapturingGroup ("MatchText"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\\"  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\'"  })' // consumes to characters \' until it finds ' not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = "[^']"  }))))).Sequence (new Literal {  	MatchText = "'"  }))' // optional do case-insensitive pattern matching.   new Optional (new CapturingGroup ("CaseInsensitive"' new Literal {  	MatchText = @"\i"  }))));  
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mLiteral,The following statement contains a magic number: return new CapturingGroup ("Literal"' new Sequence (new PrioritizedChoice (new Sequence (new Literal {  	MatchText = "\""  }' new CapturingGroup ("MatchText"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\\"  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\"""  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = "[^\"]"  }))))).Sequence (new Literal {  	MatchText = "\""  })' new Sequence (new Literal {  	MatchText = "'"  }' new CapturingGroup ("MatchText"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\\"  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\'"  })' // consumes to characters \' until it finds ' not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = "[^']"  }))))).Sequence (new Literal {  	MatchText = "'"  }))' // optional do case-insensitive pattern matching.   new Optional (new CapturingGroup ("CaseInsensitive"' new Literal {  	MatchText = @"\i"  }))));  
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mLiteral,The following statement contains a magic number: return new CapturingGroup ("Literal"' new Sequence (new PrioritizedChoice (new Sequence (new Literal {  	MatchText = "\""  }' new CapturingGroup ("MatchText"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\\"  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\"""  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = "[^\"]"  }))))).Sequence (new Literal {  	MatchText = "\""  })' new Sequence (new Literal {  	MatchText = "'"  }' new CapturingGroup ("MatchText"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\\"  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\'"  })' // consumes to characters \' until it finds ' not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = "[^']"  }))))).Sequence (new Literal {  	MatchText = "'"  }))' // optional do case-insensitive pattern matching.   new Optional (new CapturingGroup ("CaseInsensitive"' new Literal {  	MatchText = @"\i"  }))));  
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mLiteral,The following statement contains a magic number: return new CapturingGroup ("Literal"' new Sequence (new PrioritizedChoice (new Sequence (new Literal {  	MatchText = "\""  }' new CapturingGroup ("MatchText"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\\"  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\"""  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = "[^\"]"  }))))).Sequence (new Literal {  	MatchText = "\""  })' new Sequence (new Literal {  	MatchText = "'"  }' new CapturingGroup ("MatchText"' new OneOrMore (new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\\"  })' // consumes two characters \" until it finds " not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new PrioritizedChoice (new Sequence (new AndPredicate (new Literal {  	MatchText = @"\'"  })' // consumes to characters \' until it finds ' not escaped  new LimitingRepetition (new AnyCharacter ()) {  	Min = 2'  	Max = 2  })' new CharacterClass {  	ClassExpression = "[^']"  }))))).Sequence (new Literal {  	MatchText = "'"  }))' // optional do case-insensitive pattern matching.   new Optional (new CapturingGroup ("CaseInsensitive"' new Literal {  	MatchText = @"\i"  }))));  
Magic Number,NPEG.GrammarInterpreter,LimitingRepetitionVariableLengthExpressionSolver,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\LimitingRepetitionVariableLengthExpressionSolver.cs,VisitEnter,The following statement contains a magic number: switch (node.Token.Name) {  case "Variable":  	var key = node.Children [0].Token.ValueAsString (_userExpressionIterator);  	if (!_variableValues.Any (x => x.Token.Name.Equals (key' StringComparison.InvariantCultureIgnoreCase))) {  		throw new ArgumentOutOfRangeException (string.Format ("backreference key {0} does not exist."' key));  	}  	uint value = 0;  	foreach (var b in _variableValues.First (x => x.Token.Name.Equals (key' StringComparison.InvariantCultureIgnoreCase)).Token.ValueAsBytes (_inputIterator).Reverse ()) {  		value <<= 8;  		value |= (uint)b & 0xFF;  	}  	_results.Peek ().Push (value);  	break;  case "Symbol":  	_symbol.Peek ().Push (node.Token.ValueAsString (_userExpressionIterator) [0]);  	break;  case "Digit":  	_results.Peek ().Push (double.Parse (node.Token.ValueAsString (_userExpressionIterator)));  	break;  case "Sum":  	_symbol.Push (new Stack<char> ());  	_results.Push (new Stack<double> ());  	break;  case "Product":  	_symbol.Push (new Stack<char> ());  	_results.Push (new Stack<double> ());  	break;  }  
Magic Number,NPEG.GrammarInterpreter,LimitingRepetitionVariableLengthExpressionSolver,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\LimitingRepetitionVariableLengthExpressionSolver.cs,VisitEnter,The following statement contains a magic number: foreach (var b in _variableValues.First (x => x.Token.Name.Equals (key' StringComparison.InvariantCultureIgnoreCase)).Token.ValueAsBytes (_inputIterator).Reverse ()) {  	value <<= 8;  	value |= (uint)b & 0xFF;  }  
Magic Number,NPEG.GrammarInterpreter,LimitingRepetitionVariableLengthExpressionSolver,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\LimitingRepetitionVariableLengthExpressionSolver.cs,VisitEnter,The following statement contains a magic number: value <<= 8;  
Missing Default,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The following switch statement is missing a default case: switch (node.Children [0].Children [1].Token.Name) {  case "BETWEEN":  	expressionStack.Push (new LimitingRepetition (expressionStack.Pop ()) {  		Min = Int32.Parse (node.Children [0].Children [1].Children [0].Token.ValueAsString (_inputIterator))'  		Max = Int32.Parse (node.Children [0].Children [1].Children [1].Token.ValueAsString (_inputIterator))'  		RuleStart = node.Token.Start'  		RuleEnd = node.Token.End  	});  	break;  case "ATMOST":  	expressionStack.Push (new LimitingRepetition (expressionStack.Pop ()) {  		Min = null'  		Max = Int32.Parse (node.Children [0].Children [1].Children [0].Token.ValueAsString (_inputIterator))'  		RuleStart = node.Token.Start'  		RuleEnd = node.Token.End  	});  	break;  case "ATLEAST":  	expressionStack.Push (new LimitingRepetition (expressionStack.Pop ()) {  		Min = Int32.Parse (node.Children [0].Children [1].Children [0].Token.ValueAsString (_inputIterator))'  		Max = null'  		RuleStart = node.Token.Start'  		RuleEnd = node.Token.End  	});  	break;  case "EXACT":  	Int32 exactcount = Int32.Parse (node.Children [0].Children [1].Token.ValueAsString (_inputIterator));  	expressionStack.Push (new LimitingRepetition (expressionStack.Pop ()) {  		Min = exactcount'  		Max = exactcount'  		RuleStart = node.Token.Start'  		RuleEnd = node.Token.End  	});  	break;  case "VariableLength":  	var variableLengthExpression = node.Children [0].Children [1].Token.ValueAsString (_inputIterator);  	expressionStack.Push (new LimitingRepetition (expressionStack.Pop ()) {  		VariableLengthExpression = variableLengthExpression'  		RuleStart = node.Token.Start'  		RuleEnd = node.Token.End  	});  	break;  }  
Missing Default,NPEG.GrammarInterpreter.AstNodes,PeGrammarAstNodeFactory,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\PeGrammarAstNodeFactory.cs,Create,The following switch statement is missing a default case: switch (original.Token.Name) {  case "Statement":  	return new StatementAstNode (_inputIterator);  case "PEG":  	return new InterpreterAstNode (_inputIterator);  }  
Missing Default,NPEG.GrammarInterpreter,LimitingRepetitionVariableLengthExpressionSolver,D:\newReposJune17\leblancmeneses_NPEG\NPEG\GrammarInterpreter\LimitingRepetitionVariableLengthExpressionSolver.cs,VisitEnter,The following switch statement is missing a default case: switch (node.Token.Name) {  case "Variable":  	var key = node.Children [0].Token.ValueAsString (_userExpressionIterator);  	if (!_variableValues.Any (x => x.Token.Name.Equals (key' StringComparison.InvariantCultureIgnoreCase))) {  		throw new ArgumentOutOfRangeException (string.Format ("backreference key {0} does not exist."' key));  	}  	uint value = 0;  	foreach (var b in _variableValues.First (x => x.Token.Name.Equals (key' StringComparison.InvariantCultureIgnoreCase)).Token.ValueAsBytes (_inputIterator).Reverse ()) {  		value <<= 8;  		value |= (uint)b & 0xFF;  	}  	_results.Peek ().Push (value);  	break;  case "Symbol":  	_symbol.Peek ().Push (node.Token.ValueAsString (_userExpressionIterator) [0]);  	break;  case "Digit":  	_results.Peek ().Push (double.Parse (node.Token.ValueAsString (_userExpressionIterator)));  	break;  case "Sum":  	_symbol.Push (new Stack<char> ());  	_results.Push (new Stack<double> ());  	break;  case "Product":  	_symbol.Push (new Stack<char> ());  	_results.Push (new Stack<double> ());  	break;  }  
