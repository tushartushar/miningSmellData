Implementation smell,Namespace,Class,File,Method,Description
Long Method,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,VisitLeave,The method has 106 lines of code.
Long Method,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The method has 212 lines of code.
Long Method,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The method has 212 lines of code.
Long Method,NPEG.GrammarInterpreter,PEGrammar,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mSuffix,The method has 211 lines of code.
Complex Method,NPEG.Algorithms,WriteRuleVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\Algorithms\WriteRuleVisitor.cs,VisitLeave,Cyclomatic complexity of the method is 8
Complex Method,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,Cyclomatic complexity of the method is 38
Complex Method,NPEG.GrammarInterpreter,LimitingRepetitionVariableLengthExpressionSolver,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\LimitingRepetitionVariableLengthExpressionSolver.cs,VisitLeave,Cyclomatic complexity of the method is 11
Long Statement,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,VisitLeave,The length of the statement  "								"Second constructor overload is required during instantiation.  astNodeFactory requires to be set with this parser implementation."); " is 133.
Long Statement,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,VisitLeave,The length of the statement  "								// Warn terminal does not consume and ast should not be created for it' yet it should return that it was successful match. " is 122.
Long Statement,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,VisitLeave,The length of the statement  "								// logic inside astnodereplacement is to create properties' business names' that internally check Children collection to mine data. " is 131.
Long Statement,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The length of the statement  "								if (!String.Equals(Encoding.UTF8.GetString(new[] { (Byte)iterator.Current() }' 0' 1)' Encoding.UTF8.GetString(new[] { c }' 0' 1)' StringComparison.CurrentCultureIgnoreCase)) " is 173.
Long Statement,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The length of the statement  "						matchBytes = _xmlDisableBackReferencePop.Count <= 0 ? _xmlBackReferenceLookup[backreferencename].Pop() : _xmlBackReferenceLookup[backreferencename].Peek(); " is 155.
Long Statement,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The length of the statement  "							var captureStatement = new CapturingGroup(statement.Name' expressionStack.Pop()){RuleStart = node.Token.Start' RuleEnd = node.Token.End}; " is 137.
Long Statement,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The length of the statement  "								expressionStack.Push(new NotPredicate(expressionStack.Pop()) { RuleStart = node.Token.Start' RuleEnd = node.Token.End }); " is 121.
Long Statement,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The length of the statement  "								expressionStack.Push(new AndPredicate(expressionStack.Pop()) { RuleStart = node.Token.Start' RuleEnd = node.Token.End }); " is 121.
Long Statement,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The length of the statement  "										expressionStack.Push(new LimitingRepetition(expressionStack.Pop()) { Min = exactcount' Max = exactcount' RuleStart = node.Token.Start' RuleEnd = node.Token.End }); " is 163.
Long Statement,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The length of the statement  "										expressionStack.Push(new LimitingRepetition(expressionStack.Pop()) { VariableLengthExpression = variableLengthExpression' RuleStart = node.Token.Start' RuleEnd = node.Token.End }); " is 180.
Long Statement,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The length of the statement  "						var capture = new CapturingGroup(node.Children[0].Token.ValueAsString(_inputIterator)' expressionStack.Pop()) { RuleStart = node.Token.Start' RuleEnd = node.Token.End }; " is 169.
Long Statement,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The length of the statement  "						expressionStack.Push(new CharacterClass { ClassExpression = node.Token.ValueAsString(_inputIterator)' RuleStart = node.Token.Start' RuleEnd = node.Token.End }); " is 160.
Long Statement,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The length of the statement  "						expressionStack.Push(new CodePoint { Match = "#" + node.Children[0].Token.ValueAsString(_inputIterator)' RuleStart = node.Token.Start' RuleEnd = node.Token.End }); " is 163.
Long Statement,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The length of the statement  "						expressionStack.Push(new Fatal { Message = node.Children[0].Token.ValueAsString(_inputIterator)' RuleStart = node.Token.Start' RuleEnd = node.Token.End }); " is 155.
Long Statement,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The length of the statement  "						expressionStack.Push(new Warn { Message = node.Children[0].Token.ValueAsString(_inputIterator)' RuleStart = node.Token.Start' RuleEnd = node.Token.End }); " is 154.
Long Statement,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The length of the statement  "							expressionStack.Push(new DynamicBackReference { BackReferenceName = node.Children[0].Token.ValueAsString(_inputIterator)' RuleStart = node.Token.Start' RuleEnd = node.Token.End }); " is 180.
Long Statement,NPEG.GrammarInterpreter,PEGrammar,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,Load,The length of the statement  "			var visitor = new NpegParserVisitor(iterator' new PeGrammarAstNodeFactory(iterator)) { IsOptimized = (options & NpegOptions.Optimize) == NpegOptions.Optimize }; " is 160.
Long Statement,NPEG.GrammarInterpreter,LimitingRepetitionVariableLengthExpressionSolver,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\LimitingRepetitionVariableLengthExpressionSolver.cs,VisitEnter,The length of the statement  "					foreach (var b in _variableValues.First(x=>x.Token.Name.Equals(key' StringComparison.InvariantCultureIgnoreCase)).Token.ValueAsBytes(_inputIterator).Reverse()) " is 159.
Long Statement,NPEG.GrammarInterpreter,LimitingRepetitionVariableLengthExpressionSolver,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\LimitingRepetitionVariableLengthExpressionSolver.cs,VisitLeave,The length of the statement  "					else if (node.Token.ValueAsString(_userExpressionIterator).StartsWith("sin"' StringComparison.InvariantCultureIgnoreCase)) " is 122.
Complex Conditional,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The conditional expression  "((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)"  is complex.
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,Visit,The following statement contains a magic number: _matchStack.Push(  				delegate(IInputIterator iterator)  				{  					return LogTerminal(expression' iterator' () =>  					{  						if (matchtext.StartsWith("#x"))  						{  							//hexadecimal evaluation  							String hexinput = matchtext.Substring(2);  							if (hexinput == String.Empty)  								throw new ArgumentException("Hex value specified is empty.");  							if (hexinput.Length % 2 != 0)  								hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    							int total_compare_bytes = hexinput.Length / 2;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();    								for (Int32 j = 0; j < 2; j++)  								{  									// low nibble comparison  									Int32 nibbleOffset = 0;  									if (j == 0)  									{  										// high nibble comparison  										nibbleOffset = 4;  									}    									// j == 0 == high nibble  									// j == 1 == low nibble  									var tmp = (Byte)hexinput[i * 2 + j];  									if (tmp >= (Byte)'0' && tmp <= (Byte)'9')  									{  										tmp = (Byte)((tmp - (Byte)'0') << nibbleOffset);  									}  									else if (tmp >= (Byte)'a' && tmp <= (Byte)'f')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp >= (Byte)'A' && tmp <= (Byte)'F')  									{  										tmp = (Byte)((tmp - (Byte)'A' + 10) << nibbleOffset);  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException("Hex value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										if (  											((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  											((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  											((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  											((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  											((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  											((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  											((compareWith & (1 << nibbleOffset)) >> nibbleOffset) !=  											((tmp & (1 << nibbleOffset)) >> nibbleOffset)  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else if (matchtext.StartsWith("#b"))  						{  							// binary evaluation  							String binaryinput = matchtext.Substring(2);  							if (binaryinput == String.Empty)  								throw new ArgumentException("Binary value specified is empty.");  							if (binaryinput.Length % 8 != 0)  								binaryinput = "".PadLeft(8 - (binaryinput.Length % 8)' '0') + binaryinput;  							// on incomplete byte boundaries shift right    							int total_compare_bytes = binaryinput.Length / 8;    							for (int i = 0; i < total_compare_bytes; i++)  							{  								if (iterator.Current() == -1)  									return false;    								var compareWith = (Byte)iterator.Current();  								for (Int32 j = 0; j < 8; j++)  								{  									var tmp = (Byte)binaryinput[i * 8 + j];  									if (tmp == (Byte)'0')  									{  										tmp = 0x00;  									}  									else if (tmp == (Byte)'1')  									{  										tmp = 0x01;  									}  									else if (tmp == (Byte)'x' || tmp == (Byte)'X')  									{  										// don't care ignore nibble comparison  									}  									else  									{  										throw new ArgumentException(  											"Binary value specified contains invalid characters.");  									}    									if (!(tmp == (Byte)'x' || tmp == (Byte)'X'))  									{  										Int32 bit2compare = 7 - j;  										if (  											((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  											)  										{  											return false;  										}  									}  								}    								iterator.Next();  							}  						}  						else  						{  							// decimal codepoint evaluation  							String decimalinput = matchtext.Substring(1);  							if (decimalinput == String.Empty)  								throw new ArgumentException("Decimal codepoint value specified is empty.");  							if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  								throw new ArgumentException(  									"Decimal codepoint value specified contains invalid characters.");  							if (decimalinput.Length > 10) // 4'294'967'295  								throw new ArgumentException(  									"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    							UInt32 codepoint = UInt32.Parse(decimalinput);  							var c4 = (Byte)(codepoint >> 24);  							var c3 = (Byte)(codepoint >> 16);  							var c2 = (Byte)(codepoint >> 8);  							var c1 = (Byte)(codepoint);  							if (c4 != 0x00)  							{  								// consumes 4 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c4)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c3 != 0x00)  							{  								// consumes 3 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c3)  								{  									return false;  								}  								iterator.Next();  							}  							else if (c2 != 0x00)  							{  								// consumes 2 bytes  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  								if (iterator.Current() == -1 || iterator.Current() != c2)  								{  									return false;  								}  								iterator.Next();  							}  							else  							{  								// user must want to match null \0  								// (c1 != 0x00)  								// consumes 1 byte  								if (iterator.Current() == -1 || iterator.Current() != c1)  								{  									return false;  								}  								iterator.Next();  							}  						}    						return true;  					});    				});
Magic Number,NPEG.Extensions,StringExtensions,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\Extensions\StringExtensions.cs,ToHexStringFromByteArray,The following statement contains a magic number: var hex = new StringBuilder(bytes.Length * 2);
Magic Number,NPEG.Extensions,StringExtensions,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\Extensions\StringExtensions.cs,ToBytesFromHexString,The following statement contains a magic number: return (from Match item in items select Convert.ToByte(item.Groups["Hex"].Value' 16)).ToList();
Magic Number,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The following statement contains a magic number: switch (node.Token.Name)  				{  					case "Statement":  						hasPassedNodeDefinition = false;  						var statement = (StatementAstNode) node;    						if (statement.IsCaptured)  						{  							var captureStatement = new CapturingGroup(statement.Name' expressionStack.Pop()){RuleStart = node.Token.Start' RuleEnd = node.Token.End};  							if (  								statement.Children[0].Children[0].Children.Any(child => child.Token.Name == "OptionalFlags")  								&&  								statement.Children[0].Children[0].Children[1].Children.Any(child => child.Token.Name == "ReplaceBySingleChild")  								)  							{  								captureStatement.DoReplaceBySingleChildNode = true; // default is false  							}  							expression = captureStatement;  						}  						else  						{  							expression = expressionStack.Pop();  						}      						// Assumes Terminals are at the top of the file and   						// final root non terminal expression is at the bottom.  						if (wrapWithRecursionRule.Contains(statement.Name))  						{  							expression = new RecursionCreate(statement.Name' expression){RuleStart = node.Token.Start' RuleEnd = node.Token.End};  						}    						completedStatements.Add(statement.Name' expression);    						break;  					case "Sequence":  						var reverse = new Stack<AExpression>();  						for (int i = 0; i < node.Children.Count; i++)  						{  							reverse.Push(expressionStack.Pop());  						}    						Decimal sequence_cnt = (decimal) node.Children.Count - 1;  						for (; sequence_cnt > 0; sequence_cnt--)  						{  							left = reverse.Pop();  							right = reverse.Pop();  							reverse.Push(  								new Sequence(left' right) { RuleStart = node.Token.Start' RuleEnd = node.Token.End }  								);  						}    						expressionStack.Push(reverse.Pop());    						break;  					case "PrioritizedChoice":  						Int32 cnt = node.Children.Count - 1;  						for (Int32 i = 0; i < cnt; i++)  						{  							right = expressionStack.Pop();  							left = expressionStack.Pop();    							expressionStack.Push(  								new PrioritizedChoice(left' right) { RuleStart = node.Token.Start' RuleEnd = node.Token.End }  								);  						}  						break;      					case "Prefix":  						switch (node.Token.ValueAsString(_inputIterator)[0].ToString())  						{  							case "!":  								expressionStack.Push(new NotPredicate(expressionStack.Pop()) { RuleStart = node.Token.Start' RuleEnd = node.Token.End });  								break;  							case "&":  								expressionStack.Push(new AndPredicate(expressionStack.Pop()) { RuleStart = node.Token.Start' RuleEnd = node.Token.End });  								break;  							default:  								throw new Exception("Unsupported PEG Prefix.");  						}  						break;    					case "Suffix":  						switch (node.Children[0].Token.Name)  						{  							case "ZeroOrMore":  								expressionStack.Push(new ZeroOrMore(expressionStack.Pop()) { RuleStart = node.Token.Start' RuleEnd = node.Token.End });  								break;  							case "OneOrMore":  								expressionStack.Push(new OneOrMore(expressionStack.Pop()) { RuleStart = node.Token.Start' RuleEnd = node.Token.End });  								break;  							case "Optional":  								expressionStack.Push(new Optional(expressionStack.Pop()) { RuleStart = node.Token.Start' RuleEnd = node.Token.End });  								break;  							case "LimitingRepetition":  								switch (node.Children[0].Children[1].Token.Name)  								{  									case "BETWEEN":  										expressionStack.Push(new LimitingRepetition(expressionStack.Pop())  										                     	{  										                     		Min =  										                     			Int32.Parse(  										                     				node.Children[0].Children[1].Children[0].  																				Token.ValueAsString(_inputIterator))'  										                     		Max =  										                     			Int32.Parse(  										                     				node.Children[0].Children[1].Children[1].  																				Token.ValueAsString(_inputIterator))'  																	RuleStart = node.Token.Start'  																	RuleEnd = node.Token.End  										                     	});  										break;  									case "ATMOST":  										expressionStack.Push(new LimitingRepetition(expressionStack.Pop())  										                     	{  										                     		Min = null'  										                     		Max = Int32.Parse(node.Children[0].Children[1].Children[0].Token  																				.ValueAsString(_inputIterator))'  																	RuleStart = node.Token.Start'  																	RuleEnd = node.Token.End  										                     	});  										break;  									case "ATLEAST":  										expressionStack.Push(new LimitingRepetition(expressionStack.Pop())  										                     	{  										                     		Min =  										                     			Int32.Parse(node.Children[0].Children[1].Children[0].  																				Token.ValueAsString(_inputIterator))'  																	Max = null'  																	RuleStart = node.Token.Start'  																	RuleEnd = node.Token.End  										                     	});  										break;  									case "EXACT":  										Int32 exactcount = Int32.Parse(node.Children[0].Children[1].Token.ValueAsString(_inputIterator));  										expressionStack.Push(new LimitingRepetition(expressionStack.Pop()) { Min = exactcount' Max = exactcount' RuleStart = node.Token.Start' RuleEnd = node.Token.End });  										break;  									case "VariableLength":  										var variableLengthExpression = node.Children[0].Children[1].Token.ValueAsString(_inputIterator);  										expressionStack.Push(new LimitingRepetition(expressionStack.Pop()) { VariableLengthExpression = variableLengthExpression' RuleStart = node.Token.Start' RuleEnd = node.Token.End });  										break;  								}  								break;  							default:  								throw new Exception("Unsupported PEG Suffix.");  						}  						break;      					case "CapturingGroup":  						var capture = new CapturingGroup(node.Children[0].Token.ValueAsString(_inputIterator)' expressionStack.Pop()) { RuleStart = node.Token.Start' RuleEnd = node.Token.End };    						if (node.Children.Any(child => child.Token.Name == "OptionalFlags"))  						{  							if (node.Children[1].Children.Any(child => child.Token.Name == "ReplaceBySingleChild"))  							{  								capture.DoReplaceBySingleChildNode = true; // default is false  							}  							if (node.Children[1].Children.Any(child => child.Token.Name == "ReplacementNode"))  							{  								capture.DoCreateCustomAstNode = true; // default is false  							}  						}  						expressionStack.Push(capture);  						break;  					case "Group":  						break;  					case "AnyCharacter":  						expressionStack.Push(new AnyCharacter() { RuleStart = node.Token.Start' RuleEnd = node.Token.End });  						break;  					case "Literal":  						Boolean isCaseSensitive = true;  						if (node.Children.Count == 2)  							isCaseSensitive = false;    						expressionStack.Push(new Literal  						                     	{  						                     		IsCaseSensitive = isCaseSensitive'  						                     		MatchText = Regex.Replace(  														Regex.Replace(node.Children[0].Token.ValueAsString(_inputIterator)' @"\\(?<quote>""|')"' @"${quote}")  						                     			' @"\\\\"' @"\")'  													RuleStart = node.Token.Start'  													RuleEnd = node.Token.End  						                     	});  						break;  					case "CharacterClass":  						expressionStack.Push(new CharacterClass { ClassExpression = node.Token.ValueAsString(_inputIterator)' RuleStart = node.Token.Start' RuleEnd = node.Token.End });  						break;  					case "RecursionCall":  						expressionStack.Push((this)[node.Children[0].Token.ValueAsString(_inputIterator)]);  						break;  					case "CodePoint":  						expressionStack.Push(new CodePoint { Match = "#" + node.Children[0].Token.ValueAsString(_inputIterator)' RuleStart = node.Token.Start' RuleEnd = node.Token.End });  						break;  					case "Fatal":  						expressionStack.Push(new Fatal { Message = node.Children[0].Token.ValueAsString(_inputIterator)' RuleStart = node.Token.Start' RuleEnd = node.Token.End });  						break;  					case "Warn":  						expressionStack.Push(new Warn { Message = node.Children[0].Token.ValueAsString(_inputIterator)' RuleStart = node.Token.Start' RuleEnd = node.Token.End });  						break;  					case "DynamicBackReferencing":  						if (node.Children.Count == 1)  						{  							// no options specified only tag name.  							expressionStack.Push(new DynamicBackReference { BackReferenceName = node.Children[0].Token.ValueAsString(_inputIterator)' RuleStart = node.Token.Start' RuleEnd = node.Token.End });  						}  						else  						{  							throw new NotImplementedException(  								"Add IsCaseSensitive using children[1].Token.Name == IsCasesensitive");  						}  						break;  				}
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mFATAL,The following statement contains a magic number: return new CapturingGroup("Fatal"'  			                          new Sequence(  			                          	new Literal {MatchText = "Fatal"' IsCaseSensitive = false}'  			                          	new Sequence(  			                          		new Sequence(new Literal {MatchText = "<"}' new Optional(mSpace()))'  			                          		new PrioritizedChoice(  			                          			// with single quotes  			                          			new Sequence(  			                          				new Literal {MatchText = "'"}'  			                          				new CapturingGroup("Message"'  			                          				                   new OneOrMore(  			                          				                   	new PrioritizedChoice(  			                          				                   		new Sequence(  			                          				                   			new AndPredicate(new Literal {MatchText = @"\'"})'  			                          				                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          				                   			)'  			                          				                   		new CharacterClass {ClassExpression = @"[^']"}  			                          				                   		)  			                          				                   	)  			                          					)  			                          				)  			                          				.Sequence(new Literal {MatchText = "'"})  			                          			'  			                          			// without double quotes  			                          			new Sequence(  			                          				new Literal {MatchText = "\""}'  			                          				new CapturingGroup("Message"'  			                          				                   new OneOrMore(  			                          				                   	new PrioritizedChoice(  			                          				                   		new Sequence(  			                          				                   			new AndPredicate(new Literal {MatchText = @"\"""})'  			                          				                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          				                   			)'  			                          				                   		new CharacterClass {ClassExpression = @"[^""]"}  			                          				                   		)  			                          				                   	)  			                          					)  			                          				)  			                          				.Sequence(new Literal {MatchText = "\""})  			                          			)  			                          			.Or(  			                          				// no quotes  			                          			new Sequence(  			                          				new Optional(mSpace())'  			                          				new CapturingGroup("Message"'  			                          				                   new OneOrMore(  			                          				                   	new Sequence(  			                          				                   		new NotPredicate(  			                          				                   			new Sequence(new Optional(mSpace())'  			                          				                   			             new Literal {MatchText = ">"})  			                          				                   			)'  			                          				                   		new CharacterClass {ClassExpression = @"[^>]"}  			                          				                   		)  			                          				                   	)  			                          					)  			                          				)  			                          			)  			                          		)  			                          	)  			                          	.Sequence(  			                          		new Sequence(new Optional(mSpace())' new Literal {MatchText = ">"})  			                          	)  				);
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mFATAL,The following statement contains a magic number: return new CapturingGroup("Fatal"'  			                          new Sequence(  			                          	new Literal {MatchText = "Fatal"' IsCaseSensitive = false}'  			                          	new Sequence(  			                          		new Sequence(new Literal {MatchText = "<"}' new Optional(mSpace()))'  			                          		new PrioritizedChoice(  			                          			// with single quotes  			                          			new Sequence(  			                          				new Literal {MatchText = "'"}'  			                          				new CapturingGroup("Message"'  			                          				                   new OneOrMore(  			                          				                   	new PrioritizedChoice(  			                          				                   		new Sequence(  			                          				                   			new AndPredicate(new Literal {MatchText = @"\'"})'  			                          				                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          				                   			)'  			                          				                   		new CharacterClass {ClassExpression = @"[^']"}  			                          				                   		)  			                          				                   	)  			                          					)  			                          				)  			                          				.Sequence(new Literal {MatchText = "'"})  			                          			'  			                          			// without double quotes  			                          			new Sequence(  			                          				new Literal {MatchText = "\""}'  			                          				new CapturingGroup("Message"'  			                          				                   new OneOrMore(  			                          				                   	new PrioritizedChoice(  			                          				                   		new Sequence(  			                          				                   			new AndPredicate(new Literal {MatchText = @"\"""})'  			                          				                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          				                   			)'  			                          				                   		new CharacterClass {ClassExpression = @"[^""]"}  			                          				                   		)  			                          				                   	)  			                          					)  			                          				)  			                          				.Sequence(new Literal {MatchText = "\""})  			                          			)  			                          			.Or(  			                          				// no quotes  			                          			new Sequence(  			                          				new Optional(mSpace())'  			                          				new CapturingGroup("Message"'  			                          				                   new OneOrMore(  			                          				                   	new Sequence(  			                          				                   		new NotPredicate(  			                          				                   			new Sequence(new Optional(mSpace())'  			                          				                   			             new Literal {MatchText = ">"})  			                          				                   			)'  			                          				                   		new CharacterClass {ClassExpression = @"[^>]"}  			                          				                   		)  			                          				                   	)  			                          					)  			                          				)  			                          			)  			                          		)  			                          	)  			                          	.Sequence(  			                          		new Sequence(new Optional(mSpace())' new Literal {MatchText = ">"})  			                          	)  				);
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mFATAL,The following statement contains a magic number: return new CapturingGroup("Fatal"'  			                          new Sequence(  			                          	new Literal {MatchText = "Fatal"' IsCaseSensitive = false}'  			                          	new Sequence(  			                          		new Sequence(new Literal {MatchText = "<"}' new Optional(mSpace()))'  			                          		new PrioritizedChoice(  			                          			// with single quotes  			                          			new Sequence(  			                          				new Literal {MatchText = "'"}'  			                          				new CapturingGroup("Message"'  			                          				                   new OneOrMore(  			                          				                   	new PrioritizedChoice(  			                          				                   		new Sequence(  			                          				                   			new AndPredicate(new Literal {MatchText = @"\'"})'  			                          				                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          				                   			)'  			                          				                   		new CharacterClass {ClassExpression = @"[^']"}  			                          				                   		)  			                          				                   	)  			                          					)  			                          				)  			                          				.Sequence(new Literal {MatchText = "'"})  			                          			'  			                          			// without double quotes  			                          			new Sequence(  			                          				new Literal {MatchText = "\""}'  			                          				new CapturingGroup("Message"'  			                          				                   new OneOrMore(  			                          				                   	new PrioritizedChoice(  			                          				                   		new Sequence(  			                          				                   			new AndPredicate(new Literal {MatchText = @"\"""})'  			                          				                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          				                   			)'  			                          				                   		new CharacterClass {ClassExpression = @"[^""]"}  			                          				                   		)  			                          				                   	)  			                          					)  			                          				)  			                          				.Sequence(new Literal {MatchText = "\""})  			                          			)  			                          			.Or(  			                          				// no quotes  			                          			new Sequence(  			                          				new Optional(mSpace())'  			                          				new CapturingGroup("Message"'  			                          				                   new OneOrMore(  			                          				                   	new Sequence(  			                          				                   		new NotPredicate(  			                          				                   			new Sequence(new Optional(mSpace())'  			                          				                   			             new Literal {MatchText = ">"})  			                          				                   			)'  			                          				                   		new CharacterClass {ClassExpression = @"[^>]"}  			                          				                   		)  			                          				                   	)  			                          					)  			                          				)  			                          			)  			                          		)  			                          	)  			                          	.Sequence(  			                          		new Sequence(new Optional(mSpace())' new Literal {MatchText = ">"})  			                          	)  				);
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mFATAL,The following statement contains a magic number: return new CapturingGroup("Fatal"'  			                          new Sequence(  			                          	new Literal {MatchText = "Fatal"' IsCaseSensitive = false}'  			                          	new Sequence(  			                          		new Sequence(new Literal {MatchText = "<"}' new Optional(mSpace()))'  			                          		new PrioritizedChoice(  			                          			// with single quotes  			                          			new Sequence(  			                          				new Literal {MatchText = "'"}'  			                          				new CapturingGroup("Message"'  			                          				                   new OneOrMore(  			                          				                   	new PrioritizedChoice(  			                          				                   		new Sequence(  			                          				                   			new AndPredicate(new Literal {MatchText = @"\'"})'  			                          				                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          				                   			)'  			                          				                   		new CharacterClass {ClassExpression = @"[^']"}  			                          				                   		)  			                          				                   	)  			                          					)  			                          				)  			                          				.Sequence(new Literal {MatchText = "'"})  			                          			'  			                          			// without double quotes  			                          			new Sequence(  			                          				new Literal {MatchText = "\""}'  			                          				new CapturingGroup("Message"'  			                          				                   new OneOrMore(  			                          				                   	new PrioritizedChoice(  			                          				                   		new Sequence(  			                          				                   			new AndPredicate(new Literal {MatchText = @"\"""})'  			                          				                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          				                   			)'  			                          				                   		new CharacterClass {ClassExpression = @"[^""]"}  			                          				                   		)  			                          				                   	)  			                          					)  			                          				)  			                          				.Sequence(new Literal {MatchText = "\""})  			                          			)  			                          			.Or(  			                          				// no quotes  			                          			new Sequence(  			                          				new Optional(mSpace())'  			                          				new CapturingGroup("Message"'  			                          				                   new OneOrMore(  			                          				                   	new Sequence(  			                          				                   		new NotPredicate(  			                          				                   			new Sequence(new Optional(mSpace())'  			                          				                   			             new Literal {MatchText = ">"})  			                          				                   			)'  			                          				                   		new CharacterClass {ClassExpression = @"[^>]"}  			                          				                   		)  			                          				                   	)  			                          					)  			                          				)  			                          			)  			                          		)  			                          	)  			                          	.Sequence(  			                          		new Sequence(new Optional(mSpace())' new Literal {MatchText = ">"})  			                          	)  				);
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mLiteral,The following statement contains a magic number: return new CapturingGroup("Literal"'  			                          new Sequence(  			                          	new PrioritizedChoice(  			                          		new Sequence(  			                          			new Literal {MatchText = "\""}'  			                          			new CapturingGroup("MatchText"'  			                          			                   new OneOrMore(  			                          			                   	new PrioritizedChoice(  			                          			                   		new Sequence(  			                          			                   			new AndPredicate(  			                          			                   				new Literal {MatchText = @"\\"}  			                          			                   				)  			                          			                   			'  			                          			                   			// consumes two characters \" until it finds " not escaped  			                          			                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   			)  			                          			                   		'  			                          			                   		new PrioritizedChoice(  			                          			                   			new Sequence(  			                          			                   				new AndPredicate(  			                          			                   					new Literal {MatchText = @"\"""}  			                          			                   					)  			                          			                   				'  			                          			                   				// consumes two characters \" until it finds " not escaped  			                          			                   				new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   				)  			                          			                   			'  			                          			                   			new CharacterClass {ClassExpression = "[^\"]"}  			                          			                   			)  			                          			                   		)  			                          			                   	)  			                          				)  			                          			)  			                          			.Sequence(new Literal {MatchText = "\""})  			                          		'  			                          		new Sequence(  			                          			new Literal {MatchText = "'"}'  			                          			new CapturingGroup("MatchText"'  			                          			                   new OneOrMore(  			                          			                   	new PrioritizedChoice(  			                          			                   		new Sequence(  			                          			                   			new AndPredicate(  			                          			                   				new Literal {MatchText = @"\\"}  			                          			                   				)  			                          			                   			'  			                          			                   			// consumes two characters \" until it finds " not escaped  			                          			                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   			)  			                          			                   		'  			                          			                   		new PrioritizedChoice(  			                          			                   			new Sequence(  			                          			                   				new AndPredicate(  			                          			                   					new Literal {MatchText = @"\'"}  			                          			                   					)  			                          			                   				'  			                          			                   				// consumes to characters \' until it finds ' not escaped  			                          			                   				new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   				)  			                          			                   			'  			                          			                   			new CharacterClass {ClassExpression = "[^']"}  			                          			                   			)  			                          			                   		)  			                          			                   	)  			                          				)  			                          			)  			                          			.Sequence(new Literal {MatchText = "'"})  			                          		)  			                          	'  			                          	// optional do case-insensitive pattern matching.   			                          	new Optional(new CapturingGroup("CaseInsensitive"' new Literal {MatchText = @"\i"}))  			                          	)  				);
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mLiteral,The following statement contains a magic number: return new CapturingGroup("Literal"'  			                          new Sequence(  			                          	new PrioritizedChoice(  			                          		new Sequence(  			                          			new Literal {MatchText = "\""}'  			                          			new CapturingGroup("MatchText"'  			                          			                   new OneOrMore(  			                          			                   	new PrioritizedChoice(  			                          			                   		new Sequence(  			                          			                   			new AndPredicate(  			                          			                   				new Literal {MatchText = @"\\"}  			                          			                   				)  			                          			                   			'  			                          			                   			// consumes two characters \" until it finds " not escaped  			                          			                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   			)  			                          			                   		'  			                          			                   		new PrioritizedChoice(  			                          			                   			new Sequence(  			                          			                   				new AndPredicate(  			                          			                   					new Literal {MatchText = @"\"""}  			                          			                   					)  			                          			                   				'  			                          			                   				// consumes two characters \" until it finds " not escaped  			                          			                   				new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   				)  			                          			                   			'  			                          			                   			new CharacterClass {ClassExpression = "[^\"]"}  			                          			                   			)  			                          			                   		)  			                          			                   	)  			                          				)  			                          			)  			                          			.Sequence(new Literal {MatchText = "\""})  			                          		'  			                          		new Sequence(  			                          			new Literal {MatchText = "'"}'  			                          			new CapturingGroup("MatchText"'  			                          			                   new OneOrMore(  			                          			                   	new PrioritizedChoice(  			                          			                   		new Sequence(  			                          			                   			new AndPredicate(  			                          			                   				new Literal {MatchText = @"\\"}  			                          			                   				)  			                          			                   			'  			                          			                   			// consumes two characters \" until it finds " not escaped  			                          			                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   			)  			                          			                   		'  			                          			                   		new PrioritizedChoice(  			                          			                   			new Sequence(  			                          			                   				new AndPredicate(  			                          			                   					new Literal {MatchText = @"\'"}  			                          			                   					)  			                          			                   				'  			                          			                   				// consumes to characters \' until it finds ' not escaped  			                          			                   				new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   				)  			                          			                   			'  			                          			                   			new CharacterClass {ClassExpression = "[^']"}  			                          			                   			)  			                          			                   		)  			                          			                   	)  			                          				)  			                          			)  			                          			.Sequence(new Literal {MatchText = "'"})  			                          		)  			                          	'  			                          	// optional do case-insensitive pattern matching.   			                          	new Optional(new CapturingGroup("CaseInsensitive"' new Literal {MatchText = @"\i"}))  			                          	)  				);
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mLiteral,The following statement contains a magic number: return new CapturingGroup("Literal"'  			                          new Sequence(  			                          	new PrioritizedChoice(  			                          		new Sequence(  			                          			new Literal {MatchText = "\""}'  			                          			new CapturingGroup("MatchText"'  			                          			                   new OneOrMore(  			                          			                   	new PrioritizedChoice(  			                          			                   		new Sequence(  			                          			                   			new AndPredicate(  			                          			                   				new Literal {MatchText = @"\\"}  			                          			                   				)  			                          			                   			'  			                          			                   			// consumes two characters \" until it finds " not escaped  			                          			                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   			)  			                          			                   		'  			                          			                   		new PrioritizedChoice(  			                          			                   			new Sequence(  			                          			                   				new AndPredicate(  			                          			                   					new Literal {MatchText = @"\"""}  			                          			                   					)  			                          			                   				'  			                          			                   				// consumes two characters \" until it finds " not escaped  			                          			                   				new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   				)  			                          			                   			'  			                          			                   			new CharacterClass {ClassExpression = "[^\"]"}  			                          			                   			)  			                          			                   		)  			                          			                   	)  			                          				)  			                          			)  			                          			.Sequence(new Literal {MatchText = "\""})  			                          		'  			                          		new Sequence(  			                          			new Literal {MatchText = "'"}'  			                          			new CapturingGroup("MatchText"'  			                          			                   new OneOrMore(  			                          			                   	new PrioritizedChoice(  			                          			                   		new Sequence(  			                          			                   			new AndPredicate(  			                          			                   				new Literal {MatchText = @"\\"}  			                          			                   				)  			                          			                   			'  			                          			                   			// consumes two characters \" until it finds " not escaped  			                          			                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   			)  			                          			                   		'  			                          			                   		new PrioritizedChoice(  			                          			                   			new Sequence(  			                          			                   				new AndPredicate(  			                          			                   					new Literal {MatchText = @"\'"}  			                          			                   					)  			                          			                   				'  			                          			                   				// consumes to characters \' until it finds ' not escaped  			                          			                   				new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   				)  			                          			                   			'  			                          			                   			new CharacterClass {ClassExpression = "[^']"}  			                          			                   			)  			                          			                   		)  			                          			                   	)  			                          				)  			                          			)  			                          			.Sequence(new Literal {MatchText = "'"})  			                          		)  			                          	'  			                          	// optional do case-insensitive pattern matching.   			                          	new Optional(new CapturingGroup("CaseInsensitive"' new Literal {MatchText = @"\i"}))  			                          	)  				);
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mLiteral,The following statement contains a magic number: return new CapturingGroup("Literal"'  			                          new Sequence(  			                          	new PrioritizedChoice(  			                          		new Sequence(  			                          			new Literal {MatchText = "\""}'  			                          			new CapturingGroup("MatchText"'  			                          			                   new OneOrMore(  			                          			                   	new PrioritizedChoice(  			                          			                   		new Sequence(  			                          			                   			new AndPredicate(  			                          			                   				new Literal {MatchText = @"\\"}  			                          			                   				)  			                          			                   			'  			                          			                   			// consumes two characters \" until it finds " not escaped  			                          			                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   			)  			                          			                   		'  			                          			                   		new PrioritizedChoice(  			                          			                   			new Sequence(  			                          			                   				new AndPredicate(  			                          			                   					new Literal {MatchText = @"\"""}  			                          			                   					)  			                          			                   				'  			                          			                   				// consumes two characters \" until it finds " not escaped  			                          			                   				new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   				)  			                          			                   			'  			                          			                   			new CharacterClass {ClassExpression = "[^\"]"}  			                          			                   			)  			                          			                   		)  			                          			                   	)  			                          				)  			                          			)  			                          			.Sequence(new Literal {MatchText = "\""})  			                          		'  			                          		new Sequence(  			                          			new Literal {MatchText = "'"}'  			                          			new CapturingGroup("MatchText"'  			                          			                   new OneOrMore(  			                          			                   	new PrioritizedChoice(  			                          			                   		new Sequence(  			                          			                   			new AndPredicate(  			                          			                   				new Literal {MatchText = @"\\"}  			                          			                   				)  			                          			                   			'  			                          			                   			// consumes two characters \" until it finds " not escaped  			                          			                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   			)  			                          			                   		'  			                          			                   		new PrioritizedChoice(  			                          			                   			new Sequence(  			                          			                   				new AndPredicate(  			                          			                   					new Literal {MatchText = @"\'"}  			                          			                   					)  			                          			                   				'  			                          			                   				// consumes to characters \' until it finds ' not escaped  			                          			                   				new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   				)  			                          			                   			'  			                          			                   			new CharacterClass {ClassExpression = "[^']"}  			                          			                   			)  			                          			                   		)  			                          			                   	)  			                          				)  			                          			)  			                          			.Sequence(new Literal {MatchText = "'"})  			                          		)  			                          	'  			                          	// optional do case-insensitive pattern matching.   			                          	new Optional(new CapturingGroup("CaseInsensitive"' new Literal {MatchText = @"\i"}))  			                          	)  				);
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mLiteral,The following statement contains a magic number: return new CapturingGroup("Literal"'  			                          new Sequence(  			                          	new PrioritizedChoice(  			                          		new Sequence(  			                          			new Literal {MatchText = "\""}'  			                          			new CapturingGroup("MatchText"'  			                          			                   new OneOrMore(  			                          			                   	new PrioritizedChoice(  			                          			                   		new Sequence(  			                          			                   			new AndPredicate(  			                          			                   				new Literal {MatchText = @"\\"}  			                          			                   				)  			                          			                   			'  			                          			                   			// consumes two characters \" until it finds " not escaped  			                          			                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   			)  			                          			                   		'  			                          			                   		new PrioritizedChoice(  			                          			                   			new Sequence(  			                          			                   				new AndPredicate(  			                          			                   					new Literal {MatchText = @"\"""}  			                          			                   					)  			                          			                   				'  			                          			                   				// consumes two characters \" until it finds " not escaped  			                          			                   				new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   				)  			                          			                   			'  			                          			                   			new CharacterClass {ClassExpression = "[^\"]"}  			                          			                   			)  			                          			                   		)  			                          			                   	)  			                          				)  			                          			)  			                          			.Sequence(new Literal {MatchText = "\""})  			                          		'  			                          		new Sequence(  			                          			new Literal {MatchText = "'"}'  			                          			new CapturingGroup("MatchText"'  			                          			                   new OneOrMore(  			                          			                   	new PrioritizedChoice(  			                          			                   		new Sequence(  			                          			                   			new AndPredicate(  			                          			                   				new Literal {MatchText = @"\\"}  			                          			                   				)  			                          			                   			'  			                          			                   			// consumes two characters \" until it finds " not escaped  			                          			                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   			)  			                          			                   		'  			                          			                   		new PrioritizedChoice(  			                          			                   			new Sequence(  			                          			                   				new AndPredicate(  			                          			                   					new Literal {MatchText = @"\'"}  			                          			                   					)  			                          			                   				'  			                          			                   				// consumes to characters \' until it finds ' not escaped  			                          			                   				new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   				)  			                          			                   			'  			                          			                   			new CharacterClass {ClassExpression = "[^']"}  			                          			                   			)  			                          			                   		)  			                          			                   	)  			                          				)  			                          			)  			                          			.Sequence(new Literal {MatchText = "'"})  			                          		)  			                          	'  			                          	// optional do case-insensitive pattern matching.   			                          	new Optional(new CapturingGroup("CaseInsensitive"' new Literal {MatchText = @"\i"}))  			                          	)  				);
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mLiteral,The following statement contains a magic number: return new CapturingGroup("Literal"'  			                          new Sequence(  			                          	new PrioritizedChoice(  			                          		new Sequence(  			                          			new Literal {MatchText = "\""}'  			                          			new CapturingGroup("MatchText"'  			                          			                   new OneOrMore(  			                          			                   	new PrioritizedChoice(  			                          			                   		new Sequence(  			                          			                   			new AndPredicate(  			                          			                   				new Literal {MatchText = @"\\"}  			                          			                   				)  			                          			                   			'  			                          			                   			// consumes two characters \" until it finds " not escaped  			                          			                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   			)  			                          			                   		'  			                          			                   		new PrioritizedChoice(  			                          			                   			new Sequence(  			                          			                   				new AndPredicate(  			                          			                   					new Literal {MatchText = @"\"""}  			                          			                   					)  			                          			                   				'  			                          			                   				// consumes two characters \" until it finds " not escaped  			                          			                   				new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   				)  			                          			                   			'  			                          			                   			new CharacterClass {ClassExpression = "[^\"]"}  			                          			                   			)  			                          			                   		)  			                          			                   	)  			                          				)  			                          			)  			                          			.Sequence(new Literal {MatchText = "\""})  			                          		'  			                          		new Sequence(  			                          			new Literal {MatchText = "'"}'  			                          			new CapturingGroup("MatchText"'  			                          			                   new OneOrMore(  			                          			                   	new PrioritizedChoice(  			                          			                   		new Sequence(  			                          			                   			new AndPredicate(  			                          			                   				new Literal {MatchText = @"\\"}  			                          			                   				)  			                          			                   			'  			                          			                   			// consumes two characters \" until it finds " not escaped  			                          			                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   			)  			                          			                   		'  			                          			                   		new PrioritizedChoice(  			                          			                   			new Sequence(  			                          			                   				new AndPredicate(  			                          			                   					new Literal {MatchText = @"\'"}  			                          			                   					)  			                          			                   				'  			                          			                   				// consumes to characters \' until it finds ' not escaped  			                          			                   				new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   				)  			                          			                   			'  			                          			                   			new CharacterClass {ClassExpression = "[^']"}  			                          			                   			)  			                          			                   		)  			                          			                   	)  			                          				)  			                          			)  			                          			.Sequence(new Literal {MatchText = "'"})  			                          		)  			                          	'  			                          	// optional do case-insensitive pattern matching.   			                          	new Optional(new CapturingGroup("CaseInsensitive"' new Literal {MatchText = @"\i"}))  			                          	)  				);
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mLiteral,The following statement contains a magic number: return new CapturingGroup("Literal"'  			                          new Sequence(  			                          	new PrioritizedChoice(  			                          		new Sequence(  			                          			new Literal {MatchText = "\""}'  			                          			new CapturingGroup("MatchText"'  			                          			                   new OneOrMore(  			                          			                   	new PrioritizedChoice(  			                          			                   		new Sequence(  			                          			                   			new AndPredicate(  			                          			                   				new Literal {MatchText = @"\\"}  			                          			                   				)  			                          			                   			'  			                          			                   			// consumes two characters \" until it finds " not escaped  			                          			                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   			)  			                          			                   		'  			                          			                   		new PrioritizedChoice(  			                          			                   			new Sequence(  			                          			                   				new AndPredicate(  			                          			                   					new Literal {MatchText = @"\"""}  			                          			                   					)  			                          			                   				'  			                          			                   				// consumes two characters \" until it finds " not escaped  			                          			                   				new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   				)  			                          			                   			'  			                          			                   			new CharacterClass {ClassExpression = "[^\"]"}  			                          			                   			)  			                          			                   		)  			                          			                   	)  			                          				)  			                          			)  			                          			.Sequence(new Literal {MatchText = "\""})  			                          		'  			                          		new Sequence(  			                          			new Literal {MatchText = "'"}'  			                          			new CapturingGroup("MatchText"'  			                          			                   new OneOrMore(  			                          			                   	new PrioritizedChoice(  			                          			                   		new Sequence(  			                          			                   			new AndPredicate(  			                          			                   				new Literal {MatchText = @"\\"}  			                          			                   				)  			                          			                   			'  			                          			                   			// consumes two characters \" until it finds " not escaped  			                          			                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   			)  			                          			                   		'  			                          			                   		new PrioritizedChoice(  			                          			                   			new Sequence(  			                          			                   				new AndPredicate(  			                          			                   					new Literal {MatchText = @"\'"}  			                          			                   					)  			                          			                   				'  			                          			                   				// consumes to characters \' until it finds ' not escaped  			                          			                   				new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   				)  			                          			                   			'  			                          			                   			new CharacterClass {ClassExpression = "[^']"}  			                          			                   			)  			                          			                   		)  			                          			                   	)  			                          				)  			                          			)  			                          			.Sequence(new Literal {MatchText = "'"})  			                          		)  			                          	'  			                          	// optional do case-insensitive pattern matching.   			                          	new Optional(new CapturingGroup("CaseInsensitive"' new Literal {MatchText = @"\i"}))  			                          	)  				);
Magic Number,NPEG.GrammarInterpreter,PEGrammar,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\PEGrammar.cs,mLiteral,The following statement contains a magic number: return new CapturingGroup("Literal"'  			                          new Sequence(  			                          	new PrioritizedChoice(  			                          		new Sequence(  			                          			new Literal {MatchText = "\""}'  			                          			new CapturingGroup("MatchText"'  			                          			                   new OneOrMore(  			                          			                   	new PrioritizedChoice(  			                          			                   		new Sequence(  			                          			                   			new AndPredicate(  			                          			                   				new Literal {MatchText = @"\\"}  			                          			                   				)  			                          			                   			'  			                          			                   			// consumes two characters \" until it finds " not escaped  			                          			                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   			)  			                          			                   		'  			                          			                   		new PrioritizedChoice(  			                          			                   			new Sequence(  			                          			                   				new AndPredicate(  			                          			                   					new Literal {MatchText = @"\"""}  			                          			                   					)  			                          			                   				'  			                          			                   				// consumes two characters \" until it finds " not escaped  			                          			                   				new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   				)  			                          			                   			'  			                          			                   			new CharacterClass {ClassExpression = "[^\"]"}  			                          			                   			)  			                          			                   		)  			                          			                   	)  			                          				)  			                          			)  			                          			.Sequence(new Literal {MatchText = "\""})  			                          		'  			                          		new Sequence(  			                          			new Literal {MatchText = "'"}'  			                          			new CapturingGroup("MatchText"'  			                          			                   new OneOrMore(  			                          			                   	new PrioritizedChoice(  			                          			                   		new Sequence(  			                          			                   			new AndPredicate(  			                          			                   				new Literal {MatchText = @"\\"}  			                          			                   				)  			                          			                   			'  			                          			                   			// consumes two characters \" until it finds " not escaped  			                          			                   			new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   			)  			                          			                   		'  			                          			                   		new PrioritizedChoice(  			                          			                   			new Sequence(  			                          			                   				new AndPredicate(  			                          			                   					new Literal {MatchText = @"\'"}  			                          			                   					)  			                          			                   				'  			                          			                   				// consumes to characters \' until it finds ' not escaped  			                          			                   				new LimitingRepetition(new AnyCharacter()) {Min = 2' Max = 2}  			                          			                   				)  			                          			                   			'  			                          			                   			new CharacterClass {ClassExpression = "[^']"}  			                          			                   			)  			                          			                   		)  			                          			                   	)  			                          				)  			                          			)  			                          			.Sequence(new Literal {MatchText = "'"})  			                          		)  			                          	'  			                          	// optional do case-insensitive pattern matching.   			                          	new Optional(new CapturingGroup("CaseInsensitive"' new Literal {MatchText = @"\i"}))  			                          	)  				);
Magic Number,NPEG.GrammarInterpreter,LimitingRepetitionVariableLengthExpressionSolver,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\LimitingRepetitionVariableLengthExpressionSolver.cs,VisitEnter,The following statement contains a magic number: switch (node.Token.Name)  			{  				case "Variable":  					var key = node.Children[0].Token.ValueAsString(_userExpressionIterator);  					if (!_variableValues.Any(x=>x.Token.Name.Equals(key' StringComparison.InvariantCultureIgnoreCase)))  					{  						throw new ArgumentOutOfRangeException(string.Format("backreference key {0} does not exist."' key));  					}    					uint value = 0;    					foreach (var b in _variableValues.First(x=>x.Token.Name.Equals(key' StringComparison.InvariantCultureIgnoreCase)).Token.ValueAsBytes(_inputIterator).Reverse())  					{  						value <<= 8;  						value |= (uint)b & 0xFF;  					}  					_results.Peek().Push(value);  					break;  				case "Symbol":  					_symbol.Peek().Push(node.Token.ValueAsString(_userExpressionIterator)[0]);  					break;  				case "Digit":  					_results.Peek().Push(double.Parse(node.Token.ValueAsString(_userExpressionIterator)));  					break;  				case "Sum":  					_symbol.Push(new Stack<char>());  					_results.Push(new Stack<double>());  					break;  				case "Product":  					_symbol.Push(new Stack<char>());  					_results.Push(new Stack<double>());  					break;  			}
Duplicate Code,NPEG,NpegParserVisitor,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\NpegParserVisitor.cs,VisitLeave,The method contains a code clone-set at the following line numbers (starting from the method definition): ((17' 39)' (50' 72))
Missing Default,NPEG.GrammarInterpreter.AstNodes,InterpreterAstNode,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\InterpreterAstNode.cs,VisitLeave,The following switch statement is missing a default case: switch (node.Children[0].Children[1].Token.Name)  								{  									case "BETWEEN":  										expressionStack.Push(new LimitingRepetition(expressionStack.Pop())  										                     	{  										                     		Min =  										                     			Int32.Parse(  										                     				node.Children[0].Children[1].Children[0].  																				Token.ValueAsString(_inputIterator))'  										                     		Max =  										                     			Int32.Parse(  										                     				node.Children[0].Children[1].Children[1].  																				Token.ValueAsString(_inputIterator))'  																	RuleStart = node.Token.Start'  																	RuleEnd = node.Token.End  										                     	});  										break;  									case "ATMOST":  										expressionStack.Push(new LimitingRepetition(expressionStack.Pop())  										                     	{  										                     		Min = null'  										                     		Max = Int32.Parse(node.Children[0].Children[1].Children[0].Token  																				.ValueAsString(_inputIterator))'  																	RuleStart = node.Token.Start'  																	RuleEnd = node.Token.End  										                     	});  										break;  									case "ATLEAST":  										expressionStack.Push(new LimitingRepetition(expressionStack.Pop())  										                     	{  										                     		Min =  										                     			Int32.Parse(node.Children[0].Children[1].Children[0].  																				Token.ValueAsString(_inputIterator))'  																	Max = null'  																	RuleStart = node.Token.Start'  																	RuleEnd = node.Token.End  										                     	});  										break;  									case "EXACT":  										Int32 exactcount = Int32.Parse(node.Children[0].Children[1].Token.ValueAsString(_inputIterator));  										expressionStack.Push(new LimitingRepetition(expressionStack.Pop()) { Min = exactcount' Max = exactcount' RuleStart = node.Token.Start' RuleEnd = node.Token.End });  										break;  									case "VariableLength":  										var variableLengthExpression = node.Children[0].Children[1].Token.ValueAsString(_inputIterator);  										expressionStack.Push(new LimitingRepetition(expressionStack.Pop()) { VariableLengthExpression = variableLengthExpression' RuleStart = node.Token.Start' RuleEnd = node.Token.End });  										break;  								}
Missing Default,NPEG.GrammarInterpreter.AstNodes,PeGrammarAstNodeFactory,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\AstNodes\PeGrammarAstNodeFactory.cs,Create,The following switch statement is missing a default case: switch (original.Token.Name)  			{  				case "Statement":  					return new StatementAstNode(_inputIterator);  				case "PEG":  					return new InterpreterAstNode(_inputIterator);  			}
Missing Default,NPEG.GrammarInterpreter,LimitingRepetitionVariableLengthExpressionSolver,D:\research\architectureSmells\repos\leblancmeneses_NPEG\NPEG\GrammarInterpreter\LimitingRepetitionVariableLengthExpressionSolver.cs,VisitEnter,The following switch statement is missing a default case: switch (node.Token.Name)  			{  				case "Variable":  					var key = node.Children[0].Token.ValueAsString(_userExpressionIterator);  					if (!_variableValues.Any(x=>x.Token.Name.Equals(key' StringComparison.InvariantCultureIgnoreCase)))  					{  						throw new ArgumentOutOfRangeException(string.Format("backreference key {0} does not exist."' key));  					}    					uint value = 0;    					foreach (var b in _variableValues.First(x=>x.Token.Name.Equals(key' StringComparison.InvariantCultureIgnoreCase)).Token.ValueAsBytes(_inputIterator).Reverse())  					{  						value <<= 8;  						value |= (uint)b & 0xFF;  					}  					_results.Peek().Push(value);  					break;  				case "Symbol":  					_symbol.Peek().Push(node.Token.ValueAsString(_userExpressionIterator)[0]);  					break;  				case "Digit":  					_results.Peek().Push(double.Parse(node.Token.ValueAsString(_userExpressionIterator)));  					break;  				case "Sum":  					_symbol.Push(new Stack<char>());  					_results.Push(new Stack<double>());  					break;  				case "Product":  					_symbol.Push(new Stack<char>());  					_results.Push(new Stack<double>());  					break;  			}
