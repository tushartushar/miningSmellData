Implementation smell,Namespace,Class,File,Method,Description
Long Method,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The method has 201 lines of code.
Complex Method,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CapturingGroup,Cyclomatic complexity of the method is 9
Complex Method,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,Cyclomatic complexity of the method is 11
Long Statement,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CapturingGroup,The length of the statement  "					"Second constructor overload is required during instantiation.  Function pointer to AstNodeCreate method requires to be set with this parser implementation."); " is 159.
Long Statement,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CapturingGroup,The length of the statement  "					// logic inside astnodereplacement is to create properties' business names' that internally check Children collection to mine data. " is 131.
Complex Conditional,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The conditional expression  "((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)"  is complex.
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Magic Number,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,CodePoint,The following statement contains a magic number: if (matchCode.StartsWith("#x"))  			{  				//hexadecimal evaluation  				String hexinput = matchCode.Substring(2);  				if (hexinput == String.Empty)  					throw new ArgumentException("Hex value specified is empty.");  				if (hexinput.Length%2 != 0)  					hexinput = "0" + hexinput; // on incomplete byte boundaries shift right    				int total_compare_bytes = hexinput.Length/2;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();    					for (Int32 j = 0; j < 2; j++)  					{  						// low nibble comparison  						Int32 nibbleOffset = 0;  						if (j == 0)  						{  							// high nibble comparison  							nibbleOffset = 4;  						}    						// j == 0 == high nibble  						// j == 1 == low nibble  						var tmp = (Byte) hexinput[i*2 + j];  						if (tmp >= (Byte) '0' && tmp <= (Byte) '9')  						{  							tmp = (Byte) ((tmp - (Byte) '0') << nibbleOffset);  						}  						else if (tmp >= (Byte) 'a' && tmp <= (Byte) 'f')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp >= (Byte) 'A' && tmp <= (Byte) 'F')  						{  							tmp = (Byte) ((tmp - (Byte) 'A' + 10) << nibbleOffset);  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Hex value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							if (  								((compareWith & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) !=  								((tmp & (1 << (nibbleOffset + 3))) >> (nibbleOffset + 3)) ||  								((compareWith & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) !=  								((tmp & (1 << (nibbleOffset + 2))) >> (nibbleOffset + 2)) ||  								((compareWith & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) !=  								((tmp & (1 << (nibbleOffset + 1))) >> (nibbleOffset + 1)) ||  								((compareWith & (1 << nibbleOffset)) >> nibbleOffset) != ((tmp & (1 << nibbleOffset)) >> nibbleOffset)  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else if (matchCode.StartsWith("#b"))  			{  				// binary evaluation  				String binaryinput = matchCode.Substring(2);  				if (binaryinput == String.Empty)  					throw new ArgumentException("Binary value specified is empty.");  				if (binaryinput.Length%8 != 0)  					binaryinput = "".PadLeft(8 - (binaryinput.Length%8)' '0') + binaryinput;  						// on incomplete byte boundaries shift right    				int total_compare_bytes = binaryinput.Length/8;    				for (int i = 0; i < total_compare_bytes; i++)  				{  					if (iterator.Current() == -1)  						return false;    					var compareWith = (Byte) iterator.Current();  					for (Int32 j = 0; j < 8; j++)  					{  						var tmp = (Byte) binaryinput[i*8 + j];  						if (tmp == (Byte) '0')  						{  							tmp = 0x00;  						}  						else if (tmp == (Byte) '1')  						{  							tmp = 0x01;  						}  						else if (tmp == (Byte) 'x' || tmp == (Byte) 'X')  						{  							// don't care ignore nibble comparison  						}  						else  						{  							throw new ArgumentException("Binary value specified contains invalid characters.");  						}    						if (!(tmp == (Byte) 'x' || tmp == (Byte) 'X'))  						{  							Int32 bit2compare = 7 - j;  							if (  								((compareWith & (1 << bit2compare)) >> bit2compare) != tmp  								)  							{  								return false;  							}  						}  					}    					iterator.Next();  				}  			}  			else  			{  				// decimal codepoint evaluation  				String decimalinput = matchCode.Substring(1);  				if (decimalinput == String.Empty)  					throw new ArgumentException("Decimal codepoint value specified is empty.");  				if (!Regex.IsMatch(decimalinput' @"^[0-9]+$"))  					throw new ArgumentException("Decimal codepoint value specified contains invalid characters.");  				if (decimalinput.Length > 10) // 4'294'967'295  					throw new ArgumentException(  						"Decimal codepoint value exceeds 4 byte maximum length.  Largest decimal value possible 2^32");    				UInt32 codepoint = UInt32.Parse(decimalinput);  				var c4 = (Byte) (codepoint >> 24);  				var c3 = (Byte) (codepoint >> 16);  				var c2 = (Byte) (codepoint >> 8);  				var c1 = (Byte) (codepoint);  				if (c4 != 0x00)  				{  					// consumes 4 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c4)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c3 != 0x00)  				{  					// consumes 3 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c3)  					{  						return false;  					}  					iterator.Next();  				}  				else if (c2 != 0x00)  				{  					// consumes 2 bytes  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  					if (iterator.Current() == -1 || iterator.Current() != c2)  					{  						return false;  					}  					iterator.Next();  				}  				else  				{  					// user must want to match null \0  					// (c1 != 0x00)  					// consumes 1 byte  					if (iterator.Current() == -1 || iterator.Current() != c1)  					{  						return false;  					}  					iterator.Next();  				}  			}
Duplicate Code,RobustHaven.Text.Npeg,NpegParser,C:\repos\leblancmeneses_NPEG\Languages\npeg_csharp\RobustHaven.Text.Npeg\NpegParser.cs,PrioritizedChoice,The method contains a code clone-set at the following line numbers (starting from the method definition): ((8' 27)' (34' 53))
