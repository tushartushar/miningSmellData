Implementation smell,Namespace,Class,File,Method,Description
Long Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ReadFixedArg,The method has 235 lines of code.
Long Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The method has 181 lines of code.
Long Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The method has 282 lines of code.
Long Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteField,The method has 109 lines of code.
Long Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WritePermissionSet,The method has 122 lines of code.
Long Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteSignatureType,The method has 169 lines of code.
Long Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The method has 382 lines of code.
Long Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineMethod,The method has 121 lines of code.
Complex Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteData,Cyclomatic complexity of the method is 9
Complex Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteType,Cyclomatic complexity of the method is 28
Complex Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteGenericParameterDef,Cyclomatic complexity of the method is 12
Complex Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteProperty,Cyclomatic complexity of the method is 8
Complex Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,Cyclomatic complexity of the method is 43
Complex Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WritePInvokeImpl,Cyclomatic complexity of the method is 10
Complex Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMarshalAs,Cyclomatic complexity of the method is 14
Complex Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,QuoteIdentifier,Cyclomatic complexity of the method is 14
Complex Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteField,Cyclomatic complexity of the method is 17
Complex Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteModuleManifest,Cyclomatic complexity of the method is 10
Complex Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,Cyclomatic complexity of the method is 9
Complex Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteBytes,Cyclomatic complexity of the method is 9
Complex Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,Cyclomatic complexity of the method is 24
Complex Method,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineMethod,Cyclomatic complexity of the method is 14
Long Parameter List,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,AppendTypeName,The method has 5 parameters. Parameters: sb' type' typeName' noself' securityCompatHack
Long Parameter List,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ReadNamedArguments,The method has 5 parameters. Parameters: sb' br' named' level' securityCompatHack
Long Parameter List,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteData,The method has 5 parameters. Parameters: lw' section' rva' size' uninitialized
Long Parameter List,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMarshalAs,The method has 5 parameters. Parameters: lw' level' hasFieldMarshalRecord' marshal' wrap
Long Parameter List,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMarshalAs,The method has 5 parameters. Parameters: sb' level' hasFieldMarshalRecord' marshal' wrap
Long Parameter List,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WritePermissionSet,The method has 5 parameters. Parameters: lw' level' action' list' metadataToken
Long Parameter List,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The method has 5 parameters. Parameters: lw' mb' body' genericTypeArguments' genericMethodArguments
Long Parameter List,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineVar,The method has 5 parameters. Parameters: lw' mb' opcode' parameters' index
Long Parameter List,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineMethod,The method has 5 parameters. Parameters: lw' mb' optionalParameterTypes' customModifiers' methodimpl
Long Identifier,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,,The length of the parameter IMAGE_SCN_CNT_INITIALIZED_DATA is 30.
Long Identifier,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,,The length of the parameter IMAGE_SCN_CNT_UNINITIALIZED_DATA is 32.
Long Identifier,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,,The length of the parameter COMIMAGE_FLAGS_STRONGNAMESIGNED is 31.
Long Identifier,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,,The length of the parameter COMIMAGE_FLAGS_NATIVE_ENTRYPOINT is 32.
Long Identifier,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,,The length of the parameter COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN is 42.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,AppendTypeName,The length of the statement  "            if (type.Assembly == assembly && !type.__IsMissing && !noself && (!type.IsGenericType || type.IsGenericTypeDefinition) && !type.HasElementType) " is 143.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteData,The length of the statement  "                if (!module.__GetSectionInfo(rva' out name' out characteristics' out virtualAddress' out virtualSize' out pointerToRawData' out sizeOfRawData)) " is 143.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The length of the statement  "            if ((type.Attributes & TypeAttributes.WindowsRuntime) != 0 && (compat == CompatLevel.None || compat >= CompatLevel.V45)) " is 120.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteEvent,The length of the statement  "            if (!evt.EventHandlerType.__IsMissing && evt.EventHandlerType.IsGenericType && !evt.EventHandlerType.IsGenericTypeDefinition) " is 125.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The length of the statement  "            ParameterInfo returnParameter = method is ConstructorInfo ? ((ConstructorInfo)method).__ReturnParameter : ((MethodInfo)method).ReturnParameter; " is 143.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The length of the statement  "            if ((implflags & MethodImplAttributes.AggressiveInlining) != 0 && compat != CompatLevel.V20 && compat != CompatLevel.V40) " is 121.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The length of the statement  "            WriteParam(lw' level0 + 2' method is ConstructorInfo ? ((ConstructorInfo)method).__ReturnParameter : ((MethodInfo)method).ReturnParameter); " is 139.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The length of the statement  "                WriteIL(lw' method' body' method.DeclaringType == null ? null : method.DeclaringType.GetGenericArguments()' method.GetGenericArguments()); " is 138.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The length of the statement  "            if ((method.Attributes & MethodAttributes.PinvokeImpl) != 0 && (implflags & MethodImplAttributes.CodeTypeMask) != MethodImplAttributes.Native) " is 142.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The length of the statement  "                    lw.WriteLine("}} // end of method {0}::{1}"' QuoteIdentifier(method.DeclaringType.__Name)' QuoteIdentifier(methodName)); " is 120.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMarshalAs,The length of the statement  "            if (marshal.SafeArraySubType != null && marshal.UnmanagedType == System.Runtime.InteropServices.UnmanagedType.SafeArray) " is 120.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,QuoteIdentifier,The length of the statement  "                else if (str.Length == 68 && str.StartsWith("<PrivateImplementationDetails>{"' StringComparison.Ordinal) && str.EndsWith("}"' StringComparison.Ordinal)) " is 152.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The length of the statement  "                ((int)assembly.__AssemblyFlags & 512) != 0 && (compat == CompatLevel.None || compat >= CompatLevel.V45) ? "windowsruntime " : ""' " is 129.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The length of the statement  "            lw.WriteLine("  .ver {0}:{1}:{2}:{3}"' assembly.GetName().Version.Major' assembly.GetName().Version.Minor' assembly.GetName().Version.Build' assembly.GetName().Version.Revision); " is 178.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteResources,The length of the statement  "                    lw.WriteLine("  // Offset: 0x{0:X8} Length: 0x{1:X8}"' mres.__Offset' assembly.GetManifestResourceStream(resourceName).Length); " is 127.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteCustomAttributeImpl,The length of the statement  "                if ((flags & Flags.Caverbal) != 0 && DecodeCABlob(sb = new StringBuilder()' ca.Constructor' blob' wrap ? (level0 + 4) * (comment ? -1 : 1) : lw.Column + 5)) " is 156.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteSignatureType,The length of the statement  "                WriteStandAloneMethodSig(lw' type.__MethodSignature' true' loc == TypeLocation.Local || loc == TypeLocation.Parameter || loc == TypeLocation.MemberRef); " is 152.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteSignatureType,The length of the statement  "                        loc == TypeLocation.MemberRef || loc == TypeLocation.MemberRefNoWrap || loc == TypeLocation.DeclaringType || loc == TypeLocation.MethodGenericParameter || type.Name == null " is 172.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteSignatureType,The length of the statement  "                        loc == TypeLocation.MemberRef || loc == TypeLocation.MemberRefNoWrap || loc == TypeLocation.GenericMethodImpl || type.Name == null " is 130.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                    if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength) " is 140.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                                Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers); " is 136.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                        WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false); " is 152.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally) " is 126.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos) " is 148.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                        lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength); " is 174.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                        lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength); " is 187.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                            exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength' " is 126.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                            exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength); " is 139.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                    if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength) " is 143.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The length of the statement  "                        return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]' buf2[4]' buf2[5]' buf2[6]' buf2[7]); " is 154.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The length of the statement  "                    return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf[0]' buf[1]' buf[2]' buf[3]' buf[4]' buf[5]' buf[6]' buf[7]); " is 146.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineMethod,The length of the statement  "                WriteSignatureType(lw' ((MethodInfo)mb.__GetMethodOnTypeDefinition()).ReturnType' IsArrayOfGenericParameter(mb.DeclaringType) ? TypeLocation.General : TypeLocation.MemberRefNoWrap); " is 181.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ResolveOptionalParameterTypes,The length of the statement  "            return module.__ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers); " is 120.
Long Statement,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,SortExceptions,The length of the statement  "                            Debug.Assert(exceptions[j].TryOffset == exceptions[first].TryOffset && exceptions[j].TryLength == exceptions[first].TryLength); " is 127.
Long Statement,Ildasm,Program,C:\repos\jfrijters_ikdasm\Program.cs,TryMatchOption,The length of the statement  "            if (arg.Length > key.Length + 2 && (arg[key.Length + 1] == ':' || arg[key.Length + 1] == '=') && String.Compare(arg' 1' key' 0' key.Length' true) == 0) " is 151.
Complex Conditional,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,AppendTypeName,The conditional expression  "type.Assembly == assembly && !type.__IsMissing && !noself && (!type.IsGenericType || type.IsGenericTypeDefinition) && !type.HasElementType"  is complex.
Complex Conditional,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMscorlibDirective,The conditional expression  "obj != null && !obj.__IsMissing && obj.BaseType == null && obj.IsClass"  is complex.
Complex Conditional,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetTypeSize,The conditional expression  "type.__IsFunctionPointer || type.IsPointer || type == typeofSystemIntPtr || type == typeofSystemUIntPtr"  is complex.
Complex Conditional,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,QuoteIdentifier,The conditional expression  "quote                  || str.IndexOf('<') != -1                  || str.IndexOf('>') != -1                  || str.StartsWith("?")                  || (str.StartsWith(".") && str != ".ctor" && str != ".cctor")                  || str.Contains(".?")                  || str.Contains("..")                  || str.IndexOf('{') != -1                  || str.IndexOf('}') != -1                  || str.IndexOf('[') != -1                  || str.IndexOf(']') != -1                  || str.IndexOf('!') != -1                  || str.IndexOf('/') != -1                  || str.IndexOf('=') != -1                  || str.IndexOf('+') != -1                  || str.IndexOf(':') != -1                  || str.IndexOf('|') != -1                  || str.IndexOf('~') != -1                  || str.IndexOf('^') != -1                  || str.IndexOf('-') != -1"  is complex.
Complex Conditional,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetTokenFromExportOrdinal,The conditional expression  "machine == ImageFileMachine.ARM && buf[0] == 0xDF && buf[1] == 0xF8 && buf[2] == 0x08 && buf[3] == 0xC0"  is complex.
Complex Conditional,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The conditional expression  "opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally"  is complex.
Complex Conditional,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineVar,The conditional expression  "opcode == OpCodes.Ldarg_S                  || opcode == OpCodes.Starg_S                  || opcode == OpCodes.Ldarga_S                  || opcode == OpCodes.Ldarg                  || opcode == OpCodes.Starg                  || opcode == OpCodes.Ldarga"  is complex.
Complex Conditional,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The conditional expression  "i < str.Length - 2 && ((pos == 94 && pos - initial != backslashes) || pos > 94)"  is complex.
Complex Conditional,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,SortExceptions,The conditional expression  "i < exceptions.Count                      && exceptions[first].TryOffset == exceptions[i].TryOffset                      && exceptions[first].TryLength == exceptions[i].TryLength                      && (compat != CompatLevel.V20 || exceptions[i].FilterOffset == 0)"  is complex.
Complex Conditional,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,SortExceptions,The conditional expression  "exceptions[j].FilterOffset != 0                                  || (i < exceptions.Count                                      && exceptions[j].TryOffset == exceptions[i].TryOffset                                      && exceptions[j].TryLength == exceptions[i].TryLength                                      && exceptions[j].HandlerOffset + exceptions[j].HandlerLength > exceptions[i].FilterOffset)"  is complex.
Complex Conditional,Ildasm,Program,C:\repos\jfrijters_ikdasm\Program.cs,TryMatchOption,The conditional expression  "arg.Length > key.Length + 2 && (arg[key.Length + 1] == ':' || arg[key.Length + 1] == '=') && String.Compare(arg' 1' key' 0' key.Length' true) == 0"  is complex.
Empty Catch Block,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,DecodeCABlob,The method has an empty catch block.
Empty Catch Block,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,DecodeCABlob,The method has an empty catch block.
Empty Catch Block,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetMethodNames,The method has an empty catch block.
Empty Catch Block,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetFieldNames,The method has an empty catch block.
Empty Catch Block,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WritePermissionSet,The method has an empty catch block.
Magic Number,IKVM.Reflection.Reader,ByteReader,C:\repos\jfrijters_ikdasm\ByteReader.cs,FromBlob,The following statement contains a magic number: ByteReader br = new ByteReader(blobHeap' blob' 4);
Magic Number,IKVM.Reflection.Reader,ByteReader,C:\repos\jfrijters_ikdasm\ByteReader.cs,ReadCompressedInt,The following statement contains a magic number: if (b1 <= 0x7F)              {                  return b1;              }              else if ((b1 & 0xC0) == 0x80)              {                  byte b2 = ReadByte();                  return ((b1 & 0x3F) << 8) | b2;              }              else              {                  byte b2 = ReadByte();                  byte b3 = ReadByte();                  byte b4 = ReadByte();                  return ((b1 & 0x3F) << 24) + (b2 << 16) + (b3 << 8) + b4;              }
Magic Number,IKVM.Reflection.Reader,ByteReader,C:\repos\jfrijters_ikdasm\ByteReader.cs,ReadCompressedInt,The following statement contains a magic number: if (b1 <= 0x7F)              {                  return b1;              }              else if ((b1 & 0xC0) == 0x80)              {                  byte b2 = ReadByte();                  return ((b1 & 0x3F) << 8) | b2;              }              else              {                  byte b2 = ReadByte();                  byte b3 = ReadByte();                  byte b4 = ReadByte();                  return ((b1 & 0x3F) << 24) + (b2 << 16) + (b3 << 8) + b4;              }
Magic Number,IKVM.Reflection.Reader,ByteReader,C:\repos\jfrijters_ikdasm\ByteReader.cs,ReadCompressedInt,The following statement contains a magic number: if (b1 <= 0x7F)              {                  return b1;              }              else if ((b1 & 0xC0) == 0x80)              {                  byte b2 = ReadByte();                  return ((b1 & 0x3F) << 8) | b2;              }              else              {                  byte b2 = ReadByte();                  byte b3 = ReadByte();                  byte b4 = ReadByte();                  return ((b1 & 0x3F) << 24) + (b2 << 16) + (b3 << 8) + b4;              }
Magic Number,IKVM.Reflection.Reader,ByteReader,C:\repos\jfrijters_ikdasm\ByteReader.cs,ReadCompressedInt,The following statement contains a magic number: if (b1 <= 0x7F)              {                  return b1;              }              else if ((b1 & 0xC0) == 0x80)              {                  byte b2 = ReadByte();                  return ((b1 & 0x3F) << 8) | b2;              }              else              {                  byte b2 = ReadByte();                  byte b3 = ReadByte();                  byte b4 = ReadByte();                  return ((b1 & 0x3F) << 24) + (b2 << 16) + (b3 << 8) + b4;              }
Magic Number,IKVM.Reflection.Reader,ByteReader,C:\repos\jfrijters_ikdasm\ByteReader.cs,ReadInt16,The following statement contains a magic number: if (end - pos < 2)                  throw new BadImageFormatException();
Magic Number,IKVM.Reflection.Reader,ByteReader,C:\repos\jfrijters_ikdasm\ByteReader.cs,ReadInt16,The following statement contains a magic number: return (short)(b1 | (b2 << 8));
Magic Number,IKVM.Reflection.Reader,ByteReader,C:\repos\jfrijters_ikdasm\ByteReader.cs,ReadInt32,The following statement contains a magic number: if (end - pos < 4)                  throw new BadImageFormatException();
Magic Number,IKVM.Reflection.Reader,ByteReader,C:\repos\jfrijters_ikdasm\ByteReader.cs,ReadInt32,The following statement contains a magic number: return (int)(b1 | (b2 << 8) | (b3 << 16) | (b4 << 24));
Magic Number,IKVM.Reflection.Reader,ByteReader,C:\repos\jfrijters_ikdasm\ByteReader.cs,ReadInt32,The following statement contains a magic number: return (int)(b1 | (b2 << 8) | (b3 << 16) | (b4 << 24));
Magic Number,IKVM.Reflection.Reader,ByteReader,C:\repos\jfrijters_ikdasm\ByteReader.cs,ReadInt32,The following statement contains a magic number: return (int)(b1 | (b2 << 8) | (b3 << 16) | (b4 << 24));
Magic Number,IKVM.Reflection.Reader,ByteReader,C:\repos\jfrijters_ikdasm\ByteReader.cs,ReadInt64,The following statement contains a magic number: return (long)(lo | (hi << 32));
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,DecodeDeclSecurity,The following statement contains a magic number: try              {                  sb.Append("           = {");                  bool first = true;                  foreach (var sec in list)                  {                      if (!first)                      {                          sb.Append(''');                          sb.AppendLine();                          sb.Append(' '' level + 14);                      }                      first = false;                      string typeName = sec.Constructor.DeclaringType.AssemblyQualifiedName;                      if (typeName.EndsWith("' mscorlib"' StringComparison.Ordinal))                      {                          typeName = typeName.Substring(0' typeName.Length - 10);                      }                      AppendTypeName(sb' sec.Constructor.DeclaringType' typeName' compat != CompatLevel.None);                      sb.Append(" = {");                      byte[] blob = sec.__GetBlob();                      // LAMESPEC the count of named arguments is a compressed integer (instead of UInt16 as NumNamed in custom attributes)                      var br = new ByteReader(blob' 0' blob.Length);                      int count = br.ReadCompressedInt();                      ReadNamedArguments(sb' br' count' 0' compat != CompatLevel.None && count > 1);                      sb.Append('}');                  }                  sb.Append('}');                  return true;              }              catch (Managed.Reflection.BadImageFormatException)              {                  return false;              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,DecodeDeclSecurity,The following statement contains a magic number: try              {                  sb.Append("           = {");                  bool first = true;                  foreach (var sec in list)                  {                      if (!first)                      {                          sb.Append(''');                          sb.AppendLine();                          sb.Append(' '' level + 14);                      }                      first = false;                      string typeName = sec.Constructor.DeclaringType.AssemblyQualifiedName;                      if (typeName.EndsWith("' mscorlib"' StringComparison.Ordinal))                      {                          typeName = typeName.Substring(0' typeName.Length - 10);                      }                      AppendTypeName(sb' sec.Constructor.DeclaringType' typeName' compat != CompatLevel.None);                      sb.Append(" = {");                      byte[] blob = sec.__GetBlob();                      // LAMESPEC the count of named arguments is a compressed integer (instead of UInt16 as NumNamed in custom attributes)                      var br = new ByteReader(blob' 0' blob.Length);                      int count = br.ReadCompressedInt();                      ReadNamedArguments(sb' br' count' 0' compat != CompatLevel.None && count > 1);                      sb.Append('}');                  }                  sb.Append('}');                  return true;              }              catch (Managed.Reflection.BadImageFormatException)              {                  return false;              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,DecodeCABlob,The following statement contains a magic number: try              {                  // CustomAttribute                  var br = new ByteReader(blob' 2' blob.Length - 4);                  ReadConstructorArguments(sb' br' constructor' level);                  br = new ByteReader(blob' blob.Length - (br.Length + 2)' br.Length + 2);                  int named = br.ReadUInt16();                  if (constructor.GetParameters().Length != 0 && named != 0)                  {                      AppendNewLine(sb' level);                  }                  ReadNamedArguments(sb' br' named' level' false);                  return true;              }              catch (Managed.Reflection.BadImageFormatException) { }              catch (ArgumentOutOfRangeException) { }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,DecodeCABlob,The following statement contains a magic number: try              {                  // CustomAttribute                  var br = new ByteReader(blob' 2' blob.Length - 4);                  ReadConstructorArguments(sb' br' constructor' level);                  br = new ByteReader(blob' blob.Length - (br.Length + 2)' br.Length + 2);                  int named = br.ReadUInt16();                  if (constructor.GetParameters().Length != 0 && named != 0)                  {                      AppendNewLine(sb' level);                  }                  ReadNamedArguments(sb' br' named' level' false);                  return true;              }              catch (Managed.Reflection.BadImageFormatException) { }              catch (ArgumentOutOfRangeException) { }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,DecodeCABlob,The following statement contains a magic number: try              {                  // CustomAttribute                  var br = new ByteReader(blob' 2' blob.Length - 4);                  ReadConstructorArguments(sb' br' constructor' level);                  br = new ByteReader(blob' blob.Length - (br.Length + 2)' br.Length + 2);                  int named = br.ReadUInt16();                  if (constructor.GetParameters().Length != 0 && named != 0)                  {                      AppendNewLine(sb' level);                  }                  ReadNamedArguments(sb' br' named' level' false);                  return true;              }              catch (Managed.Reflection.BadImageFormatException) { }              catch (ArgumentOutOfRangeException) { }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,DecodeCABlob,The following statement contains a magic number: try              {                  // CustomAttribute                  var br = new ByteReader(blob' 2' blob.Length - 4);                  ReadConstructorArguments(sb' br' constructor' level);                  br = new ByteReader(blob' blob.Length - (br.Length + 2)' br.Length + 2);                  int named = br.ReadUInt16();                  if (constructor.GetParameters().Length != 0 && named != 0)                  {                      AppendNewLine(sb' level);                  }                  ReadNamedArguments(sb' br' named' level' false);                  return true;              }              catch (Managed.Reflection.BadImageFormatException) { }              catch (ArgumentOutOfRangeException) { }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,AppendNewLine,The following statement contains a magic number: if (level < 0)              {                  sb.Append("  //");                  sb.Append(' '' -level - 4);              }              else              {                  sb.Append(' '' level);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ReadFixedArg,The following statement contains a magic number: if (type.IsArray)              {                  int length = br.ReadInt32();                  if (length == -1 && compat == CompatLevel.None)                  {                      sb.Append("nullref");                  }                  else if (length == 0 && compat != CompatLevel.None)                  {                      throw new Managed.Reflection.BadImageFormatException();                  }                  else                  {                      Type elementType = type.GetElementType();                      AppendCATypeName(sb' elementType' null);                      sb.AppendFormat("[{0}]("' length);                      for (int i = 0; i < length; i++)                      {                          if (i != 0)                          {                              sb.Append(' ');                          }                          if (elementType == typeofSystemObject)                          {                              string typeName;                              ReadFixedArg(sb' br' ReadFieldOrPropType(sb' br' out typeName)' false);                          }                          else                          {                              ReadFixedArg(sb' br' elementType' true);                          }                      }                      sb.Append(')');                  }              }              else if (type.FullName == "System.Type" && type.Assembly.GetName().Name == "mscorlib")              {                  if (!arrayElement)                  {                      AppendCATypeName(sb' type' null);                      sb.Append('(');                  }                  string typeName;                  var type1 = ReadType(br' out typeName);                  if (type1 == null)                  {                      if (typeName == null)                      {                          sb.Append("nullref");                      }                      else                      {                          sb.Append("class ").Append(QuoteIdentifier(typeName' true));                      }                  }                  else                  {                      AppendTypeName(sb' type1' typeName' compat != CompatLevel.None && IsNestedTypeWithNamespace(type1));                  }                  if (!arrayElement)                  {                      sb.Append(')');                  }              }              else if (type.Assembly == mscorlib)              {                  if (!arrayElement)                  {                      AppendCATypeName(sb' type' null);                      sb.Append('(');                  }                  if (type == typeofSystemBoolean)                  {                      sb.Append(br.ReadByte() == 0 ? "false" : "true");                  }                  else if (type == typeofSystemByte)                  {                      sb.Append(br.ReadByte());                  }                  else if (type == typeofSystemSByte)                  {                      sb.Append(br.ReadSByte());                  }                  else if (type == typeofSystemChar)                  {                      sb.AppendFormat("0x{0:X4}"' (int)br.ReadChar());                  }                  else if (type == typeofSystemInt16)                  {                      sb.Append(br.ReadInt16());                  }                  else if (type == typeofSystemUInt16)                  {                      sb.Append(br.ReadUInt16());                  }                  else if (type == typeofSystemInt32)                  {                      sb.Append(br.ReadInt32());                  }                  else if (type == typeofSystemUInt32)                  {                      sb.Append(br.ReadInt32());                  }                  else if (type == typeofSystemInt64)                  {                      sb.Append(br.ReadInt64());                  }                  else if (type == typeofSystemUInt64)                  {                      sb.Append(br.ReadInt64());                  }                  else if (type == typeofSystemSingle)                  {                      sb.Append(ToString(br.ReadSingle()' true));                  }                  else if (type == typeofSystemDouble)                  {                      sb.Append(ToString(br.ReadDouble()' true));                  }                  else if (type == typeofSystemString)                  {                      var str = br.ReadString();                      if (str == null)                      {                          sb.Append("nullref");                      }                      else                      {                          if (compat != CompatLevel.None)                          {                              int pos = str.IndexOf((char)0);                              if (pos != -1)                              {                                  str = str.Substring(0' pos);                              }                          }                          sb.Append(QuoteIdentifier(str' true));                      }                  }                  else if (type == typeofSystemObject)                  {                      string typeName;                      ReadFixedArg(sb' br' ReadFieldOrPropType(sb' br' out typeName));                  }                  else                  {                      throw new NotImplementedException(type.FullName);                  }                  if (!arrayElement)                  {                      sb.Append(')');                  }              }              else if (type.__IsMissing || (compat != CompatLevel.None && typerefs.Contains(type)))              {                  // ildasm actually tries to load the assembly' but we can't do that' so we cheat by having                  // a list of 'known' enum types                  if (type.Assembly.GetName().Name == "mscorlib")                  {                      switch (type.FullName)                      {                          case "System.AttributeTargets":                          case "System.Runtime.ConstrainedExecution.Consistency":                          case "System.Runtime.ConstrainedExecution.Cer":                          case "System.Security.Permissions.SecurityAction":                          case "System.Security.Permissions.SecurityPermissionFlag":                          case "System.Runtime.Versioning.ResourceScope":                          case "System.Runtime.InteropServices.CallingConvention":                          case "System.Runtime.InteropServices.CharSet":                              ReadFixedArg(sb' br' typeofSystemInt32);                              return;                          case "System.Security.SecurityRuleSet":                              if (compat != CompatLevel.V20)                              {                                  ReadFixedArg(sb' br' typeofSystemByte);                                  return;                              }                              break;                          case "System.Diagnostics.Tracing.EventLevel":                          case "System.Diagnostics.Tracing.EventTask":                          case "System.Diagnostics.Tracing.EventOpcode":                              if (compat != CompatLevel.V20 && compat != CompatLevel.V40)                              {                                  ReadFixedArg(sb' br' typeofSystemInt32);                                  return;                              }                              break;                          case "System.Type":                              sb.Append("type(");                              string typeName;                              AppendTypeName(sb' ReadType(br' out typeName)' typeName);                              sb.Append(")");                              return;                      }                  }                  switch (br.Length)                  {                      case 1:                          if (compat != CompatLevel.None)                          {                              // ildasm uses bool (???) as the underlying type in this case                              sb.AppendFormat("bool({0})"' br.ReadByte() == 0 ? "false" : "true");                          }                          else                          {                              // just guess that the enum has int8 as the underlying type                              sb.AppendFormat("int8({0})"' br.ReadSByte());                          }                          break;                      case 2:                          // just guess that the enum has int16 as the underlying type                          sb.AppendFormat("int16({0})"' br.ReadInt16());                          break;                      case 4:                          // just guess that the enum has int32 as the underlying type                          sb.AppendFormat("int32({0})"' br.ReadInt32());                          break;                      case 8:                          // just guess that the enum has int64 as the underlying type                          sb.AppendFormat("int64({0})"' br.ReadInt64());                          break;                      default:                          throw new Managed.Reflection.BadImageFormatException();                  }              }              else if (type.IsEnum)              {                  ReadFixedArg(sb' br' type.GetEnumUnderlyingType()' arrayElement);              }              else              {                  throw new NotImplementedException(type.FullName);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ReadFixedArg,The following statement contains a magic number: if (type.IsArray)              {                  int length = br.ReadInt32();                  if (length == -1 && compat == CompatLevel.None)                  {                      sb.Append("nullref");                  }                  else if (length == 0 && compat != CompatLevel.None)                  {                      throw new Managed.Reflection.BadImageFormatException();                  }                  else                  {                      Type elementType = type.GetElementType();                      AppendCATypeName(sb' elementType' null);                      sb.AppendFormat("[{0}]("' length);                      for (int i = 0; i < length; i++)                      {                          if (i != 0)                          {                              sb.Append(' ');                          }                          if (elementType == typeofSystemObject)                          {                              string typeName;                              ReadFixedArg(sb' br' ReadFieldOrPropType(sb' br' out typeName)' false);                          }                          else                          {                              ReadFixedArg(sb' br' elementType' true);                          }                      }                      sb.Append(')');                  }              }              else if (type.FullName == "System.Type" && type.Assembly.GetName().Name == "mscorlib")              {                  if (!arrayElement)                  {                      AppendCATypeName(sb' type' null);                      sb.Append('(');                  }                  string typeName;                  var type1 = ReadType(br' out typeName);                  if (type1 == null)                  {                      if (typeName == null)                      {                          sb.Append("nullref");                      }                      else                      {                          sb.Append("class ").Append(QuoteIdentifier(typeName' true));                      }                  }                  else                  {                      AppendTypeName(sb' type1' typeName' compat != CompatLevel.None && IsNestedTypeWithNamespace(type1));                  }                  if (!arrayElement)                  {                      sb.Append(')');                  }              }              else if (type.Assembly == mscorlib)              {                  if (!arrayElement)                  {                      AppendCATypeName(sb' type' null);                      sb.Append('(');                  }                  if (type == typeofSystemBoolean)                  {                      sb.Append(br.ReadByte() == 0 ? "false" : "true");                  }                  else if (type == typeofSystemByte)                  {                      sb.Append(br.ReadByte());                  }                  else if (type == typeofSystemSByte)                  {                      sb.Append(br.ReadSByte());                  }                  else if (type == typeofSystemChar)                  {                      sb.AppendFormat("0x{0:X4}"' (int)br.ReadChar());                  }                  else if (type == typeofSystemInt16)                  {                      sb.Append(br.ReadInt16());                  }                  else if (type == typeofSystemUInt16)                  {                      sb.Append(br.ReadUInt16());                  }                  else if (type == typeofSystemInt32)                  {                      sb.Append(br.ReadInt32());                  }                  else if (type == typeofSystemUInt32)                  {                      sb.Append(br.ReadInt32());                  }                  else if (type == typeofSystemInt64)                  {                      sb.Append(br.ReadInt64());                  }                  else if (type == typeofSystemUInt64)                  {                      sb.Append(br.ReadInt64());                  }                  else if (type == typeofSystemSingle)                  {                      sb.Append(ToString(br.ReadSingle()' true));                  }                  else if (type == typeofSystemDouble)                  {                      sb.Append(ToString(br.ReadDouble()' true));                  }                  else if (type == typeofSystemString)                  {                      var str = br.ReadString();                      if (str == null)                      {                          sb.Append("nullref");                      }                      else                      {                          if (compat != CompatLevel.None)                          {                              int pos = str.IndexOf((char)0);                              if (pos != -1)                              {                                  str = str.Substring(0' pos);                              }                          }                          sb.Append(QuoteIdentifier(str' true));                      }                  }                  else if (type == typeofSystemObject)                  {                      string typeName;                      ReadFixedArg(sb' br' ReadFieldOrPropType(sb' br' out typeName));                  }                  else                  {                      throw new NotImplementedException(type.FullName);                  }                  if (!arrayElement)                  {                      sb.Append(')');                  }              }              else if (type.__IsMissing || (compat != CompatLevel.None && typerefs.Contains(type)))              {                  // ildasm actually tries to load the assembly' but we can't do that' so we cheat by having                  // a list of 'known' enum types                  if (type.Assembly.GetName().Name == "mscorlib")                  {                      switch (type.FullName)                      {                          case "System.AttributeTargets":                          case "System.Runtime.ConstrainedExecution.Consistency":                          case "System.Runtime.ConstrainedExecution.Cer":                          case "System.Security.Permissions.SecurityAction":                          case "System.Security.Permissions.SecurityPermissionFlag":                          case "System.Runtime.Versioning.ResourceScope":                          case "System.Runtime.InteropServices.CallingConvention":                          case "System.Runtime.InteropServices.CharSet":                              ReadFixedArg(sb' br' typeofSystemInt32);                              return;                          case "System.Security.SecurityRuleSet":                              if (compat != CompatLevel.V20)                              {                                  ReadFixedArg(sb' br' typeofSystemByte);                                  return;                              }                              break;                          case "System.Diagnostics.Tracing.EventLevel":                          case "System.Diagnostics.Tracing.EventTask":                          case "System.Diagnostics.Tracing.EventOpcode":                              if (compat != CompatLevel.V20 && compat != CompatLevel.V40)                              {                                  ReadFixedArg(sb' br' typeofSystemInt32);                                  return;                              }                              break;                          case "System.Type":                              sb.Append("type(");                              string typeName;                              AppendTypeName(sb' ReadType(br' out typeName)' typeName);                              sb.Append(")");                              return;                      }                  }                  switch (br.Length)                  {                      case 1:                          if (compat != CompatLevel.None)                          {                              // ildasm uses bool (???) as the underlying type in this case                              sb.AppendFormat("bool({0})"' br.ReadByte() == 0 ? "false" : "true");                          }                          else                          {                              // just guess that the enum has int8 as the underlying type                              sb.AppendFormat("int8({0})"' br.ReadSByte());                          }                          break;                      case 2:                          // just guess that the enum has int16 as the underlying type                          sb.AppendFormat("int16({0})"' br.ReadInt16());                          break;                      case 4:                          // just guess that the enum has int32 as the underlying type                          sb.AppendFormat("int32({0})"' br.ReadInt32());                          break;                      case 8:                          // just guess that the enum has int64 as the underlying type                          sb.AppendFormat("int64({0})"' br.ReadInt64());                          break;                      default:                          throw new Managed.Reflection.BadImageFormatException();                  }              }              else if (type.IsEnum)              {                  ReadFixedArg(sb' br' type.GetEnumUnderlyingType()' arrayElement);              }              else              {                  throw new NotImplementedException(type.FullName);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ReadFixedArg,The following statement contains a magic number: if (type.IsArray)              {                  int length = br.ReadInt32();                  if (length == -1 && compat == CompatLevel.None)                  {                      sb.Append("nullref");                  }                  else if (length == 0 && compat != CompatLevel.None)                  {                      throw new Managed.Reflection.BadImageFormatException();                  }                  else                  {                      Type elementType = type.GetElementType();                      AppendCATypeName(sb' elementType' null);                      sb.AppendFormat("[{0}]("' length);                      for (int i = 0; i < length; i++)                      {                          if (i != 0)                          {                              sb.Append(' ');                          }                          if (elementType == typeofSystemObject)                          {                              string typeName;                              ReadFixedArg(sb' br' ReadFieldOrPropType(sb' br' out typeName)' false);                          }                          else                          {                              ReadFixedArg(sb' br' elementType' true);                          }                      }                      sb.Append(')');                  }              }              else if (type.FullName == "System.Type" && type.Assembly.GetName().Name == "mscorlib")              {                  if (!arrayElement)                  {                      AppendCATypeName(sb' type' null);                      sb.Append('(');                  }                  string typeName;                  var type1 = ReadType(br' out typeName);                  if (type1 == null)                  {                      if (typeName == null)                      {                          sb.Append("nullref");                      }                      else                      {                          sb.Append("class ").Append(QuoteIdentifier(typeName' true));                      }                  }                  else                  {                      AppendTypeName(sb' type1' typeName' compat != CompatLevel.None && IsNestedTypeWithNamespace(type1));                  }                  if (!arrayElement)                  {                      sb.Append(')');                  }              }              else if (type.Assembly == mscorlib)              {                  if (!arrayElement)                  {                      AppendCATypeName(sb' type' null);                      sb.Append('(');                  }                  if (type == typeofSystemBoolean)                  {                      sb.Append(br.ReadByte() == 0 ? "false" : "true");                  }                  else if (type == typeofSystemByte)                  {                      sb.Append(br.ReadByte());                  }                  else if (type == typeofSystemSByte)                  {                      sb.Append(br.ReadSByte());                  }                  else if (type == typeofSystemChar)                  {                      sb.AppendFormat("0x{0:X4}"' (int)br.ReadChar());                  }                  else if (type == typeofSystemInt16)                  {                      sb.Append(br.ReadInt16());                  }                  else if (type == typeofSystemUInt16)                  {                      sb.Append(br.ReadUInt16());                  }                  else if (type == typeofSystemInt32)                  {                      sb.Append(br.ReadInt32());                  }                  else if (type == typeofSystemUInt32)                  {                      sb.Append(br.ReadInt32());                  }                  else if (type == typeofSystemInt64)                  {                      sb.Append(br.ReadInt64());                  }                  else if (type == typeofSystemUInt64)                  {                      sb.Append(br.ReadInt64());                  }                  else if (type == typeofSystemSingle)                  {                      sb.Append(ToString(br.ReadSingle()' true));                  }                  else if (type == typeofSystemDouble)                  {                      sb.Append(ToString(br.ReadDouble()' true));                  }                  else if (type == typeofSystemString)                  {                      var str = br.ReadString();                      if (str == null)                      {                          sb.Append("nullref");                      }                      else                      {                          if (compat != CompatLevel.None)                          {                              int pos = str.IndexOf((char)0);                              if (pos != -1)                              {                                  str = str.Substring(0' pos);                              }                          }                          sb.Append(QuoteIdentifier(str' true));                      }                  }                  else if (type == typeofSystemObject)                  {                      string typeName;                      ReadFixedArg(sb' br' ReadFieldOrPropType(sb' br' out typeName));                  }                  else                  {                      throw new NotImplementedException(type.FullName);                  }                  if (!arrayElement)                  {                      sb.Append(')');                  }              }              else if (type.__IsMissing || (compat != CompatLevel.None && typerefs.Contains(type)))              {                  // ildasm actually tries to load the assembly' but we can't do that' so we cheat by having                  // a list of 'known' enum types                  if (type.Assembly.GetName().Name == "mscorlib")                  {                      switch (type.FullName)                      {                          case "System.AttributeTargets":                          case "System.Runtime.ConstrainedExecution.Consistency":                          case "System.Runtime.ConstrainedExecution.Cer":                          case "System.Security.Permissions.SecurityAction":                          case "System.Security.Permissions.SecurityPermissionFlag":                          case "System.Runtime.Versioning.ResourceScope":                          case "System.Runtime.InteropServices.CallingConvention":                          case "System.Runtime.InteropServices.CharSet":                              ReadFixedArg(sb' br' typeofSystemInt32);                              return;                          case "System.Security.SecurityRuleSet":                              if (compat != CompatLevel.V20)                              {                                  ReadFixedArg(sb' br' typeofSystemByte);                                  return;                              }                              break;                          case "System.Diagnostics.Tracing.EventLevel":                          case "System.Diagnostics.Tracing.EventTask":                          case "System.Diagnostics.Tracing.EventOpcode":                              if (compat != CompatLevel.V20 && compat != CompatLevel.V40)                              {                                  ReadFixedArg(sb' br' typeofSystemInt32);                                  return;                              }                              break;                          case "System.Type":                              sb.Append("type(");                              string typeName;                              AppendTypeName(sb' ReadType(br' out typeName)' typeName);                              sb.Append(")");                              return;                      }                  }                  switch (br.Length)                  {                      case 1:                          if (compat != CompatLevel.None)                          {                              // ildasm uses bool (???) as the underlying type in this case                              sb.AppendFormat("bool({0})"' br.ReadByte() == 0 ? "false" : "true");                          }                          else                          {                              // just guess that the enum has int8 as the underlying type                              sb.AppendFormat("int8({0})"' br.ReadSByte());                          }                          break;                      case 2:                          // just guess that the enum has int16 as the underlying type                          sb.AppendFormat("int16({0})"' br.ReadInt16());                          break;                      case 4:                          // just guess that the enum has int32 as the underlying type                          sb.AppendFormat("int32({0})"' br.ReadInt32());                          break;                      case 8:                          // just guess that the enum has int64 as the underlying type                          sb.AppendFormat("int64({0})"' br.ReadInt64());                          break;                      default:                          throw new Managed.Reflection.BadImageFormatException();                  }              }              else if (type.IsEnum)              {                  ReadFixedArg(sb' br' type.GetEnumUnderlyingType()' arrayElement);              }              else              {                  throw new NotImplementedException(type.FullName);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteUnhandledCustomAttributes,The following statement contains a magic number: foreach (var ca in module.__EnumerateCustomAttributeTable())              {                  int parent = ca.__Parent;                  switch (parent >> 24)                  {                      case 0x00:  // Module                      case 0x02:  // TypeDef                      case 0x04:  // Field                      case 0x06:  // MethodDef                      case 0x08:  // Param                      case 0x14:  // Event                      case 0x17:  // Property                      case 0x20:  // Assembly                      case 0x2a:  // GenericParam                          break;                      case 0x01:  // TypeRef                          lw.Write(".custom (");                          int level = lw.Column - 1;                          WriteTypeDefOrRef(lw' module.ResolveType(parent));                          lw.Write(") ");                          WriteCustomAttributeImpl(lw' ca' false' level);                          break;                      default:                          if (compat == CompatLevel.V20 || compat == CompatLevel.V40 || (parent >> 24) != 0x09)                          {                              lw.Write(".custom (UNKNOWN_OWNER) ");                              WriteCustomAttributeImpl(lw' ca' false' lw.Column - 16);                          }                          break;                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteUnhandledCustomAttributes,The following statement contains a magic number: foreach (var ca in module.__EnumerateCustomAttributeTable())              {                  int parent = ca.__Parent;                  switch (parent >> 24)                  {                      case 0x00:  // Module                      case 0x02:  // TypeDef                      case 0x04:  // Field                      case 0x06:  // MethodDef                      case 0x08:  // Param                      case 0x14:  // Event                      case 0x17:  // Property                      case 0x20:  // Assembly                      case 0x2a:  // GenericParam                          break;                      case 0x01:  // TypeRef                          lw.Write(".custom (");                          int level = lw.Column - 1;                          WriteTypeDefOrRef(lw' module.ResolveType(parent));                          lw.Write(") ");                          WriteCustomAttributeImpl(lw' ca' false' level);                          break;                      default:                          if (compat == CompatLevel.V20 || compat == CompatLevel.V40 || (parent >> 24) != 0x09)                          {                              lw.Write(".custom (UNKNOWN_OWNER) ");                              WriteCustomAttributeImpl(lw' ca' false' lw.Column - 16);                          }                          break;                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteUnhandledCustomAttributes,The following statement contains a magic number: foreach (var ca in module.__EnumerateCustomAttributeTable())              {                  int parent = ca.__Parent;                  switch (parent >> 24)                  {                      case 0x00:  // Module                      case 0x02:  // TypeDef                      case 0x04:  // Field                      case 0x06:  // MethodDef                      case 0x08:  // Param                      case 0x14:  // Event                      case 0x17:  // Property                      case 0x20:  // Assembly                      case 0x2a:  // GenericParam                          break;                      case 0x01:  // TypeRef                          lw.Write(".custom (");                          int level = lw.Column - 1;                          WriteTypeDefOrRef(lw' module.ResolveType(parent));                          lw.Write(") ");                          WriteCustomAttributeImpl(lw' ca' false' level);                          break;                      default:                          if (compat == CompatLevel.V20 || compat == CompatLevel.V40 || (parent >> 24) != 0x09)                          {                              lw.Write(".custom (UNKNOWN_OWNER) ");                              WriteCustomAttributeImpl(lw' ca' false' lw.Column - 16);                          }                          break;                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetPointerSize,The following statement contains a magic number: if ((peKind & PortableExecutableKinds.PE32Plus) != 0)              {                  return 8;              }              else              {                  return 4;              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetPointerSize,The following statement contains a magic number: if ((peKind & PortableExecutableKinds.PE32Plus) != 0)              {                  return 8;              }              else              {                  return 4;              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetTypeSize,The following statement contains a magic number: if (type.__IsFunctionPointer || type.IsPointer || type == typeofSystemIntPtr || type == typeofSystemUIntPtr)              {                  typeSize = GetPointerSize();              }              else if (type.__IsMissing || !type.__GetLayout(out packingSize' out typeSize))              {                  if (type == typeofSystemSByte                      || type == typeofSystemByte                      || type == typeofSystemBoolean)                  {                      typeSize = 1;                  }                  else if (type == typeofSystemInt16                      || type == typeofSystemUInt16                      || type == typeofSystemChar)                  {                      typeSize = 2;                  }                  else if (type == typeofSystemInt32                      || type == typeofSystemUInt32                      || type == typeofSystemSingle)                  {                      typeSize = 4;                  }                  else if (type == typeofSystemInt64                      || type == typeofSystemUInt64                      || type == typeofSystemDouble)                  {                      typeSize = 8;                  }                  else                  {                      // unknown                      typeSize = 0;                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetTypeSize,The following statement contains a magic number: if (type.__IsFunctionPointer || type.IsPointer || type == typeofSystemIntPtr || type == typeofSystemUIntPtr)              {                  typeSize = GetPointerSize();              }              else if (type.__IsMissing || !type.__GetLayout(out packingSize' out typeSize))              {                  if (type == typeofSystemSByte                      || type == typeofSystemByte                      || type == typeofSystemBoolean)                  {                      typeSize = 1;                  }                  else if (type == typeofSystemInt16                      || type == typeofSystemUInt16                      || type == typeofSystemChar)                  {                      typeSize = 2;                  }                  else if (type == typeofSystemInt32                      || type == typeofSystemUInt32                      || type == typeofSystemSingle)                  {                      typeSize = 4;                  }                  else if (type == typeofSystemInt64                      || type == typeofSystemUInt64                      || type == typeofSystemDouble)                  {                      typeSize = 8;                  }                  else                  {                      // unknown                      typeSize = 0;                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetTypeSize,The following statement contains a magic number: if (type.__IsFunctionPointer || type.IsPointer || type == typeofSystemIntPtr || type == typeofSystemUIntPtr)              {                  typeSize = GetPointerSize();              }              else if (type.__IsMissing || !type.__GetLayout(out packingSize' out typeSize))              {                  if (type == typeofSystemSByte                      || type == typeofSystemByte                      || type == typeofSystemBoolean)                  {                      typeSize = 1;                  }                  else if (type == typeofSystemInt16                      || type == typeofSystemUInt16                      || type == typeofSystemChar)                  {                      typeSize = 2;                  }                  else if (type == typeofSystemInt32                      || type == typeofSystemUInt32                      || type == typeofSystemSingle)                  {                      typeSize = 4;                  }                  else if (type == typeofSystemInt64                      || type == typeofSystemUInt64                      || type == typeofSystemDouble)                  {                      typeSize = 8;                  }                  else                  {                      // unknown                      typeSize = 0;                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteData,The following statement contains a magic number: foreach (VTableFixups fixup in GetVTableFixups())              {                  ptrs.Add(new DataPointer(fixup.RVA' fixup.Count * ((fixup.Type & COR_VTABLE_32BIT) != 0 ? 4 : 8)));              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteData,The following statement contains a magic number: foreach (VTableFixups fixup in GetVTableFixups())              {                  ptrs.Add(new DataPointer(fixup.RVA' fixup.Count * ((fixup.Type & COR_VTABLE_32BIT) != 0 ? 4 : 8)));              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteData,The following statement contains a magic number: if (uninitialized)              {                  lw.WriteLine("int8[{0}]"' size);              }              else              {                  lw.WriteLine("bytearray (");                  lw.GoToColumn(17);                  byte[] buf = new byte[size];                  module.__ReadDataFromRVA(rva' buf' 0' buf.Length);                  WriteBytes(lw' buf' true);                  lw.WriteLine();              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteNativeResources,The following statement contains a magic number: module.__GetDataDirectoryEntry(2' out rva' out length);
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: if (interfaces.Length != 0)              {                  lw.Write("       implements ");                  bool first = true;                  foreach (var iface in interfaces)                  {                      if (!first)                      {                          lw.WriteLine("'");                          lw.GoToColumn(level + 18);                      }                      first = false;                      WriteInterfaceOrBaseType(lw' iface);                  }                  lw.WriteLine();                  lw.GoToColumn(level);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: if (type.__GetLayout(out packingSize' out typeSize))              {                  lw.GoToColumn(level + 2);                  lw.WriteLine(".pack {0}"' packingSize);                  lw.GoToColumn(level + 2);                  lw.WriteLine(".size {0}"' typeSize);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: if (type.__GetLayout(out packingSize' out typeSize))              {                  lw.GoToColumn(level + 2);                  lw.WriteLine(".pack {0}"' packingSize);                  lw.GoToColumn(level + 2);                  lw.WriteLine(".size {0}"' typeSize);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: WriteCustomAttributes(lw' level + 2' type.__GetCustomAttributes(null' false));
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: WriteDeclarativeSecurity(lw' level + 2' CustomAttributeData.__GetDeclarativeSecurity(type)' type.MetadataToken);
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: WriteGenericParameterCustomAttributes(lw' level + 2' type.GetGenericArguments());
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: if (compat == CompatLevel.None || compat >= CompatLevel.V45)              {                  foreach (var iface in type.__GetDeclaredInterfaces())                  {                      var cas = CustomAttributeData.__GetCustomAttributes(type' iface' null' false);                      if (cas.Count != 0)                      {                          lw.GoToColumn(level + 2);                          lw.Write(".interfaceimpl type ");                          WriteInterfaceOrBaseType(lw' iface);                          lw.WriteLine();                          WriteCustomAttributes(lw' level + 2' cas);                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: if (compat == CompatLevel.None || compat >= CompatLevel.V45)              {                  foreach (var iface in type.__GetDeclaredInterfaces())                  {                      var cas = CustomAttributeData.__GetCustomAttributes(type' iface' null' false);                      if (cas.Count != 0)                      {                          lw.GoToColumn(level + 2);                          lw.Write(".interfaceimpl type ");                          WriteInterfaceOrBaseType(lw' iface);                          lw.WriteLine();                          WriteCustomAttributes(lw' level + 2' cas);                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: foreach (var nested in type.__GetDeclaredTypes())              {                  lw.GoToColumn(level + 2);                  WriteType(lw' nested);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: foreach (var field in fields)              {                  lw.GoToColumn(level + 2);                  WriteField(lw' field);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: foreach (var method in type.__GetDeclaredMethods())              {                  lw.GoToColumn(level + 2);                  WriteMethod(lw' method);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: foreach (var evt in type.__GetDeclaredEvents())              {                  lw.GoToColumn(level + 2);                  WriteEvent(lw' evt);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: foreach (var prop in type.__GetDeclaredProperties())              {                  lw.GoToColumn(level + 2);                  WriteProperty(lw' prop);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteGenericParameterDef,The following statement contains a magic number: for (int i = 0; i < parameters.Length; i++)              {                  Type par = parameters[i];                  lw.Write(sep);                  if (wrap && i != 0 && i % 4 == 0)                  {                      lw.WriteLine();                      lw.GoToColumn(level);                  }                  if ((par.GenericParameterAttributes & GenericParameterAttributes.Contravariant) != 0)                  {                      lw.Write("- ");                  }                  if ((par.GenericParameterAttributes & GenericParameterAttributes.Covariant) != 0)                  {                      lw.Write("+ ");                  }                  if ((par.GenericParameterAttributes & GenericParameterAttributes.ReferenceTypeConstraint) != 0)                  {                      lw.Write("class ");                  }                  if ((par.GenericParameterAttributes & GenericParameterAttributes.NotNullableValueTypeConstraint) != 0)                  {                      lw.Write("valuetype ");                  }                  if ((par.GenericParameterAttributes & GenericParameterAttributes.DefaultConstructorConstraint) != 0)                  {                      lw.Write(".ctor ");                  }                  string sep2 = "(";                  Type[] constraints = par.GetGenericParameterConstraints();                  CustomModifiers[] customModifiers = par.__GetGenericParameterConstraintCustomModifiers();                  for (int j = 0; j < constraints.Length; j++)                  {                      Type constraint = constraints[j];                      lw.Write(sep2);                      sep2 = "' ";                      if (constraint.__IsMissing || !constraint.IsGenericType)                      {                          if (!customModifiers[j].IsEmpty && !constraint.IsGenericParameter)                          {                              lw.Write(constraint.IsValueType ? "valuetype " : "class ");                          }                          WriteTypeDefOrRef(lw' constraint);                      }                      else                      {                          WriteSignatureType(lw' constraint);                      }                      WriteCustomModifiers(lw' customModifiers[j]);                  }                  if (sep2 != "(")                  {                      lw.Write(") ");                  }                  lw.Write("{0}"' QuoteIdentifier(par.Name));                  sep = "'";              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteEvent,The following statement contains a magic number: WriteCustomAttributes(lw' level + 2' evt.__GetCustomAttributes(null' false));
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteEvent,The following statement contains a magic number: foreach (var acc in accessors)              {                  lw.GoToColumn(level + 2);                  if (acc == evt.GetAddMethod(true))                  {                      lw.Write(".addon ");                  }                  else if (acc == evt.GetRemoveMethod(true))                  {                      lw.Write(".removeon ");                  }                  else if (acc == evt.GetRaiseMethod(true))                  {                      lw.Write(".fire ");                  }                  else                  {                      lw.Write(".other ");                  }                  WriteCallingConvention(lw' acc.CallingConvention);                  WriteSignatureType(lw' acc.ReturnType);                  lw.Write(" ");                  WriteTypeDefOrRef(lw' acc.DeclaringType);                  lw.Write("::{0}("' QuoteIdentifier(GetMethodName(acc)));                  WriteParameters(lw' acc.GetParameters());                  lw.WriteLine(")");              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteProperty,The following statement contains a magic number: if (lw.Column > 40)              {                  lw.WriteLine();                  lw.GoToColumn(level + 8);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteProperty,The following statement contains a magic number: if (lw.Column > 40)              {                  lw.WriteLine();                  lw.GoToColumn(level + 8);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteProperty,The following statement contains a magic number: if (lw.Column > 40)              {                  lw.WriteLine();                  lw.GoToColumn(level + 7);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteProperty,The following statement contains a magic number: if (lw.Column > 40)              {                  lw.WriteLine();                  lw.GoToColumn(level + 7);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteProperty,The following statement contains a magic number: WriteCustomAttributes(lw' level + 2' prop.__GetCustomAttributes(null' false));
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteProperty,The following statement contains a magic number: foreach (var acc in accessors)              {                  lw.GoToColumn(level + 2);                  if (acc == prop.GetGetMethod(true))                  {                      lw.Write(".get ");                  }                  else if (acc == prop.GetSetMethod(true))                  {                      lw.Write(".set ");                  }                  else                  {                      lw.Write(".other ");                  }                  WriteCallingConvention(lw' acc.CallingConvention);                  WriteSignatureType(lw' acc.ReturnType);                  WriteCustomModifiers(lw' acc.ReturnParameter.__GetCustomModifiers());                  lw.Write(" ");                  WriteTypeDefOrRef(lw' acc.DeclaringType);                  lw.Write("::{0}("' QuoteIdentifier(GetMethodName(acc)));                  WriteParameters(lw' acc.GetParameters());                  lw.WriteLine(")");              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: if (lw.Column > 40)              {                  lw.WriteLine();                  lw.GoToColumn(level1);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: if ((returnParameter.Attributes & ParameterAttributes.HasFieldMarshal) != 0)              {                  var sb = new StringBuilder();                  FieldMarshal marshal;                  WriteMarshalAs(sb' level1 - 1' returnParameter.__TryGetFieldMarshal(out marshal)' marshal' false);                  bool wrap = lw.Column + sb.Length > 40;                  if (wrap)                  {                      lw.WriteLine();                      lw.GoToColumn(level1 - 1);                  }                  lw.Write("{0}"' sb);                  if (wrap)                  {                      lw.WriteLine();                      lw.GoToColumn(level1 - 1);                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: if (lw.Column > 40)              {                  lw.WriteLine();                  lw.GoToColumn(level1 - 1);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: if (method.MetadataToken == module.__EntryPointToken)              {                  lw.GoToColumn(level0 + 2);                  lw.WriteLine(".entrypoint");              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: WriteCustomAttributes(lw' level0 + 2' method.__GetCustomAttributes(null' false));
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: WriteGenericParameterCustomAttributes(lw' level0 + 2' method.GetGenericArguments());
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: WriteParam(lw' level0 + 2' method is ConstructorInfo ? ((ConstructorInfo)method).__ReturnParameter : ((MethodInfo)method).ReturnParameter);
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: foreach (var parameter in method.GetParameters())              {                  WriteParam(lw' level0 + 2' parameter);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: WriteDeclarativeSecurity(lw' level0 + 2' CustomAttributeData.__GetDeclarativeSecurity(method)' method.MetadataToken);
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: if (vtentryMap.TryGetValue(method' out vtentries))              {                  foreach (var vtentry in vtentries)                  {                      lw.GoToColumn(level0 + 2);                      lw.WriteLine(".vtentry {0} : {1}"' vtentry.Key' vtentry.Value);                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: if (exportedMethods.TryGetValue(method.MetadataToken' out exports))              {                  foreach (var export in exports)                  {                      lw.GoToColumn(level0 + 2);                      lw.WriteLine(".export [{0}] as {1}"' export.ordinal' QuoteIdentifier(export.name));                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: if (method.DeclaringType != null && method is MethodInfo)              {                  foreach (var impl in ((MethodInfo)method).__GetMethodImpls())                  {                      lw.GoToColumn(level0 + 2);                      lw.Write(".override ");                      if (!impl.DeclaringType.__IsMissing && impl.DeclaringType.IsGenericType)                      {                          lw.Write(" method ");                          WriteInlineMethod(lw' impl' Type.EmptyTypes' null' (MethodInfo)method);                          lw.WriteLine();                      }                      else                      {                          WriteTypeDefOrRef(lw' impl.DeclaringType);                          lw.Write("::");                          lw.WriteLine("{0}"' QuoteIdentifier(GetMethodName(impl)));                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: if (body != null)              {                  lw.GoToColumn(level0 + 2);                  WriteIL(lw' method' body' method.DeclaringType == null ? null : method.DeclaringType.GetGenericArguments()' method.GetGenericArguments());              }              else if ((implflags & MethodImplAttributes.CodeTypeMask) == MethodImplAttributes.Native)              {                  lw.GoToColumn(level0 + 2);                  lw.WriteLine("// Embedded native code");                  lw.GoToColumn(level0 + 2);                  lw.WriteLine("// Disassembly of native methods is not supported.");                  lw.GoToColumn(level0 + 2);                  lw.WriteLine("//  Managed TargetRVA = 0x{0:X8}"' method.__MethodRVA);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: if (body != null)              {                  lw.GoToColumn(level0 + 2);                  WriteIL(lw' method' body' method.DeclaringType == null ? null : method.DeclaringType.GetGenericArguments()' method.GetGenericArguments());              }              else if ((implflags & MethodImplAttributes.CodeTypeMask) == MethodImplAttributes.Native)              {                  lw.GoToColumn(level0 + 2);                  lw.WriteLine("// Embedded native code");                  lw.GoToColumn(level0 + 2);                  lw.WriteLine("// Disassembly of native methods is not supported.");                  lw.GoToColumn(level0 + 2);                  lw.WriteLine("//  Managed TargetRVA = 0x{0:X8}"' method.__MethodRVA);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: if (body != null)              {                  lw.GoToColumn(level0 + 2);                  WriteIL(lw' method' body' method.DeclaringType == null ? null : method.DeclaringType.GetGenericArguments()' method.GetGenericArguments());              }              else if ((implflags & MethodImplAttributes.CodeTypeMask) == MethodImplAttributes.Native)              {                  lw.GoToColumn(level0 + 2);                  lw.WriteLine("// Embedded native code");                  lw.GoToColumn(level0 + 2);                  lw.WriteLine("// Disassembly of native methods is not supported.");                  lw.GoToColumn(level0 + 2);                  lw.WriteLine("//  Managed TargetRVA = 0x{0:X8}"' method.__MethodRVA);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: if (body != null)              {                  lw.GoToColumn(level0 + 2);                  WriteIL(lw' method' body' method.DeclaringType == null ? null : method.DeclaringType.GetGenericArguments()' method.GetGenericArguments());              }              else if ((implflags & MethodImplAttributes.CodeTypeMask) == MethodImplAttributes.Native)              {                  lw.GoToColumn(level0 + 2);                  lw.WriteLine("// Embedded native code");                  lw.GoToColumn(level0 + 2);                  lw.WriteLine("// Disassembly of native methods is not supported.");                  lw.GoToColumn(level0 + 2);                  lw.WriteLine("//  Managed TargetRVA = 0x{0:X8}"' method.__MethodRVA);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: if ((method.Attributes & MethodAttributes.PinvokeImpl) != 0 && (implflags & MethodImplAttributes.CodeTypeMask) != MethodImplAttributes.Native)              {                  lw.WriteLine("}");              }              else              {                  string methodName = GetMethodName(method);                  if ((method.Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.PrivateScope)                  {                      methodName = methodName.Substring(0' methodName.Length - 12);                  }                  if (method.DeclaringType == null)                  {                      lw.WriteLine("}} // end of global method {0}"' QuoteIdentifier(methodName));                  }                  else                  {                      lw.WriteLine("}} // end of method {0}::{1}"' QuoteIdentifier(method.DeclaringType.__Name)' QuoteIdentifier(methodName));                  }                  lw.WriteLine();              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,UnmanagedTypeToString,The following statement contains a magic number: switch (unmanagedType)              {                  case System.Runtime.InteropServices.UnmanagedType.Bool:                      return " bool";                  case System.Runtime.InteropServices.UnmanagedType.SysInt:                      return " int";                  case System.Runtime.InteropServices.UnmanagedType.SysUInt:                      return " uint";                  case System.Runtime.InteropServices.UnmanagedType.I1:                      return " int8";                  case System.Runtime.InteropServices.UnmanagedType.I2:                      return " int16";                  case System.Runtime.InteropServices.UnmanagedType.I4:                      return " int32";                  case System.Runtime.InteropServices.UnmanagedType.I8:                      return " int64";                  case System.Runtime.InteropServices.UnmanagedType.U1:                      return " unsigned int8";                  case System.Runtime.InteropServices.UnmanagedType.U2:                      return " unsigned int16";                  case System.Runtime.InteropServices.UnmanagedType.U4:                      return " unsigned int32";                  case System.Runtime.InteropServices.UnmanagedType.U8:                      return " unsigned int64";                  case System.Runtime.InteropServices.UnmanagedType.R4:                      return " float32";                  case System.Runtime.InteropServices.UnmanagedType.R8:                      return " float64";                  case System.Runtime.InteropServices.UnmanagedType.BStr:                      return " bstr";                  case System.Runtime.InteropServices.UnmanagedType.LPWStr:                      return " lpwstr";                  case System.Runtime.InteropServices.UnmanagedType.SafeArray:                      return " safearray";                  case System.Runtime.InteropServices.UnmanagedType.ByValArray:                      return " fixed array";                  case System.Runtime.InteropServices.UnmanagedType.ByValTStr:                      return " fixed sysstring";                  case System.Runtime.InteropServices.UnmanagedType.IUnknown:                      return " iunknown";                  case System.Runtime.InteropServices.UnmanagedType.Interface:                      return " interface";                  case System.Runtime.InteropServices.UnmanagedType.CustomMarshaler:                      return " custom ";                  case System.Runtime.InteropServices.UnmanagedType.LPArray:                      return "[]";                  case System.Runtime.InteropServices.UnmanagedType.AsAny:                      return " as any";                  case System.Runtime.InteropServices.UnmanagedType.LPStruct:                      return " lpstruct";                  case System.Runtime.InteropServices.UnmanagedType.IDispatch:                      return " idispatch ";                  case System.Runtime.InteropServices.UnmanagedType.Struct:                      return " struct";                  case System.Runtime.InteropServices.UnmanagedType.FunctionPtr:                      return " method";                  case System.Runtime.InteropServices.UnmanagedType.LPStr:                      return " lpstr";                  case System.Runtime.InteropServices.UnmanagedType.Error:                      return " error";                  case System.Runtime.InteropServices.UnmanagedType.LPTStr:                      return " lptstr";                  case System.Runtime.InteropServices.UnmanagedType.VBByRefStr:                      return " byvalstr";                  case System.Runtime.InteropServices.UnmanagedType.Currency:                      return " currency";                  case System.Runtime.InteropServices.UnmanagedType.VariantBool:                      return " variant bool";                  case (System.Runtime.InteropServices.UnmanagedType)80:                      return "";  // Microsoft.SqlServer.DTSRuntimeWrap.dll (9.0.242.0) has this bogus value                  case (System.Runtime.InteropServices.UnmanagedType)46:                      return compat == CompatLevel.None ? " iinspectable" : compat == CompatLevel.V45 ? "{ 2E }" : "";                  case (System.Runtime.InteropServices.UnmanagedType)47:                      return compat == CompatLevel.None ? " hstring" : compat == CompatLevel.V45 ? "{ 2F }" : "";                  default:                      Console.WriteLine("unsupported unmanagedType in marshal blob: {0}"' unmanagedType);                      return "";              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,UnmanagedTypeToString,The following statement contains a magic number: switch (unmanagedType)              {                  case System.Runtime.InteropServices.UnmanagedType.Bool:                      return " bool";                  case System.Runtime.InteropServices.UnmanagedType.SysInt:                      return " int";                  case System.Runtime.InteropServices.UnmanagedType.SysUInt:                      return " uint";                  case System.Runtime.InteropServices.UnmanagedType.I1:                      return " int8";                  case System.Runtime.InteropServices.UnmanagedType.I2:                      return " int16";                  case System.Runtime.InteropServices.UnmanagedType.I4:                      return " int32";                  case System.Runtime.InteropServices.UnmanagedType.I8:                      return " int64";                  case System.Runtime.InteropServices.UnmanagedType.U1:                      return " unsigned int8";                  case System.Runtime.InteropServices.UnmanagedType.U2:                      return " unsigned int16";                  case System.Runtime.InteropServices.UnmanagedType.U4:                      return " unsigned int32";                  case System.Runtime.InteropServices.UnmanagedType.U8:                      return " unsigned int64";                  case System.Runtime.InteropServices.UnmanagedType.R4:                      return " float32";                  case System.Runtime.InteropServices.UnmanagedType.R8:                      return " float64";                  case System.Runtime.InteropServices.UnmanagedType.BStr:                      return " bstr";                  case System.Runtime.InteropServices.UnmanagedType.LPWStr:                      return " lpwstr";                  case System.Runtime.InteropServices.UnmanagedType.SafeArray:                      return " safearray";                  case System.Runtime.InteropServices.UnmanagedType.ByValArray:                      return " fixed array";                  case System.Runtime.InteropServices.UnmanagedType.ByValTStr:                      return " fixed sysstring";                  case System.Runtime.InteropServices.UnmanagedType.IUnknown:                      return " iunknown";                  case System.Runtime.InteropServices.UnmanagedType.Interface:                      return " interface";                  case System.Runtime.InteropServices.UnmanagedType.CustomMarshaler:                      return " custom ";                  case System.Runtime.InteropServices.UnmanagedType.LPArray:                      return "[]";                  case System.Runtime.InteropServices.UnmanagedType.AsAny:                      return " as any";                  case System.Runtime.InteropServices.UnmanagedType.LPStruct:                      return " lpstruct";                  case System.Runtime.InteropServices.UnmanagedType.IDispatch:                      return " idispatch ";                  case System.Runtime.InteropServices.UnmanagedType.Struct:                      return " struct";                  case System.Runtime.InteropServices.UnmanagedType.FunctionPtr:                      return " method";                  case System.Runtime.InteropServices.UnmanagedType.LPStr:                      return " lpstr";                  case System.Runtime.InteropServices.UnmanagedType.Error:                      return " error";                  case System.Runtime.InteropServices.UnmanagedType.LPTStr:                      return " lptstr";                  case System.Runtime.InteropServices.UnmanagedType.VBByRefStr:                      return " byvalstr";                  case System.Runtime.InteropServices.UnmanagedType.Currency:                      return " currency";                  case System.Runtime.InteropServices.UnmanagedType.VariantBool:                      return " variant bool";                  case (System.Runtime.InteropServices.UnmanagedType)80:                      return "";  // Microsoft.SqlServer.DTSRuntimeWrap.dll (9.0.242.0) has this bogus value                  case (System.Runtime.InteropServices.UnmanagedType)46:                      return compat == CompatLevel.None ? " iinspectable" : compat == CompatLevel.V45 ? "{ 2E }" : "";                  case (System.Runtime.InteropServices.UnmanagedType)47:                      return compat == CompatLevel.None ? " hstring" : compat == CompatLevel.V45 ? "{ 2F }" : "";                  default:                      Console.WriteLine("unsupported unmanagedType in marshal blob: {0}"' unmanagedType);                      return "";              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,UnmanagedTypeToString,The following statement contains a magic number: switch (unmanagedType)              {                  case System.Runtime.InteropServices.UnmanagedType.Bool:                      return " bool";                  case System.Runtime.InteropServices.UnmanagedType.SysInt:                      return " int";                  case System.Runtime.InteropServices.UnmanagedType.SysUInt:                      return " uint";                  case System.Runtime.InteropServices.UnmanagedType.I1:                      return " int8";                  case System.Runtime.InteropServices.UnmanagedType.I2:                      return " int16";                  case System.Runtime.InteropServices.UnmanagedType.I4:                      return " int32";                  case System.Runtime.InteropServices.UnmanagedType.I8:                      return " int64";                  case System.Runtime.InteropServices.UnmanagedType.U1:                      return " unsigned int8";                  case System.Runtime.InteropServices.UnmanagedType.U2:                      return " unsigned int16";                  case System.Runtime.InteropServices.UnmanagedType.U4:                      return " unsigned int32";                  case System.Runtime.InteropServices.UnmanagedType.U8:                      return " unsigned int64";                  case System.Runtime.InteropServices.UnmanagedType.R4:                      return " float32";                  case System.Runtime.InteropServices.UnmanagedType.R8:                      return " float64";                  case System.Runtime.InteropServices.UnmanagedType.BStr:                      return " bstr";                  case System.Runtime.InteropServices.UnmanagedType.LPWStr:                      return " lpwstr";                  case System.Runtime.InteropServices.UnmanagedType.SafeArray:                      return " safearray";                  case System.Runtime.InteropServices.UnmanagedType.ByValArray:                      return " fixed array";                  case System.Runtime.InteropServices.UnmanagedType.ByValTStr:                      return " fixed sysstring";                  case System.Runtime.InteropServices.UnmanagedType.IUnknown:                      return " iunknown";                  case System.Runtime.InteropServices.UnmanagedType.Interface:                      return " interface";                  case System.Runtime.InteropServices.UnmanagedType.CustomMarshaler:                      return " custom ";                  case System.Runtime.InteropServices.UnmanagedType.LPArray:                      return "[]";                  case System.Runtime.InteropServices.UnmanagedType.AsAny:                      return " as any";                  case System.Runtime.InteropServices.UnmanagedType.LPStruct:                      return " lpstruct";                  case System.Runtime.InteropServices.UnmanagedType.IDispatch:                      return " idispatch ";                  case System.Runtime.InteropServices.UnmanagedType.Struct:                      return " struct";                  case System.Runtime.InteropServices.UnmanagedType.FunctionPtr:                      return " method";                  case System.Runtime.InteropServices.UnmanagedType.LPStr:                      return " lpstr";                  case System.Runtime.InteropServices.UnmanagedType.Error:                      return " error";                  case System.Runtime.InteropServices.UnmanagedType.LPTStr:                      return " lptstr";                  case System.Runtime.InteropServices.UnmanagedType.VBByRefStr:                      return " byvalstr";                  case System.Runtime.InteropServices.UnmanagedType.Currency:                      return " currency";                  case System.Runtime.InteropServices.UnmanagedType.VariantBool:                      return " variant bool";                  case (System.Runtime.InteropServices.UnmanagedType)80:                      return "";  // Microsoft.SqlServer.DTSRuntimeWrap.dll (9.0.242.0) has this bogus value                  case (System.Runtime.InteropServices.UnmanagedType)46:                      return compat == CompatLevel.None ? " iinspectable" : compat == CompatLevel.V45 ? "{ 2E }" : "";                  case (System.Runtime.InteropServices.UnmanagedType)47:                      return compat == CompatLevel.None ? " hstring" : compat == CompatLevel.V45 ? "{ 2F }" : "";                  default:                      Console.WriteLine("unsupported unmanagedType in marshal blob: {0}"' unmanagedType);                      return "";              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,QuoteIdentifier,The following statement contains a magic number: if (diffMode)              {                  if (str.StartsWith("$$method0x"' StringComparison.Ordinal))                  {                      return "'$$method0x...'";                  }                  else if (str.Length == 68 && str.StartsWith("<PrivateImplementationDetails>{"' StringComparison.Ordinal) && str.EndsWith("}"' StringComparison.Ordinal))                  {                      return "'<PrivateImplementationDetails>{nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn}'";                  }                  for (int pos' cur = 0; (pos = str.IndexOf("?A0x"' cur)) != -1; cur = pos + 4)                  {                      str = str.Substring(0' pos + 4) + "________" + str.Substring(pos + 12);                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,QuoteIdentifier,The following statement contains a magic number: if (diffMode)              {                  if (str.StartsWith("$$method0x"' StringComparison.Ordinal))                  {                      return "'$$method0x...'";                  }                  else if (str.Length == 68 && str.StartsWith("<PrivateImplementationDetails>{"' StringComparison.Ordinal) && str.EndsWith("}"' StringComparison.Ordinal))                  {                      return "'<PrivateImplementationDetails>{nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn}'";                  }                  for (int pos' cur = 0; (pos = str.IndexOf("?A0x"' cur)) != -1; cur = pos + 4)                  {                      str = str.Substring(0' pos + 4) + "________" + str.Substring(pos + 12);                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,QuoteIdentifier,The following statement contains a magic number: if (diffMode)              {                  if (str.StartsWith("$$method0x"' StringComparison.Ordinal))                  {                      return "'$$method0x...'";                  }                  else if (str.Length == 68 && str.StartsWith("<PrivateImplementationDetails>{"' StringComparison.Ordinal) && str.EndsWith("}"' StringComparison.Ordinal))                  {                      return "'<PrivateImplementationDetails>{nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn}'";                  }                  for (int pos' cur = 0; (pos = str.IndexOf("?A0x"' cur)) != -1; cur = pos + 4)                  {                      str = str.Substring(0' pos + 4) + "________" + str.Substring(pos + 12);                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,QuoteIdentifier,The following statement contains a magic number: if (diffMode)              {                  if (str.StartsWith("$$method0x"' StringComparison.Ordinal))                  {                      return "'$$method0x...'";                  }                  else if (str.Length == 68 && str.StartsWith("<PrivateImplementationDetails>{"' StringComparison.Ordinal) && str.EndsWith("}"' StringComparison.Ordinal))                  {                      return "'<PrivateImplementationDetails>{nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn}'";                  }                  for (int pos' cur = 0; (pos = str.IndexOf("?A0x"' cur)) != -1; cur = pos + 4)                  {                      str = str.Substring(0' pos + 4) + "________" + str.Substring(pos + 12);                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,QuoteIdentifier,The following statement contains a magic number: foreach (char c in str)              {                  if (c <= 32 || c >= 127)                  {                      quote = true;                      break;                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,QuoteIdentifier,The following statement contains a magic number: foreach (char c in str)              {                  if (c <= 32 || c >= 127)                  {                      quote = true;                      break;                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,QuoteIdentifier,The following statement contains a magic number: if (compat == CompatLevel.V20 || compat == CompatLevel.V40)              {                  StringBuilder sb = null;                  for (int i = 0; i < str.Length; i++)                  {                      if (str[i] >= 128)                      {                          if (sb == null)                          {                              sb = new StringBuilder(str);                          }                          sb[i] = '\uFFFD';                      }                  }                  if (sb != null)                  {                      str = sb.ToString();                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The following statement contains a magic number: lw.WriteLine(".assembly {0}{1}{2}"'                  ((int)assembly.__AssemblyFlags & 16) != 0 ? "cil " : ""'                  ((int)assembly.__AssemblyFlags & 512) != 0 && (compat == CompatLevel.None || compat >= CompatLevel.V45) ? "windowsruntime " : ""'                  QuoteIdentifier(assembly.GetName().Name));
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The following statement contains a magic number: lw.WriteLine(".assembly {0}{1}{2}"'                  ((int)assembly.__AssemblyFlags & 16) != 0 ? "cil " : ""'                  ((int)assembly.__AssemblyFlags & 512) != 0 && (compat == CompatLevel.None || compat >= CompatLevel.V45) ? "windowsruntime " : ""'                  QuoteIdentifier(assembly.GetName().Name));
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The following statement contains a magic number: WriteDeclarativeSecurity(lw' 2' CustomAttributeData.__GetDeclarativeSecurity(assembly)' 0x20000001);
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The following statement contains a magic number: if (assembly.GetName().CultureInfo != null)              {                  string culture = assembly.GetName().CultureInfo.Name;                  if (culture != "")                  {                      lw.Write("  .locale = (");                      byte[] buf = new byte[culture.Length * 2 + 2];                      for (int i = 0; i < culture.Length; i++)                      {                          buf[i * 2 + 0] = (byte)(culture[i] >> 0);                          buf[i * 2 + 1] = (byte)(culture[i] >> 8);                      }                      WriteBytes(lw' buf' false);                      lw.WriteLine();                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The following statement contains a magic number: if (assembly.GetName().CultureInfo != null)              {                  string culture = assembly.GetName().CultureInfo.Name;                  if (culture != "")                  {                      lw.Write("  .locale = (");                      byte[] buf = new byte[culture.Length * 2 + 2];                      for (int i = 0; i < culture.Length; i++)                      {                          buf[i * 2 + 0] = (byte)(culture[i] >> 0);                          buf[i * 2 + 1] = (byte)(culture[i] >> 8);                      }                      WriteBytes(lw' buf' false);                      lw.WriteLine();                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The following statement contains a magic number: if (assembly.GetName().CultureInfo != null)              {                  string culture = assembly.GetName().CultureInfo.Name;                  if (culture != "")                  {                      lw.Write("  .locale = (");                      byte[] buf = new byte[culture.Length * 2 + 2];                      for (int i = 0; i < culture.Length; i++)                      {                          buf[i * 2 + 0] = (byte)(culture[i] >> 0);                          buf[i * 2 + 1] = (byte)(culture[i] >> 8);                      }                      WriteBytes(lw' buf' false);                      lw.WriteLine();                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The following statement contains a magic number: if (assembly.GetName().CultureInfo != null)              {                  string culture = assembly.GetName().CultureInfo.Name;                  if (culture != "")                  {                      lw.Write("  .locale = (");                      byte[] buf = new byte[culture.Length * 2 + 2];                      for (int i = 0; i < culture.Length; i++)                      {                          buf[i * 2 + 0] = (byte)(culture[i] >> 0);                          buf[i * 2 + 1] = (byte)(culture[i] >> 8);                      }                      WriteBytes(lw' buf' false);                      lw.WriteLine();                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The following statement contains a magic number: if (assembly.GetName().CultureInfo != null)              {                  string culture = assembly.GetName().CultureInfo.Name;                  if (culture != "")                  {                      lw.Write("  .locale = (");                      byte[] buf = new byte[culture.Length * 2 + 2];                      for (int i = 0; i < culture.Length; i++)                      {                          buf[i * 2 + 0] = (byte)(culture[i] >> 0);                          buf[i * 2 + 1] = (byte)(culture[i] >> 8);                      }                      WriteBytes(lw' buf' false);                      lw.WriteLine();                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WritePermissionSet,The following statement contains a magic number: if (list.Count != 0)              {                  lw.GoToColumn(level);                  lw.Write(".permissionset ");                  switch (action)                  {                      case 0:                          break;                      case (System.Security.Permissions.SecurityAction)1:                          lw.Write("request");                          break;                      case System.Security.Permissions.SecurityAction.Assert:                          lw.Write("assert");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.Deny:  #pragma warning restore 618                          lw.Write("deny");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.PermitOnly:  #pragma warning restore 618                          lw.Write("permitonly");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestMinimum:  #pragma warning restore 618                          lw.Write("reqmin");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestRefuse:  #pragma warning restore 618                          lw.Write("reqrefuse");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestOptional:  #pragma warning restore 618                          lw.Write("reqopt");                          break;                      case System.Security.Permissions.SecurityAction.Demand:                          lw.Write("demand");                          break;                      case System.Security.Permissions.SecurityAction.LinkDemand:                          lw.Write("linkcheck");                          break;                      case System.Security.Permissions.SecurityAction.InheritanceDemand:                          lw.Write("inheritcheck");                          break;                      case (System.Security.Permissions.SecurityAction)11:                          lw.Write("prejitgrant");                          break;                      case (System.Security.Permissions.SecurityAction)12:                          lw.Write("prejitdeny");                          break;                      case (System.Security.Permissions.SecurityAction)13:                          lw.Write("noncasdemand");                          break;                      case (System.Security.Permissions.SecurityAction)14:                          lw.Write("noncaslinkdemand");                          break;                      case (System.Security.Permissions.SecurityAction)15:                          lw.Write("noncasinheritance");                          break;                      default:                          lw.Write("<UNKNOWN_ACTION>");                          break;                  }                  lw.WriteLine();                  lw.GoToColumn(level);                  var sb = new StringBuilder();                  if (list.Count == 1)                  {                      try                      {                          var args = list[0].NamedArguments;                          if (args.Count == 1 && args[0].MemberInfo.Name == "XML")                          {                              if (compat >= CompatLevel.V45)                              {                                  // starting with 4.5 ildasm no longer supports the 1.1 format                                  lw.Write("          bytearray (");                                  WriteBytes(lw' Encoding.Unicode.GetBytes((string)args[0].TypedValue.Value)' false);                                  lw.WriteLine();                                  return;                              }                              lw.Write("          ");                              WriteInlineString(lw' (string)args[0].TypedValue.Value' level);                              lw.WriteLine();                              return;                          }                      }                      catch (Managed.Reflection.MissingMemberException) { }                  }                  if (DecodeDeclSecurity(sb' list' level))                  {                      lw.WriteLine("{0}"' sb);                  }                  else                  {                      var mem = new System.IO.MemoryStream();                      mem.WriteByte((byte)'.');                      WriteCompressedInt(mem' list.Count);                      foreach (var sec in list)                      {                          Write(mem' sec.Constructor.DeclaringType.AssemblyQualifiedName.Replace("' PublicKeyToken=null"' ""));                          byte[] buf = sec.__GetBlob();                          WriteCompressedInt(mem' buf.Length);                          mem.Write(buf' 0' buf.Length);                      }                      byte[] blob = mem.ToArray();                      if ((compat == CompatLevel.V20 || compat == CompatLevel.V40) && (blob.Length & 1) == 1)                      {                          // ildasm bug http://connect.microsoft.com/VisualStudio/feedback/details/652653/                          Array.Resize(ref blob' blob.Length - 1);                      }                      lw.Write("          bytearray (");                      WriteBytes(lw' blob' false);                      lw.WriteLine();                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WritePermissionSet,The following statement contains a magic number: if (list.Count != 0)              {                  lw.GoToColumn(level);                  lw.Write(".permissionset ");                  switch (action)                  {                      case 0:                          break;                      case (System.Security.Permissions.SecurityAction)1:                          lw.Write("request");                          break;                      case System.Security.Permissions.SecurityAction.Assert:                          lw.Write("assert");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.Deny:  #pragma warning restore 618                          lw.Write("deny");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.PermitOnly:  #pragma warning restore 618                          lw.Write("permitonly");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestMinimum:  #pragma warning restore 618                          lw.Write("reqmin");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestRefuse:  #pragma warning restore 618                          lw.Write("reqrefuse");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestOptional:  #pragma warning restore 618                          lw.Write("reqopt");                          break;                      case System.Security.Permissions.SecurityAction.Demand:                          lw.Write("demand");                          break;                      case System.Security.Permissions.SecurityAction.LinkDemand:                          lw.Write("linkcheck");                          break;                      case System.Security.Permissions.SecurityAction.InheritanceDemand:                          lw.Write("inheritcheck");                          break;                      case (System.Security.Permissions.SecurityAction)11:                          lw.Write("prejitgrant");                          break;                      case (System.Security.Permissions.SecurityAction)12:                          lw.Write("prejitdeny");                          break;                      case (System.Security.Permissions.SecurityAction)13:                          lw.Write("noncasdemand");                          break;                      case (System.Security.Permissions.SecurityAction)14:                          lw.Write("noncaslinkdemand");                          break;                      case (System.Security.Permissions.SecurityAction)15:                          lw.Write("noncasinheritance");                          break;                      default:                          lw.Write("<UNKNOWN_ACTION>");                          break;                  }                  lw.WriteLine();                  lw.GoToColumn(level);                  var sb = new StringBuilder();                  if (list.Count == 1)                  {                      try                      {                          var args = list[0].NamedArguments;                          if (args.Count == 1 && args[0].MemberInfo.Name == "XML")                          {                              if (compat >= CompatLevel.V45)                              {                                  // starting with 4.5 ildasm no longer supports the 1.1 format                                  lw.Write("          bytearray (");                                  WriteBytes(lw' Encoding.Unicode.GetBytes((string)args[0].TypedValue.Value)' false);                                  lw.WriteLine();                                  return;                              }                              lw.Write("          ");                              WriteInlineString(lw' (string)args[0].TypedValue.Value' level);                              lw.WriteLine();                              return;                          }                      }                      catch (Managed.Reflection.MissingMemberException) { }                  }                  if (DecodeDeclSecurity(sb' list' level))                  {                      lw.WriteLine("{0}"' sb);                  }                  else                  {                      var mem = new System.IO.MemoryStream();                      mem.WriteByte((byte)'.');                      WriteCompressedInt(mem' list.Count);                      foreach (var sec in list)                      {                          Write(mem' sec.Constructor.DeclaringType.AssemblyQualifiedName.Replace("' PublicKeyToken=null"' ""));                          byte[] buf = sec.__GetBlob();                          WriteCompressedInt(mem' buf.Length);                          mem.Write(buf' 0' buf.Length);                      }                      byte[] blob = mem.ToArray();                      if ((compat == CompatLevel.V20 || compat == CompatLevel.V40) && (blob.Length & 1) == 1)                      {                          // ildasm bug http://connect.microsoft.com/VisualStudio/feedback/details/652653/                          Array.Resize(ref blob' blob.Length - 1);                      }                      lw.Write("          bytearray (");                      WriteBytes(lw' blob' false);                      lw.WriteLine();                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WritePermissionSet,The following statement contains a magic number: if (list.Count != 0)              {                  lw.GoToColumn(level);                  lw.Write(".permissionset ");                  switch (action)                  {                      case 0:                          break;                      case (System.Security.Permissions.SecurityAction)1:                          lw.Write("request");                          break;                      case System.Security.Permissions.SecurityAction.Assert:                          lw.Write("assert");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.Deny:  #pragma warning restore 618                          lw.Write("deny");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.PermitOnly:  #pragma warning restore 618                          lw.Write("permitonly");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestMinimum:  #pragma warning restore 618                          lw.Write("reqmin");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestRefuse:  #pragma warning restore 618                          lw.Write("reqrefuse");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestOptional:  #pragma warning restore 618                          lw.Write("reqopt");                          break;                      case System.Security.Permissions.SecurityAction.Demand:                          lw.Write("demand");                          break;                      case System.Security.Permissions.SecurityAction.LinkDemand:                          lw.Write("linkcheck");                          break;                      case System.Security.Permissions.SecurityAction.InheritanceDemand:                          lw.Write("inheritcheck");                          break;                      case (System.Security.Permissions.SecurityAction)11:                          lw.Write("prejitgrant");                          break;                      case (System.Security.Permissions.SecurityAction)12:                          lw.Write("prejitdeny");                          break;                      case (System.Security.Permissions.SecurityAction)13:                          lw.Write("noncasdemand");                          break;                      case (System.Security.Permissions.SecurityAction)14:                          lw.Write("noncaslinkdemand");                          break;                      case (System.Security.Permissions.SecurityAction)15:                          lw.Write("noncasinheritance");                          break;                      default:                          lw.Write("<UNKNOWN_ACTION>");                          break;                  }                  lw.WriteLine();                  lw.GoToColumn(level);                  var sb = new StringBuilder();                  if (list.Count == 1)                  {                      try                      {                          var args = list[0].NamedArguments;                          if (args.Count == 1 && args[0].MemberInfo.Name == "XML")                          {                              if (compat >= CompatLevel.V45)                              {                                  // starting with 4.5 ildasm no longer supports the 1.1 format                                  lw.Write("          bytearray (");                                  WriteBytes(lw' Encoding.Unicode.GetBytes((string)args[0].TypedValue.Value)' false);                                  lw.WriteLine();                                  return;                              }                              lw.Write("          ");                              WriteInlineString(lw' (string)args[0].TypedValue.Value' level);                              lw.WriteLine();                              return;                          }                      }                      catch (Managed.Reflection.MissingMemberException) { }                  }                  if (DecodeDeclSecurity(sb' list' level))                  {                      lw.WriteLine("{0}"' sb);                  }                  else                  {                      var mem = new System.IO.MemoryStream();                      mem.WriteByte((byte)'.');                      WriteCompressedInt(mem' list.Count);                      foreach (var sec in list)                      {                          Write(mem' sec.Constructor.DeclaringType.AssemblyQualifiedName.Replace("' PublicKeyToken=null"' ""));                          byte[] buf = sec.__GetBlob();                          WriteCompressedInt(mem' buf.Length);                          mem.Write(buf' 0' buf.Length);                      }                      byte[] blob = mem.ToArray();                      if ((compat == CompatLevel.V20 || compat == CompatLevel.V40) && (blob.Length & 1) == 1)                      {                          // ildasm bug http://connect.microsoft.com/VisualStudio/feedback/details/652653/                          Array.Resize(ref blob' blob.Length - 1);                      }                      lw.Write("          bytearray (");                      WriteBytes(lw' blob' false);                      lw.WriteLine();                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WritePermissionSet,The following statement contains a magic number: if (list.Count != 0)              {                  lw.GoToColumn(level);                  lw.Write(".permissionset ");                  switch (action)                  {                      case 0:                          break;                      case (System.Security.Permissions.SecurityAction)1:                          lw.Write("request");                          break;                      case System.Security.Permissions.SecurityAction.Assert:                          lw.Write("assert");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.Deny:  #pragma warning restore 618                          lw.Write("deny");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.PermitOnly:  #pragma warning restore 618                          lw.Write("permitonly");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestMinimum:  #pragma warning restore 618                          lw.Write("reqmin");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestRefuse:  #pragma warning restore 618                          lw.Write("reqrefuse");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestOptional:  #pragma warning restore 618                          lw.Write("reqopt");                          break;                      case System.Security.Permissions.SecurityAction.Demand:                          lw.Write("demand");                          break;                      case System.Security.Permissions.SecurityAction.LinkDemand:                          lw.Write("linkcheck");                          break;                      case System.Security.Permissions.SecurityAction.InheritanceDemand:                          lw.Write("inheritcheck");                          break;                      case (System.Security.Permissions.SecurityAction)11:                          lw.Write("prejitgrant");                          break;                      case (System.Security.Permissions.SecurityAction)12:                          lw.Write("prejitdeny");                          break;                      case (System.Security.Permissions.SecurityAction)13:                          lw.Write("noncasdemand");                          break;                      case (System.Security.Permissions.SecurityAction)14:                          lw.Write("noncaslinkdemand");                          break;                      case (System.Security.Permissions.SecurityAction)15:                          lw.Write("noncasinheritance");                          break;                      default:                          lw.Write("<UNKNOWN_ACTION>");                          break;                  }                  lw.WriteLine();                  lw.GoToColumn(level);                  var sb = new StringBuilder();                  if (list.Count == 1)                  {                      try                      {                          var args = list[0].NamedArguments;                          if (args.Count == 1 && args[0].MemberInfo.Name == "XML")                          {                              if (compat >= CompatLevel.V45)                              {                                  // starting with 4.5 ildasm no longer supports the 1.1 format                                  lw.Write("          bytearray (");                                  WriteBytes(lw' Encoding.Unicode.GetBytes((string)args[0].TypedValue.Value)' false);                                  lw.WriteLine();                                  return;                              }                              lw.Write("          ");                              WriteInlineString(lw' (string)args[0].TypedValue.Value' level);                              lw.WriteLine();                              return;                          }                      }                      catch (Managed.Reflection.MissingMemberException) { }                  }                  if (DecodeDeclSecurity(sb' list' level))                  {                      lw.WriteLine("{0}"' sb);                  }                  else                  {                      var mem = new System.IO.MemoryStream();                      mem.WriteByte((byte)'.');                      WriteCompressedInt(mem' list.Count);                      foreach (var sec in list)                      {                          Write(mem' sec.Constructor.DeclaringType.AssemblyQualifiedName.Replace("' PublicKeyToken=null"' ""));                          byte[] buf = sec.__GetBlob();                          WriteCompressedInt(mem' buf.Length);                          mem.Write(buf' 0' buf.Length);                      }                      byte[] blob = mem.ToArray();                      if ((compat == CompatLevel.V20 || compat == CompatLevel.V40) && (blob.Length & 1) == 1)                      {                          // ildasm bug http://connect.microsoft.com/VisualStudio/feedback/details/652653/                          Array.Resize(ref blob' blob.Length - 1);                      }                      lw.Write("          bytearray (");                      WriteBytes(lw' blob' false);                      lw.WriteLine();                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WritePermissionSet,The following statement contains a magic number: if (list.Count != 0)              {                  lw.GoToColumn(level);                  lw.Write(".permissionset ");                  switch (action)                  {                      case 0:                          break;                      case (System.Security.Permissions.SecurityAction)1:                          lw.Write("request");                          break;                      case System.Security.Permissions.SecurityAction.Assert:                          lw.Write("assert");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.Deny:  #pragma warning restore 618                          lw.Write("deny");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.PermitOnly:  #pragma warning restore 618                          lw.Write("permitonly");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestMinimum:  #pragma warning restore 618                          lw.Write("reqmin");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestRefuse:  #pragma warning restore 618                          lw.Write("reqrefuse");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestOptional:  #pragma warning restore 618                          lw.Write("reqopt");                          break;                      case System.Security.Permissions.SecurityAction.Demand:                          lw.Write("demand");                          break;                      case System.Security.Permissions.SecurityAction.LinkDemand:                          lw.Write("linkcheck");                          break;                      case System.Security.Permissions.SecurityAction.InheritanceDemand:                          lw.Write("inheritcheck");                          break;                      case (System.Security.Permissions.SecurityAction)11:                          lw.Write("prejitgrant");                          break;                      case (System.Security.Permissions.SecurityAction)12:                          lw.Write("prejitdeny");                          break;                      case (System.Security.Permissions.SecurityAction)13:                          lw.Write("noncasdemand");                          break;                      case (System.Security.Permissions.SecurityAction)14:                          lw.Write("noncaslinkdemand");                          break;                      case (System.Security.Permissions.SecurityAction)15:                          lw.Write("noncasinheritance");                          break;                      default:                          lw.Write("<UNKNOWN_ACTION>");                          break;                  }                  lw.WriteLine();                  lw.GoToColumn(level);                  var sb = new StringBuilder();                  if (list.Count == 1)                  {                      try                      {                          var args = list[0].NamedArguments;                          if (args.Count == 1 && args[0].MemberInfo.Name == "XML")                          {                              if (compat >= CompatLevel.V45)                              {                                  // starting with 4.5 ildasm no longer supports the 1.1 format                                  lw.Write("          bytearray (");                                  WriteBytes(lw' Encoding.Unicode.GetBytes((string)args[0].TypedValue.Value)' false);                                  lw.WriteLine();                                  return;                              }                              lw.Write("          ");                              WriteInlineString(lw' (string)args[0].TypedValue.Value' level);                              lw.WriteLine();                              return;                          }                      }                      catch (Managed.Reflection.MissingMemberException) { }                  }                  if (DecodeDeclSecurity(sb' list' level))                  {                      lw.WriteLine("{0}"' sb);                  }                  else                  {                      var mem = new System.IO.MemoryStream();                      mem.WriteByte((byte)'.');                      WriteCompressedInt(mem' list.Count);                      foreach (var sec in list)                      {                          Write(mem' sec.Constructor.DeclaringType.AssemblyQualifiedName.Replace("' PublicKeyToken=null"' ""));                          byte[] buf = sec.__GetBlob();                          WriteCompressedInt(mem' buf.Length);                          mem.Write(buf' 0' buf.Length);                      }                      byte[] blob = mem.ToArray();                      if ((compat == CompatLevel.V20 || compat == CompatLevel.V40) && (blob.Length & 1) == 1)                      {                          // ildasm bug http://connect.microsoft.com/VisualStudio/feedback/details/652653/                          Array.Resize(ref blob' blob.Length - 1);                      }                      lw.Write("          bytearray (");                      WriteBytes(lw' blob' false);                      lw.WriteLine();                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteCompressedInt,The following statement contains a magic number: if (value <= 0x7F)              {                  mem.WriteByte((byte)value);              }              else if (value <= 0x3FFF)              {                  mem.WriteByte((byte)(0x80 | (value >> 8)));                  mem.WriteByte((byte)value);              }              else              {                  mem.WriteByte((byte)(0xC0 | (value >> 24)));                  mem.WriteByte((byte)(value >> 16));                  mem.WriteByte((byte)(value >> 8));                  mem.WriteByte((byte)value);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteCompressedInt,The following statement contains a magic number: if (value <= 0x7F)              {                  mem.WriteByte((byte)value);              }              else if (value <= 0x3FFF)              {                  mem.WriteByte((byte)(0x80 | (value >> 8)));                  mem.WriteByte((byte)value);              }              else              {                  mem.WriteByte((byte)(0xC0 | (value >> 24)));                  mem.WriteByte((byte)(value >> 16));                  mem.WriteByte((byte)(value >> 8));                  mem.WriteByte((byte)value);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteCompressedInt,The following statement contains a magic number: if (value <= 0x7F)              {                  mem.WriteByte((byte)value);              }              else if (value <= 0x3FFF)              {                  mem.WriteByte((byte)(0x80 | (value >> 8)));                  mem.WriteByte((byte)value);              }              else              {                  mem.WriteByte((byte)(0xC0 | (value >> 24)));                  mem.WriteByte((byte)(value >> 16));                  mem.WriteByte((byte)(value >> 8));                  mem.WriteByte((byte)value);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteCompressedInt,The following statement contains a magic number: if (value <= 0x7F)              {                  mem.WriteByte((byte)value);              }              else if (value <= 0x3FFF)              {                  mem.WriteByte((byte)(0x80 | (value >> 8)));                  mem.WriteByte((byte)value);              }              else              {                  mem.WriteByte((byte)(0xC0 | (value >> 24)));                  mem.WriteByte((byte)(value >> 16));                  mem.WriteByte((byte)(value >> 8));                  mem.WriteByte((byte)value);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteModuleHeader,The following statement contains a magic number: if (compat == CompatLevel.V20 || GetPointerSize() == 4)              {                  lw.WriteLine(".imagebase 0x{0:x8}"' module.__ImageBase);              }              else              {                  lw.WriteLine(".imagebase 0x{0:x16}"' module.__ImageBase);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteModuleHeader,The following statement contains a magic number: if (GetPointerSize() == 4)              {                  lw.WriteLine(".stackreserve 0x{0:x8}"' module.__StackReserve);              }              else              {                  lw.WriteLine(".stackreserve 0x{0:x16}"' module.__StackReserve);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetCorFlags,The following statement contains a magic number: module.__GetDataDirectoryEntry(14' out rva' out length);
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetCorFlags,The following statement contains a magic number: var buf = new byte[4];
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetCorFlags,The following statement contains a magic number: module.__ReadDataFromRVA(rva + 16' buf' 0' 4);
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetCorFlags,The following statement contains a magic number: module.__ReadDataFromRVA(rva + 16' buf' 0' 4);
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,SubsystemToString,The following statement contains a magic number: switch (subsystem)              {                  case 2:                      return "WINDOWS_GUI";                  case 3:                      return "WINDOWS_CUI";                  default:                      throw new NotImplementedException();              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,SubsystemToString,The following statement contains a magic number: switch (subsystem)              {                  case 2:                      return "WINDOWS_GUI";                  case 3:                      return "WINDOWS_CUI";                  default:                      throw new NotImplementedException();              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteCustomAttributeImpl,The following statement contains a magic number: if (blob.Length == 0)              {                  lw.WriteLine(")");              }              else              {                  var wrap = lw.Column >= 80;                  StringBuilder sb;                  if ((flags & Flags.Caverbal) != 0 && DecodeCABlob(sb = new StringBuilder()' ca.Constructor' blob' wrap ? (level0 + 4) * (comment ? -1 : 1) : lw.Column + 5))                  {                      lw.Write(")");                      if (wrap)                      {                          lw.WriteLine();                          if (comment)                          {                              lw.Write("  //");                          }                          lw.GoToColumn(level0);                      }                      lw.Write(" = {{{0}"' sb);                      lw.WriteLine("}");                  }                  else                  {                      lw.Write(") = ( ");                      WriteBytes(lw' blob' false);                      lw.WriteLine();                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteCustomAttributeImpl,The following statement contains a magic number: if (blob.Length == 0)              {                  lw.WriteLine(")");              }              else              {                  var wrap = lw.Column >= 80;                  StringBuilder sb;                  if ((flags & Flags.Caverbal) != 0 && DecodeCABlob(sb = new StringBuilder()' ca.Constructor' blob' wrap ? (level0 + 4) * (comment ? -1 : 1) : lw.Column + 5))                  {                      lw.Write(")");                      if (wrap)                      {                          lw.WriteLine();                          if (comment)                          {                              lw.Write("  //");                          }                          lw.GoToColumn(level0);                      }                      lw.Write(" = {{{0}"' sb);                      lw.WriteLine("}");                  }                  else                  {                      lw.Write(") = ( ");                      WriteBytes(lw' blob' false);                      lw.WriteLine();                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteCustomAttributeImpl,The following statement contains a magic number: if (blob.Length == 0)              {                  lw.WriteLine(")");              }              else              {                  var wrap = lw.Column >= 80;                  StringBuilder sb;                  if ((flags & Flags.Caverbal) != 0 && DecodeCABlob(sb = new StringBuilder()' ca.Constructor' blob' wrap ? (level0 + 4) * (comment ? -1 : 1) : lw.Column + 5))                  {                      lw.Write(")");                      if (wrap)                      {                          lw.WriteLine();                          if (comment)                          {                              lw.Write("  //");                          }                          lw.GoToColumn(level0);                      }                      lw.Write(" = {{{0}"' sb);                      lw.WriteLine("}");                  }                  else                  {                      lw.Write(") = ( ");                      WriteBytes(lw' blob' false);                      lw.WriteLine();                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteBytes,The following statement contains a magic number: for (int i = 0; i < buf.Length; i++)              {                  if (i != 0)                  {                      if (i % 16 == 0)                      {                          if (hasText)                          {                              hasText = false;                              lw.Write(data ? "  // " : "   // ");                              for (int j = i - 16; j < i; j++)                              {                                  lw.Write("{0}"' IsText(buf[j]) ? (char)buf[j] : '.');                              }                          }                          else if (!data)                          {                              lw.Write(" ");                          }                          lw.WriteLine();                          lw.GoToColumn(column);                      }                      else                      {                          lw.Write(" ");                      }                  }                  lw.Write("{0:X2}"' buf[i]);                  hasText |= IsText(buf[i]);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteBytes,The following statement contains a magic number: for (int i = 0; i < buf.Length; i++)              {                  if (i != 0)                  {                      if (i % 16 == 0)                      {                          if (hasText)                          {                              hasText = false;                              lw.Write(data ? "  // " : "   // ");                              for (int j = i - 16; j < i; j++)                              {                                  lw.Write("{0}"' IsText(buf[j]) ? (char)buf[j] : '.');                              }                          }                          else if (!data)                          {                              lw.Write(" ");                          }                          lw.WriteLine();                          lw.GoToColumn(column);                      }                      else                      {                          lw.Write(" ");                      }                  }                  lw.Write("{0:X2}"' buf[i]);                  hasText |= IsText(buf[i]);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteBytes,The following statement contains a magic number: if (hasText)              {                  lw.GoToColumn(column + 16 * 3 + (data ? 1 : 2));                  lw.Write("// ");                  for (int j = (buf.Length + 15 & ~15) - 16; j < buf.Length; j++)                  {                      lw.Write("{0}"' IsText(buf[j]) ? (char)buf[j] : '.');                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteBytes,The following statement contains a magic number: if (hasText)              {                  lw.GoToColumn(column + 16 * 3 + (data ? 1 : 2));                  lw.Write("// ");                  for (int j = (buf.Length + 15 & ~15) - 16; j < buf.Length; j++)                  {                      lw.Write("{0}"' IsText(buf[j]) ? (char)buf[j] : '.');                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteBytes,The following statement contains a magic number: if (hasText)              {                  lw.GoToColumn(column + 16 * 3 + (data ? 1 : 2));                  lw.Write("// ");                  for (int j = (buf.Length + 15 & ~15) - 16; j < buf.Length; j++)                  {                      lw.Write("{0}"' IsText(buf[j]) ? (char)buf[j] : '.');                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteBytes,The following statement contains a magic number: if (hasText)              {                  lw.GoToColumn(column + 16 * 3 + (data ? 1 : 2));                  lw.Write("// ");                  for (int j = (buf.Length + 15 & ~15) - 16; j < buf.Length; j++)                  {                      lw.Write("{0}"' IsText(buf[j]) ? (char)buf[j] : '.');                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteBytes,The following statement contains a magic number: if (hasText)              {                  lw.GoToColumn(column + 16 * 3 + (data ? 1 : 2));                  lw.Write("// ");                  for (int j = (buf.Length + 15 & ~15) - 16; j < buf.Length; j++)                  {                      lw.Write("{0}"' IsText(buf[j]) ? (char)buf[j] : '.');                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteBytes,The following statement contains a magic number: if (hasText)              {                  lw.GoToColumn(column + 16 * 3 + (data ? 1 : 2));                  lw.Write("// ");                  for (int j = (buf.Length + 15 & ~15) - 16; j < buf.Length; j++)                  {                      lw.Write("{0}"' IsText(buf[j]) ? (char)buf[j] : '.');                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,IsText,The following statement contains a magic number: return b >= 32 && b < 127;
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,IsText,The following statement contains a magic number: return b >= 32 && b < 127;
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetExportedMethods,The following statement contains a magic number: if (rva == 0 || length < 40)              {                  return new Dictionary<int' List<ExportedMethod>>();              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetExportedMethods,The following statement contains a magic number: byte[] buf = new byte[512];
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetExportedMethods,The following statement contains a magic number: module.__ReadDataFromRVA(rva' buf' 0' 40);
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetExportedMethods,The following statement contains a magic number: for (int i = 0; i < edt.NumberOfNamePointers; i++)              {                  module.__ReadDataFromRVA((int)edt.OrdinalTableRVA + i * 2' buf' 0' 2);                  int ordinal = BitConverter.ToInt16(buf' 0) + (int)edt.OrdinalBase;                  string name = null;                  if (edt.NamePointerRVA != 0)                  {                      module.__ReadDataFromRVA((int)edt.NamePointerRVA + i * 4' buf' 0' 4);                      module.__ReadDataFromRVA(BitConverter.ToInt32(buf' 0)' buf' 0' buf.Length);                      int len = 0;                      while (buf[len] != 0) len++;                      name = Encoding.ASCII.GetString(buf' 0' len);                  }                  int token = GetTokenFromExportOrdinal(module' edt' ordinal);                  if (token == -1)                  {                      continue;                  }                  List<ExportedMethod> list;                  if (!methods.TryGetValue(token' out list))                  {                      list = new List<ExportedMethod>();                      methods.Add(token' list);                  }                  ExportedMethod method;                  method.name = name;                  method.ordinal = ordinal;                  list.Add(method);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetExportedMethods,The following statement contains a magic number: for (int i = 0; i < edt.NumberOfNamePointers; i++)              {                  module.__ReadDataFromRVA((int)edt.OrdinalTableRVA + i * 2' buf' 0' 2);                  int ordinal = BitConverter.ToInt16(buf' 0) + (int)edt.OrdinalBase;                  string name = null;                  if (edt.NamePointerRVA != 0)                  {                      module.__ReadDataFromRVA((int)edt.NamePointerRVA + i * 4' buf' 0' 4);                      module.__ReadDataFromRVA(BitConverter.ToInt32(buf' 0)' buf' 0' buf.Length);                      int len = 0;                      while (buf[len] != 0) len++;                      name = Encoding.ASCII.GetString(buf' 0' len);                  }                  int token = GetTokenFromExportOrdinal(module' edt' ordinal);                  if (token == -1)                  {                      continue;                  }                  List<ExportedMethod> list;                  if (!methods.TryGetValue(token' out list))                  {                      list = new List<ExportedMethod>();                      methods.Add(token' list);                  }                  ExportedMethod method;                  method.name = name;                  method.ordinal = ordinal;                  list.Add(method);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetExportedMethods,The following statement contains a magic number: for (int i = 0; i < edt.NumberOfNamePointers; i++)              {                  module.__ReadDataFromRVA((int)edt.OrdinalTableRVA + i * 2' buf' 0' 2);                  int ordinal = BitConverter.ToInt16(buf' 0) + (int)edt.OrdinalBase;                  string name = null;                  if (edt.NamePointerRVA != 0)                  {                      module.__ReadDataFromRVA((int)edt.NamePointerRVA + i * 4' buf' 0' 4);                      module.__ReadDataFromRVA(BitConverter.ToInt32(buf' 0)' buf' 0' buf.Length);                      int len = 0;                      while (buf[len] != 0) len++;                      name = Encoding.ASCII.GetString(buf' 0' len);                  }                  int token = GetTokenFromExportOrdinal(module' edt' ordinal);                  if (token == -1)                  {                      continue;                  }                  List<ExportedMethod> list;                  if (!methods.TryGetValue(token' out list))                  {                      list = new List<ExportedMethod>();                      methods.Add(token' list);                  }                  ExportedMethod method;                  method.name = name;                  method.ordinal = ordinal;                  list.Add(method);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetExportedMethods,The following statement contains a magic number: for (int i = 0; i < edt.NumberOfNamePointers; i++)              {                  module.__ReadDataFromRVA((int)edt.OrdinalTableRVA + i * 2' buf' 0' 2);                  int ordinal = BitConverter.ToInt16(buf' 0) + (int)edt.OrdinalBase;                  string name = null;                  if (edt.NamePointerRVA != 0)                  {                      module.__ReadDataFromRVA((int)edt.NamePointerRVA + i * 4' buf' 0' 4);                      module.__ReadDataFromRVA(BitConverter.ToInt32(buf' 0)' buf' 0' buf.Length);                      int len = 0;                      while (buf[len] != 0) len++;                      name = Encoding.ASCII.GetString(buf' 0' len);                  }                  int token = GetTokenFromExportOrdinal(module' edt' ordinal);                  if (token == -1)                  {                      continue;                  }                  List<ExportedMethod> list;                  if (!methods.TryGetValue(token' out list))                  {                      list = new List<ExportedMethod>();                      methods.Add(token' list);                  }                  ExportedMethod method;                  method.name = name;                  method.ordinal = ordinal;                  list.Add(method);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetTokenFromExportOrdinal,The following statement contains a magic number: byte[] buf = new byte[16];
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetTokenFromExportOrdinal,The following statement contains a magic number: module.__ReadDataFromRVA((int)edt.ExportAddressTableRVA + (int)(ordinal - edt.OrdinalBase) * 4' buf' 0' 4);
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetTokenFromExportOrdinal,The following statement contains a magic number: module.__ReadDataFromRVA((int)edt.ExportAddressTableRVA + (int)(ordinal - edt.OrdinalBase) * 4' buf' 0' 4);
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetTokenFromExportOrdinal,The following statement contains a magic number: module.__ReadDataFromRVA(exportRVA' buf' 0' 16);
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetTokenFromExportOrdinal,The following statement contains a magic number: if (machine == ImageFileMachine.I386 && buf[0] == 0xFF && buf[1] == 0x25)              {                  // for x86 the code here is:                  //   FF 25 00 40 40 00               jmp         dword ptr ds:[00404000h]                  offset = 2;              }              else if (machine == ImageFileMachine.AMD64 && buf[0] == 0x48 && buf[1] == 0xA1)              {                  // for x64 the code here is:                  //   48 A1 00 40 40 00 00 00 00 00   mov         rax'qword ptr [0000000000404000h]                  //   FF E0                           jmp         rax                  offset = 2;              }              else if (machine == ImageFileMachine.ARM && buf[0] == 0xDF && buf[1] == 0xF8 && buf[2] == 0x08 && buf[3] == 0xC0)              {                  // for arm the code here is:                  // F8DF C008 ldr         r12'0040145C                  // F8DC C000 ldr         r12'[r12]                  // 4760      bx          r12                  // DEFE      __debugbreak                  // here is the RVA                  offset = 12;              }              else              {                  return -1;              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetTokenFromExportOrdinal,The following statement contains a magic number: if (machine == ImageFileMachine.I386 && buf[0] == 0xFF && buf[1] == 0x25)              {                  // for x86 the code here is:                  //   FF 25 00 40 40 00               jmp         dword ptr ds:[00404000h]                  offset = 2;              }              else if (machine == ImageFileMachine.AMD64 && buf[0] == 0x48 && buf[1] == 0xA1)              {                  // for x64 the code here is:                  //   48 A1 00 40 40 00 00 00 00 00   mov         rax'qword ptr [0000000000404000h]                  //   FF E0                           jmp         rax                  offset = 2;              }              else if (machine == ImageFileMachine.ARM && buf[0] == 0xDF && buf[1] == 0xF8 && buf[2] == 0x08 && buf[3] == 0xC0)              {                  // for arm the code here is:                  // F8DF C008 ldr         r12'0040145C                  // F8DC C000 ldr         r12'[r12]                  // 4760      bx          r12                  // DEFE      __debugbreak                  // here is the RVA                  offset = 12;              }              else              {                  return -1;              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetTokenFromExportOrdinal,The following statement contains a magic number: if (machine == ImageFileMachine.I386 && buf[0] == 0xFF && buf[1] == 0x25)              {                  // for x86 the code here is:                  //   FF 25 00 40 40 00               jmp         dword ptr ds:[00404000h]                  offset = 2;              }              else if (machine == ImageFileMachine.AMD64 && buf[0] == 0x48 && buf[1] == 0xA1)              {                  // for x64 the code here is:                  //   48 A1 00 40 40 00 00 00 00 00   mov         rax'qword ptr [0000000000404000h]                  //   FF E0                           jmp         rax                  offset = 2;              }              else if (machine == ImageFileMachine.ARM && buf[0] == 0xDF && buf[1] == 0xF8 && buf[2] == 0x08 && buf[3] == 0xC0)              {                  // for arm the code here is:                  // F8DF C008 ldr         r12'0040145C                  // F8DC C000 ldr         r12'[r12]                  // 4760      bx          r12                  // DEFE      __debugbreak                  // here is the RVA                  offset = 12;              }              else              {                  return -1;              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetTokenFromExportOrdinal,The following statement contains a magic number: if (machine == ImageFileMachine.I386 && buf[0] == 0xFF && buf[1] == 0x25)              {                  // for x86 the code here is:                  //   FF 25 00 40 40 00               jmp         dword ptr ds:[00404000h]                  offset = 2;              }              else if (machine == ImageFileMachine.AMD64 && buf[0] == 0x48 && buf[1] == 0xA1)              {                  // for x64 the code here is:                  //   48 A1 00 40 40 00 00 00 00 00   mov         rax'qword ptr [0000000000404000h]                  //   FF E0                           jmp         rax                  offset = 2;              }              else if (machine == ImageFileMachine.ARM && buf[0] == 0xDF && buf[1] == 0xF8 && buf[2] == 0x08 && buf[3] == 0xC0)              {                  // for arm the code here is:                  // F8DF C008 ldr         r12'0040145C                  // F8DC C000 ldr         r12'[r12]                  // 4760      bx          r12                  // DEFE      __debugbreak                  // here is the RVA                  offset = 12;              }              else              {                  return -1;              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetTokenFromExportOrdinal,The following statement contains a magic number: if (machine == ImageFileMachine.I386 && buf[0] == 0xFF && buf[1] == 0x25)              {                  // for x86 the code here is:                  //   FF 25 00 40 40 00               jmp         dword ptr ds:[00404000h]                  offset = 2;              }              else if (machine == ImageFileMachine.AMD64 && buf[0] == 0x48 && buf[1] == 0xA1)              {                  // for x64 the code here is:                  //   48 A1 00 40 40 00 00 00 00 00   mov         rax'qword ptr [0000000000404000h]                  //   FF E0                           jmp         rax                  offset = 2;              }              else if (machine == ImageFileMachine.ARM && buf[0] == 0xDF && buf[1] == 0xF8 && buf[2] == 0x08 && buf[3] == 0xC0)              {                  // for arm the code here is:                  // F8DF C008 ldr         r12'0040145C                  // F8DC C000 ldr         r12'[r12]                  // 4760      bx          r12                  // DEFE      __debugbreak                  // here is the RVA                  offset = 12;              }              else              {                  return -1;              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetTokenFromExportOrdinal,The following statement contains a magic number: module.__ReadDataFromRVA(vtableRVA' buf' 0' 4);
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetOpCodes,The following statement contains a magic number: OpCode[] opcodes = new OpCode[768];
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetOpCodes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo field in typeof(OpCodes).GetFields())              {                  OpCode opc = (OpCode)field.GetValue(null);                  opcodes[opc.Value + 512] = opc;              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: if (locals.Count != 0)              {                  lw.GoToColumn(level);                  lw.Write(".locals ");                  if (body.InitLocals)                  {                      lw.Write("init ");                  }                  lw.Write("(");                  bool first = true;                  foreach (var local in locals)                  {                      if (!first)                      {                          lw.WriteLine("'");                          lw.GoToColumn(level + 9);                      }                      first = false;                      WriteSignatureType(lw' local.LocalType' TypeLocation.Local);                      if (local.IsPinned)                      {                          lw.Write(" pinned");                      }                      WriteCustomModifiers(lw' local.__GetCustomModifiers());                      lw.Write(" V_{0}"' local.LocalIndex);                  }                  lw.WriteLine(")");              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: while (pos < code.Length)              {                  if (extraNewLine)                  {                      lw.WriteLine();                      extraNewLine = false;                  }                  if (currentException != null)                  {                      if (currentException.HandlerOffset == pos)                      {                          switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }                      }                      else if (currentException.FilterOffset == pos && pos != 0)                      {                          lw.GoToColumn(level - 2);                          if (handler)                          {                              lw.WriteLine("}  // end handler");                          }                          else                          {                              lw.WriteLine("}  // end .try");                          }                          lw.GoToColumn(level - 2);                          lw.WriteLine("filter");                          lw.GoToColumn(level - 2);                          lw.WriteLine("{");                      }                  }                  while (nextException < exceptions.Count                      && exceptions[nextException].TryOffset == pos)                  {                      activeExceptions.Push(currentException);                      ExceptionHandlingClause prevException = currentException;                      currentException = exceptions[nextException++];                      if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength)                      {                          // another handler for the same block                          continue;                      }                      handler = false;                      lw.GoToColumn(level);                      lw.WriteLine(".try");                      lw.GoToColumn(level);                      lw.WriteLine("{");                      level += 2;                  }                  lw.GoToColumn(level);                  int currPos = pos;                  lw.Write("IL_{0:x4}:  "' pos);                  int level1 = lw.Column;                  short opcodeValue = code[pos++];                  if (opcodeValue == 0xFE)                  {                      opcodeValue = (short)(0xFE00 + code[pos++]);                  }                  OpCode opcode = opcodes[opcodeValue + 512];                  lw.Write("{0}"' opcode.Name);                  switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }                  lw.WriteLine();                    if (opcode == OpCodes.Leave || opcode == OpCodes.Leave_S)                  {                      if (pos < code.Length)                      {                          lw.WriteLine();                      }                  }                  else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally)                  {                      switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }                  }                  if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos)                  {                      if (extraNewLine && pos < code.Length)                      {                          extraNewLine = false;                          lw.WriteLine();                      }                      lw.GoToColumn(level);                      if (exceptions2[nextFlatException].FilterOffset == 0)                      {                          lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength);                          if (exceptions2[nextFlatException].CatchType.__IsMissing || !exceptions2[nextFlatException].CatchType.IsGenericType)                          {                              WriteTypeDefOrRef(lw' exceptions2[nextFlatException].CatchType);                          }                          else                          {                              WriteSignatureType(lw' exceptions2[nextFlatException].CatchType);                          }                          lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      else                      {                          lw.WriteLine(".try IL_{0:x4} to IL_{1:x4} filter IL_{2:x4} handler IL_{3:x4} to IL_{4:x4}"'                              exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength'                              exceptions2[nextFlatException].FilterOffset'                              exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength);                      }                      nextFlatException++;                  }                    while (currentException != null && currentException.HandlerOffset + currentException.HandlerLength == pos)                  {                      ExceptionHandlingClause prevException = currentException;                      currentException = activeExceptions.Pop();                      if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength)                      {                          if (extraNewLine && pos < code.Length)                          {                              extraNewLine = false;                              lw.WriteLine();                          }                          level -= 2;                          lw.GoToColumn(level);                          lw.WriteLine("}  // end handler");                          handler = false;                      }                      else                      {                          handler = true;                      }                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return FloatToInt32Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 8' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  float v2;                  if (Single.TryParse(str' out v2) && FloatToInt32Bits(value) == FloatToInt32Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' FloatToInt32Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]);                      }                  }              }              else if (Single.IsInfinity(value) || Single.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' FloatToInt32Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2})"' buf[0]' buf[1]' buf[2]' buf[3]);                  }              }              else              {                  return String.Format("{0:R}"' value);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return FloatToInt32Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 8' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  float v2;                  if (Single.TryParse(str' out v2) && FloatToInt32Bits(value) == FloatToInt32Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' FloatToInt32Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]);                      }                  }              }              else if (Single.IsInfinity(value) || Single.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' FloatToInt32Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2})"' buf[0]' buf[1]' buf[2]' buf[3]);                  }              }              else              {                  return String.Format("{0:R}"' value);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return FloatToInt32Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 8' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  float v2;                  if (Single.TryParse(str' out v2) && FloatToInt32Bits(value) == FloatToInt32Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' FloatToInt32Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]);                      }                  }              }              else if (Single.IsInfinity(value) || Single.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' FloatToInt32Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2})"' buf[0]' buf[1]' buf[2]' buf[3]);                  }              }              else              {                  return String.Format("{0:R}"' value);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return FloatToInt32Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 8' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  float v2;                  if (Single.TryParse(str' out v2) && FloatToInt32Bits(value) == FloatToInt32Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' FloatToInt32Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]);                      }                  }              }              else if (Single.IsInfinity(value) || Single.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' FloatToInt32Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2})"' buf[0]' buf[1]' buf[2]' buf[3]);                  }              }              else              {                  return String.Format("{0:R}"' value);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return FloatToInt32Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 8' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  float v2;                  if (Single.TryParse(str' out v2) && FloatToInt32Bits(value) == FloatToInt32Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' FloatToInt32Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]);                      }                  }              }              else if (Single.IsInfinity(value) || Single.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' FloatToInt32Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2})"' buf[0]' buf[1]' buf[2]' buf[3]);                  }              }              else              {                  return String.Format("{0:R}"' value);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return FloatToInt32Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 8' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  float v2;                  if (Single.TryParse(str' out v2) && FloatToInt32Bits(value) == FloatToInt32Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' FloatToInt32Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]);                      }                  }              }              else if (Single.IsInfinity(value) || Single.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' FloatToInt32Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2})"' buf[0]' buf[1]' buf[2]' buf[3]);                  }              }              else              {                  return String.Format("{0:R}"' value);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return BitConverter.DoubleToInt64Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 17' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  double v2;                  if (Double.TryParse(str' out v2) && BitConverter.DoubleToInt64Bits(value) == BitConverter.DoubleToInt64Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]' buf2[4]' buf2[5]' buf2[6]' buf2[7]);                      }                  }              }              else if (Double.IsInfinity(value) || Double.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf[0]' buf[1]' buf[2]' buf[3]' buf[4]' buf[5]' buf[6]' buf[7]);                  }              }              else              {                  return String.Format("{0:R}"' value.ToString("R"));              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return BitConverter.DoubleToInt64Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 17' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  double v2;                  if (Double.TryParse(str' out v2) && BitConverter.DoubleToInt64Bits(value) == BitConverter.DoubleToInt64Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]' buf2[4]' buf2[5]' buf2[6]' buf2[7]);                      }                  }              }              else if (Double.IsInfinity(value) || Double.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf[0]' buf[1]' buf[2]' buf[3]' buf[4]' buf[5]' buf[6]' buf[7]);                  }              }              else              {                  return String.Format("{0:R}"' value.ToString("R"));              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return BitConverter.DoubleToInt64Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 17' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  double v2;                  if (Double.TryParse(str' out v2) && BitConverter.DoubleToInt64Bits(value) == BitConverter.DoubleToInt64Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]' buf2[4]' buf2[5]' buf2[6]' buf2[7]);                      }                  }              }              else if (Double.IsInfinity(value) || Double.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf[0]' buf[1]' buf[2]' buf[3]' buf[4]' buf[5]' buf[6]' buf[7]);                  }              }              else              {                  return String.Format("{0:R}"' value.ToString("R"));              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return BitConverter.DoubleToInt64Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 17' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  double v2;                  if (Double.TryParse(str' out v2) && BitConverter.DoubleToInt64Bits(value) == BitConverter.DoubleToInt64Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]' buf2[4]' buf2[5]' buf2[6]' buf2[7]);                      }                  }              }              else if (Double.IsInfinity(value) || Double.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf[0]' buf[1]' buf[2]' buf[3]' buf[4]' buf[5]' buf[6]' buf[7]);                  }              }              else              {                  return String.Format("{0:R}"' value.ToString("R"));              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return BitConverter.DoubleToInt64Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 17' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  double v2;                  if (Double.TryParse(str' out v2) && BitConverter.DoubleToInt64Bits(value) == BitConverter.DoubleToInt64Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]' buf2[4]' buf2[5]' buf2[6]' buf2[7]);                      }                  }              }              else if (Double.IsInfinity(value) || Double.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf[0]' buf[1]' buf[2]' buf[3]' buf[4]' buf[5]' buf[6]' buf[7]);                  }              }              else              {                  return String.Format("{0:R}"' value.ToString("R"));              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return BitConverter.DoubleToInt64Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 17' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  double v2;                  if (Double.TryParse(str' out v2) && BitConverter.DoubleToInt64Bits(value) == BitConverter.DoubleToInt64Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]' buf2[4]' buf2[5]' buf2[6]' buf2[7]);                      }                  }              }              else if (Double.IsInfinity(value) || Double.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf[0]' buf[1]' buf[2]' buf[3]' buf[4]' buf[5]' buf[6]' buf[7]);                  }              }              else              {                  return String.Format("{0:R}"' value.ToString("R"));              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return BitConverter.DoubleToInt64Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 17' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  double v2;                  if (Double.TryParse(str' out v2) && BitConverter.DoubleToInt64Bits(value) == BitConverter.DoubleToInt64Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]' buf2[4]' buf2[5]' buf2[6]' buf2[7]);                      }                  }              }              else if (Double.IsInfinity(value) || Double.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf[0]' buf[1]' buf[2]' buf[3]' buf[4]' buf[5]' buf[6]' buf[7]);                  }              }              else              {                  return String.Format("{0:R}"' value.ToString("R"));              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return BitConverter.DoubleToInt64Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 17' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  double v2;                  if (Double.TryParse(str' out v2) && BitConverter.DoubleToInt64Bits(value) == BitConverter.DoubleToInt64Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]' buf2[4]' buf2[5]' buf2[6]' buf2[7]);                      }                  }              }              else if (Double.IsInfinity(value) || Double.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf[0]' buf[1]' buf[2]' buf[3]' buf[4]' buf[5]' buf[6]' buf[7]);                  }              }              else              {                  return String.Format("{0:R}"' value.ToString("R"));              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return BitConverter.DoubleToInt64Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 17' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  double v2;                  if (Double.TryParse(str' out v2) && BitConverter.DoubleToInt64Bits(value) == BitConverter.DoubleToInt64Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]' buf2[4]' buf2[5]' buf2[6]' buf2[7]);                      }                  }              }              else if (Double.IsInfinity(value) || Double.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf[0]' buf[1]' buf[2]' buf[3]' buf[4]' buf[5]' buf[6]' buf[7]);                  }              }              else              {                  return String.Format("{0:R}"' value.ToString("R"));              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return BitConverter.DoubleToInt64Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 17' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  double v2;                  if (Double.TryParse(str' out v2) && BitConverter.DoubleToInt64Bits(value) == BitConverter.DoubleToInt64Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]' buf2[4]' buf2[5]' buf2[6]' buf2[7]);                      }                  }              }              else if (Double.IsInfinity(value) || Double.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf[0]' buf[1]' buf[2]' buf[3]' buf[4]' buf[5]' buf[6]' buf[7]);                  }              }              else              {                  return String.Format("{0:R}"' value.ToString("R"));              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return BitConverter.DoubleToInt64Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 17' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  double v2;                  if (Double.TryParse(str' out v2) && BitConverter.DoubleToInt64Bits(value) == BitConverter.DoubleToInt64Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]' buf2[4]' buf2[5]' buf2[6]' buf2[7]);                      }                  }              }              else if (Double.IsInfinity(value) || Double.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf[0]' buf[1]' buf[2]' buf[3]' buf[4]' buf[5]' buf[6]' buf[7]);                  }              }              else              {                  return String.Format("{0:R}"' value.ToString("R"));              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return BitConverter.DoubleToInt64Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 17' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  double v2;                  if (Double.TryParse(str' out v2) && BitConverter.DoubleToInt64Bits(value) == BitConverter.DoubleToInt64Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]' buf2[4]' buf2[5]' buf2[6]' buf2[7]);                      }                  }              }              else if (Double.IsInfinity(value) || Double.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf[0]' buf[1]' buf[2]' buf[3]' buf[4]' buf[5]' buf[6]' buf[7]);                  }              }              else              {                  return String.Format("{0:R}"' value.ToString("R"));              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return BitConverter.DoubleToInt64Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 17' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  double v2;                  if (Double.TryParse(str' out v2) && BitConverter.DoubleToInt64Bits(value) == BitConverter.DoubleToInt64Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]' buf2[4]' buf2[5]' buf2[6]' buf2[7]);                      }                  }              }              else if (Double.IsInfinity(value) || Double.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf[0]' buf[1]' buf[2]' buf[3]' buf[4]' buf[5]' buf[6]' buf[7]);                  }              }              else              {                  return String.Format("{0:R}"' value.ToString("R"));              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ToString,The following statement contains a magic number: if (value == 0 && !field)              {                  return BitConverter.DoubleToInt64Bits(value) < 0                      ? "-0.0"                      : "0.0";              }              else if (compat != CompatLevel.None)              {                  byte[] buf = new byte[50];                  _gcvt(value' 17' buf);                  string str = Encoding.ASCII.GetString(buf' 0' Array.IndexOf(buf' (byte)0));                  double v2;                  if (Double.TryParse(str' out v2) && BitConverter.DoubleToInt64Bits(value) == BitConverter.DoubleToInt64Bits(v2))                  {                      return str;                  }                  else                  {                      if (field)                      {                          return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                      }                      else                      {                          byte[] buf2 = BitConverter.GetBytes(value);                          return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]' buf2[4]' buf2[5]' buf2[6]' buf2[7]);                      }                  }              }              else if (Double.IsInfinity(value) || Double.IsNaN(value))              {                  if (field)                  {                      return String.Format("0x{0:X}"' BitConverter.DoubleToInt64Bits(value));                  }                  else                  {                      byte[] buf = BitConverter.GetBytes(value);                      return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf[0]' buf[1]' buf[2]' buf[3]' buf[4]' buf[5]' buf[6]' buf[7]);                  }              }              else              {                  return String.Format("{0:R}"' value.ToString("R"));              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: int initial = 44 - lw.Column + level;
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: int pos = 44;
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(str.Length + 10);
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: for (int i = 0; i < str.Length; i++)              {                  char c = str[i];                  if (i < str.Length - 2 && ((pos == 94 && pos - initial != backslashes) || pos > 94))                  {                      if (pos - initial == backslashes)                      {                          sb.Append('\\'' backslashes * 2);                          backslashes = 0;                      }                      pos = initial + backslashes;                      sb.Append("\"\r\n");                      sb.Append(' '' level);                      sb.Append("+ \"");                  }                  if (c == '\\')                  {                      backslashes++;                  }                  else if (backslashes != 0)                  {                      sb.Append('\\'' backslashes * 2);                      backslashes = 0;                  }                  if (c < 32)                  {                      switch (c)                      {                          case '\r':                              sb.Append("\\r");                              break;                          case '\n':                              sb.Append("\\n");                              break;                          case '\t':                              sb.Append("\\t");                              break;                          default:                              lw.Write("bytearray (");                              WriteBytes(lw' GetBytes(str)' false);                              return;                      }                  }                  else if (c > 126)                  {                      lw.Write("bytearray (");                      WriteBytes(lw' GetBytes(str)' false);                      return;                  }                  else                  {                      switch (c)                      {                          case '"':                              sb.Append("\\\"");                              break;                          case '?':                              sb.Append("\\?");                              break;                          case '\\':                              break;                          default:                              sb.Append(c);                              break;                      }                  }                  pos++;              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: for (int i = 0; i < str.Length; i++)              {                  char c = str[i];                  if (i < str.Length - 2 && ((pos == 94 && pos - initial != backslashes) || pos > 94))                  {                      if (pos - initial == backslashes)                      {                          sb.Append('\\'' backslashes * 2);                          backslashes = 0;                      }                      pos = initial + backslashes;                      sb.Append("\"\r\n");                      sb.Append(' '' level);                      sb.Append("+ \"");                  }                  if (c == '\\')                  {                      backslashes++;                  }                  else if (backslashes != 0)                  {                      sb.Append('\\'' backslashes * 2);                      backslashes = 0;                  }                  if (c < 32)                  {                      switch (c)                      {                          case '\r':                              sb.Append("\\r");                              break;                          case '\n':                              sb.Append("\\n");                              break;                          case '\t':                              sb.Append("\\t");                              break;                          default:                              lw.Write("bytearray (");                              WriteBytes(lw' GetBytes(str)' false);                              return;                      }                  }                  else if (c > 126)                  {                      lw.Write("bytearray (");                      WriteBytes(lw' GetBytes(str)' false);                      return;                  }                  else                  {                      switch (c)                      {                          case '"':                              sb.Append("\\\"");                              break;                          case '?':                              sb.Append("\\?");                              break;                          case '\\':                              break;                          default:                              sb.Append(c);                              break;                      }                  }                  pos++;              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: for (int i = 0; i < str.Length; i++)              {                  char c = str[i];                  if (i < str.Length - 2 && ((pos == 94 && pos - initial != backslashes) || pos > 94))                  {                      if (pos - initial == backslashes)                      {                          sb.Append('\\'' backslashes * 2);                          backslashes = 0;                      }                      pos = initial + backslashes;                      sb.Append("\"\r\n");                      sb.Append(' '' level);                      sb.Append("+ \"");                  }                  if (c == '\\')                  {                      backslashes++;                  }                  else if (backslashes != 0)                  {                      sb.Append('\\'' backslashes * 2);                      backslashes = 0;                  }                  if (c < 32)                  {                      switch (c)                      {                          case '\r':                              sb.Append("\\r");                              break;                          case '\n':                              sb.Append("\\n");                              break;                          case '\t':                              sb.Append("\\t");                              break;                          default:                              lw.Write("bytearray (");                              WriteBytes(lw' GetBytes(str)' false);                              return;                      }                  }                  else if (c > 126)                  {                      lw.Write("bytearray (");                      WriteBytes(lw' GetBytes(str)' false);                      return;                  }                  else                  {                      switch (c)                      {                          case '"':                              sb.Append("\\\"");                              break;                          case '?':                              sb.Append("\\?");                              break;                          case '\\':                              break;                          default:                              sb.Append(c);                              break;                      }                  }                  pos++;              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: for (int i = 0; i < str.Length; i++)              {                  char c = str[i];                  if (i < str.Length - 2 && ((pos == 94 && pos - initial != backslashes) || pos > 94))                  {                      if (pos - initial == backslashes)                      {                          sb.Append('\\'' backslashes * 2);                          backslashes = 0;                      }                      pos = initial + backslashes;                      sb.Append("\"\r\n");                      sb.Append(' '' level);                      sb.Append("+ \"");                  }                  if (c == '\\')                  {                      backslashes++;                  }                  else if (backslashes != 0)                  {                      sb.Append('\\'' backslashes * 2);                      backslashes = 0;                  }                  if (c < 32)                  {                      switch (c)                      {                          case '\r':                              sb.Append("\\r");                              break;                          case '\n':                              sb.Append("\\n");                              break;                          case '\t':                              sb.Append("\\t");                              break;                          default:                              lw.Write("bytearray (");                              WriteBytes(lw' GetBytes(str)' false);                              return;                      }                  }                  else if (c > 126)                  {                      lw.Write("bytearray (");                      WriteBytes(lw' GetBytes(str)' false);                      return;                  }                  else                  {                      switch (c)                      {                          case '"':                              sb.Append("\\\"");                              break;                          case '?':                              sb.Append("\\?");                              break;                          case '\\':                              break;                          default:                              sb.Append(c);                              break;                      }                  }                  pos++;              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: for (int i = 0; i < str.Length; i++)              {                  char c = str[i];                  if (i < str.Length - 2 && ((pos == 94 && pos - initial != backslashes) || pos > 94))                  {                      if (pos - initial == backslashes)                      {                          sb.Append('\\'' backslashes * 2);                          backslashes = 0;                      }                      pos = initial + backslashes;                      sb.Append("\"\r\n");                      sb.Append(' '' level);                      sb.Append("+ \"");                  }                  if (c == '\\')                  {                      backslashes++;                  }                  else if (backslashes != 0)                  {                      sb.Append('\\'' backslashes * 2);                      backslashes = 0;                  }                  if (c < 32)                  {                      switch (c)                      {                          case '\r':                              sb.Append("\\r");                              break;                          case '\n':                              sb.Append("\\n");                              break;                          case '\t':                              sb.Append("\\t");                              break;                          default:                              lw.Write("bytearray (");                              WriteBytes(lw' GetBytes(str)' false);                              return;                      }                  }                  else if (c > 126)                  {                      lw.Write("bytearray (");                      WriteBytes(lw' GetBytes(str)' false);                      return;                  }                  else                  {                      switch (c)                      {                          case '"':                              sb.Append("\\\"");                              break;                          case '?':                              sb.Append("\\?");                              break;                          case '\\':                              break;                          default:                              sb.Append(c);                              break;                      }                  }                  pos++;              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: for (int i = 0; i < str.Length; i++)              {                  char c = str[i];                  if (i < str.Length - 2 && ((pos == 94 && pos - initial != backslashes) || pos > 94))                  {                      if (pos - initial == backslashes)                      {                          sb.Append('\\'' backslashes * 2);                          backslashes = 0;                      }                      pos = initial + backslashes;                      sb.Append("\"\r\n");                      sb.Append(' '' level);                      sb.Append("+ \"");                  }                  if (c == '\\')                  {                      backslashes++;                  }                  else if (backslashes != 0)                  {                      sb.Append('\\'' backslashes * 2);                      backslashes = 0;                  }                  if (c < 32)                  {                      switch (c)                      {                          case '\r':                              sb.Append("\\r");                              break;                          case '\n':                              sb.Append("\\n");                              break;                          case '\t':                              sb.Append("\\t");                              break;                          default:                              lw.Write("bytearray (");                              WriteBytes(lw' GetBytes(str)' false);                              return;                      }                  }                  else if (c > 126)                  {                      lw.Write("bytearray (");                      WriteBytes(lw' GetBytes(str)' false);                      return;                  }                  else                  {                      switch (c)                      {                          case '"':                              sb.Append("\\\"");                              break;                          case '?':                              sb.Append("\\?");                              break;                          case '\\':                              break;                          default:                              sb.Append(c);                              break;                      }                  }                  pos++;              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: for (int i = 0; i < str.Length; i++)              {                  char c = str[i];                  if (i < str.Length - 2 && ((pos == 94 && pos - initial != backslashes) || pos > 94))                  {                      if (pos - initial == backslashes)                      {                          sb.Append('\\'' backslashes * 2);                          backslashes = 0;                      }                      pos = initial + backslashes;                      sb.Append("\"\r\n");                      sb.Append(' '' level);                      sb.Append("+ \"");                  }                  if (c == '\\')                  {                      backslashes++;                  }                  else if (backslashes != 0)                  {                      sb.Append('\\'' backslashes * 2);                      backslashes = 0;                  }                  if (c < 32)                  {                      switch (c)                      {                          case '\r':                              sb.Append("\\r");                              break;                          case '\n':                              sb.Append("\\n");                              break;                          case '\t':                              sb.Append("\\t");                              break;                          default:                              lw.Write("bytearray (");                              WriteBytes(lw' GetBytes(str)' false);                              return;                      }                  }                  else if (c > 126)                  {                      lw.Write("bytearray (");                      WriteBytes(lw' GetBytes(str)' false);                      return;                  }                  else                  {                      switch (c)                      {                          case '"':                              sb.Append("\\\"");                              break;                          case '?':                              sb.Append("\\?");                              break;                          case '\\':                              break;                          default:                              sb.Append(c);                              break;                      }                  }                  pos++;              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: sb.Append('\\'' backslashes * 2);
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetBytes,The following statement contains a magic number: byte[] buf = new byte[str.Length * 2];
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetBytes,The following statement contains a magic number: for (int i = 0; i < str.Length; i++)              {                  char ch = str[i];                  buf[i * 2 + 0] = (byte)(ch >> 0);                  buf[i * 2 + 1] = (byte)(ch >> 8);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetBytes,The following statement contains a magic number: for (int i = 0; i < str.Length; i++)              {                  char ch = str[i];                  buf[i * 2 + 0] = (byte)(ch >> 0);                  buf[i * 2 + 1] = (byte)(ch >> 8);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetBytes,The following statement contains a magic number: for (int i = 0; i < str.Length; i++)              {                  char ch = str[i];                  buf[i * 2 + 0] = (byte)(ch >> 0);                  buf[i * 2 + 1] = (byte)(ch >> 8);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineI,The following statement contains a magic number: if (value >= 128 || value < 128)              {                  lw.Write("0x{0:x}"' value);              }              else              {                  lw.Write("{0}"' value);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineI,The following statement contains a magic number: if (value >= 128 || value < 128)              {                  lw.Write("0x{0:x}"' value);              }              else              {                  lw.Write("{0}"' value);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineI8,The following statement contains a magic number: if (value >= 128 || value < 128)              {                  lw.Write("0x{0:x}"' value);              }              else              {                  lw.Write("{0}"' value);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineI8,The following statement contains a magic number: if (value >= 128 || value < 128)              {                  lw.Write("0x{0:x}"' value);              }              else              {                  lw.Write("{0}"' value);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineMethod,The following statement contains a magic number: if (compat != CompatLevel.None && loc == TypeLocation.GenericMethodImpl)              {                  // ildasm doesn't take the length of the arity ("<[1]>") into account                  level -= 5 + (int)Math.Log10(mb.GetGenericArguments().Length);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineType,The following statement contains a magic number: if (metadataToken >> 24 == 0x1B)              {                  mods = module.__ResolveTypeSpecCustomModifiers(metadataToken' genericTypeArguments' genericMethodArguments);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ReadInt16,The following statement contains a magic number: pos += 2;
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ReadInt32,The following statement contains a magic number: pos += 4;
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ReadInt64,The following statement contains a magic number: pos += 8;
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ReadSingle,The following statement contains a magic number: pos += 4;
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ReadDouble,The following statement contains a magic number: pos += 8;
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteVTableFixupComment,The following statement contains a magic number: if (fixups.Length != 0)              {                  lw.WriteLine("// VTableFixup Directory:");                  for (int i = 0; i < fixups.Length; i++)                  {                      lw.WriteLine("//   IMAGE_COR_VTABLEFIXUP[{0}]:"' i);                      lw.WriteLine("//       RVA:               0x{0:x8}"' fixups[i].RVA);                      lw.WriteLine("//       Count:             0x{0:x4}"' fixups[i].Count);                      lw.WriteLine("//       Type:              0x{0:x4}"' fixups[i].Type);                      var methods = GetVTableMethods(fixups[i]);                      for (int j = 0; j < methods.Length; j++)                      {                          var method = methods[j];                          List<KeyValuePair<int'int>> list;                          if (!vtentryMap.TryGetValue(method' out list))                          {                              list = new List<KeyValuePair<int' int>>();                              vtentryMap.Add(method' list);                          }                          list.Add(new KeyValuePair<int'int>(i + 1' j + 1));                          if (ptrsize == 4)                          {                              lw.WriteLine("//         [0x{0:x4}]            (0x{1:x8})"' j' method.MetadataToken);                          }                          else                          {                              lw.WriteLine("//         [0x{0:x4}]            (0x         {1:x})"' j' method.MetadataToken);                          }                      }                  }                  lw.WriteLine();              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteVTableFixups,The following statement contains a magic number: if (fixups.Length != 0)              {                  for (int i = 0; i < fixups.Length; i++)                  {                      lw.Write(".vtfixup [{0}] {1}{2} at D_{3:X8} //"'                          fixups[i].Count'                          (fixups[i].Type & COR_VTABLE_32BIT) != 0 ? "int32" : "int64"'                          (fixups[i].Type & COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN) != 0                              ? " retainappdomain"                              : (fixups[i].Type & COR_VTABLE_FROM_UNMANAGED) != 0                                  ? " fromunmanaged"                                  : ""'                          fixups[i].RVA);                      foreach (var method in GetVTableMethods(fixups[i]))                      {                          if (ptrsize == 4)                          {                              lw.Write(" {0:X8}"' method.MetadataToken);                          }                          else                          {                              lw.Write(" {0:X16}"' method.MetadataToken);                          }                      }                      lw.WriteLine();                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: module.__GetDataDirectoryEntry(14' out rva' out length);
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: byte[] buf = new byte[8];
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: module.__ReadDataFromRVA(rva + 48' buf' 0' 8);
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: module.__ReadDataFromRVA(rva + 48' buf' 0' 8);
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: VTableFixups[] entries = new VTableFixups[BitConverter.ToInt32(buf' 4) / 8];
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: VTableFixups[] entries = new VTableFixups[BitConverter.ToInt32(buf' 4) / 8];
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: for (int i = 0; i < entries.Length; i++)              {                  module.__ReadDataFromRVA(rva + i * 8' buf' 0' 8);                  entries[i].RVA = BitConverter.ToInt32(buf' 0);                  entries[i].Count = BitConverter.ToInt16(buf' 4);                  entries[i].Type = BitConverter.ToInt16(buf' 6);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: for (int i = 0; i < entries.Length; i++)              {                  module.__ReadDataFromRVA(rva + i * 8' buf' 0' 8);                  entries[i].RVA = BitConverter.ToInt32(buf' 0);                  entries[i].Count = BitConverter.ToInt16(buf' 4);                  entries[i].Type = BitConverter.ToInt16(buf' 6);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: for (int i = 0; i < entries.Length; i++)              {                  module.__ReadDataFromRVA(rva + i * 8' buf' 0' 8);                  entries[i].RVA = BitConverter.ToInt32(buf' 0);                  entries[i].Count = BitConverter.ToInt16(buf' 4);                  entries[i].Type = BitConverter.ToInt16(buf' 6);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: for (int i = 0; i < entries.Length; i++)              {                  module.__ReadDataFromRVA(rva + i * 8' buf' 0' 8);                  entries[i].RVA = BitConverter.ToInt32(buf' 0);                  entries[i].Count = BitConverter.ToInt16(buf' 4);                  entries[i].Type = BitConverter.ToInt16(buf' 6);              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetVTableMethods,The following statement contains a magic number: byte[] buf = new byte[8];
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetVTableMethods,The following statement contains a magic number: for (int i = 0; i < fixups.Count; i++)              {                  module.__ReadDataFromRVA(fixuprva' buf' 0' 4);                  methods[i] = module.ResolveMethod(BitConverter.ToInt32(buf' 0));                  if ((fixups.Type & COR_VTABLE_32BIT) != 0)                  {                      fixuprva += 4;                  }                  if ((fixups.Type & COR_VTABLE_64BIT) != 0)                  {                      fixuprva += 8;                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetVTableMethods,The following statement contains a magic number: for (int i = 0; i < fixups.Count; i++)              {                  module.__ReadDataFromRVA(fixuprva' buf' 0' 4);                  methods[i] = module.ResolveMethod(BitConverter.ToInt32(buf' 0));                  if ((fixups.Type & COR_VTABLE_32BIT) != 0)                  {                      fixuprva += 4;                  }                  if ((fixups.Type & COR_VTABLE_64BIT) != 0)                  {                      fixuprva += 8;                  }              }
Magic Number,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,GetVTableMethods,The following statement contains a magic number: for (int i = 0; i < fixups.Count; i++)              {                  module.__ReadDataFromRVA(fixuprva' buf' 0' 4);                  methods[i] = module.ResolveMethod(BitConverter.ToInt32(buf' 0));                  if ((fixups.Type & COR_VTABLE_32BIT) != 0)                  {                      fixuprva += 4;                  }                  if ((fixups.Type & COR_VTABLE_64BIT) != 0)                  {                      fixuprva += 8;                  }              }
Magic Number,Ildasm,Program,C:\repos\jfrijters_ikdasm\Program.cs,Main,The following statement contains a magic number: foreach (var arg in args)              {                  if (arg.StartsWith("-"' StringComparison.Ordinal) || arg.StartsWith("/"' StringComparison.Ordinal))                  {                      string value;                      if (TryMatchOption(arg' "out"' out value))                      {                          outputFile = value;                      }                      else if (TryMatchOption(arg' "compat"' out value))                      {                          switch (value)                          {                              case "2.0":                                  compatLevel = CompatLevel.V20;                                  break;                              case "4.0":                                  compatLevel = CompatLevel.V40;                                  break;                              case "4.5":                                  compatLevel = CompatLevel.V45;                                  break;                              default:                                  PrintUsage();                                  return;                          }                      }                      else if (String.Compare(arg' 1' "diffmode"' 0' 8' StringComparison.OrdinalIgnoreCase) == 0)                      {                          flags |= Flags.DiffMode;                      }                      else if (IsIldasmOption(arg' "caverbal"))                      {                          flags |= Flags.Caverbal;                      }                      else if (IsIldasmOption(arg' "project"))                      {                          flags |= Flags.Project;                      }                      else                      {                          PrintUsage();                          return;                      }                  }                  else                  {                      if (inputFile != null)                      {                          PrintUsage();                          return;                      }                      else                      {                          inputFile = arg;                      }                  }              }
Magic Number,Ildasm,Program,C:\repos\jfrijters_ikdasm\Program.cs,TryMatchOption,The following statement contains a magic number: if (arg.Length > key.Length + 2 && (arg[key.Length + 1] == ':' || arg[key.Length + 1] == '=') && String.Compare(arg' 1' key' 0' key.Length' true) == 0)              {                  value = arg.Substring(key.Length + 2);                  return true;              }
Magic Number,Ildasm,Program,C:\repos\jfrijters_ikdasm\Program.cs,TryMatchOption,The following statement contains a magic number: if (arg.Length > key.Length + 2 && (arg[key.Length + 1] == ':' || arg[key.Length + 1] == '=') && String.Compare(arg' 1' key' 0' key.Length' true) == 0)              {                  value = arg.Substring(key.Length + 2);                  return true;              }
Magic Number,Ildasm,Program,C:\repos\jfrijters_ikdasm\Program.cs,IsIldasmOption,The following statement contains a magic number: return String.Compare(arg' 1' option' 0' 3' StringComparison.OrdinalIgnoreCase) == 0;
Missing Default,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,ReadFixedArg,The following switch statement is missing a default case: switch (type.FullName)                      {                          case "System.AttributeTargets":                          case "System.Runtime.ConstrainedExecution.Consistency":                          case "System.Runtime.ConstrainedExecution.Cer":                          case "System.Security.Permissions.SecurityAction":                          case "System.Security.Permissions.SecurityPermissionFlag":                          case "System.Runtime.Versioning.ResourceScope":                          case "System.Runtime.InteropServices.CallingConvention":                          case "System.Runtime.InteropServices.CharSet":                              ReadFixedArg(sb' br' typeofSystemInt32);                              return;                          case "System.Security.SecurityRuleSet":                              if (compat != CompatLevel.V20)                              {                                  ReadFixedArg(sb' br' typeofSystemByte);                                  return;                              }                              break;                          case "System.Diagnostics.Tracing.EventLevel":                          case "System.Diagnostics.Tracing.EventTask":                          case "System.Diagnostics.Tracing.EventOpcode":                              if (compat != CompatLevel.V20 && compat != CompatLevel.V40)                              {                                  ReadFixedArg(sb' br' typeofSystemInt32);                                  return;                              }                              break;                          case "System.Type":                              sb.Append("type(");                              string typeName;                              AppendTypeName(sb' ReadType(br' out typeName)' typeName);                              sb.Append(")");                              return;                      }
Missing Default,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following switch statement is missing a default case: switch (type.StructLayoutAttribute.Value)              {                  case System.Runtime.InteropServices.LayoutKind.Auto:                      lw.Write("auto ");                      break;                  case System.Runtime.InteropServices.LayoutKind.Sequential:                      lw.Write("sequential ");                      break;                  case System.Runtime.InteropServices.LayoutKind.Explicit:                      lw.Write("explicit ");                      break;              }
Missing Default,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following switch statement is missing a default case: switch (type.Attributes & TypeAttributes.StringFormatMask)              {                  case TypeAttributes.AnsiClass:                      lw.Write("ansi ");                      break;                  case TypeAttributes.UnicodeClass:                      lw.Write("unicode ");                      break;                  case TypeAttributes.AutoClass:                      lw.Write("autochar ");                      break;              }
Missing Default,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following switch statement is missing a default case: switch (type.Attributes & TypeAttributes.VisibilityMask)              {                  case TypeAttributes.NestedPublic:                      lw.Write("nested public ");                      break;                  case TypeAttributes.NestedPrivate:                      lw.Write("nested private ");                      break;                  case TypeAttributes.NestedAssembly:                      lw.Write("nested assembly ");                      break;                  case TypeAttributes.NestedFamily:                      lw.Write("nested family ");                      break;                  case TypeAttributes.NestedFamORAssem:                      lw.Write("nested famorassem ");                      break;              }
Missing Default,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following switch statement is missing a default case: switch (method.Attributes & MethodAttributes.MemberAccessMask)              {                  case MethodAttributes.Public:                      lw.Write("public ");                      break;                  case MethodAttributes.Private:                      lw.Write("private ");                      break;                  case MethodAttributes.Assembly:                      lw.Write("assembly ");                      break;                  case MethodAttributes.Family:                      lw.Write("family ");                      break;                  case MethodAttributes.FamORAssem:                      lw.Write("famorassem ");                      break;                  case MethodAttributes.PrivateScope:                      lw.Write("privatescope ");                      break;              }
Missing Default,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following switch statement is missing a default case: switch (implflags & MethodImplAttributes.CodeTypeMask)              {                  case MethodImplAttributes.IL:                      lw.Write(" cil");                      break;                  case MethodImplAttributes.Native:                      lw.Write(" native");                      break;                  case MethodImplAttributes.OPTIL:                      lw.Write(" optil");                      break;                  case MethodImplAttributes.Runtime:                      lw.Write(" runtime");                      break;              }
Missing Default,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WritePInvokeImpl,The following switch statement is missing a default case: switch (flags & ImplMapFlags.CharSetMask)                  {                      case ImplMapFlags.CharSetAnsi:                          lw.Write(" ansi");                          break;                      case ImplMapFlags.CharSetAuto:                          lw.Write(" autochar");                          break;                      case ImplMapFlags.CharSetUnicode:                          lw.Write(" unicode");                          break;                  }
Missing Default,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WritePInvokeImpl,The following switch statement is missing a default case: switch (flags & ImplMapFlags.CallConvMask)                  {                      case ImplMapFlags.CallConvWinapi:                          lw.Write(" winapi");                          break;                      case ImplMapFlags.CallConvStdcall:                          lw.Write(" stdcall");                          break;                      case ImplMapFlags.CallConvCdecl:                          lw.Write(" cdecl");                          break;                      case ImplMapFlags.CallConvThiscall:                          lw.Write(" thiscall");                          break;                  }
Missing Default,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WritePInvokeImpl,The following switch statement is missing a default case: switch (flags & (ImplMapFlags.BestFitOff | ImplMapFlags.BestFitOn))                  {                      case ImplMapFlags.BestFitOn:                          lw.Write(" bestfit:on");                          break;                      case ImplMapFlags.BestFitOff:                          lw.Write(" bestfit:off");                          break;                  }
Missing Default,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WritePInvokeImpl,The following switch statement is missing a default case: switch (flags & (ImplMapFlags.CharMapErrorOff | ImplMapFlags.CharMapErrorOn))                  {                      case ImplMapFlags.CharMapErrorOn:                          lw.Write(" charmaperror:on");                          break;                      case ImplMapFlags.CharMapErrorOff:                          lw.Write(" charmaperror:off");                          break;                  }
Missing Default,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteMarshalAs,The following switch statement is missing a default case: switch (marshal.ArraySubType.Value)                  {                      case System.Runtime.InteropServices.UnmanagedType.IUnknown:                      case System.Runtime.InteropServices.UnmanagedType.Interface:                          if (marshal.SizeParamIndex == null)                          {                              sb.Append(" ");                          }                          else                          {                              sb.AppendFormat("(iidparam = {0}) "' marshal.SizeParamIndex.Value);                              sizeParamIndex = null;                          }                          break;                  }
Missing Default,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteField,The following switch statement is missing a default case: switch (field.Attributes & FieldAttributes.FieldAccessMask)              {                  case FieldAttributes.Public:                      lw.Write("public ");                      break;                  case FieldAttributes.Private:                      lw.Write("private ");                      break;              }
Missing Default,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteField,The following switch statement is missing a default case: switch (field.Attributes & FieldAttributes.FieldAccessMask)              {                  case FieldAttributes.Family:                      lw.Write("family ");                      break;                  case FieldAttributes.Assembly:                      lw.Write("assembly ");                      break;                  case FieldAttributes.FamORAssem:                      lw.Write("famorassem ");                      break;                  case FieldAttributes.PrivateScope:                      lw.Write("privatescope ");                      break;              }
Missing Default,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteModuleManifest,The following switch statement is missing a default case: switch (asm.ProcessorArchitecture)                  {                      case ProcessorArchitecture.MSIL:                          lw.Write("cil ");                          break;                      case ProcessorArchitecture.X86:                          lw.Write("x86 ");                          break;                      case ProcessorArchitecture.IA64:                          lw.Write("ia64 ");                          break;                      case ProcessorArchitecture.Amd64:                          lw.Write("amd64 ");                          break;                      case ProcessorArchitecture.Arm:                          if (compat == CompatLevel.None)                          {                              lw.Write("/*arm*/ ");                          }                          break;                  }
Missing Default,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteStandAloneMethodSig,The following switch statement is missing a default case: switch (sig.UnmanagedCallingConvention)                  {                      case System.Runtime.InteropServices.CallingConvention.Cdecl:                          lw.Write("cdecl ");                          break;                      case System.Runtime.InteropServices.CallingConvention.StdCall:                          lw.Write("stdcall ");                          break;                      case System.Runtime.InteropServices.CallingConvention.ThisCall:                          lw.Write("thiscall ");                          break;                  }
Missing Default,Ildasm,Disassembler,C:\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following switch statement is missing a default case: switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }
