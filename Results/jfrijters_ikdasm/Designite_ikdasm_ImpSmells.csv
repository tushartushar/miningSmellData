Implementation smell,Namespace,Class,File,Method,Description
Long Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,ReadFixedArg,The method has 235 lines of code.
Long Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The method has 181 lines of code.
Long Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The method has 282 lines of code.
Long Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteField,The method has 109 lines of code.
Long Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WritePermissionSet,The method has 122 lines of code.
Long Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteSignatureType,The method has 169 lines of code.
Long Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The method has 382 lines of code.
Long Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineMethod,The method has 121 lines of code.
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,ReadFixedArg,Cyclomatic complexity of the method is 45
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,AppendCATypeName,Cyclomatic complexity of the method is 17
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,ReadFieldOrPropType,Cyclomatic complexity of the method is 18
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetTypeSize,Cyclomatic complexity of the method is 8
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteData,Cyclomatic complexity of the method is 12
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteType,Cyclomatic complexity of the method is 34
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteGenericParameterDef,Cyclomatic complexity of the method is 12
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteEvent,Cyclomatic complexity of the method is 8
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteProperty,Cyclomatic complexity of the method is 9
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,Cyclomatic complexity of the method is 52
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WritePInvokeImpl,Cyclomatic complexity of the method is 13
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMarshalAs,Cyclomatic complexity of the method is 17
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,VarEnumToString,Cyclomatic complexity of the method is 18
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,UnmanagedTypeToString,Cyclomatic complexity of the method is 37
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,QuoteIdentifier,Cyclomatic complexity of the method is 16
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteField,Cyclomatic complexity of the method is 20
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteModuleManifest,Cyclomatic complexity of the method is 14
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,Cyclomatic complexity of the method is 9
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WritePermissionSet,Cyclomatic complexity of the method is 24
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteAttributeValue,Cyclomatic complexity of the method is 15
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteConstant,Cyclomatic complexity of the method is 19
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteCustomAttributeImpl,Cyclomatic complexity of the method is 8
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteSignatureType,Cyclomatic complexity of the method is 32
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteStandAloneMethodSig,Cyclomatic complexity of the method is 8
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteBytes,Cyclomatic complexity of the method is 10
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,Cyclomatic complexity of the method is 57
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,Cyclomatic complexity of the method is 14
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineMethod,Cyclomatic complexity of the method is 17
Complex Method,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,SortExceptions,Cyclomatic complexity of the method is 10
Complex Method,Ildasm,Program,D:\research\architectureSmells\repos\jfrijters_ikdasm\Program.cs,Main,Cyclomatic complexity of the method is 16
Long Parameter List,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,AppendTypeName,The method has 5 parameters. Parameters: sb' type' typeName' noself' securityCompatHack
Long Parameter List,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,ReadNamedArguments,The method has 5 parameters. Parameters: sb' br' named' level' securityCompatHack
Long Parameter List,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteData,The method has 5 parameters. Parameters: lw' section' rva' size' uninitialized
Long Parameter List,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMarshalAs,The method has 5 parameters. Parameters: lw' level' hasFieldMarshalRecord' marshal' wrap
Long Parameter List,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMarshalAs,The method has 5 parameters. Parameters: sb' level' hasFieldMarshalRecord' marshal' wrap
Long Parameter List,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WritePermissionSet,The method has 5 parameters. Parameters: lw' level' action' list' metadataToken
Long Parameter List,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The method has 5 parameters. Parameters: lw' mb' body' genericTypeArguments' genericMethodArguments
Long Parameter List,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineVar,The method has 5 parameters. Parameters: lw' mb' opcode' parameters' index
Long Parameter List,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineMethod,The method has 5 parameters. Parameters: lw' mb' optionalParameterTypes' customModifiers' methodimpl
Long Identifier,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,,The length of the parameter IMAGE_SCN_CNT_INITIALIZED_DATA is 30.
Long Identifier,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,,The length of the parameter IMAGE_SCN_CNT_UNINITIALIZED_DATA is 32.
Long Identifier,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,,The length of the parameter COMIMAGE_FLAGS_STRONGNAMESIGNED is 31.
Long Identifier,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,,The length of the parameter COMIMAGE_FLAGS_NATIVE_ENTRYPOINT is 32.
Long Identifier,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,,The length of the parameter COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN is 42.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,AppendTypeName,The length of the statement  "            if (type.Assembly == assembly && !type.__IsMissing && !noself && (!type.IsGenericType || type.IsGenericTypeDefinition) && !type.HasElementType) " is 143.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteData,The length of the statement  "                if (!module.__GetSectionInfo(rva' out name' out characteristics' out virtualAddress' out virtualSize' out pointerToRawData' out sizeOfRawData)) " is 143.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The length of the statement  "            if ((type.Attributes & TypeAttributes.WindowsRuntime) != 0 && (compat == CompatLevel.None || compat >= CompatLevel.V45)) " is 120.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteEvent,The length of the statement  "            if (!evt.EventHandlerType.__IsMissing && evt.EventHandlerType.IsGenericType && !evt.EventHandlerType.IsGenericTypeDefinition) " is 125.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The length of the statement  "            ParameterInfo returnParameter = method is ConstructorInfo ? ((ConstructorInfo)method).__ReturnParameter : ((MethodInfo)method).ReturnParameter; " is 143.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The length of the statement  "            if ((implflags & MethodImplAttributes.AggressiveInlining) != 0 && compat != CompatLevel.V20 && compat != CompatLevel.V40) " is 121.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The length of the statement  "            WriteParam(lw' level0 + 2' method is ConstructorInfo ? ((ConstructorInfo)method).__ReturnParameter : ((MethodInfo)method).ReturnParameter); " is 139.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The length of the statement  "                WriteIL(lw' method' body' method.DeclaringType == null ? null : method.DeclaringType.GetGenericArguments()' method.GetGenericArguments()); " is 138.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The length of the statement  "            if ((method.Attributes & MethodAttributes.PinvokeImpl) != 0 && (implflags & MethodImplAttributes.CodeTypeMask) != MethodImplAttributes.Native) " is 142.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The length of the statement  "                    lw.WriteLine("}} // end of method {0}::{1}"' QuoteIdentifier(method.DeclaringType.__Name)' QuoteIdentifier(methodName)); " is 120.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMarshalAs,The length of the statement  "            if (marshal.SafeArraySubType != null && marshal.UnmanagedType == System.Runtime.InteropServices.UnmanagedType.SafeArray) " is 120.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,QuoteIdentifier,The length of the statement  "                else if (str.Length == 68 && str.StartsWith("<PrivateImplementationDetails>{"' StringComparison.Ordinal) && str.EndsWith("}"' StringComparison.Ordinal)) " is 152.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The length of the statement  "                ((int)assembly.__AssemblyFlags & 512) != 0 && (compat == CompatLevel.None || compat >= CompatLevel.V45) ? "windowsruntime " : ""' " is 129.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The length of the statement  "            lw.WriteLine("  .ver {0}:{1}:{2}:{3}"' assembly.GetName().Version.Major' assembly.GetName().Version.Minor' assembly.GetName().Version.Build' assembly.GetName().Version.Revision); " is 178.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteResources,The length of the statement  "                    lw.WriteLine("  // Offset: 0x{0:X8} Length: 0x{1:X8}"' mres.__Offset' assembly.GetManifestResourceStream(resourceName).Length); " is 127.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteCustomAttributeImpl,The length of the statement  "                if ((flags & Flags.Caverbal) != 0 && DecodeCABlob(sb = new StringBuilder()' ca.Constructor' blob' wrap ? (level0 + 4) * (comment ? -1 : 1) : lw.Column + 5)) " is 156.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteSignatureType,The length of the statement  "                WriteStandAloneMethodSig(lw' type.__MethodSignature' true' loc == TypeLocation.Local || loc == TypeLocation.Parameter || loc == TypeLocation.MemberRef); " is 152.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteSignatureType,The length of the statement  "                        loc == TypeLocation.MemberRef || loc == TypeLocation.MemberRefNoWrap || loc == TypeLocation.DeclaringType || loc == TypeLocation.MethodGenericParameter || type.Name == null " is 172.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteSignatureType,The length of the statement  "                        loc == TypeLocation.MemberRef || loc == TypeLocation.MemberRefNoWrap || loc == TypeLocation.GenericMethodImpl || type.Name == null " is 130.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                    if (prevException != null && currentException.TryOffset == prevException.TryOffset && currentException.TryLength == prevException.TryLength) " is 140.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                                Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers); " is 136.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                        WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false); " is 152.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                else if (opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally) " is 126.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                if (nextFlatException < exceptions2.Count && exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength == currPos) " is 148.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                        lw.Write(".try IL_{0:x4} to IL_{1:x4} catch "' exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength); " is 174.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                        lw.WriteLine(" handler IL_{0:x4} to IL_{1:x4}"' exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength); " is 187.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                            exceptions2[nextFlatException].TryOffset' exceptions2[nextFlatException].TryOffset + exceptions2[nextFlatException].TryLength' " is 126.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                            exceptions2[nextFlatException].HandlerOffset' exceptions2[nextFlatException].HandlerOffset + exceptions2[nextFlatException].HandlerLength); " is 139.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The length of the statement  "                    if (currentException == null || currentException.TryOffset != prevException.TryOffset || currentException.TryLength != prevException.TryLength) " is 143.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,ToString,The length of the statement  "                        return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf2[0]' buf2[1]' buf2[2]' buf2[3]' buf2[4]' buf2[5]' buf2[6]' buf2[7]); " is 154.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,ToString,The length of the statement  "                    return String.Format("({0:X2} {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} {7:X2})"' buf[0]' buf[1]' buf[2]' buf[3]' buf[4]' buf[5]' buf[6]' buf[7]); " is 146.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineMethod,The length of the statement  "                WriteSignatureType(lw' ((MethodInfo)mb.__GetMethodOnTypeDefinition()).ReturnType' IsArrayOfGenericParameter(mb.DeclaringType) ? TypeLocation.General : TypeLocation.MemberRefNoWrap); " is 181.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,ResolveOptionalParameterTypes,The length of the statement  "            return module.__ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers); " is 120.
Long Statement,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,SortExceptions,The length of the statement  "                            Debug.Assert(exceptions[j].TryOffset == exceptions[first].TryOffset && exceptions[j].TryLength == exceptions[first].TryLength); " is 127.
Long Statement,Ildasm,Program,D:\research\architectureSmells\repos\jfrijters_ikdasm\Program.cs,TryMatchOption,The length of the statement  "            if (arg.Length > key.Length + 2 && (arg[key.Length + 1] == ':' || arg[key.Length + 1] == '=') && String.Compare(arg' 1' key' 0' key.Length' true) == 0) " is 151.
Complex Conditional,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,AppendTypeName,The conditional expression  "type.Assembly == assembly && !type.__IsMissing && !noself && (!type.IsGenericType || type.IsGenericTypeDefinition) && !type.HasElementType"  is complex.
Complex Conditional,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMscorlibDirective,The conditional expression  "obj != null && !obj.__IsMissing && obj.BaseType == null && obj.IsClass"  is complex.
Complex Conditional,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetTypeSize,The conditional expression  "type.__IsFunctionPointer || type.IsPointer || type == typeofSystemIntPtr || type == typeofSystemUIntPtr"  is complex.
Complex Conditional,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,QuoteIdentifier,The conditional expression  "quote                  || str.IndexOf('<') != -1                  || str.IndexOf('>') != -1                  || str.StartsWith("?")                  || (str.StartsWith(".") && str != ".ctor" && str != ".cctor")                  || str.Contains(".?")                  || str.Contains("..")                  || str.IndexOf('{') != -1                  || str.IndexOf('}') != -1                  || str.IndexOf('[') != -1                  || str.IndexOf(']') != -1                  || str.IndexOf('!') != -1                  || str.IndexOf('/') != -1                  || str.IndexOf('=') != -1                  || str.IndexOf('+') != -1                  || str.IndexOf(':') != -1                  || str.IndexOf('|') != -1                  || str.IndexOf('~') != -1                  || str.IndexOf('^') != -1                  || str.IndexOf('-') != -1"  is complex.
Complex Conditional,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetTokenFromExportOrdinal,The conditional expression  "machine == ImageFileMachine.ARM && buf[0] == 0xDF && buf[1] == 0xF8 && buf[2] == 0x08 && buf[3] == 0xC0"  is complex.
Complex Conditional,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The conditional expression  "opcode != OpCodes.Switch && opcode != OpCodes.Rethrow && opcode != OpCodes.Endfilter && opcode != OpCodes.Endfinally"  is complex.
Complex Conditional,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineVar,The conditional expression  "opcode == OpCodes.Ldarg_S                  || opcode == OpCodes.Starg_S                  || opcode == OpCodes.Ldarga_S                  || opcode == OpCodes.Ldarg                  || opcode == OpCodes.Starg                  || opcode == OpCodes.Ldarga"  is complex.
Complex Conditional,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The conditional expression  "i < str.Length - 2 && ((pos == 94 && pos - initial != backslashes) || pos > 94)"  is complex.
Complex Conditional,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,SortExceptions,The conditional expression  "i < exceptions.Count                      && exceptions[first].TryOffset == exceptions[i].TryOffset                      && exceptions[first].TryLength == exceptions[i].TryLength                      && (compat != CompatLevel.V20 || exceptions[i].FilterOffset == 0)"  is complex.
Complex Conditional,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,SortExceptions,The conditional expression  "exceptions[j].FilterOffset != 0                                  || (i < exceptions.Count                                      && exceptions[j].TryOffset == exceptions[i].TryOffset                                      && exceptions[j].TryLength == exceptions[i].TryLength                                      && exceptions[j].HandlerOffset + exceptions[j].HandlerLength > exceptions[i].FilterOffset)"  is complex.
Complex Conditional,Ildasm,Program,D:\research\architectureSmells\repos\jfrijters_ikdasm\Program.cs,TryMatchOption,The conditional expression  "arg.Length > key.Length + 2 && (arg[key.Length + 1] == ':' || arg[key.Length + 1] == '=') && String.Compare(arg' 1' key' 0' key.Length' true) == 0"  is complex.
Empty Catch Block,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,DecodeCABlob,The method has an empty catch block.
Empty Catch Block,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,DecodeCABlob,The method has an empty catch block.
Empty Catch Block,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetMethodNames,The method has an empty catch block.
Empty Catch Block,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetFieldNames,The method has an empty catch block.
Empty Catch Block,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WritePermissionSet,The method has an empty catch block.
Magic Number,IKVM.Reflection.Reader,ByteReader,D:\research\architectureSmells\repos\jfrijters_ikdasm\ByteReader.cs,FromBlob,The following statement contains a magic number: ByteReader br = new ByteReader(blobHeap' blob' 4);
Magic Number,IKVM.Reflection.Reader,ByteReader,D:\research\architectureSmells\repos\jfrijters_ikdasm\ByteReader.cs,ReadInt16,The following statement contains a magic number: end - pos < 2
Magic Number,IKVM.Reflection.Reader,ByteReader,D:\research\architectureSmells\repos\jfrijters_ikdasm\ByteReader.cs,ReadInt16,The following statement contains a magic number: return (short)(b1 | (b2 << 8));
Magic Number,IKVM.Reflection.Reader,ByteReader,D:\research\architectureSmells\repos\jfrijters_ikdasm\ByteReader.cs,ReadInt32,The following statement contains a magic number: end - pos < 4
Magic Number,IKVM.Reflection.Reader,ByteReader,D:\research\architectureSmells\repos\jfrijters_ikdasm\ByteReader.cs,ReadInt32,The following statement contains a magic number: return (int)(b1 | (b2 << 8) | (b3 << 16) | (b4 << 24));
Magic Number,IKVM.Reflection.Reader,ByteReader,D:\research\architectureSmells\repos\jfrijters_ikdasm\ByteReader.cs,ReadInt32,The following statement contains a magic number: return (int)(b1 | (b2 << 8) | (b3 << 16) | (b4 << 24));
Magic Number,IKVM.Reflection.Reader,ByteReader,D:\research\architectureSmells\repos\jfrijters_ikdasm\ByteReader.cs,ReadInt32,The following statement contains a magic number: return (int)(b1 | (b2 << 8) | (b3 << 16) | (b4 << 24));
Magic Number,IKVM.Reflection.Reader,ByteReader,D:\research\architectureSmells\repos\jfrijters_ikdasm\ByteReader.cs,ReadInt64,The following statement contains a magic number: return (long)(lo | (hi << 32));
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,DecodeDeclSecurity,The following statement contains a magic number: sb.Append(' '' level + 14);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,DecodeDeclSecurity,The following statement contains a magic number: typeName = typeName.Substring(0' typeName.Length - 10);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,DecodeCABlob,The following statement contains a magic number: var br = new ByteReader(blob' 2' blob.Length - 4);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,DecodeCABlob,The following statement contains a magic number: var br = new ByteReader(blob' 2' blob.Length - 4);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,DecodeCABlob,The following statement contains a magic number: br = new ByteReader(blob' blob.Length - (br.Length + 2)' br.Length + 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,DecodeCABlob,The following statement contains a magic number: br = new ByteReader(blob' blob.Length - (br.Length + 2)' br.Length + 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,AppendNewLine,The following statement contains a magic number: sb.Append(' '' -level - 4);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteUnhandledCustomAttributes,The following statement contains a magic number: switch (parent >> 24)                  {                      case 0x00:  // Module                      case 0x02:  // TypeDef                      case 0x04:  // Field                      case 0x06:  // MethodDef                      case 0x08:  // Param                      case 0x14:  // Event                      case 0x17:  // Property                      case 0x20:  // Assembly                      case 0x2a:  // GenericParam                          break;                      case 0x01:  // TypeRef                          lw.Write(".custom (");                          int level = lw.Column - 1;                          WriteTypeDefOrRef(lw' module.ResolveType(parent));                          lw.Write(") ");                          WriteCustomAttributeImpl(lw' ca' false' level);                          break;                      default:                          if (compat == CompatLevel.V20 || compat == CompatLevel.V40 || (parent >> 24) != 0x09)                          {                              lw.Write(".custom (UNKNOWN_OWNER) ");                              WriteCustomAttributeImpl(lw' ca' false' lw.Column - 16);                          }                          break;                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteUnhandledCustomAttributes,The following statement contains a magic number: switch (parent >> 24)                  {                      case 0x00:  // Module                      case 0x02:  // TypeDef                      case 0x04:  // Field                      case 0x06:  // MethodDef                      case 0x08:  // Param                      case 0x14:  // Event                      case 0x17:  // Property                      case 0x20:  // Assembly                      case 0x2a:  // GenericParam                          break;                      case 0x01:  // TypeRef                          lw.Write(".custom (");                          int level = lw.Column - 1;                          WriteTypeDefOrRef(lw' module.ResolveType(parent));                          lw.Write(") ");                          WriteCustomAttributeImpl(lw' ca' false' level);                          break;                      default:                          if (compat == CompatLevel.V20 || compat == CompatLevel.V40 || (parent >> 24) != 0x09)                          {                              lw.Write(".custom (UNKNOWN_OWNER) ");                              WriteCustomAttributeImpl(lw' ca' false' lw.Column - 16);                          }                          break;                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteUnhandledCustomAttributes,The following statement contains a magic number: switch (parent >> 24)                  {                      case 0x00:  // Module                      case 0x02:  // TypeDef                      case 0x04:  // Field                      case 0x06:  // MethodDef                      case 0x08:  // Param                      case 0x14:  // Event                      case 0x17:  // Property                      case 0x20:  // Assembly                      case 0x2a:  // GenericParam                          break;                      case 0x01:  // TypeRef                          lw.Write(".custom (");                          int level = lw.Column - 1;                          WriteTypeDefOrRef(lw' module.ResolveType(parent));                          lw.Write(") ");                          WriteCustomAttributeImpl(lw' ca' false' level);                          break;                      default:                          if (compat == CompatLevel.V20 || compat == CompatLevel.V40 || (parent >> 24) != 0x09)                          {                              lw.Write(".custom (UNKNOWN_OWNER) ");                              WriteCustomAttributeImpl(lw' ca' false' lw.Column - 16);                          }                          break;                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetPointerSize,The following statement contains a magic number: return 8;
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteData,The following statement contains a magic number: ptrs.Add(new DataPointer(fixup.RVA' fixup.Count * ((fixup.Type & COR_VTABLE_32BIT) != 0 ? 4 : 8)));
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteData,The following statement contains a magic number: ptrs.Add(new DataPointer(fixup.RVA' fixup.Count * ((fixup.Type & COR_VTABLE_32BIT) != 0 ? 4 : 8)));
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteNativeResources,The following statement contains a magic number: module.__GetDataDirectoryEntry(2' out rva' out length);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: lw.GoToColumn(level + 18);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: lw.GoToColumn(level + 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: lw.GoToColumn(level + 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: WriteCustomAttributes(lw' level + 2' type.__GetCustomAttributes(null' false));
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: WriteDeclarativeSecurity(lw' level + 2' CustomAttributeData.__GetDeclarativeSecurity(type)' type.MetadataToken);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: WriteGenericParameterCustomAttributes(lw' level + 2' type.GetGenericArguments());
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: lw.GoToColumn(level + 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: WriteCustomAttributes(lw' level + 2' cas);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: lw.GoToColumn(level + 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: lw.GoToColumn(level + 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: lw.GoToColumn(level + 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: lw.GoToColumn(level + 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following statement contains a magic number: lw.GoToColumn(level + 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteGenericParameterDef,The following statement contains a magic number: wrap && i != 0 && i % 4 == 0
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteEvent,The following statement contains a magic number: WriteCustomAttributes(lw' level + 2' evt.__GetCustomAttributes(null' false));
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteEvent,The following statement contains a magic number: lw.GoToColumn(level + 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteProperty,The following statement contains a magic number: lw.GoToColumn(level + 8);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteProperty,The following statement contains a magic number: lw.Column > 40
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteProperty,The following statement contains a magic number: lw.GoToColumn(level + 7);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteProperty,The following statement contains a magic number: lw.Column > 40
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteProperty,The following statement contains a magic number: WriteCustomAttributes(lw' level + 2' prop.__GetCustomAttributes(null' false));
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteProperty,The following statement contains a magic number: lw.GoToColumn(level + 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: lw.Column > 40
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: bool wrap = lw.Column + sb.Length > 40;
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: lw.Column > 40
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: lw.GoToColumn(level0 + 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: WriteCustomAttributes(lw' level0 + 2' method.__GetCustomAttributes(null' false));
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: WriteGenericParameterCustomAttributes(lw' level0 + 2' method.GetGenericArguments());
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: WriteParam(lw' level0 + 2' method is ConstructorInfo ? ((ConstructorInfo)method).__ReturnParameter : ((MethodInfo)method).ReturnParameter);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: WriteParam(lw' level0 + 2' parameter);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: WriteDeclarativeSecurity(lw' level0 + 2' CustomAttributeData.__GetDeclarativeSecurity(method)' method.MetadataToken);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: lw.GoToColumn(level0 + 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: lw.GoToColumn(level0 + 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: lw.GoToColumn(level0 + 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following statement contains a magic number: lw.GoToColumn(level0 + 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,UnmanagedTypeToString,The following statement contains a magic number: switch (unmanagedType)              {                  case System.Runtime.InteropServices.UnmanagedType.Bool:                      return " bool";                  case System.Runtime.InteropServices.UnmanagedType.SysInt:                      return " int";                  case System.Runtime.InteropServices.UnmanagedType.SysUInt:                      return " uint";                  case System.Runtime.InteropServices.UnmanagedType.I1:                      return " int8";                  case System.Runtime.InteropServices.UnmanagedType.I2:                      return " int16";                  case System.Runtime.InteropServices.UnmanagedType.I4:                      return " int32";                  case System.Runtime.InteropServices.UnmanagedType.I8:                      return " int64";                  case System.Runtime.InteropServices.UnmanagedType.U1:                      return " unsigned int8";                  case System.Runtime.InteropServices.UnmanagedType.U2:                      return " unsigned int16";                  case System.Runtime.InteropServices.UnmanagedType.U4:                      return " unsigned int32";                  case System.Runtime.InteropServices.UnmanagedType.U8:                      return " unsigned int64";                  case System.Runtime.InteropServices.UnmanagedType.R4:                      return " float32";                  case System.Runtime.InteropServices.UnmanagedType.R8:                      return " float64";                  case System.Runtime.InteropServices.UnmanagedType.BStr:                      return " bstr";                  case System.Runtime.InteropServices.UnmanagedType.LPWStr:                      return " lpwstr";                  case System.Runtime.InteropServices.UnmanagedType.SafeArray:                      return " safearray";                  case System.Runtime.InteropServices.UnmanagedType.ByValArray:                      return " fixed array";                  case System.Runtime.InteropServices.UnmanagedType.ByValTStr:                      return " fixed sysstring";                  case System.Runtime.InteropServices.UnmanagedType.IUnknown:                      return " iunknown";                  case System.Runtime.InteropServices.UnmanagedType.Interface:                      return " interface";                  case System.Runtime.InteropServices.UnmanagedType.CustomMarshaler:                      return " custom ";                  case System.Runtime.InteropServices.UnmanagedType.LPArray:                      return "[]";                  case System.Runtime.InteropServices.UnmanagedType.AsAny:                      return " as any";                  case System.Runtime.InteropServices.UnmanagedType.LPStruct:                      return " lpstruct";                  case System.Runtime.InteropServices.UnmanagedType.IDispatch:                      return " idispatch ";                  case System.Runtime.InteropServices.UnmanagedType.Struct:                      return " struct";                  case System.Runtime.InteropServices.UnmanagedType.FunctionPtr:                      return " method";                  case System.Runtime.InteropServices.UnmanagedType.LPStr:                      return " lpstr";                  case System.Runtime.InteropServices.UnmanagedType.Error:                      return " error";                  case System.Runtime.InteropServices.UnmanagedType.LPTStr:                      return " lptstr";                  case System.Runtime.InteropServices.UnmanagedType.VBByRefStr:                      return " byvalstr";                  case System.Runtime.InteropServices.UnmanagedType.Currency:                      return " currency";                  case System.Runtime.InteropServices.UnmanagedType.VariantBool:                      return " variant bool";                  case (System.Runtime.InteropServices.UnmanagedType)80:                      return "";  // Microsoft.SqlServer.DTSRuntimeWrap.dll (9.0.242.0) has this bogus value                  case (System.Runtime.InteropServices.UnmanagedType)46:                      return compat == CompatLevel.None ? " iinspectable" : compat == CompatLevel.V45 ? "{ 2E }" : "";                  case (System.Runtime.InteropServices.UnmanagedType)47:                      return compat == CompatLevel.None ? " hstring" : compat == CompatLevel.V45 ? "{ 2F }" : "";                  default:                      Console.WriteLine("unsupported unmanagedType in marshal blob: {0}"' unmanagedType);                      return "";              }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,UnmanagedTypeToString,The following statement contains a magic number: switch (unmanagedType)              {                  case System.Runtime.InteropServices.UnmanagedType.Bool:                      return " bool";                  case System.Runtime.InteropServices.UnmanagedType.SysInt:                      return " int";                  case System.Runtime.InteropServices.UnmanagedType.SysUInt:                      return " uint";                  case System.Runtime.InteropServices.UnmanagedType.I1:                      return " int8";                  case System.Runtime.InteropServices.UnmanagedType.I2:                      return " int16";                  case System.Runtime.InteropServices.UnmanagedType.I4:                      return " int32";                  case System.Runtime.InteropServices.UnmanagedType.I8:                      return " int64";                  case System.Runtime.InteropServices.UnmanagedType.U1:                      return " unsigned int8";                  case System.Runtime.InteropServices.UnmanagedType.U2:                      return " unsigned int16";                  case System.Runtime.InteropServices.UnmanagedType.U4:                      return " unsigned int32";                  case System.Runtime.InteropServices.UnmanagedType.U8:                      return " unsigned int64";                  case System.Runtime.InteropServices.UnmanagedType.R4:                      return " float32";                  case System.Runtime.InteropServices.UnmanagedType.R8:                      return " float64";                  case System.Runtime.InteropServices.UnmanagedType.BStr:                      return " bstr";                  case System.Runtime.InteropServices.UnmanagedType.LPWStr:                      return " lpwstr";                  case System.Runtime.InteropServices.UnmanagedType.SafeArray:                      return " safearray";                  case System.Runtime.InteropServices.UnmanagedType.ByValArray:                      return " fixed array";                  case System.Runtime.InteropServices.UnmanagedType.ByValTStr:                      return " fixed sysstring";                  case System.Runtime.InteropServices.UnmanagedType.IUnknown:                      return " iunknown";                  case System.Runtime.InteropServices.UnmanagedType.Interface:                      return " interface";                  case System.Runtime.InteropServices.UnmanagedType.CustomMarshaler:                      return " custom ";                  case System.Runtime.InteropServices.UnmanagedType.LPArray:                      return "[]";                  case System.Runtime.InteropServices.UnmanagedType.AsAny:                      return " as any";                  case System.Runtime.InteropServices.UnmanagedType.LPStruct:                      return " lpstruct";                  case System.Runtime.InteropServices.UnmanagedType.IDispatch:                      return " idispatch ";                  case System.Runtime.InteropServices.UnmanagedType.Struct:                      return " struct";                  case System.Runtime.InteropServices.UnmanagedType.FunctionPtr:                      return " method";                  case System.Runtime.InteropServices.UnmanagedType.LPStr:                      return " lpstr";                  case System.Runtime.InteropServices.UnmanagedType.Error:                      return " error";                  case System.Runtime.InteropServices.UnmanagedType.LPTStr:                      return " lptstr";                  case System.Runtime.InteropServices.UnmanagedType.VBByRefStr:                      return " byvalstr";                  case System.Runtime.InteropServices.UnmanagedType.Currency:                      return " currency";                  case System.Runtime.InteropServices.UnmanagedType.VariantBool:                      return " variant bool";                  case (System.Runtime.InteropServices.UnmanagedType)80:                      return "";  // Microsoft.SqlServer.DTSRuntimeWrap.dll (9.0.242.0) has this bogus value                  case (System.Runtime.InteropServices.UnmanagedType)46:                      return compat == CompatLevel.None ? " iinspectable" : compat == CompatLevel.V45 ? "{ 2E }" : "";                  case (System.Runtime.InteropServices.UnmanagedType)47:                      return compat == CompatLevel.None ? " hstring" : compat == CompatLevel.V45 ? "{ 2F }" : "";                  default:                      Console.WriteLine("unsupported unmanagedType in marshal blob: {0}"' unmanagedType);                      return "";              }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,UnmanagedTypeToString,The following statement contains a magic number: switch (unmanagedType)              {                  case System.Runtime.InteropServices.UnmanagedType.Bool:                      return " bool";                  case System.Runtime.InteropServices.UnmanagedType.SysInt:                      return " int";                  case System.Runtime.InteropServices.UnmanagedType.SysUInt:                      return " uint";                  case System.Runtime.InteropServices.UnmanagedType.I1:                      return " int8";                  case System.Runtime.InteropServices.UnmanagedType.I2:                      return " int16";                  case System.Runtime.InteropServices.UnmanagedType.I4:                      return " int32";                  case System.Runtime.InteropServices.UnmanagedType.I8:                      return " int64";                  case System.Runtime.InteropServices.UnmanagedType.U1:                      return " unsigned int8";                  case System.Runtime.InteropServices.UnmanagedType.U2:                      return " unsigned int16";                  case System.Runtime.InteropServices.UnmanagedType.U4:                      return " unsigned int32";                  case System.Runtime.InteropServices.UnmanagedType.U8:                      return " unsigned int64";                  case System.Runtime.InteropServices.UnmanagedType.R4:                      return " float32";                  case System.Runtime.InteropServices.UnmanagedType.R8:                      return " float64";                  case System.Runtime.InteropServices.UnmanagedType.BStr:                      return " bstr";                  case System.Runtime.InteropServices.UnmanagedType.LPWStr:                      return " lpwstr";                  case System.Runtime.InteropServices.UnmanagedType.SafeArray:                      return " safearray";                  case System.Runtime.InteropServices.UnmanagedType.ByValArray:                      return " fixed array";                  case System.Runtime.InteropServices.UnmanagedType.ByValTStr:                      return " fixed sysstring";                  case System.Runtime.InteropServices.UnmanagedType.IUnknown:                      return " iunknown";                  case System.Runtime.InteropServices.UnmanagedType.Interface:                      return " interface";                  case System.Runtime.InteropServices.UnmanagedType.CustomMarshaler:                      return " custom ";                  case System.Runtime.InteropServices.UnmanagedType.LPArray:                      return "[]";                  case System.Runtime.InteropServices.UnmanagedType.AsAny:                      return " as any";                  case System.Runtime.InteropServices.UnmanagedType.LPStruct:                      return " lpstruct";                  case System.Runtime.InteropServices.UnmanagedType.IDispatch:                      return " idispatch ";                  case System.Runtime.InteropServices.UnmanagedType.Struct:                      return " struct";                  case System.Runtime.InteropServices.UnmanagedType.FunctionPtr:                      return " method";                  case System.Runtime.InteropServices.UnmanagedType.LPStr:                      return " lpstr";                  case System.Runtime.InteropServices.UnmanagedType.Error:                      return " error";                  case System.Runtime.InteropServices.UnmanagedType.LPTStr:                      return " lptstr";                  case System.Runtime.InteropServices.UnmanagedType.VBByRefStr:                      return " byvalstr";                  case System.Runtime.InteropServices.UnmanagedType.Currency:                      return " currency";                  case System.Runtime.InteropServices.UnmanagedType.VariantBool:                      return " variant bool";                  case (System.Runtime.InteropServices.UnmanagedType)80:                      return "";  // Microsoft.SqlServer.DTSRuntimeWrap.dll (9.0.242.0) has this bogus value                  case (System.Runtime.InteropServices.UnmanagedType)46:                      return compat == CompatLevel.None ? " iinspectable" : compat == CompatLevel.V45 ? "{ 2E }" : "";                  case (System.Runtime.InteropServices.UnmanagedType)47:                      return compat == CompatLevel.None ? " hstring" : compat == CompatLevel.V45 ? "{ 2F }" : "";                  default:                      Console.WriteLine("unsupported unmanagedType in marshal blob: {0}"' unmanagedType);                      return "";              }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,QuoteIdentifier,The following statement contains a magic number: str = str.Substring(0' pos + 4) + "________" + str.Substring(pos + 12);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,QuoteIdentifier,The following statement contains a magic number: str = str.Substring(0' pos + 4) + "________" + str.Substring(pos + 12);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,QuoteIdentifier,The following statement contains a magic number: c <= 32 || c >= 127
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,QuoteIdentifier,The following statement contains a magic number: c <= 32 || c >= 127
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,QuoteIdentifier,The following statement contains a magic number: str[i] >= 128
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The following statement contains a magic number: lw.WriteLine(".assembly {0}{1}{2}"'                  ((int)assembly.__AssemblyFlags & 16) != 0 ? "cil " : ""'                  ((int)assembly.__AssemblyFlags & 512) != 0 && (compat == CompatLevel.None || compat >= CompatLevel.V45) ? "windowsruntime " : ""'                  QuoteIdentifier(assembly.GetName().Name));
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The following statement contains a magic number: lw.WriteLine(".assembly {0}{1}{2}"'                  ((int)assembly.__AssemblyFlags & 16) != 0 ? "cil " : ""'                  ((int)assembly.__AssemblyFlags & 512) != 0 && (compat == CompatLevel.None || compat >= CompatLevel.V45) ? "windowsruntime " : ""'                  QuoteIdentifier(assembly.GetName().Name));
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The following statement contains a magic number: WriteDeclarativeSecurity(lw' 2' CustomAttributeData.__GetDeclarativeSecurity(assembly)' 0x20000001);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The following statement contains a magic number: byte[] buf = new byte[culture.Length * 2 + 2];
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The following statement contains a magic number: byte[] buf = new byte[culture.Length * 2 + 2];
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The following statement contains a magic number: buf[i * 2 + 0] = (byte)(culture[i] >> 0);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The following statement contains a magic number: buf[i * 2 + 1] = (byte)(culture[i] >> 8);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteAssemblyManifest,The following statement contains a magic number: buf[i * 2 + 1] = (byte)(culture[i] >> 8);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WritePermissionSet,The following statement contains a magic number: switch (action)                  {                      case 0:                          break;                      case (System.Security.Permissions.SecurityAction)1:                          lw.Write("request");                          break;                      case System.Security.Permissions.SecurityAction.Assert:                          lw.Write("assert");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.Deny:  #pragma warning restore 618                          lw.Write("deny");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.PermitOnly:  #pragma warning restore 618                          lw.Write("permitonly");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestMinimum:  #pragma warning restore 618                          lw.Write("reqmin");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestRefuse:  #pragma warning restore 618                          lw.Write("reqrefuse");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestOptional:  #pragma warning restore 618                          lw.Write("reqopt");                          break;                      case System.Security.Permissions.SecurityAction.Demand:                          lw.Write("demand");                          break;                      case System.Security.Permissions.SecurityAction.LinkDemand:                          lw.Write("linkcheck");                          break;                      case System.Security.Permissions.SecurityAction.InheritanceDemand:                          lw.Write("inheritcheck");                          break;                      case (System.Security.Permissions.SecurityAction)11:                          lw.Write("prejitgrant");                          break;                      case (System.Security.Permissions.SecurityAction)12:                          lw.Write("prejitdeny");                          break;                      case (System.Security.Permissions.SecurityAction)13:                          lw.Write("noncasdemand");                          break;                      case (System.Security.Permissions.SecurityAction)14:                          lw.Write("noncaslinkdemand");                          break;                      case (System.Security.Permissions.SecurityAction)15:                          lw.Write("noncasinheritance");                          break;                      default:                          lw.Write("<UNKNOWN_ACTION>");                          break;                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WritePermissionSet,The following statement contains a magic number: switch (action)                  {                      case 0:                          break;                      case (System.Security.Permissions.SecurityAction)1:                          lw.Write("request");                          break;                      case System.Security.Permissions.SecurityAction.Assert:                          lw.Write("assert");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.Deny:  #pragma warning restore 618                          lw.Write("deny");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.PermitOnly:  #pragma warning restore 618                          lw.Write("permitonly");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestMinimum:  #pragma warning restore 618                          lw.Write("reqmin");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestRefuse:  #pragma warning restore 618                          lw.Write("reqrefuse");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestOptional:  #pragma warning restore 618                          lw.Write("reqopt");                          break;                      case System.Security.Permissions.SecurityAction.Demand:                          lw.Write("demand");                          break;                      case System.Security.Permissions.SecurityAction.LinkDemand:                          lw.Write("linkcheck");                          break;                      case System.Security.Permissions.SecurityAction.InheritanceDemand:                          lw.Write("inheritcheck");                          break;                      case (System.Security.Permissions.SecurityAction)11:                          lw.Write("prejitgrant");                          break;                      case (System.Security.Permissions.SecurityAction)12:                          lw.Write("prejitdeny");                          break;                      case (System.Security.Permissions.SecurityAction)13:                          lw.Write("noncasdemand");                          break;                      case (System.Security.Permissions.SecurityAction)14:                          lw.Write("noncaslinkdemand");                          break;                      case (System.Security.Permissions.SecurityAction)15:                          lw.Write("noncasinheritance");                          break;                      default:                          lw.Write("<UNKNOWN_ACTION>");                          break;                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WritePermissionSet,The following statement contains a magic number: switch (action)                  {                      case 0:                          break;                      case (System.Security.Permissions.SecurityAction)1:                          lw.Write("request");                          break;                      case System.Security.Permissions.SecurityAction.Assert:                          lw.Write("assert");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.Deny:  #pragma warning restore 618                          lw.Write("deny");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.PermitOnly:  #pragma warning restore 618                          lw.Write("permitonly");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestMinimum:  #pragma warning restore 618                          lw.Write("reqmin");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestRefuse:  #pragma warning restore 618                          lw.Write("reqrefuse");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestOptional:  #pragma warning restore 618                          lw.Write("reqopt");                          break;                      case System.Security.Permissions.SecurityAction.Demand:                          lw.Write("demand");                          break;                      case System.Security.Permissions.SecurityAction.LinkDemand:                          lw.Write("linkcheck");                          break;                      case System.Security.Permissions.SecurityAction.InheritanceDemand:                          lw.Write("inheritcheck");                          break;                      case (System.Security.Permissions.SecurityAction)11:                          lw.Write("prejitgrant");                          break;                      case (System.Security.Permissions.SecurityAction)12:                          lw.Write("prejitdeny");                          break;                      case (System.Security.Permissions.SecurityAction)13:                          lw.Write("noncasdemand");                          break;                      case (System.Security.Permissions.SecurityAction)14:                          lw.Write("noncaslinkdemand");                          break;                      case (System.Security.Permissions.SecurityAction)15:                          lw.Write("noncasinheritance");                          break;                      default:                          lw.Write("<UNKNOWN_ACTION>");                          break;                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WritePermissionSet,The following statement contains a magic number: switch (action)                  {                      case 0:                          break;                      case (System.Security.Permissions.SecurityAction)1:                          lw.Write("request");                          break;                      case System.Security.Permissions.SecurityAction.Assert:                          lw.Write("assert");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.Deny:  #pragma warning restore 618                          lw.Write("deny");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.PermitOnly:  #pragma warning restore 618                          lw.Write("permitonly");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestMinimum:  #pragma warning restore 618                          lw.Write("reqmin");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestRefuse:  #pragma warning restore 618                          lw.Write("reqrefuse");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestOptional:  #pragma warning restore 618                          lw.Write("reqopt");                          break;                      case System.Security.Permissions.SecurityAction.Demand:                          lw.Write("demand");                          break;                      case System.Security.Permissions.SecurityAction.LinkDemand:                          lw.Write("linkcheck");                          break;                      case System.Security.Permissions.SecurityAction.InheritanceDemand:                          lw.Write("inheritcheck");                          break;                      case (System.Security.Permissions.SecurityAction)11:                          lw.Write("prejitgrant");                          break;                      case (System.Security.Permissions.SecurityAction)12:                          lw.Write("prejitdeny");                          break;                      case (System.Security.Permissions.SecurityAction)13:                          lw.Write("noncasdemand");                          break;                      case (System.Security.Permissions.SecurityAction)14:                          lw.Write("noncaslinkdemand");                          break;                      case (System.Security.Permissions.SecurityAction)15:                          lw.Write("noncasinheritance");                          break;                      default:                          lw.Write("<UNKNOWN_ACTION>");                          break;                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WritePermissionSet,The following statement contains a magic number: switch (action)                  {                      case 0:                          break;                      case (System.Security.Permissions.SecurityAction)1:                          lw.Write("request");                          break;                      case System.Security.Permissions.SecurityAction.Assert:                          lw.Write("assert");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.Deny:  #pragma warning restore 618                          lw.Write("deny");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.PermitOnly:  #pragma warning restore 618                          lw.Write("permitonly");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestMinimum:  #pragma warning restore 618                          lw.Write("reqmin");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestRefuse:  #pragma warning restore 618                          lw.Write("reqrefuse");                          break;  #pragma warning disable 618                      case System.Security.Permissions.SecurityAction.RequestOptional:  #pragma warning restore 618                          lw.Write("reqopt");                          break;                      case System.Security.Permissions.SecurityAction.Demand:                          lw.Write("demand");                          break;                      case System.Security.Permissions.SecurityAction.LinkDemand:                          lw.Write("linkcheck");                          break;                      case System.Security.Permissions.SecurityAction.InheritanceDemand:                          lw.Write("inheritcheck");                          break;                      case (System.Security.Permissions.SecurityAction)11:                          lw.Write("prejitgrant");                          break;                      case (System.Security.Permissions.SecurityAction)12:                          lw.Write("prejitdeny");                          break;                      case (System.Security.Permissions.SecurityAction)13:                          lw.Write("noncasdemand");                          break;                      case (System.Security.Permissions.SecurityAction)14:                          lw.Write("noncaslinkdemand");                          break;                      case (System.Security.Permissions.SecurityAction)15:                          lw.Write("noncasinheritance");                          break;                      default:                          lw.Write("<UNKNOWN_ACTION>");                          break;                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteModuleHeader,The following statement contains a magic number: compat == CompatLevel.V20 || GetPointerSize() == 4
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteModuleHeader,The following statement contains a magic number: GetPointerSize() == 4
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetCorFlags,The following statement contains a magic number: module.__GetDataDirectoryEntry(14' out rva' out length);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetCorFlags,The following statement contains a magic number: var buf = new byte[4];
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetCorFlags,The following statement contains a magic number: module.__ReadDataFromRVA(rva + 16' buf' 0' 4);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetCorFlags,The following statement contains a magic number: module.__ReadDataFromRVA(rva + 16' buf' 0' 4);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,SubsystemToString,The following statement contains a magic number: switch (subsystem)              {                  case 2:                      return "WINDOWS_GUI";                  case 3:                      return "WINDOWS_CUI";                  default:                      throw new NotImplementedException();              }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,SubsystemToString,The following statement contains a magic number: switch (subsystem)              {                  case 2:                      return "WINDOWS_GUI";                  case 3:                      return "WINDOWS_CUI";                  default:                      throw new NotImplementedException();              }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteBytes,The following statement contains a magic number: i % 16 == 0
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteBytes,The following statement contains a magic number: lw.GoToColumn(column + 16 * 3 + (data ? 1 : 2));
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteBytes,The following statement contains a magic number: lw.GoToColumn(column + 16 * 3 + (data ? 1 : 2));
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteBytes,The following statement contains a magic number: lw.GoToColumn(column + 16 * 3 + (data ? 1 : 2));
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,IsText,The following statement contains a magic number: return b >= 32 && b < 127;
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,IsText,The following statement contains a magic number: return b >= 32 && b < 127;
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetExportedMethods,The following statement contains a magic number: rva == 0 || length < 40
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetExportedMethods,The following statement contains a magic number: byte[] buf = new byte[512];
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetExportedMethods,The following statement contains a magic number: module.__ReadDataFromRVA(rva' buf' 0' 40);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetExportedMethods,The following statement contains a magic number: module.__ReadDataFromRVA((int)edt.OrdinalTableRVA + i * 2' buf' 0' 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetExportedMethods,The following statement contains a magic number: module.__ReadDataFromRVA((int)edt.OrdinalTableRVA + i * 2' buf' 0' 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetExportedMethods,The following statement contains a magic number: module.__ReadDataFromRVA((int)edt.NamePointerRVA + i * 4' buf' 0' 4);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetExportedMethods,The following statement contains a magic number: module.__ReadDataFromRVA((int)edt.NamePointerRVA + i * 4' buf' 0' 4);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetTokenFromExportOrdinal,The following statement contains a magic number: byte[] buf = new byte[16];
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetTokenFromExportOrdinal,The following statement contains a magic number: module.__ReadDataFromRVA((int)edt.ExportAddressTableRVA + (int)(ordinal - edt.OrdinalBase) * 4' buf' 0' 4);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetTokenFromExportOrdinal,The following statement contains a magic number: module.__ReadDataFromRVA((int)edt.ExportAddressTableRVA + (int)(ordinal - edt.OrdinalBase) * 4' buf' 0' 4);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetTokenFromExportOrdinal,The following statement contains a magic number: module.__ReadDataFromRVA(exportRVA' buf' 0' 16);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetTokenFromExportOrdinal,The following statement contains a magic number: offset = 2;
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetTokenFromExportOrdinal,The following statement contains a magic number: module.__ReadDataFromRVA(vtableRVA' buf' 0' 4);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetOpCodes,The following statement contains a magic number: OpCode[] opcodes = new OpCode[768];
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetOpCodes,The following statement contains a magic number: opcodes[opc.Value + 512] = opc;
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: lw.GoToColumn(level + 9);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (currentException.Flags)                          {                              case ExceptionHandlingClauseOptions.Clause:                                  lw.GoToColumn(level - 2);                                  if (currentException.TryOffset + currentException.TryLength == pos)                                  {                                      lw.WriteLine("}  // end .try");                                  }                                  else                                  {                                      lw.WriteLine("}  // end handler");                                  }                                  lw.GoToColumn(level - 2);                                  lw.Write("catch ");                                  if (currentException.CatchType.__IsMissing || !currentException.CatchType.IsGenericType)                                  {                                      WriteTypeDefOrRef(lw' currentException.CatchType);                                  }                                  else                                  {                                      WriteSignatureType(lw' currentException.CatchType);                                  }                                  lw.WriteLine(" ");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  handler = true;                                  break;                              case ExceptionHandlingClauseOptions.Finally:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("finally");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Fault:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end .try");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("fault");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{");                                  break;                              case ExceptionHandlingClauseOptions.Filter:                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("}  // end filter");                                  lw.GoToColumn(level - 2);                                  lw.WriteLine("{  // handler");                                  handler = true;                                  break;                              default:                                  throw new Managed.Reflection.BadImageFormatException();                          }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: level += 2;
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: OpCode opcode = opcodes[opcodeValue + 512];
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: switch (opcode.OperandType)                  {                      case OperandType.InlineNone:                          break;                      case OperandType.InlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' ReadInt32(code' ref pos) + pos);                          break;                      case OperandType.ShortInlineBrTarget:                          lw.GoToColumn(level1 + 11);                          lw.Write("IL_{0:x4}"' (sbyte)code[pos++] + pos);                          break;                      case OperandType.InlineMethod:                          {                              lw.GoToColumn(level1 + 11);                              int token = ReadInt32(code' ref pos);                              MethodBase methodOrConstructor = ResolveMethod(token' genericTypeArguments' genericMethodArguments);                              if ((methodOrConstructor.CallingConvention & CallingConventions.Any) == CallingConventions.VarArgs)                              {                                  CustomModifiers[] customModifiers;                                  Type[] optionalParameterTypes = ResolveOptionalParameterTypes(token' genericTypeArguments' genericMethodArguments' out customModifiers);                                  WriteInlineMethod(lw' methodOrConstructor' optionalParameterTypes' customModifiers);                              }                              else                              {                                  WriteInlineMethod(lw' methodOrConstructor' Type.EmptyTypes' null);                              }                          }                          break;                      case OperandType.InlineField:                          lw.GoToColumn(level1 + 11);                          WriteInlineField(lw' ResolveField(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments));                          break;                      case OperandType.InlineI:                          lw.GoToColumn(level1 + 11);                          WriteInlineI(lw' ReadInt32(code' ref pos));                           break;                      case OperandType.InlineI8:                          lw.GoToColumn(level1 + 11);                          WriteInlineI8(lw' ReadInt64(code' ref pos));                          break;                      case OperandType.ShortInlineI:                          lw.GoToColumn(level1 + 11);                          lw.Write("{0}"' (sbyte)code[pos++]);                          break;                      case OperandType.InlineR:                          lw.GoToColumn(level1 + 11);                          WriteInlineR(lw' ReadDouble(code' ref pos)' false);                          break;                      case OperandType.ShortInlineR:                          lw.GoToColumn(level1 + 11);                          WriteShortInlineR(lw' ReadSingle(code' ref pos)' false);                          break;                      case OperandType.InlineType:                          if (opcode == OpCodes.Constrained)                          {                              // "constrained." is too long to fit in the opcode column                              lw.Write(" ");                          }                          else                          {                              lw.GoToColumn(level1 + 11);                          }                          WriteInlineType(lw' ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments);                          break;                      case OperandType.InlineTok:                          {                              int token = ReadInt32(code' ref pos);                              switch (token >> 24)                              {                                  case 0x01:                                  case 0x02:                                      lw.GoToColumn(level1 + 11);                                      WriteTypeDefOrRef(lw' ResolveType(token' genericTypeArguments' genericMethodArguments));                                      break;                                  case 0x1B:                                      {                                          Type type = ResolveType(token' genericTypeArguments' genericMethodArguments);                                          if (type.IsGenericTypeDefinition)                                          {                                              // HACK because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)                                              // we need to inflate the builder here                                              type = type.MakeGenericType(type.GetGenericArguments());                                          }                                          lw.GoToColumn(level1 + 11);                                          WriteSignatureType(lw' type);                                          break;                                      }                                  case 0x04:                                  case 0x06:                                  case 0x0A:                                  case 0x2B:                                      {                                          MemberInfo member = ResolveMember(token' genericTypeArguments' genericMethodArguments);                                          if (member is FieldInfo)                                          {                                              lw.GoToColumn(level1 + 11);                                              lw.Write("field ");                                              WriteInlineField(lw' (FieldInfo)member);                                          }                                          else                                          {                                              var mb1 = (MethodBase)member;                                              lw.GoToColumn(level1 + 11);                                              if (mb1.__IsMissing || !mb1.IsGenericMethod || compat != CompatLevel.V20)                                              {                                                  lw.Write("method ");                                              }                                              WriteInlineMethod(lw' mb1' Type.EmptyTypes' null);                                          }                                          break;                                      }                                  default:                                      throw new NotImplementedException("token type = " + (token >> 24));                              }                          }                          break;                      case OperandType.InlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' ReadInt16(code' ref pos));                          break;                      case OperandType.ShortInlineVar:                          lw.GoToColumn(level1 + 11);                          WriteInlineVar(lw' mb' opcode' parameters' code[pos++]);                          break;                      case OperandType.InlineString:                          lw.GoToColumn(level1 + 11);                          WriteInlineString(lw' module.ResolveString(ReadInt32(code' ref pos))' level);                          break;                      case OperandType.InlineSwitch:                          {                              lw.GoToColumn(level1 + 11);                              lw.WriteLine("( ");                              int count = ReadInt32(code' ref pos);                              int offset = pos + 4 * count;                              for (int i = 0; i < count - 1; i++)                              {                                  lw.GoToColumn(level + 22);                                  lw.WriteLine("IL_{0:x4}'"' offset + ReadInt32(code' ref pos));                              }                              lw.GoToColumn(level + 22);                              lw.Write("IL_{0:x4})"' offset + ReadInt32(code' ref pos));                          }                          break;                      case OperandType.InlineSig:                          lw.GoToColumn(level1 + 11);                          WriteStandAloneMethodSig(lw' module.__ResolveStandAloneMethodSig(ReadInt32(code' ref pos)' genericTypeArguments' genericMethodArguments)' false' false);                          break;                      default:                          throw new InvalidOperationException();                  }
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following statement contains a magic number: level -= 2;
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: int initial = 44 - lw.Column + level;
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: int pos = 44;
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(str.Length + 10);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: sb.Append('\\'' backslashes * 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: i < str.Length - 2 && ((pos == 94 && pos - initial != backslashes) || pos > 94)
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: i < str.Length - 2 && ((pos == 94 && pos - initial != backslashes) || pos > 94)
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: i < str.Length - 2 && ((pos == 94 && pos - initial != backslashes) || pos > 94)
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: c < 32
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineString,The following statement contains a magic number: sb.Append('\\'' backslashes * 2);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetBytes,The following statement contains a magic number: byte[] buf = new byte[str.Length * 2];
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetBytes,The following statement contains a magic number: buf[i * 2 + 0] = (byte)(ch >> 0);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetBytes,The following statement contains a magic number: buf[i * 2 + 1] = (byte)(ch >> 8);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetBytes,The following statement contains a magic number: buf[i * 2 + 1] = (byte)(ch >> 8);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineI,The following statement contains a magic number: value >= 128 || value < 128
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineI,The following statement contains a magic number: value >= 128 || value < 128
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineI8,The following statement contains a magic number: value >= 128 || value < 128
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineI8,The following statement contains a magic number: value >= 128 || value < 128
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineMethod,The following statement contains a magic number: level -= 5 + (int)Math.Log10(mb.GetGenericArguments().Length);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteInlineType,The following statement contains a magic number: metadataToken >> 24 == 0x1B
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,ReadInt16,The following statement contains a magic number: pos += 2;
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,ReadInt32,The following statement contains a magic number: pos += 4;
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,ReadInt64,The following statement contains a magic number: pos += 8;
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,ReadSingle,The following statement contains a magic number: pos += 4;
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,ReadDouble,The following statement contains a magic number: pos += 8;
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteVTableFixupComment,The following statement contains a magic number: ptrsize == 4
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteVTableFixups,The following statement contains a magic number: ptrsize == 4
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: module.__GetDataDirectoryEntry(14' out rva' out length);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: byte[] buf = new byte[8];
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: module.__ReadDataFromRVA(rva + 48' buf' 0' 8);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: module.__ReadDataFromRVA(rva + 48' buf' 0' 8);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: VTableFixups[] entries = new VTableFixups[BitConverter.ToInt32(buf' 4) / 8];
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: VTableFixups[] entries = new VTableFixups[BitConverter.ToInt32(buf' 4) / 8];
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: module.__ReadDataFromRVA(rva + i * 8' buf' 0' 8);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: module.__ReadDataFromRVA(rva + i * 8' buf' 0' 8);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: entries[i].Count = BitConverter.ToInt16(buf' 4);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetVTableFixups,The following statement contains a magic number: entries[i].Type = BitConverter.ToInt16(buf' 6);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetVTableMethods,The following statement contains a magic number: byte[] buf = new byte[8];
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetVTableMethods,The following statement contains a magic number: module.__ReadDataFromRVA(fixuprva' buf' 0' 4);
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetVTableMethods,The following statement contains a magic number: fixuprva += 4;
Magic Number,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,GetVTableMethods,The following statement contains a magic number: fixuprva += 8;
Magic Number,Ildasm,Program,D:\research\architectureSmells\repos\jfrijters_ikdasm\Program.cs,TryMatchOption,The following statement contains a magic number: value = arg.Substring(key.Length + 2);
Magic Number,Ildasm,Program,D:\research\architectureSmells\repos\jfrijters_ikdasm\Program.cs,TryMatchOption,The following statement contains a magic number: arg.Length > key.Length + 2 && (arg[key.Length + 1] == ':' || arg[key.Length + 1] == '=') && String.Compare(arg' 1' key' 0' key.Length' true) == 0
Magic Number,Ildasm,Program,D:\research\architectureSmells\repos\jfrijters_ikdasm\Program.cs,IsIldasmOption,The following statement contains a magic number: return String.Compare(arg' 1' option' 0' 3' StringComparison.OrdinalIgnoreCase) == 0;
Missing Default,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,ReadFixedArg,The following switch statement is missing a default case: switch (type.FullName)                      {                          case "System.AttributeTargets":                          case "System.Runtime.ConstrainedExecution.Consistency":                          case "System.Runtime.ConstrainedExecution.Cer":                          case "System.Security.Permissions.SecurityAction":                          case "System.Security.Permissions.SecurityPermissionFlag":                          case "System.Runtime.Versioning.ResourceScope":                          case "System.Runtime.InteropServices.CallingConvention":                          case "System.Runtime.InteropServices.CharSet":                              ReadFixedArg(sb' br' typeofSystemInt32);                              return;                          case "System.Security.SecurityRuleSet":                              if (compat != CompatLevel.V20)                              {                                  ReadFixedArg(sb' br' typeofSystemByte);                                  return;                              }                              break;                          case "System.Diagnostics.Tracing.EventLevel":                          case "System.Diagnostics.Tracing.EventTask":                          case "System.Diagnostics.Tracing.EventOpcode":                              if (compat != CompatLevel.V20 && compat != CompatLevel.V40)                              {                                  ReadFixedArg(sb' br' typeofSystemInt32);                                  return;                              }                              break;                          case "System.Type":                              sb.Append("type(");                              string typeName;                              AppendTypeName(sb' ReadType(br' out typeName)' typeName);                              sb.Append(")");                              return;                      }
Missing Default,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following switch statement is missing a default case: switch (type.StructLayoutAttribute.Value)              {                  case System.Runtime.InteropServices.LayoutKind.Auto:                      lw.Write("auto ");                      break;                  case System.Runtime.InteropServices.LayoutKind.Sequential:                      lw.Write("sequential ");                      break;                  case System.Runtime.InteropServices.LayoutKind.Explicit:                      lw.Write("explicit ");                      break;              }
Missing Default,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following switch statement is missing a default case: switch (type.Attributes & TypeAttributes.StringFormatMask)              {                  case TypeAttributes.AnsiClass:                      lw.Write("ansi ");                      break;                  case TypeAttributes.UnicodeClass:                      lw.Write("unicode ");                      break;                  case TypeAttributes.AutoClass:                      lw.Write("autochar ");                      break;              }
Missing Default,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteType,The following switch statement is missing a default case: switch (type.Attributes & TypeAttributes.VisibilityMask)              {                  case TypeAttributes.NestedPublic:                      lw.Write("nested public ");                      break;                  case TypeAttributes.NestedPrivate:                      lw.Write("nested private ");                      break;                  case TypeAttributes.NestedAssembly:                      lw.Write("nested assembly ");                      break;                  case TypeAttributes.NestedFamily:                      lw.Write("nested family ");                      break;                  case TypeAttributes.NestedFamORAssem:                      lw.Write("nested famorassem ");                      break;              }
Missing Default,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following switch statement is missing a default case: switch (method.Attributes & MethodAttributes.MemberAccessMask)              {                  case MethodAttributes.Public:                      lw.Write("public ");                      break;                  case MethodAttributes.Private:                      lw.Write("private ");                      break;                  case MethodAttributes.Assembly:                      lw.Write("assembly ");                      break;                  case MethodAttributes.Family:                      lw.Write("family ");                      break;                  case MethodAttributes.FamORAssem:                      lw.Write("famorassem ");                      break;                  case MethodAttributes.PrivateScope:                      lw.Write("privatescope ");                      break;              }
Missing Default,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMethod,The following switch statement is missing a default case: switch (implflags & MethodImplAttributes.CodeTypeMask)              {                  case MethodImplAttributes.IL:                      lw.Write(" cil");                      break;                  case MethodImplAttributes.Native:                      lw.Write(" native");                      break;                  case MethodImplAttributes.OPTIL:                      lw.Write(" optil");                      break;                  case MethodImplAttributes.Runtime:                      lw.Write(" runtime");                      break;              }
Missing Default,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WritePInvokeImpl,The following switch statement is missing a default case: switch (flags & ImplMapFlags.CharSetMask)                  {                      case ImplMapFlags.CharSetAnsi:                          lw.Write(" ansi");                          break;                      case ImplMapFlags.CharSetAuto:                          lw.Write(" autochar");                          break;                      case ImplMapFlags.CharSetUnicode:                          lw.Write(" unicode");                          break;                  }
Missing Default,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WritePInvokeImpl,The following switch statement is missing a default case: switch (flags & ImplMapFlags.CallConvMask)                  {                      case ImplMapFlags.CallConvWinapi:                          lw.Write(" winapi");                          break;                      case ImplMapFlags.CallConvStdcall:                          lw.Write(" stdcall");                          break;                      case ImplMapFlags.CallConvCdecl:                          lw.Write(" cdecl");                          break;                      case ImplMapFlags.CallConvThiscall:                          lw.Write(" thiscall");                          break;                  }
Missing Default,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WritePInvokeImpl,The following switch statement is missing a default case: switch (flags & (ImplMapFlags.BestFitOff | ImplMapFlags.BestFitOn))                  {                      case ImplMapFlags.BestFitOn:                          lw.Write(" bestfit:on");                          break;                      case ImplMapFlags.BestFitOff:                          lw.Write(" bestfit:off");                          break;                  }
Missing Default,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WritePInvokeImpl,The following switch statement is missing a default case: switch (flags & (ImplMapFlags.CharMapErrorOff | ImplMapFlags.CharMapErrorOn))                  {                      case ImplMapFlags.CharMapErrorOn:                          lw.Write(" charmaperror:on");                          break;                      case ImplMapFlags.CharMapErrorOff:                          lw.Write(" charmaperror:off");                          break;                  }
Missing Default,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteMarshalAs,The following switch statement is missing a default case: switch (marshal.ArraySubType.Value)                  {                      case System.Runtime.InteropServices.UnmanagedType.IUnknown:                      case System.Runtime.InteropServices.UnmanagedType.Interface:                          if (marshal.SizeParamIndex == null)                          {                              sb.Append(" ");                          }                          else                          {                              sb.AppendFormat("(iidparam = {0}) "' marshal.SizeParamIndex.Value);                              sizeParamIndex = null;                          }                          break;                  }
Missing Default,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteField,The following switch statement is missing a default case: switch (field.Attributes & FieldAttributes.FieldAccessMask)              {                  case FieldAttributes.Public:                      lw.Write("public ");                      break;                  case FieldAttributes.Private:                      lw.Write("private ");                      break;              }
Missing Default,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteField,The following switch statement is missing a default case: switch (field.Attributes & FieldAttributes.FieldAccessMask)              {                  case FieldAttributes.Family:                      lw.Write("family ");                      break;                  case FieldAttributes.Assembly:                      lw.Write("assembly ");                      break;                  case FieldAttributes.FamORAssem:                      lw.Write("famorassem ");                      break;                  case FieldAttributes.PrivateScope:                      lw.Write("privatescope ");                      break;              }
Missing Default,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteModuleManifest,The following switch statement is missing a default case: switch (asm.ProcessorArchitecture)                  {                      case ProcessorArchitecture.MSIL:                          lw.Write("cil ");                          break;                      case ProcessorArchitecture.X86:                          lw.Write("x86 ");                          break;                      case ProcessorArchitecture.IA64:                          lw.Write("ia64 ");                          break;                      case ProcessorArchitecture.Amd64:                          lw.Write("amd64 ");                          break;                      case ProcessorArchitecture.Arm:                          if (compat == CompatLevel.None)                          {                              lw.Write("/*arm*/ ");                          }                          break;                  }
Missing Default,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteStandAloneMethodSig,The following switch statement is missing a default case: switch (sig.UnmanagedCallingConvention)                  {                      case System.Runtime.InteropServices.CallingConvention.Cdecl:                          lw.Write("cdecl ");                          break;                      case System.Runtime.InteropServices.CallingConvention.StdCall:                          lw.Write("stdcall ");                          break;                      case System.Runtime.InteropServices.CallingConvention.ThisCall:                          lw.Write("thiscall ");                          break;                  }
Missing Default,Ildasm,Disassembler,D:\research\architectureSmells\repos\jfrijters_ikdasm\CABlob.cs,WriteIL,The following switch statement is missing a default case: switch (opcode.FlowControl)                      {                          case FlowControl.Branch:                          case FlowControl.Cond_Branch:                          case FlowControl.Throw:                          case FlowControl.Return:                              extraNewLine = true;                              break;                      }
