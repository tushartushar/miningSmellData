Implementation smell,Namespace,Class,File,Method,Description
Long Method,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,The method has 465 lines of code.
Long Method,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Stream,The method has 159 lines of code.
Long Method,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The method has 281 lines of code.
Long Method,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,CreateSubscription,The method has 104 lines of code.
Long Method,QuantConnect.Lean.Engine.DataFeeds,SubscriptionDataReader,C:\repos\QuantConnect_Lean\Engine\DataFeeds\SubscriptionDataReader.cs,MoveNext,The method has 128 lines of code.
Long Method,QuantConnect.Lean.Engine.DataFeeds,TimeSlice,C:\repos\QuantConnect_Lean\Engine\DataFeeds\TimeSlice.cs,Create,The method has 152 lines of code.
Long Method,QuantConnect.Lean.Engine.DataFeeds,UniverseSelection,C:\repos\QuantConnect_Lean\Engine\DataFeeds\UniverseSelection.cs,ApplyUniverseSelection,The method has 145 lines of code.
Long Method,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Update,The method has 176 lines of code.
Long Method,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,ProcessSynchronousEvents,The method has 116 lines of code.
Long Method,QuantConnect.Lean.Engine.Setup,BrokerageSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BrokerageSetupHandler.cs,Setup,The method has 210 lines of code.
Complex Method,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,Cyclomatic complexity of the method is 57
Complex Method,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Stream,Cyclomatic complexity of the method is 25
Complex Method,QuantConnect.Lean.Engine,LeanEngineAlgorithmHandlers,C:\repos\QuantConnect_Lean\Engine\LeanEngineAlgorithmHandlers.cs,LeanEngineAlgorithmHandlers,Cyclomatic complexity of the method is 9
Complex Method,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,Cyclomatic complexity of the method is 16
Complex Method,QuantConnect.Lean.Engine.DataFeeds,BaseDataExchange,C:\repos\QuantConnect_Lean\Engine\DataFeeds\BaseDataExchange.cs,ConsumeEnumerators,Cyclomatic complexity of the method is 10
Complex Method,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,Run,Cyclomatic complexity of the method is 9
Complex Method,QuantConnect.Lean.Engine.DataFeeds,SubscriptionDataReader,C:\repos\QuantConnect_Lean\Engine\DataFeeds\SubscriptionDataReader.cs,SubscriptionDataReader,Cyclomatic complexity of the method is 11
Complex Method,QuantConnect.Lean.Engine.DataFeeds,SubscriptionDataReader,C:\repos\QuantConnect_Lean\Engine\DataFeeds\SubscriptionDataReader.cs,TryGetNextDate,Cyclomatic complexity of the method is 9
Complex Method,QuantConnect.Lean.Engine.DataFeeds,TimeSlice,C:\repos\QuantConnect_Lean\Engine\DataFeeds\TimeSlice.cs,Create,Cyclomatic complexity of the method is 21
Complex Method,QuantConnect.Lean.Engine.DataFeeds,TimeSlice,C:\repos\QuantConnect_Lean\Engine\DataFeeds\TimeSlice.cs,HandleOptionData,Cyclomatic complexity of the method is 9
Complex Method,QuantConnect.Lean.Engine.DataFeeds,UniverseSelection,C:\repos\QuantConnect_Lean\Engine\DataFeeds\UniverseSelection.cs,ApplyUniverseSelection,Cyclomatic complexity of the method is 22
Complex Method,QuantConnect.Lean.Engine.DataFeeds.Enumerators,BaseDataCollectionAggregatorEnumerator<T>,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\BaseDataCollectionAggregatorEnumerator.cs,MoveNext,Cyclomatic complexity of the method is 8
Complex Method,QuantConnect.Lean.Engine.DataFeeds.Enumerators,FillForwardEnumerator,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\FillForwardEnumerator.cs,MoveNext,Cyclomatic complexity of the method is 14
Complex Method,QuantConnect.Lean.Engine.DataFeeds.Enumerators,SynchronizingEnumerator,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\SynchronizingEnumerator.cs,GetBruteForceMethod,Cyclomatic complexity of the method is 9
Complex Method,QuantConnect.Lean.Engine.Results,DesktopResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\DesktopResultHandler.cs,ProcessSynchronousEvents,Cyclomatic complexity of the method is 10
Complex Method,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,ProcessSynchronousEvents,Cyclomatic complexity of the method is 11
Complex Method,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Update,Cyclomatic complexity of the method is 10
Complex Method,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,ProcessSynchronousEvents,Cyclomatic complexity of the method is 18
Complex Method,QuantConnect.Lean.Engine.HistoricalData,SynchronizingHistoryProvider,C:\repos\QuantConnect_Lean\Engine\HistoricalData\SynchronizingHistoryProvider.cs,CreateSliceEnumerableFromSubscriptions,Cyclomatic complexity of the method is 11
Complex Method,QuantConnect.Lean.Engine.Setup,BrokerageSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BrokerageSetupHandler.cs,Setup,Cyclomatic complexity of the method is 10
Complex Method,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,Setup,Cyclomatic complexity of the method is 8
Complex Method,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,ProcessSynchronousEvents,Cyclomatic complexity of the method is 8
Complex Method,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,PerformCashSync,Cyclomatic complexity of the method is 8
Complex Method,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,HandleSubmitOrderRequest,Cyclomatic complexity of the method is 8
Long Parameter List,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,The method has 8 parameters. Parameters: job' algorithm' feed' transactions' results' realtime' leanManager' token
Long Parameter List,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Stream,The method has 5 parameters. Parameters: job' algorithm' feed' results' cancellationToken
Long Parameter List,QuantConnect.Lean.Engine,LeanEngineAlgorithmHandlers,C:\repos\QuantConnect_Lean\Engine\LeanEngineAlgorithmHandlers.cs,LeanEngineAlgorithmHandlers,The method has 8 parameters. Parameters: results' setup' dataFeed' transactions' realTime' mapFileProvider' factorFileProvider' dataProvider
Long Parameter List,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,Initialize,The method has 6 parameters. Parameters: algorithm' job' resultHandler' mapFileProvider' factorFileProvider' dataProvider
Long Parameter List,QuantConnect.Lean.Engine.DataFeeds,SubscriptionSynchronizer,C:\repos\QuantConnect_Lean\Engine\DataFeeds\SubscriptionSynchronizer.cs,Sync,The method has 5 parameters. Parameters: frontier' subscriptions' sliceTimeZone' cashBook' nextFrontier
Long Parameter List,QuantConnect.Lean.Engine.DataFeeds,Subscription,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Subscription.cs,Subscription,The method has 8 parameters. Parameters: universe' security' configuration' enumerator' timeZoneOffsetProvider' utcStartTime' utcEndTime' isUniverseSelectionSubscription
Long Parameter List,QuantConnect.Lean.Engine.DataFeeds,SubscriptionDataSourceReader,C:\repos\QuantConnect_Lean\Engine\DataFeeds\SubscriptionDataSourceReader.cs,ForSource,The method has 5 parameters. Parameters: source' dataCacheProvider' config' date' isLiveMode
Long Parameter List,QuantConnect.Lean.Engine.DataFeeds,SubscriptionDataReader,C:\repos\QuantConnect_Lean\Engine\DataFeeds\SubscriptionDataReader.cs,SubscriptionDataReader,The method has 11 parameters. Parameters: config' periodStart' periodFinish' resultHandler' mapFileResolver' factorFileProvider' dataProvider' tradeableDates' isLiveMode' dataCacheProvider' includeAuxilliaryData
Long Parameter List,QuantConnect.Lean.Engine.DataFeeds,TimeSlice,C:\repos\QuantConnect_Lean\Engine\DataFeeds\TimeSlice.cs,TimeSlice,The method has 9 parameters. Parameters: time' dataPointCount' slice' data' cashBookUpdateData' securitiesUpdateData' consolidatorUpdateData' customData' securityChanges
Long Parameter List,QuantConnect.Lean.Engine.DataFeeds,TimeSlice,C:\repos\QuantConnect_Lean\Engine\DataFeeds\TimeSlice.cs,Create,The method has 5 parameters. Parameters: utcDateTime' algorithmTimeZone' cashBook' data' changes
Long Parameter List,QuantConnect.Lean.Engine.DataFeeds,TimeSlice,C:\repos\QuantConnect_Lean\Engine\DataFeeds\TimeSlice.cs,PopulateDataDictionaries,The method has 6 parameters. Parameters: baseData' ticks' tradeBars' quoteBars' optionChains' futuresChains
Long Parameter List,QuantConnect.Lean.Engine.DataFeeds,TimeSlice,C:\repos\QuantConnect_Lean\Engine\DataFeeds\TimeSlice.cs,HandleOptionData,The method has 5 parameters. Parameters: algorithmTime' baseData' optionChains' security' sliceFuture
Long Parameter List,QuantConnect.Lean.Engine.DataFeeds,UniverseSelection,C:\repos\QuantConnect_Lean\Engine\DataFeeds\UniverseSelection.cs,RemoveSecurityFromUniverse,The method has 5 parameters. Parameters: universe' member' removals' dateTimeUtc' algorithmEndDateUtc
Long Parameter List,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,Initialize,The method has 6 parameters. Parameters: algorithm' job' resultHandler' mapFileProvider' factorFileProvider' dataProvider
Long Parameter List,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,ScheduleEnumerator,The method has 5 parameters. Parameters: enumerator' enqueueable' lowerThreshold' upperThreshold' firstLoopCount
Long Parameter List,QuantConnect.Lean.Engine.DataFeeds,IDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\IDataFeed.cs,Initialize,The method has 6 parameters. Parameters: algorithm' job' resultHandler' mapFileProvider' factorFileProvider' dataProvider
Long Parameter List,QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories,LiveCustomDataSubscriptionEnumeratorFactory,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\Factories\LiveCustomDataSubscriptionEnumeratorFactory.cs,EnumerateDataSourceReader,The method has 5 parameters. Parameters: config' dataProvider' localFrontier' source' localDate
Long Parameter List,QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories,SubscriptionDataReaderSubscriptionEnumeratorFactory,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\Factories\SubscriptionDataReaderSubscriptionEnumeratorFactory.cs,SubscriptionDataReaderSubscriptionEnumeratorFactory,The method has 7 parameters. Parameters: resultHandler' mapFileProvider' factorFileProvider' dataProvider' isLiveMode' includeAuxiliaryData' tradableDaysProvider
Long Parameter List,QuantConnect.Lean.Engine.DataFeeds.Enumerators,FillForwardEnumerator,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\FillForwardEnumerator.cs,FillForwardEnumerator,The method has 7 parameters. Parameters: enumerator' exchange' fillForwardResolution' isExtendedMarketHours' subscriptionEndTime' dataResolution' dataTimeZone
Long Parameter List,QuantConnect.Lean.Engine.DataFeeds.Enumerators,LiveFillForwardEnumerator,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\LiveFillForwardEnumerator.cs,LiveFillForwardEnumerator,The method has 8 parameters. Parameters: timeProvider' enumerator' exchange' fillForwardResolution' isExtendedMarketHours' subscriptionEndTime' dataResolution' dataTimeZone
Long Parameter List,QuantConnect.Lean.Engine.Results,DesktopResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\DesktopResultHandler.cs,Initialize,The method has 6 parameters. Parameters: job' messagingHandler' api' dataFeed' setupHandler' transactionHandler
Long Parameter List,QuantConnect.Lean.Engine.Results,DesktopResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\DesktopResultHandler.cs,Sample,The method has 7 parameters. Parameters: chartName' seriesName' seriesIndex' seriesType' time' value' unit
Long Parameter List,QuantConnect.Lean.Engine.Results,DesktopResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\DesktopResultHandler.cs,SendFinalResult,The method has 7 parameters. Parameters: job' orders' profitLoss' holdings' cashbook' statisticsResults' banner
Long Parameter List,QuantConnect.Lean.Engine.Results,IResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\IResultHandler.cs,Initialize,The method has 6 parameters. Parameters: job' messagingHandler' api' dataFeed' setupHandler' transactionHandler
Long Parameter List,QuantConnect.Lean.Engine.Results,IResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\IResultHandler.cs,Sample,The method has 7 parameters. Parameters: chartName' seriesName' seriesIndex' seriesType' time' value' unit
Long Parameter List,QuantConnect.Lean.Engine.Results,IResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\IResultHandler.cs,SendFinalResult,The method has 7 parameters. Parameters: job' orders' profitLoss' holdings' cashbook' statisticsResults' banner
Long Parameter List,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,Initialize,The method has 6 parameters. Parameters: job' messagingHandler' api' dataFeed' setupHandler' transactionHandler
Long Parameter List,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,SendFinalResult,The method has 7 parameters. Parameters: job' orders' profitLoss' holdings' cashbook' statisticsResults' banner
Long Parameter List,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,Sample,The method has 7 parameters. Parameters: chartName' seriesName' seriesIndex' seriesType' time' value' unit
Long Parameter List,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Initialize,The method has 6 parameters. Parameters: job' messagingHandler' api' dataFeed' setupHandler' transactionHandler
Long Parameter List,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,SplitPackets,The method has 7 parameters. Parameters: deltaCharts' deltaOrders' holdings' cashbook' deltaStatistics' runtimeStatistics' serverStatistics
Long Parameter List,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Sample,The method has 7 parameters. Parameters: chartName' seriesName' seriesIndex' seriesType' time' value' unit
Long Parameter List,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,SendFinalResult,The method has 7 parameters. Parameters: job' orders' profitLoss' holdings' cashbook' statisticsResults' runtime
Long Parameter List,QuantConnect.Lean.Engine.HistoricalData,BrokerageHistoryProvider,C:\repos\QuantConnect_Lean\Engine\HistoricalData\BrokerageHistoryProvider.cs,Initialize,The method has 6 parameters. Parameters: job' dataProvider' dataCacheProvider' mapFileProvider' factorFileProvider' statusUpdate
Long Parameter List,QuantConnect.Lean.Engine.HistoricalData,SubscriptionDataReaderHistoryProvider,C:\repos\QuantConnect_Lean\Engine\HistoricalData\SubscriptionDataReaderHistoryProvider.cs,Initialize,The method has 6 parameters. Parameters: job' dataProvider' dataCacheProvider' mapFileProvider' factorFileProvider' statusUpdate
Long Parameter List,QuantConnect.Lean.Engine.HistoricalData,ResultHandlerStub,C:\repos\QuantConnect_Lean\Engine\HistoricalData\SubscriptionDataReaderHistoryProvider.cs,Initialize,The method has 6 parameters. Parameters: job' messagingHandler' api' dataFeed' setupHandler' transactionHandler
Long Parameter List,QuantConnect.Lean.Engine.HistoricalData,ResultHandlerStub,C:\repos\QuantConnect_Lean\Engine\HistoricalData\SubscriptionDataReaderHistoryProvider.cs,Sample,The method has 7 parameters. Parameters: chartName' seriesName' seriesIndex' seriesType' time' value' unit
Long Parameter List,QuantConnect.Lean.Engine.HistoricalData,ResultHandlerStub,C:\repos\QuantConnect_Lean\Engine\HistoricalData\SubscriptionDataReaderHistoryProvider.cs,SendFinalResult,The method has 7 parameters. Parameters: job' orders' profitLoss' holdings' cashbook' statisticsResults' banner
Long Parameter List,QuantConnect.Lean.Engine.HistoricalData,SynchronizingHistoryProvider,C:\repos\QuantConnect_Lean\Engine\HistoricalData\SynchronizingHistoryProvider.cs,Initialize,The method has 6 parameters. Parameters: job' dataProvider' dataCacheProvider' mapFileProvider' factorFileProvider' statusUpdate
Long Parameter List,QuantConnect.Lean.Engine.RealTime,ScheduledEventFactory,C:\repos\QuantConnect_Lean\Engine\RealTime\ScheduledEventFactory.cs,EveryDayAt,The method has 5 parameters. Parameters: name' dates' timeOfDay' callback' currentUtcTime
Long Parameter List,QuantConnect.Lean.Engine.RealTime,ScheduledEventFactory,C:\repos\QuantConnect_Lean\Engine\RealTime\ScheduledEventFactory.cs,EveryAlgorithmEndOfDay,The method has 6 parameters. Parameters: algorithm' resultHandler' start' end' endOfDayDelta' currentUtcTime
Long Parameter List,QuantConnect.Lean.Engine.RealTime,ScheduledEventFactory,C:\repos\QuantConnect_Lean\Engine\RealTime\ScheduledEventFactory.cs,EverySecurityEndOfDay,The method has 7 parameters. Parameters: algorithm' resultHandler' security' start' end' endOfDayDelta' currentUtcTime
Long Parameter List,QuantConnect.Lean.Engine.Setup,BrokerageSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BrokerageSetupHandler.cs,Setup,The method has 6 parameters. Parameters: algorithm' brokerage' job' resultHandler' transactionHandler' realTimeHandler
Long Parameter List,QuantConnect.Lean.Engine.Setup,ConsoleSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\ConsoleSetupHandler.cs,Setup,The method has 6 parameters. Parameters: algorithm' brokerage' baseJob' resultHandler' transactionHandler' realTimeHandler
Long Parameter List,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,Setup,The method has 6 parameters. Parameters: algorithm' brokerage' baseJob' resultHandler' transactionHandler' realTimeHandler
Long Parameter List,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,GetMaximumRuntime,The method has 5 parameters. Parameters: start' finish' subscriptionManager' universeManager' controls
Long Parameter List,QuantConnect.Lean.Engine.Setup,ISetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\ISetupHandler.cs,Setup,The method has 6 parameters. Parameters: algorithm' brokerage' job' resultHandler' transactionHandler' realTimeHandler
Long Identifier,QuantConnect.Lean.Engine.DataFeeds,Subscription,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Subscription.cs,Subscription,The length of the parameter isUniverseSelectionSubscription is 31.
Long Identifier,QuantConnect.Lean.Engine.DataFeeds,SubscriptionDataReader,C:\repos\QuantConnect_Lean\Engine\DataFeeds\SubscriptionDataReader.cs,,The length of the parameter _subscriptionFactoryEnumerator is 30.
Long Identifier,QuantConnect.Lean.Engine.DataFeeds,SubscriptionDataReader,C:\repos\QuantConnect_Lean\Engine\DataFeeds\SubscriptionDataReader.cs,,The length of the parameter _lastInstanceBeforeAuxilliaryData is 33.
Long Identifier,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,,The length of the parameter _performCashSyncReentranceGuard is 31.
Long Statement,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,The length of the statement  "                .Where(x => x.Name == "OnData" && x.GetParameters().Length == 1 && x.GetParameters()[0].ParameterType == typeof (Slice)) " is 120.
Long Statement,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,The length of the statement  "                        algorithm.RunTimeError = new Exception("Data event handler not found' please create a function matching this template: public void OnData(" + config.Type.Name + " data) {  }"); " is 176.
Long Statement,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,The length of the statement  "                    Log.Error(string.Format("AlgorithmManager.Run(): Algorithm state changed to {0} at {1}"' _algorithm.Status' timeSlice.Time)); " is 125.
Long Statement,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,The length of the statement  "                            results.SamplePerformance(_previousTime.Date' Math.Round((algorithm.Portfolio.TotalPortfolioValue - portfolioValue) * 100 / portfolioValue' 10)); " is 145.
Long Statement,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,The length of the statement  "                    Log.Trace(string.Format("AlgorithmManager.Run(): Algorithm encountered a runtime error at {0}. Error: {1}"' timeSlice.Time' algorithm.RunTimeError)); " is 149.
Long Statement,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,The length of the statement  "                                algorithm.Error(string.Format("{0} - Executed MarginCallOrder: {1} - Quantity: {2} @ {3}"' algorithm.Time' ticket.Symbol' ticket.Quantity' ticket.AverageFillPrice)); " is 165.
Long Statement,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,The length of the statement  "                    if (hasOnDataTradeBars && timeSlice.Slice.Bars.Count > 0) methodInvokers[typeof(TradeBars)](algorithm' timeSlice.Slice.Bars); " is 125.
Long Statement,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,The length of the statement  "                    if (hasOnDataQuoteBars && timeSlice.Slice.QuoteBars.Count > 0) methodInvokers[typeof(QuoteBars)](algorithm' timeSlice.Slice.QuoteBars); " is 135.
Long Statement,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,The length of the statement  "                    if (hasOnDataOptionChains && timeSlice.Slice.OptionChains.Count > 0) methodInvokers[typeof(OptionChains)](algorithm' timeSlice.Slice.OptionChains); " is 147.
Long Statement,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Stream,The length of the statement  "                    Log.Trace(string.Format("AlgorithmManager.Stream(): WarmupHistoryRequest: {0}: Start: {1} End: {2} Resolution: {3}"' request.Symbol' request.StartTimeUtc' request.EndTimeUtc' request.Resolution)); " is 196.
Long Statement,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Stream,The length of the statement  "                        timeSlice = TimeSlice.Create(slice.Time.ConvertToUtc(timeZone)' timeZone' algorithm.Portfolio.CashBook' paired' SecurityChanges.None); " is 134.
Long Statement,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,ProcessVolatilityHistoryRequirements,The length of the statement  "            Log.Trace("AlgorithmManager.ProcessVolatilityHistoryRequirements(): Updating volatility models with historical data..."); " is 121.
Long Statement,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,EndTimeIsInNativeResolution,The length of the statement  "            var roundedDataPointEndTime = dataPointEndTime.RoundDownInTimeZone(config.Increment' config.ExchangeTimeZone' config.DataTimeZone); " is 131.
Long Statement,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The length of the statement  "                _algorithmHandlers.Results.Initialize(job' _systemHandlers.Notify' _systemHandlers.Api' _algorithmHandlers.DataFeed' _algorithmHandlers.Setup' _algorithmHandlers.Transactions); " is 176.
Long Statement,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The length of the statement  "                    _algorithmHandlers.DataFeed.Initialize(algorithm' job' _algorithmHandlers.Results' _algorithmHandlers.MapFileProvider' _algorithmHandlers.FactorFileProvider' _algorithmHandlers.DataProvider); " is 191.
Long Statement,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The length of the statement  "                    historyProvider.Initialize(job' _algorithmHandlers.DataProvider' historyDataCacheProvider' _algorithmHandlers.MapFileProvider' _algorithmHandlers.FactorFileProvider' progress => " is 177.
Long Statement,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The length of the statement  "                    initializeComplete = _algorithmHandlers.Setup.Setup(algorithm' brokerage' job' _algorithmHandlers.Results' _algorithmHandlers.Transactions' _algorithmHandlers.RealTime); " is 169.
Long Statement,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The length of the statement  "                    threadTransactions = new Thread(_algorithmHandlers.Transactions.Run) { IsBackground = true' Name = "Transaction Thread" }; " is 122.
Long Statement,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The length of the statement  "                    _algorithmHandlers.Results.DebugMessage(string.Format("Launching analysis for {0} with LEAN Engine v{1}"' job.AlgorithmId' Globals.Version)); " is 141.
Long Statement,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The length of the statement  "                        var complete = isolator.ExecuteWithTimeLimit(_algorithmHandlers.Setup.MaximumRuntime' algorithmManager.TimeLoopWithinLimits' () => " is 130.
Long Statement,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The length of the statement  "                                algorithmManager.Run(job' algorithm' _algorithmHandlers.DataFeed' _algorithmHandlers.Transactions' _algorithmHandlers.Results' _algorithmHandlers.RealTime' _systemHandlers.LeanManager' isolator.CancellationToken); " is 213.
Long Statement,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The length of the statement  "                                                (algorithm.Portfolio.TotalPortfolioValue - _algorithmHandlers.Setup.StartingPortfolioValue) / _algorithmHandlers.Setup.StartingPortfolioValue " is 141.
Long Statement,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The length of the statement  "                            string.Format("Algorithm Id:({0}) completed in {1} seconds at {2}k data points per second. Processing total of {3} data points."' " is 129.
Long Statement,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The length of the statement  "                        _algorithmHandlers.Results.SendFinalResult(job' orders' algorithm.Transactions.TransactionRecord' holdings' algorithm.Portfolio.CashBook' statisticsResults' banner); " is 165.
Long Statement,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The length of the statement  "                if (_liveMode && algorithmManager.State != AlgorithmStatus.Running && algorithmManager.State != AlgorithmStatus.RuntimeError) " is 125.
Long Statement,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,HandleAlgorithmError,The length of the statement  "                _systemHandlers.Api.SetAlgorithmStatus(job.AlgorithmId' AlgorithmStatus.RuntimeError' message + " Stack Trace: " + err); " is 120.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,ApiDataProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\ApiDataProvider.cs,Fetch,The length of the statement  "                Log.Trace("ApiDataProvider.Fetch(): Attempting to get data from QuantConnect.com's data library for symbol({0})' resolution({1}) and date({2})."' " is 145.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,BacktestingFutureChainProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\BacktestingFutureChainProvider.cs,GetFutureContractList,The length of the statement  "                throw new NotSupportedException($"BacktestingFutureChainProvider.GetFutureContractList(): SecurityType.Future is expected but was {symbol.SecurityType}"); " is 154.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,BacktestingFutureChainProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\BacktestingFutureChainProvider.cs,GetFutureContractList,The length of the statement  "            var zipFileName = LeanData.GenerateZipFilePath(Globals.DataFolder' symbol' date' Resolution.Minute' TickType.OpenInterest); " is 123.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,BacktestingOptionChainProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\BacktestingOptionChainProvider.cs,GetOptionContractList,The length of the statement  "                throw new NotSupportedException($"BacktestingOptionChainProvider.GetOptionContractList(): SecurityType.Equity is expected but was {symbol.SecurityType}"); " is 154.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,BacktestingOptionChainProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\BacktestingOptionChainProvider.cs,GetOptionContractList,The length of the statement  "            var canonicalSymbol = Symbol.CreateOption(symbol.Value' symbol.ID.Market' default(OptionStyle)' default(OptionRight)' 0' SecurityIdentifier.DefaultDate); " is 153.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,BacktestingOptionChainProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\BacktestingOptionChainProvider.cs,GetOptionContractList,The length of the statement  "            var zipFileName = LeanData.GenerateZipFilePath(Globals.DataFolder' canonicalSymbol' date' Resolution.Minute' TickType.OpenInterest); " is 132.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveOptionChainProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveOptionChainProvider.cs,GetOptionContractList,The length of the statement  "                throw new NotSupportedException($"LiveOptionChainProvider.GetOptionContractList(): SecurityType.Equity is expected but was {symbol.SecurityType}"); " is 147.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveOptionChainProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveOptionChainProvider.cs,FindOptionContracts,The length of the statement  "                        symbols.Add(Symbol.CreateOption(underlyingSymbol' Market.USA' OptionStyle.American' OptionRight.Call' strike' expiryDate)); " is 123.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveOptionChainProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveOptionChainProvider.cs,FindOptionContracts,The length of the statement  "                        symbols.Add(Symbol.CreateOption(underlyingSymbol' Market.USA' OptionStyle.American' OptionRight.Put' strike' expiryDate)); " is 122.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,TextSubscriptionDataSourceReader,C:\repos\QuantConnect_Lean\Engine\DataFeeds\TextSubscriptionDataSourceReader.cs,CreateStreamReader,The length of the statement  "                    throw new InvalidEnumArgumentException("Unexpected SubscriptionTransportMedium specified: " + subscriptionDataSource.TransportMedium); " is 134.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,Initialize,The length of the statement  "                                security = new Security(exchangeHours' config' _algorithm.Portfolio.CashBook[CashBook.AccountCurrency]' SymbolProperties.GetDefault(CashBook.AccountCurrency)); " is 159.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,Run,The length of the statement  "                            var collection = packet.Data[0] as BaseDataCollection ?? new BaseDataCollection(_frontierUtc' config.Symbol' packet.Data); " is 122.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,Run,The length of the statement  "                        _bridge.Add(TimeSlice.Create(_frontierUtc' _algorithm.TimeZone' _algorithm.Portfolio.CashBook' data' _changes)' _cancellationTokenSource.Token); " is 144.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,Run,The length of the statement  "                        TimeSlice.Create(nextEmit' _algorithm.TimeZone' _algorithm.Portfolio.CashBook' new List<DataFeedPacket>()' SecurityChanges.None)' " is 129.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,CreateSubscription,The length of the statement  "                var timeZoneOffsetProvider = new TimeZoneOffsetProvider(request.Security.Exchange.TimeZone' request.StartTimeUtc' request.EndTimeUtc); " is 134.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,CreateSubscription,The length of the statement  "                        if (SubscriptionShouldUpdateRealTimePrice(subscription' timeZoneOffsetProvider)) subscription.RealtimePrice = data.Value; " is 121.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,CreateSubscription,The length of the statement  "                            var quoteBarAggregator = new QuoteBarBuilderEnumerator(request.Configuration.Increment' request.Security.Exchange.TimeZone' _timeProvider); " is 139.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,CreateSubscription,The length of the statement  "                                    if (SubscriptionShouldUpdateRealTimePrice(subscription' timeZoneOffsetProvider)) subscription.RealtimePrice = data.Value; " is 121.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,CreateSubscription,The length of the statement  "                            var tradeBarAggregator = new TradeBarBuilderEnumerator(request.Configuration.Increment' request.Security.Exchange.TimeZone' _timeProvider); " is 139.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,CreateSubscription,The length of the statement  "                                    if (SubscriptionShouldUpdateRealTimePrice(subscription' timeZoneOffsetProvider)) subscription.RealtimePrice = data.Value; " is 121.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,CreateSubscription,The length of the statement  "                            var oiAggregator = new OpenInterestEnumerator(request.Configuration.Increment' request.Security.Exchange.TimeZone' _timeProvider); " is 130.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,CreateSubscription,The length of the statement  "                        if (SubscriptionShouldUpdateRealTimePrice(subscription' timeZoneOffsetProvider)) subscription.RealtimePrice = data.Value; " is 121.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,CreateSubscription,The length of the statement  "                    enumerator = new LiveFillForwardEnumerator(_frontierTimeProvider' enumerator' request.Security.Exchange' _fillForwardResolution' request.Configuration.ExtendedMarketHours' localEndTime' request.Configuration.Increment' request.Configuration.DataTimeZone); " is 255.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,CreateSubscription,The length of the statement  "                // finally' make our subscriptions aware of the frontier of the data feed' prevents future data from spewing into the feed " is 122.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,CreateSubscription,The length of the statement  "                subscription = new Subscription(request.Universe' request.Security' request.Configuration' enumerator' timeZoneOffsetProvider' request.StartTimeUtc' request.EndTimeUtc' false); " is 176.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,CreateUniverseSubscription,The length of the statement  "            var tzOffsetProvider = new TimeZoneOffsetProvider(request.Security.Exchange.TimeZone' request.StartTimeUtc' request.EndTimeUtc); " is 128.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,CreateUniverseSubscription,The length of the statement  "                Log.Trace("LiveTradingDataFeed.CreateUniverseSubscription(): Creating user defined universe: " + config.Symbol.ToString()); " is 123.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,CreateUniverseSubscription,The length of the statement  "                var enumeratorFactory = new UserDefinedUniverseSubscriptionEnumeratorFactory(userDefined' MarketHoursDatabase.FromDataFolder()); " is 128.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,CreateUniverseSubscription,The length of the statement  "                Log.Trace("LiveTradingDataFeed.CreateUniverseSubscription(): Creating option chain universe: " + config.Symbol.ToString()); " is 123.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,CreateUniverseSubscription,The length of the statement  "                    return new LiveFillForwardEnumerator(_frontierTimeProvider' input' request.Security.Exchange' _fillForwardResolution' request.Configuration.ExtendedMarketHours' localEndTime' request.Configuration.Increment' request.Configuration.DataTimeZone); " is 244.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,CreateUniverseSubscription,The length of the statement  "                Log.Trace("LiveTradingDataFeed.CreateUniverseSubscription(): Creating futures chain universe: " + config.Symbol.ToString()); " is 124.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,CreateUniverseSubscription,The length of the statement  "            var subscription = new Subscription(request.Universe' request.Security' config' enumerator' tzOffsetProvider' request.StartTimeUtc' request.EndTimeUtc' true); " is 158.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,SubscriptionSynchronizer,C:\repos\QuantConnect_Lean\Engine\DataFeeds\SubscriptionSynchronizer.cs,Sync,The length of the statement  "                        clone.Time = clone.Time.ExchangeRoundDownInTimeZone(configuration.Increment' subscription.Security.Exchange.Hours' configuration.DataTimeZone' configuration.ExtendedMarketHours); " is 178.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,SubscriptionSynchronizer,C:\repos\QuantConnect_Lean\Engine\DataFeeds\SubscriptionSynchronizer.cs,Sync,The length of the statement  "                                collection = new OptionChainUniverseDataCollection(frontier' subscription.Configuration.Symbol' packetData' underlying); " is 120.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,SubscriptionSynchronizer,C:\repos\QuantConnect_Lean\Engine\DataFeeds\SubscriptionSynchronizer.cs,Sync,The length of the statement  "                        earlyBirdTicks = Math.Min(earlyBirdTicks' Math.Min(subscription.Current.EndTime.Ticks - currentOffsetTicks' offsetProvider.GetNextDiscontinuity())); " is 148.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,SubscriptionDataReader,C:\repos\QuantConnect_Lean\Engine\DataFeeds\SubscriptionDataReader.cs,ResolveDataEnumerator,The length of the statement  "                var liveRemoteFile = _isLiveMode && (_source == null || _source.TransportMedium == SubscriptionTransportMedium.RemoteFile); " is 123.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,SubscriptionDataReader,C:\repos\QuantConnect_Lean\Engine\DataFeeds\SubscriptionDataReader.cs,CreateSubscriptionFactory,The length of the statement  "            var factory = SubscriptionDataSourceReader.ForSource(source' _dataCacheProvider' _config' _tradeableDates.Current' _isLiveMode); " is 128.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,SubscriptionDataReader,C:\repos\QuantConnect_Lean\Engine\DataFeeds\SubscriptionDataReader.cs,AttachEventHandlers,The length of the statement  "                        _resultHandler.ErrorMessage(string.Format("Error downloading custom data source file' skipped: {0} Error: {1}"' source' args.Exception.Message)' args.Exception.StackTrace); " is 172.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,SubscriptionDataReader,C:\repos\QuantConnect_Lean\Engine\DataFeeds\SubscriptionDataReader.cs,AttachEventHandlers,The length of the statement  "                    //Log.Error(string.Format("Failed to get StreamReader for data source({0})' symbol({1}). Skipping date({2}). Reader is null."' args.Source.Source' _mappedSymbol' args.Date.ToShortDateString())); " is 194.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,SubscriptionDataReader,C:\repos\QuantConnect_Lean\Engine\DataFeeds\SubscriptionDataReader.cs,AttachEventHandlers,The length of the statement  "                        _resultHandler.ErrorMessage(string.Format("We could not fetch the requested data. This may not be valid data' or a failed download of custom data. Skipping source ({0})."' args.Source.Source)); " is 193.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,SubscriptionDataReader,C:\repos\QuantConnect_Lean\Engine\DataFeeds\SubscriptionDataReader.cs,AttachEventHandlers,The length of the statement  "                    _resultHandler.RuntimeError(string.Format("Error invoking {0} data reader. Line: {1} Error: {2}"' _config.Symbol' args.Line' args.Exception.Message)' args.Exception.StackTrace); " is 177.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,TimeSlice,C:\repos\QuantConnect_Lean\Engine\DataFeeds\TimeSlice.cs,Create,The length of the statement  "                    consolidator.Add(new UpdateData<SubscriptionDataConfig>(packet.Configuration' packet.Configuration.Type' consolidatorUpdate)); " is 126.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,TimeSlice,C:\repos\QuantConnect_Lean\Engine\DataFeeds\TimeSlice.cs,Create,The length of the statement  "            slice = new Slice(algorithmTime' allDataForAlgorithm' tradeBars' quoteBars' ticks' optionChains' futuresChains' splits' dividends' delistings' symbolChanges' allDataForAlgorithm.Count > 0); " is 189.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,TimeSlice,C:\repos\QuantConnect_Lean\Engine\DataFeeds\TimeSlice.cs,HandleOptionData,The length of the statement  "            var canonical = Symbol.CreateOption(symbol.Underlying' symbol.ID.Market' default(OptionStyle)' default(OptionRight)' 0' SecurityIdentifier.DefaultDate); " is 152.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,UniverseSelection,C:\repos\QuantConnect_Lean\Engine\DataFeeds\UniverseSelection.cs,ApplyUniverseSelection,The length of the statement  "                    var symbolProperties = _symbolPropertiesDatabase.GetSymbolProperties(symbol.ID.Market' symbol' symbol.ID.SecurityType' CashBook.AccountCurrency); " is 145.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,UniverseSelection,C:\repos\QuantConnect_Lean\Engine\DataFeeds\UniverseSelection.cs,ApplyUniverseSelection,The length of the statement  "                    var request = new SubscriptionRequest(true' universe' security' new SubscriptionDataConfig(config)' dateTimeUtc' dateTimeUtc); " is 126.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,UniverseSelection,C:\repos\QuantConnect_Lean\Engine\DataFeeds\UniverseSelection.cs,ApplyUniverseSelection,The length of the statement  "                var addedSecurities = _algorithm.Portfolio.CashBook.EnsureCurrencyDataFeeds(_algorithm.Securities' _algorithm.SubscriptionManager' _marketHoursDatabase' _symbolPropertiesDatabase' _algorithm.BrokerageModel.DefaultMarkets); " is 222.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,UniverseSelection,C:\repos\QuantConnect_Lean\Engine\DataFeeds\UniverseSelection.cs,ApplyUniverseSelection,The length of the statement  "                    _dataFeed.AddSubscription(new SubscriptionRequest(false' universe' security' new SubscriptionDataConfig(security.Subscriptions.First())' dateTimeUtc' algorithmEndDateUtc)); " is 172.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,ZipDataCacheProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\ZipDataCacheProvider.cs,Fetch,The length of the statement  "                                    Log.Error("ZipDataCacheProvider.Fetch(): Corrupt zip file/entry: " + filename + "#" + entryName + " Error: " + exception); " is 122.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,ZipDataCacheProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\ZipDataCacheProvider.cs,Fetch,The length of the statement  "                                Log.Error("ZipDataCacheProvider.Fetch(): Corrupt zip file/entry: " + filename + "#" + entryName + " Error: " + exception); " is 122.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,ZipDataCacheProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\ZipDataCacheProvider.cs,CreateStream,The length of the statement  "            var entry = zipFile.Entries.FirstOrDefault(x => entryName == null || string.Compare(x.FileName' entryName' StringComparison.OrdinalIgnoreCase) == 0); " is 149.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,Initialize,The length of the statement  "            _subscriptionfactory = new SubscriptionDataReaderSubscriptionEnumeratorFactory(_resultHandler' _mapFileProvider' _factorFileProvider' _dataProvider' false' true); " is 162.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,Initialize,The length of the statement  "                                security = new Security(exchangeHours' config' _algorithm.Portfolio.CashBook[CashBook.AccountCurrency]' SymbolProperties.GetDefault(CashBook.AccountCurrency)); " is 159.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,CreateSubscription,The length of the statement  "                _algorithm.Error(string.Format("No data loaded for {0} because there were no tradeable dates for this security."' request.Security.Symbol)); " is 140.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,CreateSubscription,The length of the statement  "            ScheduleEnumerator(enumerator' enqueueable' GetLowerThreshold(request.Configuration.Resolution)' GetUpperThreshold(request.Configuration.Resolution)); " is 150.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,CreateSubscription,The length of the statement  "            var timeZoneOffsetProvider = new TimeZoneOffsetProvider(request.Security.Exchange.TimeZone' request.StartTimeUtc' request.EndTimeUtc); " is 134.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,CreateSubscription,The length of the statement  "            var subscription = new Subscription(request.Universe' request.Security' request.Configuration' enqueueable' timeZoneOffsetProvider' request.StartTimeUtc' request.EndTimeUtc' false); " is 181.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,AddSubscription,The length of the statement  "            Log.Debug("FileSystemDataFeed.AddSubscription(): Added " + request.Configuration + " Start: " + request.StartTimeUtc + " End: " + request.EndTimeUtc); " is 150.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,CreateUniverseSubscription,The length of the statement  "            var timeZoneOffsetProvider = new TimeZoneOffsetProvider(request.Security.Exchange.TimeZone' request.StartTimeUtc' request.EndTimeUtc); " is 134.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,CreateUniverseSubscription,The length of the statement  "            return new Subscription(request.Universe' request.Security' config' enumerator' timeZoneOffsetProvider' request.StartTimeUtc' request.EndTimeUtc' true); " is 152.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,GetEnumeratorFactory,The length of the statement  "                    return new UserDefinedUniverseSubscriptionEnumeratorFactory(request.Universe as UserDefinedUniverse' MarketHoursDatabase.FromDataFolder()); " is 139.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,GetEnumerator,The length of the statement  "                Log.Debug(string.Format("FileSystemDataFeed.GetEnumerator(): Finished subscription: {0} at {1} UTC"' subscription.Configuration' _frontierUtc)); " is 144.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,GetEnumerator,The length of the statement  "                    timeSlice = syncer.Sync(_frontierUtc' Subscriptions' _algorithm.TimeZone' _algorithm.Portfolio.CashBook' out nextFrontier); " is 123.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,ConfigureEnumerator,The length of the statement  "                    request.Security.IsExtendedMarketHours' request.EndTimeLocal' request.Configuration.Resolution.ToTimeSpan()' request.Configuration.DataTimeZone); " is 145.
Long Statement,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,ConfigureEnumerator,The length of the statement  "                enumerator = SubscriptionFilterEnumerator.WrapForDataFeed(_resultHandler' enumerator' request.Security' request.EndTimeLocal); " is 126.
Long Statement,QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories,LiveCustomDataSubscriptionEnumeratorFactory,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\Factories\LiveCustomDataSubscriptionEnumeratorFactory.cs,CreateEnumerator,The length of the statement  "            var timeZoneOffsetProvider = new TimeZoneOffsetProvider(request.Security.Exchange.TimeZone' request.StartTimeUtc' request.EndTimeUtc); " is 134.
Long Statement,QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories,BaseDataSubscriptionEnumeratorFactory,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\Factories\BaseDataSubscriptionEnumeratorFactory.cs,CreateEnumerator,The length of the statement  "            var sourceFactory = (BaseData)ObjectActivator.GetActivator(request.Configuration.Type).Invoke(new object[] { request.Configuration.Type }); " is 139.
Long Statement,QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories,BaseDataSubscriptionEnumeratorFactory,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\Factories\BaseDataSubscriptionEnumeratorFactory.cs,CreateEnumerator,The length of the statement  "                var factory = SubscriptionDataSourceReader.ForSource(source' _dataCacheProvider' request.Configuration' date' _isLiveMode); " is 123.
Long Statement,QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories,FineFundamentalSubscriptionEnumeratorFactory,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\Factories\FineFundamentalSubscriptionEnumeratorFactory.cs,CreateEnumerator,The length of the statement  "            var fineFundamentalConfiguration = new SubscriptionDataConfig(request.Configuration' typeof(FineFundamental)' request.Security.Symbol); " is 135.
Long Statement,QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories,FineFundamentalSubscriptionEnumeratorFactory,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\Factories\FineFundamentalSubscriptionEnumeratorFactory.cs,CreateEnumerator,The length of the statement  "                let fineFundamentalFactory = SubscriptionDataSourceReader.ForSource(fineFundamentalSource' _dataCacheProvider' fineFundamentalConfiguration' date' _isLiveMode) " is 159.
Long Statement,QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories,FineFundamentalSubscriptionEnumeratorFactory,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\Factories\FineFundamentalSubscriptionEnumeratorFactory.cs,CreateEnumerator,The length of the statement  "                    SecurityReference = fineFundamentalForDate != null ? fineFundamentalForDate.SecurityReference : new SecurityReference()' " is 120.
Long Statement,QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories,FineFundamentalSubscriptionEnumeratorFactory,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\Factories\FineFundamentalSubscriptionEnumeratorFactory.cs,CreateEnumerator,The length of the statement  "                    FinancialStatements = fineFundamentalForDate != null ? fineFundamentalForDate.FinancialStatements : new FinancialStatements()' " is 126.
Long Statement,QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories,FuturesChainUniverseSubscriptionEnumeratorFactory,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\Factories\FuturesChainUniverseSubscriptionEnumeratorFactory.cs,CreateEnumerator,The length of the statement  "                var underlyingEnumerator = new TradeBarBuilderEnumerator(request.Configuration.Increment' request.Security.Exchange.TimeZone' _timeProvider); " is 141.
Long Statement,QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories,FuturesChainUniverseSubscriptionEnumeratorFactory,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\Factories\FuturesChainUniverseSubscriptionEnumeratorFactory.cs,CreateEnumerator,The length of the statement  "                return new DataQueueFuturesChainUniverseDataCollectionEnumerator(request.Security.Symbol' configuredEnumerator' zipEntries); " is 124.
Long Statement,QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories,OptionChainUniverseSubscriptionEnumeratorFactory,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\Factories\OptionChainUniverseSubscriptionEnumeratorFactory.cs,CreateEnumerator,The length of the statement  "                var underlyingEnumerator = new TradeBarBuilderEnumerator(request.Configuration.Increment' request.Security.Exchange.TimeZone' _timeProvider); " is 141.
Long Statement,QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories,OptionChainUniverseSubscriptionEnumeratorFactory,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\Factories\OptionChainUniverseSubscriptionEnumeratorFactory.cs,CreateEnumerator,The length of the statement  "                return new DataQueueOptionChainUniverseDataCollectionEnumerator(request.Security.Symbol' configuredEnumerator' zipEntries); " is 123.
Long Statement,QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories,OptionChainUniverseSubscriptionEnumeratorFactory,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\Factories\OptionChainUniverseSubscriptionEnumeratorFactory.cs,GetSubscriptionConfigurations,The length of the statement  "                new SubscriptionDataConfig(config' resolution: resolution' fillForward: true' symbol: underlying' objectType: typeof (TradeBar)' tickType: TickType.Trade)' " is 155.
Long Statement,QuantConnect.Lean.Engine.DataFeeds.Enumerators,FillForwardEnumerator,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\FillForwardEnumerator.cs,RequiresFillForwardData,The length of the statement  "            // 3. the next fill forward bar following the next market open' 15:00-16:00 followed by 09:00-10:00 the following open market day " is 129.
Long Statement,QuantConnect.Lean.Engine.DataFeeds.Enumerators,SubscriptionFilterEnumerator,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\SubscriptionFilterEnumerator.cs,WrapForDataFeed,The length of the statement  "                resultHandler.RuntimeError("Runtime error applying data filter. Assuming filter pass: " + exception.Message' exception.StackTrace); " is 131.
Long Statement,QuantConnect.Lean.Engine.DataFeeds.Enumerators,SubscriptionFilterEnumerator,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\SubscriptionFilterEnumerator.cs,MoveNext,The length of the statement  "                    if (current.DataType != MarketDataType.Auxiliary && !_exchange.IsOpenDuringBar(current.Time' current.EndTime' _security.IsExtendedMarketHours)) " is 143.
Long Statement,QuantConnect.Lean.Engine.Results,DesktopResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\DesktopResultHandler.cs,OrderEvent,The length of the statement  "            DebugMessage("DesktopResultHandler.OrderEvent(): id:" + newEvent.OrderId + " >> Status:" + newEvent.Status + " >> Fill Price: " + newEvent.FillPrice.ToString("C") + " >> Fill Quantity: " + newEvent.FillQuantity); " is 212.
Long Statement,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,Update,The length of the statement  "                runtimeStatistics.Add("Net Profit"' "$" + (_algorithm.Portfolio.TotalProfit - _algorithm.Portfolio.TotalFees).ToString("N2")); " is 126.
Long Statement,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,Update,The length of the statement  "                runtimeStatistics.Add("Return"' ((_algorithm.Portfolio.TotalPortfolioValue - _setupHandler.StartingPortfolioValue) / _setupHandler.StartingPortfolioValue).ToString("P")); " is 170.
Long Statement,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,Update,The length of the statement  "                var completeResult = new BacktestResult(Charts' _transactionHandler.Orders' Algorithm.Transactions.TransactionRecord' new Dictionary<string' string>()' runtimeStatistics' new Dictionary<string' AlgorithmPerformance>()); " is 219.
Long Statement,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,SplitPackets,The length of the statement  "            splitPackets.Add(new BacktestResultPacket(_job' new BacktestResult { RuntimeStatistics = runtimeStatistics }' progress)); " is 121.
Long Statement,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,SendFinalResult,The length of the statement  "                    new BacktestResult(charts' orders' profitLoss' statisticsResults.Summary' banner' statisticsResults.RollingPerformances' statisticsResults.TotalPerformance) " is 156.
Long Statement,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,SetAlgorithm,The length of the statement  "            var resampleMinutes = (totalMinutes < (_minimumSamplePeriod * _samples)) ? _minimumSamplePeriod : (totalMinutes / _samples); // Space out the sampling every " is 156.
Long Statement,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Update,The length of the statement  "            if (_algorithm == null || _algorithm.Transactions == null || _transactionHandler.Orders == null || !_algorithm.GetLocked()) " is 123.
Long Statement,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Update,The length of the statement  "                    foreach (var asset in _algorithm.Securities.Values.Where(x => !x.IsInternalFeed() && !x.Symbol.IsCanonical()).OrderBy(x => x.Symbol.Value)) " is 139.
Long Statement,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Update,The length of the statement  "                                    (_algorithm.Portfolio.TotalPortfolioValue - _setupHandler.StartingPortfolioValue) / _setupHandler.StartingPortfolioValue " is 120.
Long Statement,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Update,The length of the statement  "                    runtimeStatistics.Add("Net Profit:"' "$" + (_algorithm.Portfolio.TotalProfit - _algorithm.Portfolio.TotalFees).ToString("N2")); " is 127.
Long Statement,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Update,The length of the statement  "                    var splitPackets = SplitPackets(deltaCharts' deltaOrders' holdings' _algorithm.Portfolio.CashBook' deltaStatistics' runtimeStatistics' serverStatistics); " is 153.
Long Statement,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Update,The length of the statement  "                        var complete = new LiveResultPacket(_job' new LiveResult(chartComplete' orders' _algorithm.Transactions.TransactionRecord' holdings' _algorithm.Portfolio.CashBook' deltaStatistics' runtimeStatistics' serverStatistics)); " is 219.
Long Statement,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Update,The length of the statement  "                    // Upload the logs every 1-2 minutes; this can be a heavy operation depending on amount of live logging and should probably be done asynchronously. " is 147.
Long Statement,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,SendFinalResult,The length of the statement  "                var result = new LiveResultPacket((LiveNodePacket)job' new LiveResult(charts' orders' profitLoss' holdings' cashbook' statisticsResults.Summary' runtime)); " is 155.
Long Statement,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Truncate,The length of the statement  "            //Log.Trace("LiveTradingResultHandler.Truncate: Truncate Delta: " + (unixDateStop - unixDateStart) + " Incoming Points: " + result.Charts["Strategy Equity"].Series["Equity"].Values.Count); " is 188.
Long Statement,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Truncate,The length of the statement  "                    newSeries.Values.AddRange(series.Values.Where(chartPoint => chartPoint.x >= unixDateStart && chartPoint.x <= unixDateStop)); " is 124.
Long Statement,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Truncate,The length of the statement  "            //Log.Trace("LiveTradingResultHandler.Truncate: Truncate Outgoing: " + result.Charts["Strategy Equity"].Series["Equity"].Values.Count); " is 135.
Long Statement,QuantConnect.Lean.Engine.HistoricalData,BrokerageHistoryProvider,C:\repos\QuantConnect_Lean\Engine\HistoricalData\BrokerageHistoryProvider.cs,CreateSubscription,The length of the statement  "            var security = new Security(request.ExchangeHours' config' new Cash(CashBook.AccountCurrency' 0' 1m)' SymbolProperties.GetDefault(CashBook.AccountCurrency)); " is 157.
Long Statement,QuantConnect.Lean.Engine.HistoricalData,BrokerageHistoryProvider,C:\repos\QuantConnect_Lean\Engine\HistoricalData\BrokerageHistoryProvider.cs,CreateSubscription,The length of the statement  "                reader = new FillForwardEnumerator(reader' security.Exchange' readOnlyRef' security.IsExtendedMarketHours' end' config.Increment' config.DataTimeZone); " is 151.
Long Statement,QuantConnect.Lean.Engine.HistoricalData,SubscriptionDataReaderHistoryProvider,C:\repos\QuantConnect_Lean\Engine\HistoricalData\SubscriptionDataReaderHistoryProvider.cs,CreateSubscription,The length of the statement  "            var security = new Security(request.ExchangeHours' config' new Cash(CashBook.AccountCurrency' 0' 1m)' SymbolProperties.GetDefault(CashBook.AccountCurrency)); " is 157.
Long Statement,QuantConnect.Lean.Engine.HistoricalData,SubscriptionDataReaderHistoryProvider,C:\repos\QuantConnect_Lean\Engine\HistoricalData\SubscriptionDataReaderHistoryProvider.cs,CreateSubscription,The length of the statement  "                reader = new FillForwardEnumerator(reader' security.Exchange' readOnlyRef' security.IsExtendedMarketHours' end' config.Increment' config.DataTimeZone); " is 151.
Long Statement,QuantConnect.Lean.Engine.HistoricalData,SynchronizingHistoryProvider,C:\repos\QuantConnect_Lean\Engine\HistoricalData\SynchronizingHistoryProvider.cs,CreateSliceEnumerableFromSubscriptions,The length of the statement  "                        var nextDataOrDiscontinuity = Math.Min(subscription.Current.EndTime.Ticks - currentOffsetTicks' offsetProvider.GetNextDiscontinuity()); " is 135.
Long Statement,QuantConnect.Lean.Engine.RealTime,LiveTradingRealTimeHandler,C:\repos\QuantConnect_Lean\Engine\RealTime\LiveTradingRealTimeHandler.cs,Setup,The length of the statement  "            Add(ScheduledEventFactory.EveryAlgorithmEndOfDay(_algorithm' _resultHandler' todayInAlgorithmTimeZone' Time.EndOfTime' ScheduledEvent.AlgorithmEndOfDayDelta' DateTime.UtcNow)); " is 176.
Long Statement,QuantConnect.Lean.Engine.RealTime,LiveTradingRealTimeHandler,C:\repos\QuantConnect_Lean\Engine\RealTime\LiveTradingRealTimeHandler.cs,Setup,The length of the statement  "                Add(ScheduledEventFactory.EverySecurityEndOfDay(_algorithm' _resultHandler' security' todayInAlgorithmTimeZone' Time.EndOfTime' ScheduledEvent.SecurityEndOfDayDelta' DateTime.UtcNow)); " is 184.
Long Statement,QuantConnect.Lean.Engine.RealTime,LiveTradingRealTimeHandler,C:\repos\QuantConnect_Lean\Engine\RealTime\LiveTradingRealTimeHandler.cs,Run,The length of the statement  "                        var errorMessage = $"LiveTradingRealTimeHandler.Run(): There was an error in a scheduled event {scheduledEvent.Key}. The error was {scheduledEventException.ScheduledEventExceptionMessage}"; " is 189.
Long Statement,QuantConnect.Lean.Engine.RealTime,LiveTradingRealTimeHandler,C:\repos\QuantConnect_Lean\Engine\RealTime\LiveTradingRealTimeHandler.cs,Run,The length of the statement  "            Log.Trace("LiveTradingRealTimeHandler.Run(): Exiting thread... Exit triggered: " + _cancellationTokenSource.IsCancellationRequested); " is 133.
Long Statement,QuantConnect.Lean.Engine.RealTime,LiveTradingRealTimeHandler,C:\repos\QuantConnect_Lean\Engine\RealTime\LiveTradingRealTimeHandler.cs,RefreshMarketHoursToday,The length of the statement  "                Log.Trace(string.Format("LiveTradingRealTimeHandler.RefreshMarketHoursToday({0}): Market hours set: Symbol: {1} {2} ({3})"' " is 123.
Long Statement,QuantConnect.Lean.Engine.RealTime,BacktestingRealTimeHandler,C:\repos\QuantConnect_Lean\Engine\RealTime\BacktestingRealTimeHandler.cs,Setup,The length of the statement  "            Add(ScheduledEventFactory.EveryAlgorithmEndOfDay(_algorithm' _resultHandler' _algorithm.StartDate' _algorithm.EndDate' ScheduledEvent.AlgorithmEndOfDayDelta)); " is 159.
Long Statement,QuantConnect.Lean.Engine.RealTime,BacktestingRealTimeHandler,C:\repos\QuantConnect_Lean\Engine\RealTime\BacktestingRealTimeHandler.cs,Setup,The length of the statement  "                Add(ScheduledEventFactory.EverySecurityEndOfDay(_algorithm' _resultHandler' security' algorithm.StartDate' _algorithm.EndDate' ScheduledEvent.SecurityEndOfDayDelta)); " is 166.
Long Statement,QuantConnect.Lean.Engine.RealTime,BacktestingRealTimeHandler,C:\repos\QuantConnect_Lean\Engine\RealTime\BacktestingRealTimeHandler.cs,ScanPastEvents,The length of the statement  "                        var errorMessage = $"BacktestingRealTimeHandler.Run(): There was an error in a scheduled event {scheduledEvent.Key}. The error was {scheduledEventException.ScheduledEventExceptionMessage}"; " is 189.
Long Statement,QuantConnect.Lean.Engine.Setup,BrokerageSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BrokerageSetupHandler.cs,CreateAlgorithmInstance,The length of the statement  "            var loader = new Loader(algorithmNodePacket.Language' TimeSpan.FromSeconds(15)' names => names.SingleOrAlgorithmTypeName(Config.Get("algorithm-type-name"))); " is 157.
Long Statement,QuantConnect.Lean.Engine.Setup,BrokerageSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BrokerageSetupHandler.cs,CreateAlgorithmInstance,The length of the statement  "            var complete = loader.TryCreateAlgorithmInstanceWithIsolator(assemblyPath' algorithmNodePacket.RamAllocation' out algorithm' out error); " is 136.
Long Statement,QuantConnect.Lean.Engine.Setup,BrokerageSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BrokerageSetupHandler.cs,CreateAlgorithmInstance,The length of the statement  "            if (!complete) throw new Exception(error + " Try re-building algorithm and remove duplicate QCAlgorithm base classes."); " is 120.
Long Statement,QuantConnect.Lean.Engine.Setup,BrokerageSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BrokerageSetupHandler.cs,CreateBrokerage,The length of the statement  "            _factory = Composer.Instance.Single<IBrokerageFactory>(brokerageFactory => brokerageFactory.BrokerageType.MatchesTypeName(liveJob.Brokerage)); " is 142.
Long Statement,QuantConnect.Lean.Engine.Setup,BrokerageSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BrokerageSetupHandler.cs,Setup,The length of the statement  "                        SecurityType.Equity' SecurityType.Forex' SecurityType.Cfd' SecurityType.Option' SecurityType.Future' SecurityType.Crypto " is 120.
Long Statement,QuantConnect.Lean.Engine.Setup,BrokerageSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BrokerageSetupHandler.cs,Setup,The length of the statement  "                    var minResolution = new Lazy<Resolution>(() => algorithm.Securities.Select(x => x.Value.Resolution).DefaultIfEmpty(Resolution.Second).Min()); " is 141.
Long Statement,QuantConnect.Lean.Engine.Setup,BrokerageSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BrokerageSetupHandler.cs,GetOpenOrders,The length of the statement  "                resultHandler.DebugMessage($"BrokerageSetupHandler.Setup(): Open order detected.  Creating order tickets for open order {order.Symbol.Value} with quantity {order.Quantity}. Beware that this order ticket may not accurately reflect the quantity of the order if the open order is partially filled."); " is 297.
Long Statement,QuantConnect.Lean.Engine.Setup,ConsoleSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\ConsoleSetupHandler.cs,CreateAlgorithmInstance,The length of the statement  "            var loader = new Loader(algorithmNodePacket.Language' TimeSpan.FromHours(1)' names => names.SingleOrDefault(name => MatchTypeName(name' algorithmName))); " is 153.
Long Statement,QuantConnect.Lean.Engine.Setup,ConsoleSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\ConsoleSetupHandler.cs,CreateAlgorithmInstance,The length of the statement  "            var complete = loader.TryCreateAlgorithmInstanceWithIsolator(assemblyPath' algorithmNodePacket.RamAllocation' out algorithm' out error); " is 136.
Long Statement,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,CreateAlgorithmInstance,The length of the statement  "            var loader = new Loader(algorithmNodePacket.Language' TimeSpan.FromSeconds(60)' names => names.SingleOrAlgorithmTypeName(Config.Get("algorithm-type-name"))); " is 157.
Long Statement,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,CreateAlgorithmInstance,The length of the statement  "            var complete = loader.TryCreateAlgorithmInstanceWithIsolator(assemblyPath' algorithmNodePacket.RamAllocation' out algorithm' out error); " is 136.
Long Statement,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,Setup,The length of the statement  "            Log.Trace(string.Format("BacktestingSetupHandler.Setup(): Setting up job: Plan: {0}' UID: {1}' PID: {2}' Version: {3}' Source: {4}"' job.UserPlan' job.UserId' job.ProjectId' job.Version' job.RequestSource)); " is 207.
Long Statement,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,Setup,The length of the statement  "            _maxRuntime = GetMaximumRuntime(job.PeriodStart' job.PeriodFinish' algorithm.SubscriptionManager' algorithm.UniverseManager' baseJob.Controls); " is 143.
Long Statement,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,Setup,The length of the statement  "            Log.Trace("Dates: Start: " + job.PeriodStart.ToShortDateString() + " End: " + job.PeriodFinish.ToShortDateString() + " Cash: " + _startingCaptial.ToString("C")); " is 161.
Long Statement,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,GetMaximumRuntime,The length of the statement  "            Log.Trace("BacktestingSetupHandler.GetMaxRunTime(): Job Days: " + jobDays + " Max Runtime: " + Math.Round(maxRunTime / 60) + " min"); " is 133.
Long Statement,QuantConnect.Lean.Engine.TransactionHandlers,BacktestingTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BacktestingTransactionHandler.cs,Initialize,The length of the statement  "                throw new ArgumentException("Brokerage must be of type BacktestingBrokerage for use wth the BacktestingTransactionHandler"); " is 124.
Long Statement,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,CancelOrder,The length of the statement  "                    request.SetResponse(OrderResponse.Error(request' OrderResponseErrorCode.InvalidRequest' "Cancellation is already in progress.")); " is 129.
Long Statement,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,ProcessSynchronousEvents,The length of the statement  "                if (_orderRequestQueue.IsBusy && !_orderRequestQueue.WaitHandle.WaitOne(Time.OneSecond' _cancellationTokenSource.Token)) " is 120.
Long Statement,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,ProcessSynchronousEvents,The length of the statement  "                    Log.Error("BrokerageTransactionHandler.ProcessSynchronousEvents(): Timed out waiting for request queue to finish processing."); " is 127.
Long Statement,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,PerformCashSync,The length of the statement  "                        Log.LogHandler.Trace("BrokerageTransactionHandler.PerformCashSync(): Unexpected cash found {0} {1}"' balance.Amount' balance.Symbol); " is 133.
Long Statement,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,HandleSubmitOrderRequest,The length of the statement  "                return OrderResponse.Error(request' OrderResponseErrorCode.OrderAlreadyExists' "Cannot process submit request because order with id {0} already exists"); " is 153.
Long Statement,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,HandleSubmitOrderRequest,The length of the statement  "                Log.Error("BrokerageTransactionHandler.HandleSubmitOrderRequest(): Unable to retrieve order ticket' order not processed."); " is 123.
Long Statement,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,HandleSubmitOrderRequest,The length of the statement  "                var response = OrderResponse.Error(request' OrderResponseErrorCode.InsufficientBuyingPower' string.Format("Order Error: id: {0}' Insufficient buying power to complete order (Value:{1})."' order.Id' order.GetValue(security).SmartRounding())); " is 241.
Long Statement,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,HandleSubmitOrderRequest,The length of the statement  "                if (message == null) message = new BrokerageMessageEvent(BrokerageMessageType.Warning' "InvalidOrder"' "BrokerageModel declared unable to submit order: " + order.Id); " is 166.
Long Statement,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,HandleSubmitOrderRequest,The length of the statement  "                var response = OrderResponse.Error(request' OrderResponseErrorCode.BrokerageModelRefusedToSubmitOrder' "OrderID: " + order.Id + " " + message); " is 143.
Long Statement,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,HandleUpdateOrderRequest,The length of the statement  "            if (!_algorithm.LiveMode && !_algorithm.BrokerageModel.CanUpdateOrder(_algorithm.Securities[order.Symbol]' order' request' out message)) " is 136.
Long Statement,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,HandleUpdateOrderRequest,The length of the statement  "                if (message == null) message = new BrokerageMessageEvent(BrokerageMessageType.Warning' "InvalidOrder"' "BrokerageModel declared unable to update order: " + order.Id); " is 166.
Long Statement,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,HandleUpdateOrderRequest,The length of the statement  "                var response = OrderResponse.Error(request' OrderResponseErrorCode.BrokerageModelRefusedToUpdateOrder' "OrderID: " + order.Id + " " + message); " is 143.
Long Statement,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,HandleCancelOrderRequest,The length of the statement  "                Log.Error("BrokerageTransactionHandler.HandleCancelOrderRequest(): Unable to cancel order with ID " + request.OrderId + "."); " is 125.
Long Statement,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,HandleOrderEvent,The length of the statement  "                //    Log.Error(string.Format("Currency mismatch: Fill currency: {0}' Symbol currency: {1}"' fill.FillPriceCurrency' security.SymbolProperties.QuoteCurrency)); " is 159.
Long Statement,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,HandleOrderEvent,The length of the statement  "                //    Log.Error(string.Format("Currency mismatch: Order currency: {0}' Symbol currency: {1}"' order.PriceCurrency' security.SymbolProperties.QuoteCurrency)); " is 157.
Long Statement,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,HandleOrderEvent,The length of the statement  "            // update the ticket and order after we've processed the fill' but before the event' this way everything is ready for user code " is 127.
Long Statement,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,HandleAccountChanged,The length of the statement  "                Log.Trace(string.Format("BrokerageTransactionHandler.HandleAccountChanged(): {0} Cash Delta: {1}"' account.CurrencySymbol' delta)); " is 131.
Complex Conditional,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The conditional expression  "charts.ContainsKey(strategyEquityKey) &&                                  charts[strategyEquityKey].Series.ContainsKey(equityKey) &&                                  charts[strategyEquityKey].Series.ContainsKey(dailyPerformanceKey) &&                                  charts.ContainsKey(benchmarkKey) &&                                  charts[benchmarkKey].Series.ContainsKey(benchmarkKey)"  is complex.
Complex Conditional,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The conditional expression  "(_algorithmHandlers.Results.IsActive                      || (_algorithmHandlers.Transactions != null && _algorithmHandlers.Transactions.IsActive)                      || (_algorithmHandlers.DataFeed != null && _algorithmHandlers.DataFeed.IsActive)                      || (_algorithmHandlers.RealTime != null && _algorithmHandlers.RealTime.IsActive))                      && ts.ElapsedMilliseconds < 30*1000"  is complex.
Complex Conditional,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Update,The conditional expression  "_algorithm == null || _algorithm.Transactions == null || _transactionHandler.Orders == null || !_algorithm.GetLocked()"  is complex.
Virtual Method Call from Constructor,QuantConnect.Lean.Engine.DataFeeds,ApiDataProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\ApiDataProvider.cs,ApiDataProvider,The constructor "ApiDataProvider" calls a virtual method "Initialize".
Virtual Method Call from Constructor,QuantConnect.Lean.Engine.DataFeeds.Queues,ApiDataQueueHandler,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Queues\ApiDataQueueHandler.cs,ApiDataQueueHandler,The constructor "ApiDataQueueHandler" calls a virtual method "Initialize".
Magic Number,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,The following statement contains a magic number: var marginCallFrequency = TimeSpan.FromMinutes(5);
Magic Number,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,The following statement contains a magic number: var settlementScanFrequency = TimeSpan.FromMinutes(30);
Magic Number,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,The following statement contains a magic number: foreach (var timeSlice in Stream(job' algorithm' feed' results' token))              {                  // reset our timer on each loop                  _currentTimeStepTime = DateTime.UtcNow;                    //Check this backtest is still running:                  if (_algorithm.Status != AlgorithmStatus.Running)                  {                      Log.Error(string.Format("AlgorithmManager.Run(): Algorithm state changed to {0} at {1}"' _algorithm.Status' timeSlice.Time));                      break;                  }                    //Execute with TimeLimit Monitor:                  if (token.IsCancellationRequested)                  {                      Log.Error("AlgorithmManager.Run(): CancellationRequestion at " + timeSlice.Time);                      return;                  }                    // Update the ILeanManager                  leanManager.Update();                    var time = timeSlice.Time;                  _dataPointCount += timeSlice.DataPointCount;                    //If we're in backtest mode we need to capture the daily performance. We do this here directly                  //before updating the algorithm state with the new data from this time step' otherwise we'll                  //produce incorrect samples (they'll take into account this time step's new price values)                  if (backtestMode)                  {                      //On day-change sample equity and daily performance for statistics calculations                      if (_previousTime.Date != time.Date)                      {                          SampleBenchmark(algorithm' results' _previousTime.Date);                            //Sample the portfolio value over time for chart.                          results.SampleEquity(_previousTime' Math.Round(algorithm.Portfolio.TotalPortfolioValue' 4));                            //Check for divide by zero                          if (portfolioValue == 0m)                          {                              results.SamplePerformance(_previousTime.Date' 0);                          }                          else                          {                              results.SamplePerformance(_previousTime.Date' Math.Round((algorithm.Portfolio.TotalPortfolioValue - portfolioValue) * 100 / portfolioValue' 10));                          }                          portfolioValue = algorithm.Portfolio.TotalPortfolioValue;                      }                        if (portfolioValue <= 0)                      {                          string logMessage = "AlgorithmManager.Run(): Portfolio value is less than or equal to zero";                          Log.Trace(logMessage);                          results.SystemDebugMessage(logMessage);                          break;                      }                  }                  else                  {                      // live mode continously sample the benchmark                      SampleBenchmark(algorithm' results' time);                  }                    //Update algorithm state after capturing performance from previous day                    // If backtesting' we need to check if there are realtime events in the past                  // which didn't fire because at the scheduled times there was no data (i.e. markets closed)                  // and fire them with the correct date/time.                  if (backtestMode)                  {                      realtime.ScanPastEvents(time);                  }                    //Set the algorithm and real time handler's time                  algorithm.SetDateTime(time);                    if (timeSlice.Slice.SymbolChangedEvents.Count != 0)                  {                      if (hasOnDataSymbolChangedEvents)                      {                          methodInvokers[typeof (SymbolChangedEvents)](algorithm' timeSlice.Slice.SymbolChangedEvents);                      }                      foreach (var symbol in timeSlice.Slice.SymbolChangedEvents.Keys)                      {                          // cancel all orders for the old symbol                          foreach (var ticket in transactions.GetOrderTickets(x => x.Status.IsOpen() && x.Symbol == symbol))                          {                              ticket.Cancel("Open order cancelled on symbol changed event");                          }                      }                  }                    if (timeSlice.SecurityChanges != SecurityChanges.None)                  {                      foreach (var security in timeSlice.SecurityChanges.AddedSecurities)                      {                          if (!algorithm.Securities.ContainsKey(security.Symbol))                          {                              // add the new security                              algorithm.Securities.Add(security);                          }                      }                  }                    //On each time step push the real time prices to the cashbook so we can have updated conversion rates                  foreach (var update in timeSlice.CashBookUpdateData)                  {                      var cash = update.Target;                      foreach (var data in update.Data)                      {                          cash.Update(data);                      }                  }                    //Update the securities properties: first before calling user code to avoid issues with data                  foreach (var update in timeSlice.SecuritiesUpdateData)                  {                      var security = update.Target;                      foreach (var data in update.Data)                      {                          security.SetMarketPrice(data);                      }                        // Send market price updates to the TradeBuilder                      algorithm.TradeBuilder.SetMarketPrice(security.Symbol' security.Price);                  }                    // fire real time events after we've updated based on the new data                  realtime.SetTime(timeSlice.Time);                    // process fill models on the updated data before entering algorithm' applies to all non-market orders                  transactions.ProcessSynchronousEvents();                    // process end of day delistings                  ProcessDelistedSymbols(algorithm' delistings);                    //Check if the user's signalled Quit: loop over data until day changes.                  if (algorithm.Status == AlgorithmStatus.Stopped)                  {                      Log.Trace("AlgorithmManager.Run(): Algorithm quit requested.");                      break;                  }                  if (algorithm.RunTimeError != null)                  {                      _algorithm.Status = AlgorithmStatus.RuntimeError;                      Log.Trace(string.Format("AlgorithmManager.Run(): Algorithm encountered a runtime error at {0}. Error: {1}"' timeSlice.Time' algorithm.RunTimeError));                      break;                  }                    // perform margin calls' in live mode we can also use realtime to emit these                  if (time >= nextMarginCallTime || (_liveMode && nextMarginCallTime > DateTime.UtcNow))                  {                      // determine if there are possible margin call orders to be executed                      bool issueMarginCallWarning;                      var marginCallOrders = algorithm.Portfolio.ScanForMarginCall(out issueMarginCallWarning);                      if (marginCallOrders.Count != 0)                      {                          var executingMarginCall = false;                          try                          {                              // tell the algorithm we're about to issue the margin call                              algorithm.OnMarginCall(marginCallOrders);                                executingMarginCall = true;                                // execute the margin call orders                              var executedTickets = algorithm.Portfolio.MarginCallModel.ExecuteMarginCall(marginCallOrders);                              foreach (var ticket in executedTickets)                              {                                  algorithm.Error(string.Format("{0} - Executed MarginCallOrder: {1} - Quantity: {2} @ {3}"' algorithm.Time' ticket.Symbol' ticket.Quantity' ticket.AverageFillPrice));                              }                          }                          catch (Exception err)                          {                              algorithm.RunTimeError = err;                              _algorithm.Status = AlgorithmStatus.RuntimeError;                              var locator = executingMarginCall ? "Portfolio.MarginCallModel.ExecuteMarginCall" : "OnMarginCall";                              Log.Error(string.Format("AlgorithmManager.Run(): RuntimeError: {0}: "' locator) + err);                              return;                          }                      }                      // we didn't perform a margin call' but got the warning flag back' so issue the warning to the algorithm                      else if (issueMarginCallWarning)                      {                          try                          {                              algorithm.OnMarginCallWarning();                          }                          catch (Exception err)                          {                              algorithm.RunTimeError = err;                              _algorithm.Status = AlgorithmStatus.RuntimeError;                              Log.Error("AlgorithmManager.Run(): RuntimeError: OnMarginCallWarning: " + err);                              return;                          }                      }                        nextMarginCallTime = time + marginCallFrequency;                  }                    // perform check for settlement of unsettled funds                  if (time >= nextSettlementScanTime || (_liveMode && nextSettlementScanTime > DateTime.UtcNow))                  {                      algorithm.Portfolio.ScanForCashSettlement(algorithm.UtcTime);                        nextSettlementScanTime = time + settlementScanFrequency;                  }                    // before we call any events' let the algorithm know about universe changes                  if (timeSlice.SecurityChanges != SecurityChanges.None)                  {                      try                      {                          algorithm.OnSecuritiesChanged(timeSlice.SecurityChanges);                      }                      catch (Exception err)                      {                          algorithm.RunTimeError = err;                          _algorithm.Status = AlgorithmStatus.RuntimeError;                          Log.Error("AlgorithmManager.Run(): RuntimeError: OnSecuritiesChanged event: " + err);                          return;                      }                  }                    // apply dividends                  foreach (var dividend in timeSlice.Slice.Dividends.Values)                  {                      Log.Trace("AlgorithmManager.Run(): {0}: Applying Dividend for {1}"' algorithm.Time' dividend.Symbol.ToString());                      algorithm.Portfolio.ApplyDividend(dividend);                  }                    // apply splits                  foreach (var split in timeSlice.Slice.Splits.Values)                  {                      try                      {                          Log.Trace("AlgorithmManager.Run(): {0}: Applying Split for {1}"' algorithm.Time' split.Symbol.ToString());                          algorithm.Portfolio.ApplySplit(split);                          // apply the split to open orders as well in raw mode' all other modes are split adjusted                          if (_liveMode || algorithm.Securities[split.Symbol].DataNormalizationMode == DataNormalizationMode.Raw)                          {                              // in live mode we always want to have our order match the order at the brokerage' so apply the split to the orders                              var openOrders = transactions.GetOrderTickets(ticket => ticket.Status.IsOpen() && ticket.Symbol == split.Symbol);                              algorithm.BrokerageModel.ApplySplit(openOrders.ToList()' split);                          }                      }                      catch (Exception err)                      {                          algorithm.RunTimeError = err;                          _algorithm.Status = AlgorithmStatus.RuntimeError;                          Log.Error("AlgorithmManager.Run(): RuntimeError: Split event: " + err);                          return;                      }                  }                    //Update registered consolidators for this symbol index                  try                  {                      foreach (var update in timeSlice.ConsolidatorUpdateData)                      {                          var consolidators = update.Target.Consolidators;                          foreach (var consolidator in consolidators)                          {                              foreach (var dataPoint in update.Data)                              {                                  // only push data into consolidators on the native' subscribed to resolution                                  if (EndTimeIsInNativeResolution(update.Target' dataPoint.EndTime))                                  {                                      consolidator.Update(dataPoint);                                  }                              }                                // scan for time after we've pumped all the data through for this consolidator                              var localTime = time.ConvertFromUtc(update.Target.ExchangeTimeZone);                              consolidator.Scan(localTime);                          }                      }                  }                  catch (Exception err)                  {                      algorithm.RunTimeError = err;                      _algorithm.Status = AlgorithmStatus.RuntimeError;                      Log.Error("AlgorithmManager.Run(): RuntimeError: Consolidators update: " + err);                      return;                  }                    // fire custom event handlers                  foreach (var update in timeSlice.CustomData)                  {                      MethodInvoker methodInvoker;                      if (!methodInvokers.TryGetValue(update.DataType' out methodInvoker))                      {                          continue;                      }                        try                      {                          foreach (var dataPoint in update.Data)                          {                              if (update.DataType.IsInstanceOfType(dataPoint))                              {                                  methodInvoker(algorithm' dataPoint);                              }                          }                      }                      catch (Exception err)                      {                          algorithm.RunTimeError = err;                          _algorithm.Status = AlgorithmStatus.RuntimeError;                          Log.Error("AlgorithmManager.Run(): RuntimeError: Custom Data: " + err);                          return;                      }                  }                    try                  {                      // fire off the dividend and split events before pricing events                      if (hasOnDataDividends && timeSlice.Slice.Dividends.Count != 0)                      {                          methodInvokers[typeof(Dividends)](algorithm' timeSlice.Slice.Dividends);                      }                      if (hasOnDataSplits && timeSlice.Slice.Splits.Count != 0)                      {                          methodInvokers[typeof(Splits)](algorithm' timeSlice.Slice.Splits);                      }                      if (hasOnDataDelistings && timeSlice.Slice.Delistings.Count != 0)                      {                          methodInvokers[typeof(Delistings)](algorithm' timeSlice.Slice.Delistings);                      }                  }                  catch (Exception err)                  {                      algorithm.RunTimeError = err;                      _algorithm.Status = AlgorithmStatus.RuntimeError;                      Log.Error("AlgorithmManager.Run(): RuntimeError: Dividends/Splits/Delistings: " + err);                      return;                  }                    // run the delisting logic after firing delisting events                  HandleDelistedSymbols(algorithm' timeSlice.Slice.Delistings' delistings);                    //After we've fired all other events in this second' fire the pricing events:                  try                  {                        // TODO: For backwards compatibility only. Remove in 2017                      // For compatibility with Forex Trade data' moving                      if (timeSlice.Slice.QuoteBars.Count > 0)                      {                          foreach (var tradeBar in timeSlice.Slice.QuoteBars.Where(x => x.Key.ID.SecurityType == SecurityType.Forex))                          {                              timeSlice.Slice.Bars.Add(tradeBar.Value.Collapse());                          }                      }                      if (hasOnDataTradeBars && timeSlice.Slice.Bars.Count > 0) methodInvokers[typeof(TradeBars)](algorithm' timeSlice.Slice.Bars);                      if (hasOnDataQuoteBars && timeSlice.Slice.QuoteBars.Count > 0) methodInvokers[typeof(QuoteBars)](algorithm' timeSlice.Slice.QuoteBars);                      if (hasOnDataOptionChains && timeSlice.Slice.OptionChains.Count > 0) methodInvokers[typeof(OptionChains)](algorithm' timeSlice.Slice.OptionChains);                      if (hasOnDataTicks && timeSlice.Slice.Ticks.Count > 0) methodInvokers[typeof(Ticks)](algorithm' timeSlice.Slice.Ticks);                  }                  catch (Exception err)                  {                      algorithm.RunTimeError = err;                      _algorithm.Status = AlgorithmStatus.RuntimeError;                      Log.Error("AlgorithmManager.Run(): RuntimeError: New Style Mode: " + err);                      return;                  }                    try                  {                      if (timeSlice.Slice.HasData)                      {                          // EVENT HANDLER v3.0 -- all data in a single event                          algorithm.OnData(timeSlice.Slice);                      }                  }                  catch (Exception err)                  {                      algorithm.RunTimeError = err;                      _algorithm.Status = AlgorithmStatus.RuntimeError;                      Log.Error("AlgorithmManager.Run(): RuntimeError: Slice: " + err);                      return;                  }                    //If its the historical/paper trading models' wait until market orders have been "filled"                  // Manually trigger the event handler to prevent thread switch.                  transactions.ProcessSynchronousEvents();                    //Save the previous time for the sample calculations                  _previousTime = time;                    // Process any required events of the results handler such as sampling assets' equity' or stock prices.                  results.ProcessSynchronousEvents();              }
Magic Number,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,The following statement contains a magic number: foreach (var timeSlice in Stream(job' algorithm' feed' results' token))              {                  // reset our timer on each loop                  _currentTimeStepTime = DateTime.UtcNow;                    //Check this backtest is still running:                  if (_algorithm.Status != AlgorithmStatus.Running)                  {                      Log.Error(string.Format("AlgorithmManager.Run(): Algorithm state changed to {0} at {1}"' _algorithm.Status' timeSlice.Time));                      break;                  }                    //Execute with TimeLimit Monitor:                  if (token.IsCancellationRequested)                  {                      Log.Error("AlgorithmManager.Run(): CancellationRequestion at " + timeSlice.Time);                      return;                  }                    // Update the ILeanManager                  leanManager.Update();                    var time = timeSlice.Time;                  _dataPointCount += timeSlice.DataPointCount;                    //If we're in backtest mode we need to capture the daily performance. We do this here directly                  //before updating the algorithm state with the new data from this time step' otherwise we'll                  //produce incorrect samples (they'll take into account this time step's new price values)                  if (backtestMode)                  {                      //On day-change sample equity and daily performance for statistics calculations                      if (_previousTime.Date != time.Date)                      {                          SampleBenchmark(algorithm' results' _previousTime.Date);                            //Sample the portfolio value over time for chart.                          results.SampleEquity(_previousTime' Math.Round(algorithm.Portfolio.TotalPortfolioValue' 4));                            //Check for divide by zero                          if (portfolioValue == 0m)                          {                              results.SamplePerformance(_previousTime.Date' 0);                          }                          else                          {                              results.SamplePerformance(_previousTime.Date' Math.Round((algorithm.Portfolio.TotalPortfolioValue - portfolioValue) * 100 / portfolioValue' 10));                          }                          portfolioValue = algorithm.Portfolio.TotalPortfolioValue;                      }                        if (portfolioValue <= 0)                      {                          string logMessage = "AlgorithmManager.Run(): Portfolio value is less than or equal to zero";                          Log.Trace(logMessage);                          results.SystemDebugMessage(logMessage);                          break;                      }                  }                  else                  {                      // live mode continously sample the benchmark                      SampleBenchmark(algorithm' results' time);                  }                    //Update algorithm state after capturing performance from previous day                    // If backtesting' we need to check if there are realtime events in the past                  // which didn't fire because at the scheduled times there was no data (i.e. markets closed)                  // and fire them with the correct date/time.                  if (backtestMode)                  {                      realtime.ScanPastEvents(time);                  }                    //Set the algorithm and real time handler's time                  algorithm.SetDateTime(time);                    if (timeSlice.Slice.SymbolChangedEvents.Count != 0)                  {                      if (hasOnDataSymbolChangedEvents)                      {                          methodInvokers[typeof (SymbolChangedEvents)](algorithm' timeSlice.Slice.SymbolChangedEvents);                      }                      foreach (var symbol in timeSlice.Slice.SymbolChangedEvents.Keys)                      {                          // cancel all orders for the old symbol                          foreach (var ticket in transactions.GetOrderTickets(x => x.Status.IsOpen() && x.Symbol == symbol))                          {                              ticket.Cancel("Open order cancelled on symbol changed event");                          }                      }                  }                    if (timeSlice.SecurityChanges != SecurityChanges.None)                  {                      foreach (var security in timeSlice.SecurityChanges.AddedSecurities)                      {                          if (!algorithm.Securities.ContainsKey(security.Symbol))                          {                              // add the new security                              algorithm.Securities.Add(security);                          }                      }                  }                    //On each time step push the real time prices to the cashbook so we can have updated conversion rates                  foreach (var update in timeSlice.CashBookUpdateData)                  {                      var cash = update.Target;                      foreach (var data in update.Data)                      {                          cash.Update(data);                      }                  }                    //Update the securities properties: first before calling user code to avoid issues with data                  foreach (var update in timeSlice.SecuritiesUpdateData)                  {                      var security = update.Target;                      foreach (var data in update.Data)                      {                          security.SetMarketPrice(data);                      }                        // Send market price updates to the TradeBuilder                      algorithm.TradeBuilder.SetMarketPrice(security.Symbol' security.Price);                  }                    // fire real time events after we've updated based on the new data                  realtime.SetTime(timeSlice.Time);                    // process fill models on the updated data before entering algorithm' applies to all non-market orders                  transactions.ProcessSynchronousEvents();                    // process end of day delistings                  ProcessDelistedSymbols(algorithm' delistings);                    //Check if the user's signalled Quit: loop over data until day changes.                  if (algorithm.Status == AlgorithmStatus.Stopped)                  {                      Log.Trace("AlgorithmManager.Run(): Algorithm quit requested.");                      break;                  }                  if (algorithm.RunTimeError != null)                  {                      _algorithm.Status = AlgorithmStatus.RuntimeError;                      Log.Trace(string.Format("AlgorithmManager.Run(): Algorithm encountered a runtime error at {0}. Error: {1}"' timeSlice.Time' algorithm.RunTimeError));                      break;                  }                    // perform margin calls' in live mode we can also use realtime to emit these                  if (time >= nextMarginCallTime || (_liveMode && nextMarginCallTime > DateTime.UtcNow))                  {                      // determine if there are possible margin call orders to be executed                      bool issueMarginCallWarning;                      var marginCallOrders = algorithm.Portfolio.ScanForMarginCall(out issueMarginCallWarning);                      if (marginCallOrders.Count != 0)                      {                          var executingMarginCall = false;                          try                          {                              // tell the algorithm we're about to issue the margin call                              algorithm.OnMarginCall(marginCallOrders);                                executingMarginCall = true;                                // execute the margin call orders                              var executedTickets = algorithm.Portfolio.MarginCallModel.ExecuteMarginCall(marginCallOrders);                              foreach (var ticket in executedTickets)                              {                                  algorithm.Error(string.Format("{0} - Executed MarginCallOrder: {1} - Quantity: {2} @ {3}"' algorithm.Time' ticket.Symbol' ticket.Quantity' ticket.AverageFillPrice));                              }                          }                          catch (Exception err)                          {                              algorithm.RunTimeError = err;                              _algorithm.Status = AlgorithmStatus.RuntimeError;                              var locator = executingMarginCall ? "Portfolio.MarginCallModel.ExecuteMarginCall" : "OnMarginCall";                              Log.Error(string.Format("AlgorithmManager.Run(): RuntimeError: {0}: "' locator) + err);                              return;                          }                      }                      // we didn't perform a margin call' but got the warning flag back' so issue the warning to the algorithm                      else if (issueMarginCallWarning)                      {                          try                          {                              algorithm.OnMarginCallWarning();                          }                          catch (Exception err)                          {                              algorithm.RunTimeError = err;                              _algorithm.Status = AlgorithmStatus.RuntimeError;                              Log.Error("AlgorithmManager.Run(): RuntimeError: OnMarginCallWarning: " + err);                              return;                          }                      }                        nextMarginCallTime = time + marginCallFrequency;                  }                    // perform check for settlement of unsettled funds                  if (time >= nextSettlementScanTime || (_liveMode && nextSettlementScanTime > DateTime.UtcNow))                  {                      algorithm.Portfolio.ScanForCashSettlement(algorithm.UtcTime);                        nextSettlementScanTime = time + settlementScanFrequency;                  }                    // before we call any events' let the algorithm know about universe changes                  if (timeSlice.SecurityChanges != SecurityChanges.None)                  {                      try                      {                          algorithm.OnSecuritiesChanged(timeSlice.SecurityChanges);                      }                      catch (Exception err)                      {                          algorithm.RunTimeError = err;                          _algorithm.Status = AlgorithmStatus.RuntimeError;                          Log.Error("AlgorithmManager.Run(): RuntimeError: OnSecuritiesChanged event: " + err);                          return;                      }                  }                    // apply dividends                  foreach (var dividend in timeSlice.Slice.Dividends.Values)                  {                      Log.Trace("AlgorithmManager.Run(): {0}: Applying Dividend for {1}"' algorithm.Time' dividend.Symbol.ToString());                      algorithm.Portfolio.ApplyDividend(dividend);                  }                    // apply splits                  foreach (var split in timeSlice.Slice.Splits.Values)                  {                      try                      {                          Log.Trace("AlgorithmManager.Run(): {0}: Applying Split for {1}"' algorithm.Time' split.Symbol.ToString());                          algorithm.Portfolio.ApplySplit(split);                          // apply the split to open orders as well in raw mode' all other modes are split adjusted                          if (_liveMode || algorithm.Securities[split.Symbol].DataNormalizationMode == DataNormalizationMode.Raw)                          {                              // in live mode we always want to have our order match the order at the brokerage' so apply the split to the orders                              var openOrders = transactions.GetOrderTickets(ticket => ticket.Status.IsOpen() && ticket.Symbol == split.Symbol);                              algorithm.BrokerageModel.ApplySplit(openOrders.ToList()' split);                          }                      }                      catch (Exception err)                      {                          algorithm.RunTimeError = err;                          _algorithm.Status = AlgorithmStatus.RuntimeError;                          Log.Error("AlgorithmManager.Run(): RuntimeError: Split event: " + err);                          return;                      }                  }                    //Update registered consolidators for this symbol index                  try                  {                      foreach (var update in timeSlice.ConsolidatorUpdateData)                      {                          var consolidators = update.Target.Consolidators;                          foreach (var consolidator in consolidators)                          {                              foreach (var dataPoint in update.Data)                              {                                  // only push data into consolidators on the native' subscribed to resolution                                  if (EndTimeIsInNativeResolution(update.Target' dataPoint.EndTime))                                  {                                      consolidator.Update(dataPoint);                                  }                              }                                // scan for time after we've pumped all the data through for this consolidator                              var localTime = time.ConvertFromUtc(update.Target.ExchangeTimeZone);                              consolidator.Scan(localTime);                          }                      }                  }                  catch (Exception err)                  {                      algorithm.RunTimeError = err;                      _algorithm.Status = AlgorithmStatus.RuntimeError;                      Log.Error("AlgorithmManager.Run(): RuntimeError: Consolidators update: " + err);                      return;                  }                    // fire custom event handlers                  foreach (var update in timeSlice.CustomData)                  {                      MethodInvoker methodInvoker;                      if (!methodInvokers.TryGetValue(update.DataType' out methodInvoker))                      {                          continue;                      }                        try                      {                          foreach (var dataPoint in update.Data)                          {                              if (update.DataType.IsInstanceOfType(dataPoint))                              {                                  methodInvoker(algorithm' dataPoint);                              }                          }                      }                      catch (Exception err)                      {                          algorithm.RunTimeError = err;                          _algorithm.Status = AlgorithmStatus.RuntimeError;                          Log.Error("AlgorithmManager.Run(): RuntimeError: Custom Data: " + err);                          return;                      }                  }                    try                  {                      // fire off the dividend and split events before pricing events                      if (hasOnDataDividends && timeSlice.Slice.Dividends.Count != 0)                      {                          methodInvokers[typeof(Dividends)](algorithm' timeSlice.Slice.Dividends);                      }                      if (hasOnDataSplits && timeSlice.Slice.Splits.Count != 0)                      {                          methodInvokers[typeof(Splits)](algorithm' timeSlice.Slice.Splits);                      }                      if (hasOnDataDelistings && timeSlice.Slice.Delistings.Count != 0)                      {                          methodInvokers[typeof(Delistings)](algorithm' timeSlice.Slice.Delistings);                      }                  }                  catch (Exception err)                  {                      algorithm.RunTimeError = err;                      _algorithm.Status = AlgorithmStatus.RuntimeError;                      Log.Error("AlgorithmManager.Run(): RuntimeError: Dividends/Splits/Delistings: " + err);                      return;                  }                    // run the delisting logic after firing delisting events                  HandleDelistedSymbols(algorithm' timeSlice.Slice.Delistings' delistings);                    //After we've fired all other events in this second' fire the pricing events:                  try                  {                        // TODO: For backwards compatibility only. Remove in 2017                      // For compatibility with Forex Trade data' moving                      if (timeSlice.Slice.QuoteBars.Count > 0)                      {                          foreach (var tradeBar in timeSlice.Slice.QuoteBars.Where(x => x.Key.ID.SecurityType == SecurityType.Forex))                          {                              timeSlice.Slice.Bars.Add(tradeBar.Value.Collapse());                          }                      }                      if (hasOnDataTradeBars && timeSlice.Slice.Bars.Count > 0) methodInvokers[typeof(TradeBars)](algorithm' timeSlice.Slice.Bars);                      if (hasOnDataQuoteBars && timeSlice.Slice.QuoteBars.Count > 0) methodInvokers[typeof(QuoteBars)](algorithm' timeSlice.Slice.QuoteBars);                      if (hasOnDataOptionChains && timeSlice.Slice.OptionChains.Count > 0) methodInvokers[typeof(OptionChains)](algorithm' timeSlice.Slice.OptionChains);                      if (hasOnDataTicks && timeSlice.Slice.Ticks.Count > 0) methodInvokers[typeof(Ticks)](algorithm' timeSlice.Slice.Ticks);                  }                  catch (Exception err)                  {                      algorithm.RunTimeError = err;                      _algorithm.Status = AlgorithmStatus.RuntimeError;                      Log.Error("AlgorithmManager.Run(): RuntimeError: New Style Mode: " + err);                      return;                  }                    try                  {                      if (timeSlice.Slice.HasData)                      {                          // EVENT HANDLER v3.0 -- all data in a single event                          algorithm.OnData(timeSlice.Slice);                      }                  }                  catch (Exception err)                  {                      algorithm.RunTimeError = err;                      _algorithm.Status = AlgorithmStatus.RuntimeError;                      Log.Error("AlgorithmManager.Run(): RuntimeError: Slice: " + err);                      return;                  }                    //If its the historical/paper trading models' wait until market orders have been "filled"                  // Manually trigger the event handler to prevent thread switch.                  transactions.ProcessSynchronousEvents();                    //Save the previous time for the sample calculations                  _previousTime = time;                    // Process any required events of the results handler such as sampling assets' equity' or stock prices.                  results.ProcessSynchronousEvents();              }
Magic Number,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,The following statement contains a magic number: foreach (var timeSlice in Stream(job' algorithm' feed' results' token))              {                  // reset our timer on each loop                  _currentTimeStepTime = DateTime.UtcNow;                    //Check this backtest is still running:                  if (_algorithm.Status != AlgorithmStatus.Running)                  {                      Log.Error(string.Format("AlgorithmManager.Run(): Algorithm state changed to {0} at {1}"' _algorithm.Status' timeSlice.Time));                      break;                  }                    //Execute with TimeLimit Monitor:                  if (token.IsCancellationRequested)                  {                      Log.Error("AlgorithmManager.Run(): CancellationRequestion at " + timeSlice.Time);                      return;                  }                    // Update the ILeanManager                  leanManager.Update();                    var time = timeSlice.Time;                  _dataPointCount += timeSlice.DataPointCount;                    //If we're in backtest mode we need to capture the daily performance. We do this here directly                  //before updating the algorithm state with the new data from this time step' otherwise we'll                  //produce incorrect samples (they'll take into account this time step's new price values)                  if (backtestMode)                  {                      //On day-change sample equity and daily performance for statistics calculations                      if (_previousTime.Date != time.Date)                      {                          SampleBenchmark(algorithm' results' _previousTime.Date);                            //Sample the portfolio value over time for chart.                          results.SampleEquity(_previousTime' Math.Round(algorithm.Portfolio.TotalPortfolioValue' 4));                            //Check for divide by zero                          if (portfolioValue == 0m)                          {                              results.SamplePerformance(_previousTime.Date' 0);                          }                          else                          {                              results.SamplePerformance(_previousTime.Date' Math.Round((algorithm.Portfolio.TotalPortfolioValue - portfolioValue) * 100 / portfolioValue' 10));                          }                          portfolioValue = algorithm.Portfolio.TotalPortfolioValue;                      }                        if (portfolioValue <= 0)                      {                          string logMessage = "AlgorithmManager.Run(): Portfolio value is less than or equal to zero";                          Log.Trace(logMessage);                          results.SystemDebugMessage(logMessage);                          break;                      }                  }                  else                  {                      // live mode continously sample the benchmark                      SampleBenchmark(algorithm' results' time);                  }                    //Update algorithm state after capturing performance from previous day                    // If backtesting' we need to check if there are realtime events in the past                  // which didn't fire because at the scheduled times there was no data (i.e. markets closed)                  // and fire them with the correct date/time.                  if (backtestMode)                  {                      realtime.ScanPastEvents(time);                  }                    //Set the algorithm and real time handler's time                  algorithm.SetDateTime(time);                    if (timeSlice.Slice.SymbolChangedEvents.Count != 0)                  {                      if (hasOnDataSymbolChangedEvents)                      {                          methodInvokers[typeof (SymbolChangedEvents)](algorithm' timeSlice.Slice.SymbolChangedEvents);                      }                      foreach (var symbol in timeSlice.Slice.SymbolChangedEvents.Keys)                      {                          // cancel all orders for the old symbol                          foreach (var ticket in transactions.GetOrderTickets(x => x.Status.IsOpen() && x.Symbol == symbol))                          {                              ticket.Cancel("Open order cancelled on symbol changed event");                          }                      }                  }                    if (timeSlice.SecurityChanges != SecurityChanges.None)                  {                      foreach (var security in timeSlice.SecurityChanges.AddedSecurities)                      {                          if (!algorithm.Securities.ContainsKey(security.Symbol))                          {                              // add the new security                              algorithm.Securities.Add(security);                          }                      }                  }                    //On each time step push the real time prices to the cashbook so we can have updated conversion rates                  foreach (var update in timeSlice.CashBookUpdateData)                  {                      var cash = update.Target;                      foreach (var data in update.Data)                      {                          cash.Update(data);                      }                  }                    //Update the securities properties: first before calling user code to avoid issues with data                  foreach (var update in timeSlice.SecuritiesUpdateData)                  {                      var security = update.Target;                      foreach (var data in update.Data)                      {                          security.SetMarketPrice(data);                      }                        // Send market price updates to the TradeBuilder                      algorithm.TradeBuilder.SetMarketPrice(security.Symbol' security.Price);                  }                    // fire real time events after we've updated based on the new data                  realtime.SetTime(timeSlice.Time);                    // process fill models on the updated data before entering algorithm' applies to all non-market orders                  transactions.ProcessSynchronousEvents();                    // process end of day delistings                  ProcessDelistedSymbols(algorithm' delistings);                    //Check if the user's signalled Quit: loop over data until day changes.                  if (algorithm.Status == AlgorithmStatus.Stopped)                  {                      Log.Trace("AlgorithmManager.Run(): Algorithm quit requested.");                      break;                  }                  if (algorithm.RunTimeError != null)                  {                      _algorithm.Status = AlgorithmStatus.RuntimeError;                      Log.Trace(string.Format("AlgorithmManager.Run(): Algorithm encountered a runtime error at {0}. Error: {1}"' timeSlice.Time' algorithm.RunTimeError));                      break;                  }                    // perform margin calls' in live mode we can also use realtime to emit these                  if (time >= nextMarginCallTime || (_liveMode && nextMarginCallTime > DateTime.UtcNow))                  {                      // determine if there are possible margin call orders to be executed                      bool issueMarginCallWarning;                      var marginCallOrders = algorithm.Portfolio.ScanForMarginCall(out issueMarginCallWarning);                      if (marginCallOrders.Count != 0)                      {                          var executingMarginCall = false;                          try                          {                              // tell the algorithm we're about to issue the margin call                              algorithm.OnMarginCall(marginCallOrders);                                executingMarginCall = true;                                // execute the margin call orders                              var executedTickets = algorithm.Portfolio.MarginCallModel.ExecuteMarginCall(marginCallOrders);                              foreach (var ticket in executedTickets)                              {                                  algorithm.Error(string.Format("{0} - Executed MarginCallOrder: {1} - Quantity: {2} @ {3}"' algorithm.Time' ticket.Symbol' ticket.Quantity' ticket.AverageFillPrice));                              }                          }                          catch (Exception err)                          {                              algorithm.RunTimeError = err;                              _algorithm.Status = AlgorithmStatus.RuntimeError;                              var locator = executingMarginCall ? "Portfolio.MarginCallModel.ExecuteMarginCall" : "OnMarginCall";                              Log.Error(string.Format("AlgorithmManager.Run(): RuntimeError: {0}: "' locator) + err);                              return;                          }                      }                      // we didn't perform a margin call' but got the warning flag back' so issue the warning to the algorithm                      else if (issueMarginCallWarning)                      {                          try                          {                              algorithm.OnMarginCallWarning();                          }                          catch (Exception err)                          {                              algorithm.RunTimeError = err;                              _algorithm.Status = AlgorithmStatus.RuntimeError;                              Log.Error("AlgorithmManager.Run(): RuntimeError: OnMarginCallWarning: " + err);                              return;                          }                      }                        nextMarginCallTime = time + marginCallFrequency;                  }                    // perform check for settlement of unsettled funds                  if (time >= nextSettlementScanTime || (_liveMode && nextSettlementScanTime > DateTime.UtcNow))                  {                      algorithm.Portfolio.ScanForCashSettlement(algorithm.UtcTime);                        nextSettlementScanTime = time + settlementScanFrequency;                  }                    // before we call any events' let the algorithm know about universe changes                  if (timeSlice.SecurityChanges != SecurityChanges.None)                  {                      try                      {                          algorithm.OnSecuritiesChanged(timeSlice.SecurityChanges);                      }                      catch (Exception err)                      {                          algorithm.RunTimeError = err;                          _algorithm.Status = AlgorithmStatus.RuntimeError;                          Log.Error("AlgorithmManager.Run(): RuntimeError: OnSecuritiesChanged event: " + err);                          return;                      }                  }                    // apply dividends                  foreach (var dividend in timeSlice.Slice.Dividends.Values)                  {                      Log.Trace("AlgorithmManager.Run(): {0}: Applying Dividend for {1}"' algorithm.Time' dividend.Symbol.ToString());                      algorithm.Portfolio.ApplyDividend(dividend);                  }                    // apply splits                  foreach (var split in timeSlice.Slice.Splits.Values)                  {                      try                      {                          Log.Trace("AlgorithmManager.Run(): {0}: Applying Split for {1}"' algorithm.Time' split.Symbol.ToString());                          algorithm.Portfolio.ApplySplit(split);                          // apply the split to open orders as well in raw mode' all other modes are split adjusted                          if (_liveMode || algorithm.Securities[split.Symbol].DataNormalizationMode == DataNormalizationMode.Raw)                          {                              // in live mode we always want to have our order match the order at the brokerage' so apply the split to the orders                              var openOrders = transactions.GetOrderTickets(ticket => ticket.Status.IsOpen() && ticket.Symbol == split.Symbol);                              algorithm.BrokerageModel.ApplySplit(openOrders.ToList()' split);                          }                      }                      catch (Exception err)                      {                          algorithm.RunTimeError = err;                          _algorithm.Status = AlgorithmStatus.RuntimeError;                          Log.Error("AlgorithmManager.Run(): RuntimeError: Split event: " + err);                          return;                      }                  }                    //Update registered consolidators for this symbol index                  try                  {                      foreach (var update in timeSlice.ConsolidatorUpdateData)                      {                          var consolidators = update.Target.Consolidators;                          foreach (var consolidator in consolidators)                          {                              foreach (var dataPoint in update.Data)                              {                                  // only push data into consolidators on the native' subscribed to resolution                                  if (EndTimeIsInNativeResolution(update.Target' dataPoint.EndTime))                                  {                                      consolidator.Update(dataPoint);                                  }                              }                                // scan for time after we've pumped all the data through for this consolidator                              var localTime = time.ConvertFromUtc(update.Target.ExchangeTimeZone);                              consolidator.Scan(localTime);                          }                      }                  }                  catch (Exception err)                  {                      algorithm.RunTimeError = err;                      _algorithm.Status = AlgorithmStatus.RuntimeError;                      Log.Error("AlgorithmManager.Run(): RuntimeError: Consolidators update: " + err);                      return;                  }                    // fire custom event handlers                  foreach (var update in timeSlice.CustomData)                  {                      MethodInvoker methodInvoker;                      if (!methodInvokers.TryGetValue(update.DataType' out methodInvoker))                      {                          continue;                      }                        try                      {                          foreach (var dataPoint in update.Data)                          {                              if (update.DataType.IsInstanceOfType(dataPoint))                              {                                  methodInvoker(algorithm' dataPoint);                              }                          }                      }                      catch (Exception err)                      {                          algorithm.RunTimeError = err;                          _algorithm.Status = AlgorithmStatus.RuntimeError;                          Log.Error("AlgorithmManager.Run(): RuntimeError: Custom Data: " + err);                          return;                      }                  }                    try                  {                      // fire off the dividend and split events before pricing events                      if (hasOnDataDividends && timeSlice.Slice.Dividends.Count != 0)                      {                          methodInvokers[typeof(Dividends)](algorithm' timeSlice.Slice.Dividends);                      }                      if (hasOnDataSplits && timeSlice.Slice.Splits.Count != 0)                      {                          methodInvokers[typeof(Splits)](algorithm' timeSlice.Slice.Splits);                      }                      if (hasOnDataDelistings && timeSlice.Slice.Delistings.Count != 0)                      {                          methodInvokers[typeof(Delistings)](algorithm' timeSlice.Slice.Delistings);                      }                  }                  catch (Exception err)                  {                      algorithm.RunTimeError = err;                      _algorithm.Status = AlgorithmStatus.RuntimeError;                      Log.Error("AlgorithmManager.Run(): RuntimeError: Dividends/Splits/Delistings: " + err);                      return;                  }                    // run the delisting logic after firing delisting events                  HandleDelistedSymbols(algorithm' timeSlice.Slice.Delistings' delistings);                    //After we've fired all other events in this second' fire the pricing events:                  try                  {                        // TODO: For backwards compatibility only. Remove in 2017                      // For compatibility with Forex Trade data' moving                      if (timeSlice.Slice.QuoteBars.Count > 0)                      {                          foreach (var tradeBar in timeSlice.Slice.QuoteBars.Where(x => x.Key.ID.SecurityType == SecurityType.Forex))                          {                              timeSlice.Slice.Bars.Add(tradeBar.Value.Collapse());                          }                      }                      if (hasOnDataTradeBars && timeSlice.Slice.Bars.Count > 0) methodInvokers[typeof(TradeBars)](algorithm' timeSlice.Slice.Bars);                      if (hasOnDataQuoteBars && timeSlice.Slice.QuoteBars.Count > 0) methodInvokers[typeof(QuoteBars)](algorithm' timeSlice.Slice.QuoteBars);                      if (hasOnDataOptionChains && timeSlice.Slice.OptionChains.Count > 0) methodInvokers[typeof(OptionChains)](algorithm' timeSlice.Slice.OptionChains);                      if (hasOnDataTicks && timeSlice.Slice.Ticks.Count > 0) methodInvokers[typeof(Ticks)](algorithm' timeSlice.Slice.Ticks);                  }                  catch (Exception err)                  {                      algorithm.RunTimeError = err;                      _algorithm.Status = AlgorithmStatus.RuntimeError;                      Log.Error("AlgorithmManager.Run(): RuntimeError: New Style Mode: " + err);                      return;                  }                    try                  {                      if (timeSlice.Slice.HasData)                      {                          // EVENT HANDLER v3.0 -- all data in a single event                          algorithm.OnData(timeSlice.Slice);                      }                  }                  catch (Exception err)                  {                      algorithm.RunTimeError = err;                      _algorithm.Status = AlgorithmStatus.RuntimeError;                      Log.Error("AlgorithmManager.Run(): RuntimeError: Slice: " + err);                      return;                  }                    //If its the historical/paper trading models' wait until market orders have been "filled"                  // Manually trigger the event handler to prevent thread switch.                  transactions.ProcessSynchronousEvents();                    //Save the previous time for the sample calculations                  _previousTime = time;                    // Process any required events of the results handler such as sampling assets' equity' or stock prices.                  results.ProcessSynchronousEvents();              }
Magic Number,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,The following statement contains a magic number: results.SampleEquity(_previousTime' Math.Round(algorithm.Portfolio.TotalPortfolioValue' 4));
Magic Number,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,The following statement contains a magic number: if (portfolioValue == 0m)              {                  results.SamplePerformance(backtestMode ? _previousTime.Date : _previousTime' 0m);              }              else              {                  results.SamplePerformance(backtestMode ? _previousTime.Date : _previousTime'                      Math.Round((algorithm.Portfolio.TotalPortfolioValue - portfolioValue) * 100 / portfolioValue' 10));              }
Magic Number,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Run,The following statement contains a magic number: if (portfolioValue == 0m)              {                  results.SamplePerformance(backtestMode ? _previousTime.Date : _previousTime' 0m);              }              else              {                  results.SamplePerformance(backtestMode ? _previousTime.Date : _previousTime'                      Math.Round((algorithm.Portfolio.TotalPortfolioValue - portfolioValue) * 100 / portfolioValue' 10));              }
Magic Number,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Stream,The following statement contains a magic number: if (historyRequests.Count != 0)              {                  // rewrite internal feed requests                  var subscriptions = algorithm.SubscriptionManager.Subscriptions.Where(x => !x.IsInternalFeed).ToList();                  var minResolution = subscriptions.Count > 0 ? subscriptions.Min(x => x.Resolution) : Resolution.Second;                  foreach (var request in historyRequests)                  {                      Security security;                      if (algorithm.Securities.TryGetValue(request.Symbol' out security) && security.IsInternalFeed())                      {                          if (request.Resolution < minResolution)                          {                              request.Resolution = minResolution;                              request.FillForwardResolution = request.FillForwardResolution.HasValue ? minResolution : (Resolution?) null;                          }                      }                  }                    // rewrite all to share the same fill forward resolution                  if (historyRequests.Any(x => x.FillForwardResolution.HasValue))                  {                      minResolution = historyRequests.Where(x => x.FillForwardResolution.HasValue).Min(x => x.FillForwardResolution.Value);                      foreach (var request in historyRequests.Where(x => x.FillForwardResolution.HasValue))                      {                          request.FillForwardResolution = minResolution;                      }                  }                    foreach (var request in historyRequests)                  {                      start = Math.Min(request.StartTimeUtc.Ticks' start);                      Log.Trace(string.Format("AlgorithmManager.Stream(): WarmupHistoryRequest: {0}: Start: {1} End: {2} Resolution: {3}"' request.Symbol' request.StartTimeUtc' request.EndTimeUtc' request.Resolution));                  }                    // make the history request and build time slices                  foreach (var slice in history.GetHistory(historyRequests' timeZone))                  {                      TimeSlice timeSlice;                      try                      {                          // we need to recombine this slice into a time slice                          var paired = new List<DataFeedPacket>();                          foreach (var symbol in slice.Keys)                          {                              var security = algorithm.Securities[symbol];                              var data = slice[symbol];                              var list = new List<BaseData>();                              var ticks = data as List<Tick>;                              if (ticks != null) list.AddRange(ticks);                              else               list.Add(data);                              paired.Add(new DataFeedPacket(security' security.Subscriptions.First()' list));                          }                          timeSlice = TimeSlice.Create(slice.Time.ConvertToUtc(timeZone)' timeZone' algorithm.Portfolio.CashBook' paired' SecurityChanges.None);                      }                      catch (Exception err)                      {                          Log.Error(err);                          algorithm.RunTimeError = err;                          yield break;                      }                        if (timeSlice != null)                      {                          if (!setStartTime)                          {                              setStartTime = true;                              _previousTime = timeSlice.Time;                              algorithm.Debug("Algorithm warming up...");                          }                          if (DateTime.UtcNow > nextStatusTime)                          {                              // send some status to the user letting them know we're done history' but still warming up'                              // catching up to real time data                              nextStatusTime = DateTime.UtcNow.AddSeconds(1);                              var percent = (int)(100 * (timeSlice.Time.Ticks - start) / (double)(DateTime.UtcNow.Ticks - start));                              results.SendStatusUpdate(AlgorithmStatus.History' string.Format("Catching up to realtime {0}%..."' percent));                          }                          yield return timeSlice;                          lastHistoryTimeUtc = timeSlice.Time;                      }                  }              }
Magic Number,QuantConnect.Lean.Engine,AlgorithmManager,C:\repos\QuantConnect_Lean\Engine\AlgorithmManager.cs,Stream,The following statement contains a magic number: foreach (var timeSlice in feed)              {                  if (!setStartTime)                  {                      setStartTime = true;                      _previousTime = timeSlice.Time;                  }                  if (algorithm.LiveMode && algorithm.IsWarmingUp)                  {                      // this is hand-over logic' we spin up the data feed first and then request                      // the history for warmup' so there will be some overlap between the data                      if (lastHistoryTimeUtc.HasValue)                      {                          // make sure there's no historical data' this only matters for the handover                          var hasHistoricalData = false;                          foreach (var data in timeSlice.Slice.Ticks.Values.SelectMany(x => x).Concat<BaseData>(timeSlice.Slice.Bars.Values))                          {                              // check if any ticks in the list are on or after our last warmup point' if so' skip this data                              if (data.EndTime.ConvertToUtc(algorithm.Securities[data.Symbol].Exchange.TimeZone) >= lastHistoryTimeUtc)                              {                                  hasHistoricalData = true;                                  break;                              }                          }                          if (hasHistoricalData)                          {                              continue;                          }                            // prevent us from doing these checks every loop                          lastHistoryTimeUtc = null;                      }                        // in live mode wait to mark us as finished warming up when                      // the data feed has caught up to now within the min increment                      if (timeSlice.Time > DateTime.UtcNow.Subtract(minimumIncrement))                      {                          algorithm.SetFinishedWarmingUp();                          algorithm.Debug("Algorithm finished warming up.");                          Log.Trace("AlgorithmManager.Stream(): Finished warmup");                      }                      else if (DateTime.UtcNow > nextStatusTime)                      {                          // send some status to the user letting them know we're done history' but still warming up'                          // catching up to real time data                          nextStatusTime = DateTime.UtcNow.AddSeconds(1);                          var percent = (int) (100*(timeSlice.Time.Ticks - start)/(double) (DateTime.UtcNow.Ticks - start));                          results.SendStatusUpdate(AlgorithmStatus.History' string.Format("Catching up to realtime {0}%..."' percent));                      }                  }                  yield return timeSlice;              }
Magic Number,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The following statement contains a magic number: try              {                  //Reset thread holders.                  var initializeComplete = false;                  Thread threadFeed = null;                  Thread threadTransactions = null;                  Thread threadResults = null;                  Thread threadRealTime = null;                    //-> Initialize messaging system                  _systemHandlers.Notify.SetAuthentication(job);                    //-> Set the result handler type for this algorithm job' and launch the associated result thread.                  _algorithmHandlers.Results.Initialize(job' _systemHandlers.Notify' _systemHandlers.Api' _algorithmHandlers.DataFeed' _algorithmHandlers.Setup' _algorithmHandlers.Transactions);                    threadResults = new Thread(_algorithmHandlers.Results.Run' 0) { IsBackground = true' Name = "Result Thread" };                  threadResults.Start();                    IBrokerage brokerage = null;                  try                  {                      // Save algorithm to cache' load algorithm instance:                      algorithm = _algorithmHandlers.Setup.CreateAlgorithmInstance(job' assemblyPath);                        // Set algorithm in ILeanManager                      _systemHandlers.LeanManager.SetAlgorithm(algorithm);                        // Initialize the brokerage                      IBrokerageFactory factory;                      brokerage = _algorithmHandlers.Setup.CreateBrokerage(job' algorithm' out factory);                        // Initialize the data feed before we initialize so he can intercept added securities/universes via events                      _algorithmHandlers.DataFeed.Initialize(algorithm' job' _algorithmHandlers.Results' _algorithmHandlers.MapFileProvider' _algorithmHandlers.FactorFileProvider' _algorithmHandlers.DataProvider);                        // set the order processor on the transaction manager (needs to be done before initializing BrokerageHistoryProvider)                      algorithm.Transactions.SetOrderProcessor(_algorithmHandlers.Transactions);                        // set the history provider before setting up the algorithm                      var historyProvider = GetHistoryProvider(job.HistoryProvider);                      if (historyProvider is BrokerageHistoryProvider)                      {                          (historyProvider as BrokerageHistoryProvider).SetBrokerage(brokerage);                      }                        var historyDataCacheProvider = new ZipDataCacheProvider(_algorithmHandlers.DataProvider);                      historyProvider.Initialize(job' _algorithmHandlers.DataProvider' historyDataCacheProvider' _algorithmHandlers.MapFileProvider' _algorithmHandlers.FactorFileProvider' progress =>                      {                          // send progress updates to the result handler only during initialization                          if (!algorithm.GetLocked() || algorithm.IsWarmingUp)                          {                              _algorithmHandlers.Results.SendStatusUpdate(AlgorithmStatus.History'                                  string.Format("Processing history {0}%..."' progress));                          }                      });                        algorithm.HistoryProvider = historyProvider;                        // initialize the default brokerage message handler                      algorithm.BrokerageMessageHandler = factory.CreateBrokerageMessageHandler(algorithm' job' _systemHandlers.Api);                        //Initialize the internal state of algorithm and job: executes the algorithm.Initialize() method.                      initializeComplete = _algorithmHandlers.Setup.Setup(algorithm' brokerage' job' _algorithmHandlers.Results' _algorithmHandlers.Transactions' _algorithmHandlers.RealTime);                        // set this again now that we've actually added securities                      _algorithmHandlers.Results.SetAlgorithm(algorithm);                        //If there are any reasons it failed' pass these back to the IDE.                      if (!initializeComplete || algorithm.ErrorMessages.Count > 0 || _algorithmHandlers.Setup.Errors.Count > 0)                      {                          initializeComplete = false;                          //Get all the error messages: internal in algorithm and external in setup handler.                          var errorMessage = String.Join("'"' algorithm.ErrorMessages);                          errorMessage += String.Join("'"' _algorithmHandlers.Setup.Errors);                          Log.Error("Engine.Run(): " + errorMessage);                          _algorithmHandlers.Results.RuntimeError(errorMessage);                          _systemHandlers.Api.SetAlgorithmStatus(job.AlgorithmId' AlgorithmStatus.RuntimeError' errorMessage);                      }                  }                  catch (Exception err)                  {                      Log.Error(err);                      var runtimeMessage = "Algorithm.Initialize() Error: " + err.Message + " Stack Trace: " + err.StackTrace;                      _algorithmHandlers.Results.RuntimeError(runtimeMessage' err.StackTrace);                      _systemHandlers.Api.SetAlgorithmStatus(job.AlgorithmId' AlgorithmStatus.RuntimeError' runtimeMessage);                  }                      // log the job endpoints                  Log.Trace("JOB HANDLERS: ");                  Log.Trace("         DataFeed:     " + _algorithmHandlers.DataFeed.GetType().FullName);                  Log.Trace("         Setup:        " + _algorithmHandlers.Setup.GetType().FullName);                  Log.Trace("         RealTime:     " + _algorithmHandlers.RealTime.GetType().FullName);                  Log.Trace("         Results:      " + _algorithmHandlers.Results.GetType().FullName);                  Log.Trace("         Transactions: " + _algorithmHandlers.Transactions.GetType().FullName);                  if (algorithm != null && algorithm.HistoryProvider != null)                  {                      Log.Trace("         History Provider:     " + algorithm.HistoryProvider.GetType().FullName);                  }                  if (job is LiveNodePacket) Log.Trace("         Brokerage:      " + brokerage.GetType().FullName);                    //-> Using the job + initialization: load the designated handlers:                  if (initializeComplete)                  {                      //-> Reset the backtest stopwatch; we're now running the algorithm.                      var startTime = DateTime.Now;                        //Set algorithm as locked; set it to live mode if we're trading live' and set it to locked for no further updates.                      algorithm.SetAlgorithmId(job.AlgorithmId);                      algorithm.SetLocked();                        //Load the associated handlers for transaction and realtime events:                      _algorithmHandlers.Transactions.Initialize(algorithm' brokerage' _algorithmHandlers.Results);                      _algorithmHandlers.RealTime.Setup(algorithm' job' _algorithmHandlers.Results' _systemHandlers.Api);                        // wire up the brokerage message handler                      brokerage.Message += (sender' message) =>                      {                          algorithm.BrokerageMessageHandler.Handle(message);                            // fire brokerage message events                          algorithm.OnBrokerageMessage(message);                          switch (message.Type)                          {                              case BrokerageMessageType.Disconnect:                                  algorithm.OnBrokerageDisconnect();                                  break;                              case BrokerageMessageType.Reconnect:                                  algorithm.OnBrokerageReconnect();                                  break;                          }                      };                        //Send status to user the algorithm is now executing.                      _algorithmHandlers.Results.SendStatusUpdate(AlgorithmStatus.Running);                        //Launch the data' transaction and realtime handlers into dedicated threads                      threadFeed = new Thread(_algorithmHandlers.DataFeed.Run) { IsBackground = true' Name = "DataFeed Thread" };                      threadTransactions = new Thread(_algorithmHandlers.Transactions.Run) { IsBackground = true' Name = "Transaction Thread" };                      threadRealTime = new Thread(_algorithmHandlers.RealTime.Run) { IsBackground = true' Name = "RealTime Thread" };                        //Launch the data feed' result sending' and transaction models/handlers in separate threads.                      threadFeed.Start(); // Data feed pushing data packets into thread bridge;                      threadTransactions.Start(); // Transaction modeller scanning new order requests                      threadRealTime.Start(); // RealTime scan time for time based events:                        // Result manager scanning message queue: (started earlier)                      _algorithmHandlers.Results.DebugMessage(string.Format("Launching analysis for {0} with LEAN Engine v{1}"' job.AlgorithmId' Globals.Version));                        try                      {                          //Create a new engine isolator class                          var isolator = new Isolator();                            // Execute the Algorithm Code:                          var complete = isolator.ExecuteWithTimeLimit(_algorithmHandlers.Setup.MaximumRuntime' algorithmManager.TimeLoopWithinLimits' () =>                          {                              try                              {                                  //Run Algorithm Job:                                  // -> Using this Data Feed'                                  // -> Send Orders to this TransactionHandler'                                  // -> Send Results to ResultHandler.                                  algorithmManager.Run(job' algorithm' _algorithmHandlers.DataFeed' _algorithmHandlers.Transactions' _algorithmHandlers.Results' _algorithmHandlers.RealTime' _systemHandlers.LeanManager' isolator.CancellationToken);                              }                              catch (Exception err)                              {                                  //Debugging at this level is difficult' stack trace needed.                                  Log.Error(err);                                  algorithm.RunTimeError = err;                                  algorithmManager.SetStatus(AlgorithmStatus.RuntimeError);                                  return;                              }                                Log.Trace("Engine.Run(): Exiting Algorithm Manager");                          }' job.Controls.RamAllocation);                            if (!complete)                          {                              Log.Error("Engine.Main(): Failed to complete in time: " + _algorithmHandlers.Setup.MaximumRuntime.ToString("F"));                              throw new Exception("Failed to complete algorithm within " + _algorithmHandlers.Setup.MaximumRuntime.ToString("F")                                  + " seconds. Please make it run faster.");                          }                            // Algorithm runtime error:                          if (algorithm.RunTimeError != null)                          {                              HandleAlgorithmError(job' algorithm.RunTimeError);                          }                      }                      catch (Exception err)                      {                          //Error running the user algorithm: purge datafeed' send error messages' set algorithm status to failed.                          HandleAlgorithmError(job' err);                      }                        try                      {                          var trades = algorithm.TradeBuilder.ClosedTrades;                          var charts = new Dictionary<string' Chart>(_algorithmHandlers.Results.Charts);                          var orders = new Dictionary<int' Order>(_algorithmHandlers.Transactions.Orders);                          var holdings = new Dictionary<string' Holding>();                          var banner = new Dictionary<string' string>();                          var statisticsResults = new StatisticsResults();                            var csvTransactionsFileName = Config.Get("transaction-log");                          if (!string.IsNullOrEmpty(csvTransactionsFileName))                          {                              SaveListOfTrades(_algorithmHandlers.Transactions' csvTransactionsFileName);                          }                            try                          {                              //Generates error when things don't exist (no charting logged' runtime errors in main algo execution)                              const string strategyEquityKey = "Strategy Equity";                              const string equityKey = "Equity";                              const string dailyPerformanceKey = "Daily Performance";                              const string benchmarkKey = "Benchmark";                                // make sure we've taken samples for these series before just blindly requesting them                              if (charts.ContainsKey(strategyEquityKey) &&                                  charts[strategyEquityKey].Series.ContainsKey(equityKey) &&                                  charts[strategyEquityKey].Series.ContainsKey(dailyPerformanceKey) &&                                  charts.ContainsKey(benchmarkKey) &&                                  charts[benchmarkKey].Series.ContainsKey(benchmarkKey)                              )                              {                                  var equity = charts[strategyEquityKey].Series[equityKey].Values;                                  var performance = charts[strategyEquityKey].Series[dailyPerformanceKey].Values;                                  var profitLoss = new SortedDictionary<DateTime' decimal>(algorithm.Transactions.TransactionRecord);                                  var totalTransactions = algorithm.Transactions.GetOrders(x => x.Status.IsFill()).Count();                                  var benchmark = charts[benchmarkKey].Series[benchmarkKey].Values;                                    statisticsResults = StatisticsBuilder.Generate(trades' profitLoss' equity' performance' benchmark'                                      _algorithmHandlers.Setup.StartingPortfolioValue' algorithm.Portfolio.TotalFees' totalTransactions);                                    //Some users have $0 in their brokerage account / starting cash of $0. Prevent divide by zero errors                                  var netReturn = _algorithmHandlers.Setup.StartingPortfolioValue > 0 ?                                                  (algorithm.Portfolio.TotalPortfolioValue - _algorithmHandlers.Setup.StartingPortfolioValue) / _algorithmHandlers.Setup.StartingPortfolioValue                                                  : 0;                                    //Add other fixed parameters.                                  banner.Add("Unrealized"' "$" + algorithm.Portfolio.TotalUnrealizedProfit.ToString("N2"));                                  banner.Add("Fees"' "-$" + algorithm.Portfolio.TotalFees.ToString("N2"));                                  banner.Add("Net Profit"' "$" + algorithm.Portfolio.TotalProfit.ToString("N2"));                                  banner.Add("Return"' netReturn.ToString("P"));                                  banner.Add("Equity"' "$" + algorithm.Portfolio.TotalPortfolioValue.ToString("N2"));                              }                          }                          catch (Exception err)                          {                              Log.Error(err' "Error generating statistics packet");                          }                            //Diagnostics Completed' Send Result Packet:                          var totalSeconds = (DateTime.Now - startTime).TotalSeconds;                          var dataPoints = algorithmManager.DataPoints + algorithm.HistoryProvider.DataPointCount;                          _algorithmHandlers.Results.DebugMessage(                              string.Format("Algorithm Id:({0}) completed in {1} seconds at {2}k data points per second. Processing total of {3} data points."'                                  job.AlgorithmId' totalSeconds.ToString("F2")' ((dataPoints/(double) 1000)/totalSeconds).ToString("F0")'                                  dataPoints.ToString("N0")));                            _algorithmHandlers.Results.SendFinalResult(job' orders' algorithm.Transactions.TransactionRecord' holdings' algorithm.Portfolio.CashBook' statisticsResults' banner);                      }                      catch (Exception err)                      {                          Log.Error(err' "Error sending analysis results");                      }                        //Before we return' send terminate commands to close up the threads                      _algorithmHandlers.Transactions.Exit();                      _algorithmHandlers.DataFeed.Exit();                      _algorithmHandlers.RealTime.Exit();                  }                    //Close result handler:                  _algorithmHandlers.Results.Exit();                    //Wait for the threads to complete:                  var ts = Stopwatch.StartNew();                  while ((_algorithmHandlers.Results.IsActive                      || (_algorithmHandlers.Transactions != null && _algorithmHandlers.Transactions.IsActive)                      || (_algorithmHandlers.DataFeed != null && _algorithmHandlers.DataFeed.IsActive)                      || (_algorithmHandlers.RealTime != null && _algorithmHandlers.RealTime.IsActive))                      && ts.ElapsedMilliseconds < 30*1000)                  {                      Thread.Sleep(100);                      Log.Trace("Waiting for threads to exit...");                  }                    //Terminate threads still in active state.                  if (threadFeed != null && threadFeed.IsAlive) threadFeed.Abort();                  if (threadTransactions != null && threadTransactions.IsAlive) threadTransactions.Abort();                  if (threadResults != null && threadResults.IsAlive) threadResults.Abort();                    if (brokerage != null)                  {                      Log.Trace("Engine.Run(): Disconnecting from brokerage...");                      brokerage.Disconnect();                      brokerage.Dispose();                  }                  if (_algorithmHandlers.Setup != null)                  {                      Log.Trace("Engine.Run(): Disposing of setup handler...");                      _algorithmHandlers.Setup.Dispose();                  }                  Log.Trace("Engine.Main(): Analysis Completed and Results Posted.");              }              catch (Exception err)              {                  Log.Error(err' "Error running algorithm");              }              finally              {                  //No matter what for live mode; make sure we've set algorithm status in the API for "not running" conditions:                  if (_liveMode && algorithmManager.State != AlgorithmStatus.Running && algorithmManager.State != AlgorithmStatus.RuntimeError)                      _systemHandlers.Api.SetAlgorithmStatus(job.AlgorithmId' algorithmManager.State);                    _algorithmHandlers.Results.Exit();                  _algorithmHandlers.DataFeed.Exit();                  _algorithmHandlers.Transactions.Exit();                  _algorithmHandlers.RealTime.Exit();              }
Magic Number,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The following statement contains a magic number: try              {                  //Reset thread holders.                  var initializeComplete = false;                  Thread threadFeed = null;                  Thread threadTransactions = null;                  Thread threadResults = null;                  Thread threadRealTime = null;                    //-> Initialize messaging system                  _systemHandlers.Notify.SetAuthentication(job);                    //-> Set the result handler type for this algorithm job' and launch the associated result thread.                  _algorithmHandlers.Results.Initialize(job' _systemHandlers.Notify' _systemHandlers.Api' _algorithmHandlers.DataFeed' _algorithmHandlers.Setup' _algorithmHandlers.Transactions);                    threadResults = new Thread(_algorithmHandlers.Results.Run' 0) { IsBackground = true' Name = "Result Thread" };                  threadResults.Start();                    IBrokerage brokerage = null;                  try                  {                      // Save algorithm to cache' load algorithm instance:                      algorithm = _algorithmHandlers.Setup.CreateAlgorithmInstance(job' assemblyPath);                        // Set algorithm in ILeanManager                      _systemHandlers.LeanManager.SetAlgorithm(algorithm);                        // Initialize the brokerage                      IBrokerageFactory factory;                      brokerage = _algorithmHandlers.Setup.CreateBrokerage(job' algorithm' out factory);                        // Initialize the data feed before we initialize so he can intercept added securities/universes via events                      _algorithmHandlers.DataFeed.Initialize(algorithm' job' _algorithmHandlers.Results' _algorithmHandlers.MapFileProvider' _algorithmHandlers.FactorFileProvider' _algorithmHandlers.DataProvider);                        // set the order processor on the transaction manager (needs to be done before initializing BrokerageHistoryProvider)                      algorithm.Transactions.SetOrderProcessor(_algorithmHandlers.Transactions);                        // set the history provider before setting up the algorithm                      var historyProvider = GetHistoryProvider(job.HistoryProvider);                      if (historyProvider is BrokerageHistoryProvider)                      {                          (historyProvider as BrokerageHistoryProvider).SetBrokerage(brokerage);                      }                        var historyDataCacheProvider = new ZipDataCacheProvider(_algorithmHandlers.DataProvider);                      historyProvider.Initialize(job' _algorithmHandlers.DataProvider' historyDataCacheProvider' _algorithmHandlers.MapFileProvider' _algorithmHandlers.FactorFileProvider' progress =>                      {                          // send progress updates to the result handler only during initialization                          if (!algorithm.GetLocked() || algorithm.IsWarmingUp)                          {                              _algorithmHandlers.Results.SendStatusUpdate(AlgorithmStatus.History'                                  string.Format("Processing history {0}%..."' progress));                          }                      });                        algorithm.HistoryProvider = historyProvider;                        // initialize the default brokerage message handler                      algorithm.BrokerageMessageHandler = factory.CreateBrokerageMessageHandler(algorithm' job' _systemHandlers.Api);                        //Initialize the internal state of algorithm and job: executes the algorithm.Initialize() method.                      initializeComplete = _algorithmHandlers.Setup.Setup(algorithm' brokerage' job' _algorithmHandlers.Results' _algorithmHandlers.Transactions' _algorithmHandlers.RealTime);                        // set this again now that we've actually added securities                      _algorithmHandlers.Results.SetAlgorithm(algorithm);                        //If there are any reasons it failed' pass these back to the IDE.                      if (!initializeComplete || algorithm.ErrorMessages.Count > 0 || _algorithmHandlers.Setup.Errors.Count > 0)                      {                          initializeComplete = false;                          //Get all the error messages: internal in algorithm and external in setup handler.                          var errorMessage = String.Join("'"' algorithm.ErrorMessages);                          errorMessage += String.Join("'"' _algorithmHandlers.Setup.Errors);                          Log.Error("Engine.Run(): " + errorMessage);                          _algorithmHandlers.Results.RuntimeError(errorMessage);                          _systemHandlers.Api.SetAlgorithmStatus(job.AlgorithmId' AlgorithmStatus.RuntimeError' errorMessage);                      }                  }                  catch (Exception err)                  {                      Log.Error(err);                      var runtimeMessage = "Algorithm.Initialize() Error: " + err.Message + " Stack Trace: " + err.StackTrace;                      _algorithmHandlers.Results.RuntimeError(runtimeMessage' err.StackTrace);                      _systemHandlers.Api.SetAlgorithmStatus(job.AlgorithmId' AlgorithmStatus.RuntimeError' runtimeMessage);                  }                      // log the job endpoints                  Log.Trace("JOB HANDLERS: ");                  Log.Trace("         DataFeed:     " + _algorithmHandlers.DataFeed.GetType().FullName);                  Log.Trace("         Setup:        " + _algorithmHandlers.Setup.GetType().FullName);                  Log.Trace("         RealTime:     " + _algorithmHandlers.RealTime.GetType().FullName);                  Log.Trace("         Results:      " + _algorithmHandlers.Results.GetType().FullName);                  Log.Trace("         Transactions: " + _algorithmHandlers.Transactions.GetType().FullName);                  if (algorithm != null && algorithm.HistoryProvider != null)                  {                      Log.Trace("         History Provider:     " + algorithm.HistoryProvider.GetType().FullName);                  }                  if (job is LiveNodePacket) Log.Trace("         Brokerage:      " + brokerage.GetType().FullName);                    //-> Using the job + initialization: load the designated handlers:                  if (initializeComplete)                  {                      //-> Reset the backtest stopwatch; we're now running the algorithm.                      var startTime = DateTime.Now;                        //Set algorithm as locked; set it to live mode if we're trading live' and set it to locked for no further updates.                      algorithm.SetAlgorithmId(job.AlgorithmId);                      algorithm.SetLocked();                        //Load the associated handlers for transaction and realtime events:                      _algorithmHandlers.Transactions.Initialize(algorithm' brokerage' _algorithmHandlers.Results);                      _algorithmHandlers.RealTime.Setup(algorithm' job' _algorithmHandlers.Results' _systemHandlers.Api);                        // wire up the brokerage message handler                      brokerage.Message += (sender' message) =>                      {                          algorithm.BrokerageMessageHandler.Handle(message);                            // fire brokerage message events                          algorithm.OnBrokerageMessage(message);                          switch (message.Type)                          {                              case BrokerageMessageType.Disconnect:                                  algorithm.OnBrokerageDisconnect();                                  break;                              case BrokerageMessageType.Reconnect:                                  algorithm.OnBrokerageReconnect();                                  break;                          }                      };                        //Send status to user the algorithm is now executing.                      _algorithmHandlers.Results.SendStatusUpdate(AlgorithmStatus.Running);                        //Launch the data' transaction and realtime handlers into dedicated threads                      threadFeed = new Thread(_algorithmHandlers.DataFeed.Run) { IsBackground = true' Name = "DataFeed Thread" };                      threadTransactions = new Thread(_algorithmHandlers.Transactions.Run) { IsBackground = true' Name = "Transaction Thread" };                      threadRealTime = new Thread(_algorithmHandlers.RealTime.Run) { IsBackground = true' Name = "RealTime Thread" };                        //Launch the data feed' result sending' and transaction models/handlers in separate threads.                      threadFeed.Start(); // Data feed pushing data packets into thread bridge;                      threadTransactions.Start(); // Transaction modeller scanning new order requests                      threadRealTime.Start(); // RealTime scan time for time based events:                        // Result manager scanning message queue: (started earlier)                      _algorithmHandlers.Results.DebugMessage(string.Format("Launching analysis for {0} with LEAN Engine v{1}"' job.AlgorithmId' Globals.Version));                        try                      {                          //Create a new engine isolator class                          var isolator = new Isolator();                            // Execute the Algorithm Code:                          var complete = isolator.ExecuteWithTimeLimit(_algorithmHandlers.Setup.MaximumRuntime' algorithmManager.TimeLoopWithinLimits' () =>                          {                              try                              {                                  //Run Algorithm Job:                                  // -> Using this Data Feed'                                  // -> Send Orders to this TransactionHandler'                                  // -> Send Results to ResultHandler.                                  algorithmManager.Run(job' algorithm' _algorithmHandlers.DataFeed' _algorithmHandlers.Transactions' _algorithmHandlers.Results' _algorithmHandlers.RealTime' _systemHandlers.LeanManager' isolator.CancellationToken);                              }                              catch (Exception err)                              {                                  //Debugging at this level is difficult' stack trace needed.                                  Log.Error(err);                                  algorithm.RunTimeError = err;                                  algorithmManager.SetStatus(AlgorithmStatus.RuntimeError);                                  return;                              }                                Log.Trace("Engine.Run(): Exiting Algorithm Manager");                          }' job.Controls.RamAllocation);                            if (!complete)                          {                              Log.Error("Engine.Main(): Failed to complete in time: " + _algorithmHandlers.Setup.MaximumRuntime.ToString("F"));                              throw new Exception("Failed to complete algorithm within " + _algorithmHandlers.Setup.MaximumRuntime.ToString("F")                                  + " seconds. Please make it run faster.");                          }                            // Algorithm runtime error:                          if (algorithm.RunTimeError != null)                          {                              HandleAlgorithmError(job' algorithm.RunTimeError);                          }                      }                      catch (Exception err)                      {                          //Error running the user algorithm: purge datafeed' send error messages' set algorithm status to failed.                          HandleAlgorithmError(job' err);                      }                        try                      {                          var trades = algorithm.TradeBuilder.ClosedTrades;                          var charts = new Dictionary<string' Chart>(_algorithmHandlers.Results.Charts);                          var orders = new Dictionary<int' Order>(_algorithmHandlers.Transactions.Orders);                          var holdings = new Dictionary<string' Holding>();                          var banner = new Dictionary<string' string>();                          var statisticsResults = new StatisticsResults();                            var csvTransactionsFileName = Config.Get("transaction-log");                          if (!string.IsNullOrEmpty(csvTransactionsFileName))                          {                              SaveListOfTrades(_algorithmHandlers.Transactions' csvTransactionsFileName);                          }                            try                          {                              //Generates error when things don't exist (no charting logged' runtime errors in main algo execution)                              const string strategyEquityKey = "Strategy Equity";                              const string equityKey = "Equity";                              const string dailyPerformanceKey = "Daily Performance";                              const string benchmarkKey = "Benchmark";                                // make sure we've taken samples for these series before just blindly requesting them                              if (charts.ContainsKey(strategyEquityKey) &&                                  charts[strategyEquityKey].Series.ContainsKey(equityKey) &&                                  charts[strategyEquityKey].Series.ContainsKey(dailyPerformanceKey) &&                                  charts.ContainsKey(benchmarkKey) &&                                  charts[benchmarkKey].Series.ContainsKey(benchmarkKey)                              )                              {                                  var equity = charts[strategyEquityKey].Series[equityKey].Values;                                  var performance = charts[strategyEquityKey].Series[dailyPerformanceKey].Values;                                  var profitLoss = new SortedDictionary<DateTime' decimal>(algorithm.Transactions.TransactionRecord);                                  var totalTransactions = algorithm.Transactions.GetOrders(x => x.Status.IsFill()).Count();                                  var benchmark = charts[benchmarkKey].Series[benchmarkKey].Values;                                    statisticsResults = StatisticsBuilder.Generate(trades' profitLoss' equity' performance' benchmark'                                      _algorithmHandlers.Setup.StartingPortfolioValue' algorithm.Portfolio.TotalFees' totalTransactions);                                    //Some users have $0 in their brokerage account / starting cash of $0. Prevent divide by zero errors                                  var netReturn = _algorithmHandlers.Setup.StartingPortfolioValue > 0 ?                                                  (algorithm.Portfolio.TotalPortfolioValue - _algorithmHandlers.Setup.StartingPortfolioValue) / _algorithmHandlers.Setup.StartingPortfolioValue                                                  : 0;                                    //Add other fixed parameters.                                  banner.Add("Unrealized"' "$" + algorithm.Portfolio.TotalUnrealizedProfit.ToString("N2"));                                  banner.Add("Fees"' "-$" + algorithm.Portfolio.TotalFees.ToString("N2"));                                  banner.Add("Net Profit"' "$" + algorithm.Portfolio.TotalProfit.ToString("N2"));                                  banner.Add("Return"' netReturn.ToString("P"));                                  banner.Add("Equity"' "$" + algorithm.Portfolio.TotalPortfolioValue.ToString("N2"));                              }                          }                          catch (Exception err)                          {                              Log.Error(err' "Error generating statistics packet");                          }                            //Diagnostics Completed' Send Result Packet:                          var totalSeconds = (DateTime.Now - startTime).TotalSeconds;                          var dataPoints = algorithmManager.DataPoints + algorithm.HistoryProvider.DataPointCount;                          _algorithmHandlers.Results.DebugMessage(                              string.Format("Algorithm Id:({0}) completed in {1} seconds at {2}k data points per second. Processing total of {3} data points."'                                  job.AlgorithmId' totalSeconds.ToString("F2")' ((dataPoints/(double) 1000)/totalSeconds).ToString("F0")'                                  dataPoints.ToString("N0")));                            _algorithmHandlers.Results.SendFinalResult(job' orders' algorithm.Transactions.TransactionRecord' holdings' algorithm.Portfolio.CashBook' statisticsResults' banner);                      }                      catch (Exception err)                      {                          Log.Error(err' "Error sending analysis results");                      }                        //Before we return' send terminate commands to close up the threads                      _algorithmHandlers.Transactions.Exit();                      _algorithmHandlers.DataFeed.Exit();                      _algorithmHandlers.RealTime.Exit();                  }                    //Close result handler:                  _algorithmHandlers.Results.Exit();                    //Wait for the threads to complete:                  var ts = Stopwatch.StartNew();                  while ((_algorithmHandlers.Results.IsActive                      || (_algorithmHandlers.Transactions != null && _algorithmHandlers.Transactions.IsActive)                      || (_algorithmHandlers.DataFeed != null && _algorithmHandlers.DataFeed.IsActive)                      || (_algorithmHandlers.RealTime != null && _algorithmHandlers.RealTime.IsActive))                      && ts.ElapsedMilliseconds < 30*1000)                  {                      Thread.Sleep(100);                      Log.Trace("Waiting for threads to exit...");                  }                    //Terminate threads still in active state.                  if (threadFeed != null && threadFeed.IsAlive) threadFeed.Abort();                  if (threadTransactions != null && threadTransactions.IsAlive) threadTransactions.Abort();                  if (threadResults != null && threadResults.IsAlive) threadResults.Abort();                    if (brokerage != null)                  {                      Log.Trace("Engine.Run(): Disconnecting from brokerage...");                      brokerage.Disconnect();                      brokerage.Dispose();                  }                  if (_algorithmHandlers.Setup != null)                  {                      Log.Trace("Engine.Run(): Disposing of setup handler...");                      _algorithmHandlers.Setup.Dispose();                  }                  Log.Trace("Engine.Main(): Analysis Completed and Results Posted.");              }              catch (Exception err)              {                  Log.Error(err' "Error running algorithm");              }              finally              {                  //No matter what for live mode; make sure we've set algorithm status in the API for "not running" conditions:                  if (_liveMode && algorithmManager.State != AlgorithmStatus.Running && algorithmManager.State != AlgorithmStatus.RuntimeError)                      _systemHandlers.Api.SetAlgorithmStatus(job.AlgorithmId' algorithmManager.State);                    _algorithmHandlers.Results.Exit();                  _algorithmHandlers.DataFeed.Exit();                  _algorithmHandlers.Transactions.Exit();                  _algorithmHandlers.RealTime.Exit();              }
Magic Number,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The following statement contains a magic number: try              {                  //Reset thread holders.                  var initializeComplete = false;                  Thread threadFeed = null;                  Thread threadTransactions = null;                  Thread threadResults = null;                  Thread threadRealTime = null;                    //-> Initialize messaging system                  _systemHandlers.Notify.SetAuthentication(job);                    //-> Set the result handler type for this algorithm job' and launch the associated result thread.                  _algorithmHandlers.Results.Initialize(job' _systemHandlers.Notify' _systemHandlers.Api' _algorithmHandlers.DataFeed' _algorithmHandlers.Setup' _algorithmHandlers.Transactions);                    threadResults = new Thread(_algorithmHandlers.Results.Run' 0) { IsBackground = true' Name = "Result Thread" };                  threadResults.Start();                    IBrokerage brokerage = null;                  try                  {                      // Save algorithm to cache' load algorithm instance:                      algorithm = _algorithmHandlers.Setup.CreateAlgorithmInstance(job' assemblyPath);                        // Set algorithm in ILeanManager                      _systemHandlers.LeanManager.SetAlgorithm(algorithm);                        // Initialize the brokerage                      IBrokerageFactory factory;                      brokerage = _algorithmHandlers.Setup.CreateBrokerage(job' algorithm' out factory);                        // Initialize the data feed before we initialize so he can intercept added securities/universes via events                      _algorithmHandlers.DataFeed.Initialize(algorithm' job' _algorithmHandlers.Results' _algorithmHandlers.MapFileProvider' _algorithmHandlers.FactorFileProvider' _algorithmHandlers.DataProvider);                        // set the order processor on the transaction manager (needs to be done before initializing BrokerageHistoryProvider)                      algorithm.Transactions.SetOrderProcessor(_algorithmHandlers.Transactions);                        // set the history provider before setting up the algorithm                      var historyProvider = GetHistoryProvider(job.HistoryProvider);                      if (historyProvider is BrokerageHistoryProvider)                      {                          (historyProvider as BrokerageHistoryProvider).SetBrokerage(brokerage);                      }                        var historyDataCacheProvider = new ZipDataCacheProvider(_algorithmHandlers.DataProvider);                      historyProvider.Initialize(job' _algorithmHandlers.DataProvider' historyDataCacheProvider' _algorithmHandlers.MapFileProvider' _algorithmHandlers.FactorFileProvider' progress =>                      {                          // send progress updates to the result handler only during initialization                          if (!algorithm.GetLocked() || algorithm.IsWarmingUp)                          {                              _algorithmHandlers.Results.SendStatusUpdate(AlgorithmStatus.History'                                  string.Format("Processing history {0}%..."' progress));                          }                      });                        algorithm.HistoryProvider = historyProvider;                        // initialize the default brokerage message handler                      algorithm.BrokerageMessageHandler = factory.CreateBrokerageMessageHandler(algorithm' job' _systemHandlers.Api);                        //Initialize the internal state of algorithm and job: executes the algorithm.Initialize() method.                      initializeComplete = _algorithmHandlers.Setup.Setup(algorithm' brokerage' job' _algorithmHandlers.Results' _algorithmHandlers.Transactions' _algorithmHandlers.RealTime);                        // set this again now that we've actually added securities                      _algorithmHandlers.Results.SetAlgorithm(algorithm);                        //If there are any reasons it failed' pass these back to the IDE.                      if (!initializeComplete || algorithm.ErrorMessages.Count > 0 || _algorithmHandlers.Setup.Errors.Count > 0)                      {                          initializeComplete = false;                          //Get all the error messages: internal in algorithm and external in setup handler.                          var errorMessage = String.Join("'"' algorithm.ErrorMessages);                          errorMessage += String.Join("'"' _algorithmHandlers.Setup.Errors);                          Log.Error("Engine.Run(): " + errorMessage);                          _algorithmHandlers.Results.RuntimeError(errorMessage);                          _systemHandlers.Api.SetAlgorithmStatus(job.AlgorithmId' AlgorithmStatus.RuntimeError' errorMessage);                      }                  }                  catch (Exception err)                  {                      Log.Error(err);                      var runtimeMessage = "Algorithm.Initialize() Error: " + err.Message + " Stack Trace: " + err.StackTrace;                      _algorithmHandlers.Results.RuntimeError(runtimeMessage' err.StackTrace);                      _systemHandlers.Api.SetAlgorithmStatus(job.AlgorithmId' AlgorithmStatus.RuntimeError' runtimeMessage);                  }                      // log the job endpoints                  Log.Trace("JOB HANDLERS: ");                  Log.Trace("         DataFeed:     " + _algorithmHandlers.DataFeed.GetType().FullName);                  Log.Trace("         Setup:        " + _algorithmHandlers.Setup.GetType().FullName);                  Log.Trace("         RealTime:     " + _algorithmHandlers.RealTime.GetType().FullName);                  Log.Trace("         Results:      " + _algorithmHandlers.Results.GetType().FullName);                  Log.Trace("         Transactions: " + _algorithmHandlers.Transactions.GetType().FullName);                  if (algorithm != null && algorithm.HistoryProvider != null)                  {                      Log.Trace("         History Provider:     " + algorithm.HistoryProvider.GetType().FullName);                  }                  if (job is LiveNodePacket) Log.Trace("         Brokerage:      " + brokerage.GetType().FullName);                    //-> Using the job + initialization: load the designated handlers:                  if (initializeComplete)                  {                      //-> Reset the backtest stopwatch; we're now running the algorithm.                      var startTime = DateTime.Now;                        //Set algorithm as locked; set it to live mode if we're trading live' and set it to locked for no further updates.                      algorithm.SetAlgorithmId(job.AlgorithmId);                      algorithm.SetLocked();                        //Load the associated handlers for transaction and realtime events:                      _algorithmHandlers.Transactions.Initialize(algorithm' brokerage' _algorithmHandlers.Results);                      _algorithmHandlers.RealTime.Setup(algorithm' job' _algorithmHandlers.Results' _systemHandlers.Api);                        // wire up the brokerage message handler                      brokerage.Message += (sender' message) =>                      {                          algorithm.BrokerageMessageHandler.Handle(message);                            // fire brokerage message events                          algorithm.OnBrokerageMessage(message);                          switch (message.Type)                          {                              case BrokerageMessageType.Disconnect:                                  algorithm.OnBrokerageDisconnect();                                  break;                              case BrokerageMessageType.Reconnect:                                  algorithm.OnBrokerageReconnect();                                  break;                          }                      };                        //Send status to user the algorithm is now executing.                      _algorithmHandlers.Results.SendStatusUpdate(AlgorithmStatus.Running);                        //Launch the data' transaction and realtime handlers into dedicated threads                      threadFeed = new Thread(_algorithmHandlers.DataFeed.Run) { IsBackground = true' Name = "DataFeed Thread" };                      threadTransactions = new Thread(_algorithmHandlers.Transactions.Run) { IsBackground = true' Name = "Transaction Thread" };                      threadRealTime = new Thread(_algorithmHandlers.RealTime.Run) { IsBackground = true' Name = "RealTime Thread" };                        //Launch the data feed' result sending' and transaction models/handlers in separate threads.                      threadFeed.Start(); // Data feed pushing data packets into thread bridge;                      threadTransactions.Start(); // Transaction modeller scanning new order requests                      threadRealTime.Start(); // RealTime scan time for time based events:                        // Result manager scanning message queue: (started earlier)                      _algorithmHandlers.Results.DebugMessage(string.Format("Launching analysis for {0} with LEAN Engine v{1}"' job.AlgorithmId' Globals.Version));                        try                      {                          //Create a new engine isolator class                          var isolator = new Isolator();                            // Execute the Algorithm Code:                          var complete = isolator.ExecuteWithTimeLimit(_algorithmHandlers.Setup.MaximumRuntime' algorithmManager.TimeLoopWithinLimits' () =>                          {                              try                              {                                  //Run Algorithm Job:                                  // -> Using this Data Feed'                                  // -> Send Orders to this TransactionHandler'                                  // -> Send Results to ResultHandler.                                  algorithmManager.Run(job' algorithm' _algorithmHandlers.DataFeed' _algorithmHandlers.Transactions' _algorithmHandlers.Results' _algorithmHandlers.RealTime' _systemHandlers.LeanManager' isolator.CancellationToken);                              }                              catch (Exception err)                              {                                  //Debugging at this level is difficult' stack trace needed.                                  Log.Error(err);                                  algorithm.RunTimeError = err;                                  algorithmManager.SetStatus(AlgorithmStatus.RuntimeError);                                  return;                              }                                Log.Trace("Engine.Run(): Exiting Algorithm Manager");                          }' job.Controls.RamAllocation);                            if (!complete)                          {                              Log.Error("Engine.Main(): Failed to complete in time: " + _algorithmHandlers.Setup.MaximumRuntime.ToString("F"));                              throw new Exception("Failed to complete algorithm within " + _algorithmHandlers.Setup.MaximumRuntime.ToString("F")                                  + " seconds. Please make it run faster.");                          }                            // Algorithm runtime error:                          if (algorithm.RunTimeError != null)                          {                              HandleAlgorithmError(job' algorithm.RunTimeError);                          }                      }                      catch (Exception err)                      {                          //Error running the user algorithm: purge datafeed' send error messages' set algorithm status to failed.                          HandleAlgorithmError(job' err);                      }                        try                      {                          var trades = algorithm.TradeBuilder.ClosedTrades;                          var charts = new Dictionary<string' Chart>(_algorithmHandlers.Results.Charts);                          var orders = new Dictionary<int' Order>(_algorithmHandlers.Transactions.Orders);                          var holdings = new Dictionary<string' Holding>();                          var banner = new Dictionary<string' string>();                          var statisticsResults = new StatisticsResults();                            var csvTransactionsFileName = Config.Get("transaction-log");                          if (!string.IsNullOrEmpty(csvTransactionsFileName))                          {                              SaveListOfTrades(_algorithmHandlers.Transactions' csvTransactionsFileName);                          }                            try                          {                              //Generates error when things don't exist (no charting logged' runtime errors in main algo execution)                              const string strategyEquityKey = "Strategy Equity";                              const string equityKey = "Equity";                              const string dailyPerformanceKey = "Daily Performance";                              const string benchmarkKey = "Benchmark";                                // make sure we've taken samples for these series before just blindly requesting them                              if (charts.ContainsKey(strategyEquityKey) &&                                  charts[strategyEquityKey].Series.ContainsKey(equityKey) &&                                  charts[strategyEquityKey].Series.ContainsKey(dailyPerformanceKey) &&                                  charts.ContainsKey(benchmarkKey) &&                                  charts[benchmarkKey].Series.ContainsKey(benchmarkKey)                              )                              {                                  var equity = charts[strategyEquityKey].Series[equityKey].Values;                                  var performance = charts[strategyEquityKey].Series[dailyPerformanceKey].Values;                                  var profitLoss = new SortedDictionary<DateTime' decimal>(algorithm.Transactions.TransactionRecord);                                  var totalTransactions = algorithm.Transactions.GetOrders(x => x.Status.IsFill()).Count();                                  var benchmark = charts[benchmarkKey].Series[benchmarkKey].Values;                                    statisticsResults = StatisticsBuilder.Generate(trades' profitLoss' equity' performance' benchmark'                                      _algorithmHandlers.Setup.StartingPortfolioValue' algorithm.Portfolio.TotalFees' totalTransactions);                                    //Some users have $0 in their brokerage account / starting cash of $0. Prevent divide by zero errors                                  var netReturn = _algorithmHandlers.Setup.StartingPortfolioValue > 0 ?                                                  (algorithm.Portfolio.TotalPortfolioValue - _algorithmHandlers.Setup.StartingPortfolioValue) / _algorithmHandlers.Setup.StartingPortfolioValue                                                  : 0;                                    //Add other fixed parameters.                                  banner.Add("Unrealized"' "$" + algorithm.Portfolio.TotalUnrealizedProfit.ToString("N2"));                                  banner.Add("Fees"' "-$" + algorithm.Portfolio.TotalFees.ToString("N2"));                                  banner.Add("Net Profit"' "$" + algorithm.Portfolio.TotalProfit.ToString("N2"));                                  banner.Add("Return"' netReturn.ToString("P"));                                  banner.Add("Equity"' "$" + algorithm.Portfolio.TotalPortfolioValue.ToString("N2"));                              }                          }                          catch (Exception err)                          {                              Log.Error(err' "Error generating statistics packet");                          }                            //Diagnostics Completed' Send Result Packet:                          var totalSeconds = (DateTime.Now - startTime).TotalSeconds;                          var dataPoints = algorithmManager.DataPoints + algorithm.HistoryProvider.DataPointCount;                          _algorithmHandlers.Results.DebugMessage(                              string.Format("Algorithm Id:({0}) completed in {1} seconds at {2}k data points per second. Processing total of {3} data points."'                                  job.AlgorithmId' totalSeconds.ToString("F2")' ((dataPoints/(double) 1000)/totalSeconds).ToString("F0")'                                  dataPoints.ToString("N0")));                            _algorithmHandlers.Results.SendFinalResult(job' orders' algorithm.Transactions.TransactionRecord' holdings' algorithm.Portfolio.CashBook' statisticsResults' banner);                      }                      catch (Exception err)                      {                          Log.Error(err' "Error sending analysis results");                      }                        //Before we return' send terminate commands to close up the threads                      _algorithmHandlers.Transactions.Exit();                      _algorithmHandlers.DataFeed.Exit();                      _algorithmHandlers.RealTime.Exit();                  }                    //Close result handler:                  _algorithmHandlers.Results.Exit();                    //Wait for the threads to complete:                  var ts = Stopwatch.StartNew();                  while ((_algorithmHandlers.Results.IsActive                      || (_algorithmHandlers.Transactions != null && _algorithmHandlers.Transactions.IsActive)                      || (_algorithmHandlers.DataFeed != null && _algorithmHandlers.DataFeed.IsActive)                      || (_algorithmHandlers.RealTime != null && _algorithmHandlers.RealTime.IsActive))                      && ts.ElapsedMilliseconds < 30*1000)                  {                      Thread.Sleep(100);                      Log.Trace("Waiting for threads to exit...");                  }                    //Terminate threads still in active state.                  if (threadFeed != null && threadFeed.IsAlive) threadFeed.Abort();                  if (threadTransactions != null && threadTransactions.IsAlive) threadTransactions.Abort();                  if (threadResults != null && threadResults.IsAlive) threadResults.Abort();                    if (brokerage != null)                  {                      Log.Trace("Engine.Run(): Disconnecting from brokerage...");                      brokerage.Disconnect();                      brokerage.Dispose();                  }                  if (_algorithmHandlers.Setup != null)                  {                      Log.Trace("Engine.Run(): Disposing of setup handler...");                      _algorithmHandlers.Setup.Dispose();                  }                  Log.Trace("Engine.Main(): Analysis Completed and Results Posted.");              }              catch (Exception err)              {                  Log.Error(err' "Error running algorithm");              }              finally              {                  //No matter what for live mode; make sure we've set algorithm status in the API for "not running" conditions:                  if (_liveMode && algorithmManager.State != AlgorithmStatus.Running && algorithmManager.State != AlgorithmStatus.RuntimeError)                      _systemHandlers.Api.SetAlgorithmStatus(job.AlgorithmId' algorithmManager.State);                    _algorithmHandlers.Results.Exit();                  _algorithmHandlers.DataFeed.Exit();                  _algorithmHandlers.Transactions.Exit();                  _algorithmHandlers.RealTime.Exit();              }
Magic Number,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The following statement contains a magic number: try              {                  //Reset thread holders.                  var initializeComplete = false;                  Thread threadFeed = null;                  Thread threadTransactions = null;                  Thread threadResults = null;                  Thread threadRealTime = null;                    //-> Initialize messaging system                  _systemHandlers.Notify.SetAuthentication(job);                    //-> Set the result handler type for this algorithm job' and launch the associated result thread.                  _algorithmHandlers.Results.Initialize(job' _systemHandlers.Notify' _systemHandlers.Api' _algorithmHandlers.DataFeed' _algorithmHandlers.Setup' _algorithmHandlers.Transactions);                    threadResults = new Thread(_algorithmHandlers.Results.Run' 0) { IsBackground = true' Name = "Result Thread" };                  threadResults.Start();                    IBrokerage brokerage = null;                  try                  {                      // Save algorithm to cache' load algorithm instance:                      algorithm = _algorithmHandlers.Setup.CreateAlgorithmInstance(job' assemblyPath);                        // Set algorithm in ILeanManager                      _systemHandlers.LeanManager.SetAlgorithm(algorithm);                        // Initialize the brokerage                      IBrokerageFactory factory;                      brokerage = _algorithmHandlers.Setup.CreateBrokerage(job' algorithm' out factory);                        // Initialize the data feed before we initialize so he can intercept added securities/universes via events                      _algorithmHandlers.DataFeed.Initialize(algorithm' job' _algorithmHandlers.Results' _algorithmHandlers.MapFileProvider' _algorithmHandlers.FactorFileProvider' _algorithmHandlers.DataProvider);                        // set the order processor on the transaction manager (needs to be done before initializing BrokerageHistoryProvider)                      algorithm.Transactions.SetOrderProcessor(_algorithmHandlers.Transactions);                        // set the history provider before setting up the algorithm                      var historyProvider = GetHistoryProvider(job.HistoryProvider);                      if (historyProvider is BrokerageHistoryProvider)                      {                          (historyProvider as BrokerageHistoryProvider).SetBrokerage(brokerage);                      }                        var historyDataCacheProvider = new ZipDataCacheProvider(_algorithmHandlers.DataProvider);                      historyProvider.Initialize(job' _algorithmHandlers.DataProvider' historyDataCacheProvider' _algorithmHandlers.MapFileProvider' _algorithmHandlers.FactorFileProvider' progress =>                      {                          // send progress updates to the result handler only during initialization                          if (!algorithm.GetLocked() || algorithm.IsWarmingUp)                          {                              _algorithmHandlers.Results.SendStatusUpdate(AlgorithmStatus.History'                                  string.Format("Processing history {0}%..."' progress));                          }                      });                        algorithm.HistoryProvider = historyProvider;                        // initialize the default brokerage message handler                      algorithm.BrokerageMessageHandler = factory.CreateBrokerageMessageHandler(algorithm' job' _systemHandlers.Api);                        //Initialize the internal state of algorithm and job: executes the algorithm.Initialize() method.                      initializeComplete = _algorithmHandlers.Setup.Setup(algorithm' brokerage' job' _algorithmHandlers.Results' _algorithmHandlers.Transactions' _algorithmHandlers.RealTime);                        // set this again now that we've actually added securities                      _algorithmHandlers.Results.SetAlgorithm(algorithm);                        //If there are any reasons it failed' pass these back to the IDE.                      if (!initializeComplete || algorithm.ErrorMessages.Count > 0 || _algorithmHandlers.Setup.Errors.Count > 0)                      {                          initializeComplete = false;                          //Get all the error messages: internal in algorithm and external in setup handler.                          var errorMessage = String.Join("'"' algorithm.ErrorMessages);                          errorMessage += String.Join("'"' _algorithmHandlers.Setup.Errors);                          Log.Error("Engine.Run(): " + errorMessage);                          _algorithmHandlers.Results.RuntimeError(errorMessage);                          _systemHandlers.Api.SetAlgorithmStatus(job.AlgorithmId' AlgorithmStatus.RuntimeError' errorMessage);                      }                  }                  catch (Exception err)                  {                      Log.Error(err);                      var runtimeMessage = "Algorithm.Initialize() Error: " + err.Message + " Stack Trace: " + err.StackTrace;                      _algorithmHandlers.Results.RuntimeError(runtimeMessage' err.StackTrace);                      _systemHandlers.Api.SetAlgorithmStatus(job.AlgorithmId' AlgorithmStatus.RuntimeError' runtimeMessage);                  }                      // log the job endpoints                  Log.Trace("JOB HANDLERS: ");                  Log.Trace("         DataFeed:     " + _algorithmHandlers.DataFeed.GetType().FullName);                  Log.Trace("         Setup:        " + _algorithmHandlers.Setup.GetType().FullName);                  Log.Trace("         RealTime:     " + _algorithmHandlers.RealTime.GetType().FullName);                  Log.Trace("         Results:      " + _algorithmHandlers.Results.GetType().FullName);                  Log.Trace("         Transactions: " + _algorithmHandlers.Transactions.GetType().FullName);                  if (algorithm != null && algorithm.HistoryProvider != null)                  {                      Log.Trace("         History Provider:     " + algorithm.HistoryProvider.GetType().FullName);                  }                  if (job is LiveNodePacket) Log.Trace("         Brokerage:      " + brokerage.GetType().FullName);                    //-> Using the job + initialization: load the designated handlers:                  if (initializeComplete)                  {                      //-> Reset the backtest stopwatch; we're now running the algorithm.                      var startTime = DateTime.Now;                        //Set algorithm as locked; set it to live mode if we're trading live' and set it to locked for no further updates.                      algorithm.SetAlgorithmId(job.AlgorithmId);                      algorithm.SetLocked();                        //Load the associated handlers for transaction and realtime events:                      _algorithmHandlers.Transactions.Initialize(algorithm' brokerage' _algorithmHandlers.Results);                      _algorithmHandlers.RealTime.Setup(algorithm' job' _algorithmHandlers.Results' _systemHandlers.Api);                        // wire up the brokerage message handler                      brokerage.Message += (sender' message) =>                      {                          algorithm.BrokerageMessageHandler.Handle(message);                            // fire brokerage message events                          algorithm.OnBrokerageMessage(message);                          switch (message.Type)                          {                              case BrokerageMessageType.Disconnect:                                  algorithm.OnBrokerageDisconnect();                                  break;                              case BrokerageMessageType.Reconnect:                                  algorithm.OnBrokerageReconnect();                                  break;                          }                      };                        //Send status to user the algorithm is now executing.                      _algorithmHandlers.Results.SendStatusUpdate(AlgorithmStatus.Running);                        //Launch the data' transaction and realtime handlers into dedicated threads                      threadFeed = new Thread(_algorithmHandlers.DataFeed.Run) { IsBackground = true' Name = "DataFeed Thread" };                      threadTransactions = new Thread(_algorithmHandlers.Transactions.Run) { IsBackground = true' Name = "Transaction Thread" };                      threadRealTime = new Thread(_algorithmHandlers.RealTime.Run) { IsBackground = true' Name = "RealTime Thread" };                        //Launch the data feed' result sending' and transaction models/handlers in separate threads.                      threadFeed.Start(); // Data feed pushing data packets into thread bridge;                      threadTransactions.Start(); // Transaction modeller scanning new order requests                      threadRealTime.Start(); // RealTime scan time for time based events:                        // Result manager scanning message queue: (started earlier)                      _algorithmHandlers.Results.DebugMessage(string.Format("Launching analysis for {0} with LEAN Engine v{1}"' job.AlgorithmId' Globals.Version));                        try                      {                          //Create a new engine isolator class                          var isolator = new Isolator();                            // Execute the Algorithm Code:                          var complete = isolator.ExecuteWithTimeLimit(_algorithmHandlers.Setup.MaximumRuntime' algorithmManager.TimeLoopWithinLimits' () =>                          {                              try                              {                                  //Run Algorithm Job:                                  // -> Using this Data Feed'                                  // -> Send Orders to this TransactionHandler'                                  // -> Send Results to ResultHandler.                                  algorithmManager.Run(job' algorithm' _algorithmHandlers.DataFeed' _algorithmHandlers.Transactions' _algorithmHandlers.Results' _algorithmHandlers.RealTime' _systemHandlers.LeanManager' isolator.CancellationToken);                              }                              catch (Exception err)                              {                                  //Debugging at this level is difficult' stack trace needed.                                  Log.Error(err);                                  algorithm.RunTimeError = err;                                  algorithmManager.SetStatus(AlgorithmStatus.RuntimeError);                                  return;                              }                                Log.Trace("Engine.Run(): Exiting Algorithm Manager");                          }' job.Controls.RamAllocation);                            if (!complete)                          {                              Log.Error("Engine.Main(): Failed to complete in time: " + _algorithmHandlers.Setup.MaximumRuntime.ToString("F"));                              throw new Exception("Failed to complete algorithm within " + _algorithmHandlers.Setup.MaximumRuntime.ToString("F")                                  + " seconds. Please make it run faster.");                          }                            // Algorithm runtime error:                          if (algorithm.RunTimeError != null)                          {                              HandleAlgorithmError(job' algorithm.RunTimeError);                          }                      }                      catch (Exception err)                      {                          //Error running the user algorithm: purge datafeed' send error messages' set algorithm status to failed.                          HandleAlgorithmError(job' err);                      }                        try                      {                          var trades = algorithm.TradeBuilder.ClosedTrades;                          var charts = new Dictionary<string' Chart>(_algorithmHandlers.Results.Charts);                          var orders = new Dictionary<int' Order>(_algorithmHandlers.Transactions.Orders);                          var holdings = new Dictionary<string' Holding>();                          var banner = new Dictionary<string' string>();                          var statisticsResults = new StatisticsResults();                            var csvTransactionsFileName = Config.Get("transaction-log");                          if (!string.IsNullOrEmpty(csvTransactionsFileName))                          {                              SaveListOfTrades(_algorithmHandlers.Transactions' csvTransactionsFileName);                          }                            try                          {                              //Generates error when things don't exist (no charting logged' runtime errors in main algo execution)                              const string strategyEquityKey = "Strategy Equity";                              const string equityKey = "Equity";                              const string dailyPerformanceKey = "Daily Performance";                              const string benchmarkKey = "Benchmark";                                // make sure we've taken samples for these series before just blindly requesting them                              if (charts.ContainsKey(strategyEquityKey) &&                                  charts[strategyEquityKey].Series.ContainsKey(equityKey) &&                                  charts[strategyEquityKey].Series.ContainsKey(dailyPerformanceKey) &&                                  charts.ContainsKey(benchmarkKey) &&                                  charts[benchmarkKey].Series.ContainsKey(benchmarkKey)                              )                              {                                  var equity = charts[strategyEquityKey].Series[equityKey].Values;                                  var performance = charts[strategyEquityKey].Series[dailyPerformanceKey].Values;                                  var profitLoss = new SortedDictionary<DateTime' decimal>(algorithm.Transactions.TransactionRecord);                                  var totalTransactions = algorithm.Transactions.GetOrders(x => x.Status.IsFill()).Count();                                  var benchmark = charts[benchmarkKey].Series[benchmarkKey].Values;                                    statisticsResults = StatisticsBuilder.Generate(trades' profitLoss' equity' performance' benchmark'                                      _algorithmHandlers.Setup.StartingPortfolioValue' algorithm.Portfolio.TotalFees' totalTransactions);                                    //Some users have $0 in their brokerage account / starting cash of $0. Prevent divide by zero errors                                  var netReturn = _algorithmHandlers.Setup.StartingPortfolioValue > 0 ?                                                  (algorithm.Portfolio.TotalPortfolioValue - _algorithmHandlers.Setup.StartingPortfolioValue) / _algorithmHandlers.Setup.StartingPortfolioValue                                                  : 0;                                    //Add other fixed parameters.                                  banner.Add("Unrealized"' "$" + algorithm.Portfolio.TotalUnrealizedProfit.ToString("N2"));                                  banner.Add("Fees"' "-$" + algorithm.Portfolio.TotalFees.ToString("N2"));                                  banner.Add("Net Profit"' "$" + algorithm.Portfolio.TotalProfit.ToString("N2"));                                  banner.Add("Return"' netReturn.ToString("P"));                                  banner.Add("Equity"' "$" + algorithm.Portfolio.TotalPortfolioValue.ToString("N2"));                              }                          }                          catch (Exception err)                          {                              Log.Error(err' "Error generating statistics packet");                          }                            //Diagnostics Completed' Send Result Packet:                          var totalSeconds = (DateTime.Now - startTime).TotalSeconds;                          var dataPoints = algorithmManager.DataPoints + algorithm.HistoryProvider.DataPointCount;                          _algorithmHandlers.Results.DebugMessage(                              string.Format("Algorithm Id:({0}) completed in {1} seconds at {2}k data points per second. Processing total of {3} data points."'                                  job.AlgorithmId' totalSeconds.ToString("F2")' ((dataPoints/(double) 1000)/totalSeconds).ToString("F0")'                                  dataPoints.ToString("N0")));                            _algorithmHandlers.Results.SendFinalResult(job' orders' algorithm.Transactions.TransactionRecord' holdings' algorithm.Portfolio.CashBook' statisticsResults' banner);                      }                      catch (Exception err)                      {                          Log.Error(err' "Error sending analysis results");                      }                        //Before we return' send terminate commands to close up the threads                      _algorithmHandlers.Transactions.Exit();                      _algorithmHandlers.DataFeed.Exit();                      _algorithmHandlers.RealTime.Exit();                  }                    //Close result handler:                  _algorithmHandlers.Results.Exit();                    //Wait for the threads to complete:                  var ts = Stopwatch.StartNew();                  while ((_algorithmHandlers.Results.IsActive                      || (_algorithmHandlers.Transactions != null && _algorithmHandlers.Transactions.IsActive)                      || (_algorithmHandlers.DataFeed != null && _algorithmHandlers.DataFeed.IsActive)                      || (_algorithmHandlers.RealTime != null && _algorithmHandlers.RealTime.IsActive))                      && ts.ElapsedMilliseconds < 30*1000)                  {                      Thread.Sleep(100);                      Log.Trace("Waiting for threads to exit...");                  }                    //Terminate threads still in active state.                  if (threadFeed != null && threadFeed.IsAlive) threadFeed.Abort();                  if (threadTransactions != null && threadTransactions.IsAlive) threadTransactions.Abort();                  if (threadResults != null && threadResults.IsAlive) threadResults.Abort();                    if (brokerage != null)                  {                      Log.Trace("Engine.Run(): Disconnecting from brokerage...");                      brokerage.Disconnect();                      brokerage.Dispose();                  }                  if (_algorithmHandlers.Setup != null)                  {                      Log.Trace("Engine.Run(): Disposing of setup handler...");                      _algorithmHandlers.Setup.Dispose();                  }                  Log.Trace("Engine.Main(): Analysis Completed and Results Posted.");              }              catch (Exception err)              {                  Log.Error(err' "Error running algorithm");              }              finally              {                  //No matter what for live mode; make sure we've set algorithm status in the API for "not running" conditions:                  if (_liveMode && algorithmManager.State != AlgorithmStatus.Running && algorithmManager.State != AlgorithmStatus.RuntimeError)                      _systemHandlers.Api.SetAlgorithmStatus(job.AlgorithmId' algorithmManager.State);                    _algorithmHandlers.Results.Exit();                  _algorithmHandlers.DataFeed.Exit();                  _algorithmHandlers.Transactions.Exit();                  _algorithmHandlers.RealTime.Exit();              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds,LiveOptionChainProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveOptionChainProvider.cs,FindOptionContracts,The following statement contains a magic number: using (var client = new WebClient())              {                  // download the text file                  var url = "https://www.theocc.com/webapps/series-search?symbolType=U&symbol=" + underlyingSymbol;                  var fileContent = client.DownloadString(url);                    // read the lines' skipping the headers                  var lines = fileContent.Split(new[] { "\r\n" }' StringSplitOptions.None).Skip(7);                    // parse the lines' creating the Lean option symbols                  foreach (var line in lines)                  {                      var fields = line.Split('\t');                        var ticker = fields[0].Trim();                      if (ticker != underlyingSymbol)                          continue;                        var expiryDate = new DateTime(fields[2].ToInt32()' fields[3].ToInt32()' fields[4].ToInt32());                      var strike = (fields[5] + "." + fields[6]).ToDecimal();                        if (fields[7].Contains("C"))                      {                          symbols.Add(Symbol.CreateOption(underlyingSymbol' Market.USA' OptionStyle.American' OptionRight.Call' strike' expiryDate));                      }                        if (fields[7].Contains("P"))                      {                          symbols.Add(Symbol.CreateOption(underlyingSymbol' Market.USA' OptionStyle.American' OptionRight.Put' strike' expiryDate));                      }                  }              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds,LiveOptionChainProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveOptionChainProvider.cs,FindOptionContracts,The following statement contains a magic number: using (var client = new WebClient())              {                  // download the text file                  var url = "https://www.theocc.com/webapps/series-search?symbolType=U&symbol=" + underlyingSymbol;                  var fileContent = client.DownloadString(url);                    // read the lines' skipping the headers                  var lines = fileContent.Split(new[] { "\r\n" }' StringSplitOptions.None).Skip(7);                    // parse the lines' creating the Lean option symbols                  foreach (var line in lines)                  {                      var fields = line.Split('\t');                        var ticker = fields[0].Trim();                      if (ticker != underlyingSymbol)                          continue;                        var expiryDate = new DateTime(fields[2].ToInt32()' fields[3].ToInt32()' fields[4].ToInt32());                      var strike = (fields[5] + "." + fields[6]).ToDecimal();                        if (fields[7].Contains("C"))                      {                          symbols.Add(Symbol.CreateOption(underlyingSymbol' Market.USA' OptionStyle.American' OptionRight.Call' strike' expiryDate));                      }                        if (fields[7].Contains("P"))                      {                          symbols.Add(Symbol.CreateOption(underlyingSymbol' Market.USA' OptionStyle.American' OptionRight.Put' strike' expiryDate));                      }                  }              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds,LiveOptionChainProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveOptionChainProvider.cs,FindOptionContracts,The following statement contains a magic number: using (var client = new WebClient())              {                  // download the text file                  var url = "https://www.theocc.com/webapps/series-search?symbolType=U&symbol=" + underlyingSymbol;                  var fileContent = client.DownloadString(url);                    // read the lines' skipping the headers                  var lines = fileContent.Split(new[] { "\r\n" }' StringSplitOptions.None).Skip(7);                    // parse the lines' creating the Lean option symbols                  foreach (var line in lines)                  {                      var fields = line.Split('\t');                        var ticker = fields[0].Trim();                      if (ticker != underlyingSymbol)                          continue;                        var expiryDate = new DateTime(fields[2].ToInt32()' fields[3].ToInt32()' fields[4].ToInt32());                      var strike = (fields[5] + "." + fields[6]).ToDecimal();                        if (fields[7].Contains("C"))                      {                          symbols.Add(Symbol.CreateOption(underlyingSymbol' Market.USA' OptionStyle.American' OptionRight.Call' strike' expiryDate));                      }                        if (fields[7].Contains("P"))                      {                          symbols.Add(Symbol.CreateOption(underlyingSymbol' Market.USA' OptionStyle.American' OptionRight.Put' strike' expiryDate));                      }                  }              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds,LiveOptionChainProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveOptionChainProvider.cs,FindOptionContracts,The following statement contains a magic number: using (var client = new WebClient())              {                  // download the text file                  var url = "https://www.theocc.com/webapps/series-search?symbolType=U&symbol=" + underlyingSymbol;                  var fileContent = client.DownloadString(url);                    // read the lines' skipping the headers                  var lines = fileContent.Split(new[] { "\r\n" }' StringSplitOptions.None).Skip(7);                    // parse the lines' creating the Lean option symbols                  foreach (var line in lines)                  {                      var fields = line.Split('\t');                        var ticker = fields[0].Trim();                      if (ticker != underlyingSymbol)                          continue;                        var expiryDate = new DateTime(fields[2].ToInt32()' fields[3].ToInt32()' fields[4].ToInt32());                      var strike = (fields[5] + "." + fields[6]).ToDecimal();                        if (fields[7].Contains("C"))                      {                          symbols.Add(Symbol.CreateOption(underlyingSymbol' Market.USA' OptionStyle.American' OptionRight.Call' strike' expiryDate));                      }                        if (fields[7].Contains("P"))                      {                          symbols.Add(Symbol.CreateOption(underlyingSymbol' Market.USA' OptionStyle.American' OptionRight.Put' strike' expiryDate));                      }                  }              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds,LiveOptionChainProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveOptionChainProvider.cs,FindOptionContracts,The following statement contains a magic number: using (var client = new WebClient())              {                  // download the text file                  var url = "https://www.theocc.com/webapps/series-search?symbolType=U&symbol=" + underlyingSymbol;                  var fileContent = client.DownloadString(url);                    // read the lines' skipping the headers                  var lines = fileContent.Split(new[] { "\r\n" }' StringSplitOptions.None).Skip(7);                    // parse the lines' creating the Lean option symbols                  foreach (var line in lines)                  {                      var fields = line.Split('\t');                        var ticker = fields[0].Trim();                      if (ticker != underlyingSymbol)                          continue;                        var expiryDate = new DateTime(fields[2].ToInt32()' fields[3].ToInt32()' fields[4].ToInt32());                      var strike = (fields[5] + "." + fields[6]).ToDecimal();                        if (fields[7].Contains("C"))                      {                          symbols.Add(Symbol.CreateOption(underlyingSymbol' Market.USA' OptionStyle.American' OptionRight.Call' strike' expiryDate));                      }                        if (fields[7].Contains("P"))                      {                          symbols.Add(Symbol.CreateOption(underlyingSymbol' Market.USA' OptionStyle.American' OptionRight.Put' strike' expiryDate));                      }                  }              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds,LiveOptionChainProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveOptionChainProvider.cs,FindOptionContracts,The following statement contains a magic number: using (var client = new WebClient())              {                  // download the text file                  var url = "https://www.theocc.com/webapps/series-search?symbolType=U&symbol=" + underlyingSymbol;                  var fileContent = client.DownloadString(url);                    // read the lines' skipping the headers                  var lines = fileContent.Split(new[] { "\r\n" }' StringSplitOptions.None).Skip(7);                    // parse the lines' creating the Lean option symbols                  foreach (var line in lines)                  {                      var fields = line.Split('\t');                        var ticker = fields[0].Trim();                      if (ticker != underlyingSymbol)                          continue;                        var expiryDate = new DateTime(fields[2].ToInt32()' fields[3].ToInt32()' fields[4].ToInt32());                      var strike = (fields[5] + "." + fields[6]).ToDecimal();                        if (fields[7].Contains("C"))                      {                          symbols.Add(Symbol.CreateOption(underlyingSymbol' Market.USA' OptionStyle.American' OptionRight.Call' strike' expiryDate));                      }                        if (fields[7].Contains("P"))                      {                          symbols.Add(Symbol.CreateOption(underlyingSymbol' Market.USA' OptionStyle.American' OptionRight.Put' strike' expiryDate));                      }                  }              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds,LiveOptionChainProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveOptionChainProvider.cs,FindOptionContracts,The following statement contains a magic number: using (var client = new WebClient())              {                  // download the text file                  var url = "https://www.theocc.com/webapps/series-search?symbolType=U&symbol=" + underlyingSymbol;                  var fileContent = client.DownloadString(url);                    // read the lines' skipping the headers                  var lines = fileContent.Split(new[] { "\r\n" }' StringSplitOptions.None).Skip(7);                    // parse the lines' creating the Lean option symbols                  foreach (var line in lines)                  {                      var fields = line.Split('\t');                        var ticker = fields[0].Trim();                      if (ticker != underlyingSymbol)                          continue;                        var expiryDate = new DateTime(fields[2].ToInt32()' fields[3].ToInt32()' fields[4].ToInt32());                      var strike = (fields[5] + "." + fields[6]).ToDecimal();                        if (fields[7].Contains("C"))                      {                          symbols.Add(Symbol.CreateOption(underlyingSymbol' Market.USA' OptionStyle.American' OptionRight.Call' strike' expiryDate));                      }                        if (fields[7].Contains("P"))                      {                          symbols.Add(Symbol.CreateOption(underlyingSymbol' Market.USA' OptionStyle.American' OptionRight.Put' strike' expiryDate));                      }                  }              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds,LiveOptionChainProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveOptionChainProvider.cs,FindOptionContracts,The following statement contains a magic number: using (var client = new WebClient())              {                  // download the text file                  var url = "https://www.theocc.com/webapps/series-search?symbolType=U&symbol=" + underlyingSymbol;                  var fileContent = client.DownloadString(url);                    // read the lines' skipping the headers                  var lines = fileContent.Split(new[] { "\r\n" }' StringSplitOptions.None).Skip(7);                    // parse the lines' creating the Lean option symbols                  foreach (var line in lines)                  {                      var fields = line.Split('\t');                        var ticker = fields[0].Trim();                      if (ticker != underlyingSymbol)                          continue;                        var expiryDate = new DateTime(fields[2].ToInt32()' fields[3].ToInt32()' fields[4].ToInt32());                      var strike = (fields[5] + "." + fields[6]).ToDecimal();                        if (fields[7].Contains("C"))                      {                          symbols.Add(Symbol.CreateOption(underlyingSymbol' Market.USA' OptionStyle.American' OptionRight.Call' strike' expiryDate));                      }                        if (fields[7].Contains("P"))                      {                          symbols.Add(Symbol.CreateOption(underlyingSymbol' Market.USA' OptionStyle.American' OptionRight.Put' strike' expiryDate));                      }                  }              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds,LiveTradingDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\LiveTradingDataFeed.cs,Initialize,The following statement contains a magic number: _customExchange = new BaseDataExchange("CustomDataExchange") {SleepInterval = 10};
Magic Number,QuantConnect.Lean.Engine.DataFeeds,SubscriptionDataSourceReader,C:\repos\QuantConnect_Lean\Engine\DataFeeds\SubscriptionDataSourceReader.cs,CheckRemoteFileCache,The following statement contains a magic number: foreach (var file in Directory.EnumerateFiles(Globals.Cache))              {                  if (File.GetCreationTime(file) < DateTime.Now.AddHours(-24)) File.Delete(file);              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds,ZipDataCacheProvider,C:\repos\QuantConnect_Lean\Engine\DataFeeds\ZipDataCacheProvider.cs,Fetch,The following statement contains a magic number: if (filename.GetExtension() == ".zip")              {                  Stream stream = null;                    // scan the cache once every 3 seconds                  if (_lastCacheScan == DateTime.MinValue || _lastCacheScan < DateTime.Now.AddSeconds(-3))                  {                      CleanCache();                  }                    try                  {                      CachedZipFile existingEntry;                      if (!_zipFileCache.TryGetValue(filename' out existingEntry))                      {                          var dataStream = _dataProvider.Fetch(filename);                            if (dataStream != null)                          {                              try                              {                                  var newItem = new CachedZipFile(ZipFile.Read(dataStream)' filename);                                    lock (_zipFileSynchronizer)                                  {                                      stream = CreateStream(newItem.ZipFile' entryName);                                  }                                    _zipFileCache.TryAdd(filename' newItem);                              }                              catch (Exception exception)                              {                                  if (exception is ZipException || exception is ZlibException)                                  {                                      Log.Error("ZipDataCacheProvider.Fetch(): Corrupt zip file/entry: " + filename + "#" + entryName + " Error: " + exception);                                  }                                  else throw;                              }                          }                      }                      else                      {                          try                          {                              lock (_zipFileSynchronizer)                              {                                  stream = CreateStream(existingEntry.ZipFile' entryName);                              }                          }                          catch (Exception exception)                          {                              if (exception is ZipException || exception is ZlibException)                              {                                  Log.Error("ZipDataCacheProvider.Fetch(): Corrupt zip file/entry: " + filename + "#" + entryName + " Error: " + exception);                              }                              else throw;                          }                      }                        return stream;                  }                  catch (Exception err)                  {                      Log.Error(err' "Inner try/catch");                      if (stream != null) stream.Dispose();                      return null;                  }              }              else              {                  // handles text files                  return _dataProvider.Fetch(filename);              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,Initialize,The following statement contains a magic number: var threadCount = Math.Max(1' Math.Min(4' Environment.ProcessorCount - 3));
Magic Number,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,Initialize,The following statement contains a magic number: var threadCount = Math.Max(1' Math.Min(4' Environment.ProcessorCount - 3));
Magic Number,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,CreateUniverseSubscription,The following statement contains a magic number: var firstLoopCount = 5;
Magic Number,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,CreateUniverseSubscription,The following statement contains a magic number: if (config.Type == typeof (CoarseFundamental))              {                  firstLoopCount = 2;                  lowerThreshold = 5;                  upperThreshold = 100000;              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,CreateUniverseSubscription,The following statement contains a magic number: if (config.Type == typeof (CoarseFundamental))              {                  firstLoopCount = 2;                  lowerThreshold = 5;                  upperThreshold = 100000;              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,CreateUniverseSubscription,The following statement contains a magic number: if (config.Type == typeof (CoarseFundamental))              {                  firstLoopCount = 2;                  lowerThreshold = 5;                  upperThreshold = 100000;              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,GetLowerThreshold,The following statement contains a magic number: switch (resolution)              {                  case Resolution.Tick:                      return 500;                    case Resolution.Second:                  case Resolution.Minute:                  case Resolution.Hour:                  case Resolution.Daily:                      return 250;                    default:                      throw new ArgumentOutOfRangeException("resolution"' resolution' null);              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,GetLowerThreshold,The following statement contains a magic number: switch (resolution)              {                  case Resolution.Tick:                      return 500;                    case Resolution.Second:                  case Resolution.Minute:                  case Resolution.Hour:                  case Resolution.Daily:                      return 250;                    default:                      throw new ArgumentOutOfRangeException("resolution"' resolution' null);              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,GetUpperThreshold,The following statement contains a magic number: switch (resolution)              {                  case Resolution.Tick:                      return 10000;                    case Resolution.Second:                  case Resolution.Minute:                  case Resolution.Hour:                  case Resolution.Daily:                      return 5000;                    default:                      throw new ArgumentOutOfRangeException("resolution"' resolution' null);              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds,FileSystemDataFeed,C:\repos\QuantConnect_Lean\Engine\DataFeeds\FileSystemDataFeed.cs,GetUpperThreshold,The following statement contains a magic number: switch (resolution)              {                  case Resolution.Tick:                      return 10000;                    case Resolution.Second:                  case Resolution.Minute:                  case Resolution.Hour:                  case Resolution.Daily:                      return 5000;                    default:                      throw new ArgumentOutOfRangeException("resolution"' resolution' null);              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories,LiveCustomDataSubscriptionEnumeratorFactory,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\Factories\LiveCustomDataSubscriptionEnumeratorFactory.cs,GetMinimumTimeBetweenCalls,The following statement contains a magic number: return TimeSpan.FromTicks(Math.Min(increment.Ticks' TimeSpan.FromMinutes(30).Ticks));
Magic Number,QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories,LiveCustomDataSubscriptionEnumeratorFactory,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\Factories\LiveCustomDataSubscriptionEnumeratorFactory.cs,GetMaximumDataAge,The following statement contains a magic number: return TimeSpan.FromTicks(Math.Max(increment.Ticks' TimeSpan.FromSeconds(5).Ticks));
Magic Number,QuantConnect.Lean.Engine.DataFeeds.Enumerators,SynchronizingEnumerator,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Enumerators\SynchronizingEnumerator.cs,GetSynchronizedEnumerator,The following statement contains a magic number: if (streamCount < 500)              {                  //Less than 50 streams use the brute force method:                  return GetBruteForceMethod(enumerators);              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds.Queues,FakeDataQueue,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Queues\FakeDataQueue.cs,FakeDataQueue,The following statement contains a magic number: _timer = new Timer              {                  AutoReset = true'                  Enabled = true'                  Interval = 1000'              };
Magic Number,QuantConnect.Lean.Engine.DataFeeds.Queues,FakeDataQueue,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Queues\FakeDataQueue.cs,PopulateQueue,The following statement contains a magic number: foreach (var symbol in symbols)              {                  // emits 500k per second                  for (int i = 0; i < 500000; i++)                  {                      _ticks.Enqueue(new Tick                      {                          Time = DateTime.Now'                          Symbol = symbol'                          Value = 10 + (decimal)Math.Abs(Math.Sin(DateTime.Now.TimeOfDay.TotalMinutes))'                          TickType = TickType.Trade'                          Quantity = _random.Next(10' (int)_timer.Interval)                      });                  }              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds.Queues,FakeDataQueue,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Queues\FakeDataQueue.cs,PopulateQueue,The following statement contains a magic number: foreach (var symbol in symbols)              {                  // emits 500k per second                  for (int i = 0; i < 500000; i++)                  {                      _ticks.Enqueue(new Tick                      {                          Time = DateTime.Now'                          Symbol = symbol'                          Value = 10 + (decimal)Math.Abs(Math.Sin(DateTime.Now.TimeOfDay.TotalMinutes))'                          TickType = TickType.Trade'                          Quantity = _random.Next(10' (int)_timer.Interval)                      });                  }              }
Magic Number,QuantConnect.Lean.Engine.DataFeeds.Queues,FakeDataQueue,C:\repos\QuantConnect_Lean\Engine\DataFeeds\Queues\FakeDataQueue.cs,PopulateQueue,The following statement contains a magic number: foreach (var symbol in symbols)              {                  // emits 500k per second                  for (int i = 0; i < 500000; i++)                  {                      _ticks.Enqueue(new Tick                      {                          Time = DateTime.Now'                          Symbol = symbol'                          Value = 10 + (decimal)Math.Abs(Math.Sin(DateTime.Now.TimeOfDay.TotalMinutes))'                          TickType = TickType.Trade'                          Quantity = _random.Next(10' (int)_timer.Interval)                      });                  }              }
Magic Number,QuantConnect.Lean.Engine.Results,DesktopResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\DesktopResultHandler.cs,DesktopResultHandler,The following statement contains a magic number: _resamplePeriod = TimeSpan.FromSeconds(2);
Magic Number,QuantConnect.Lean.Engine.Results,DesktopResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\DesktopResultHandler.cs,DesktopResultHandler,The following statement contains a magic number: _notificationPeriod = TimeSpan.FromSeconds(2);
Magic Number,QuantConnect.Lean.Engine.Results,DesktopResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\DesktopResultHandler.cs,Run,The following statement contains a magic number: while ( !_exitTriggered || Messages.Count > 0 )              {                  Thread.Sleep(100);              }
Magic Number,QuantConnect.Lean.Engine.Results,DesktopResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\DesktopResultHandler.cs,ProcessSynchronousEvents,The following statement contains a magic number: if (time > _nextSample || forceProcess)              {                  //Set next sample time: 4000 samples per backtest                  _nextSample = time.Add(ResamplePeriod);                    //Sample the portfolio value over time for chart.                  SampleEquity(time' Math.Round(_algorithm.Portfolio.TotalPortfolioValue' 4));                    //Also add the user samples / plots to the result handler tracking:                  SampleRange(_algorithm.GetChartUpdates());                    //Sample the asset pricing:                  foreach (var security in _algorithm.Securities.Values)                  {                      SampleAssetPrices(security.Symbol' time' security.Price);                  }              }
Magic Number,QuantConnect.Lean.Engine.Results,DesktopResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\DesktopResultHandler.cs,ProcessSynchronousEvents,The following statement contains a magic number: while (_algorithm.DebugMessages.Count > 0 && debugStopWatch.ElapsedMilliseconds < 250)              {                  string message;                  if (_algorithm.DebugMessages.TryDequeue(out message))                  {                      DebugMessage(message);                  }              }
Magic Number,QuantConnect.Lean.Engine.Results,DesktopResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\DesktopResultHandler.cs,ProcessSynchronousEvents,The following statement contains a magic number: while (_algorithm.ErrorMessages.Count > 0 && errorStopWatch.ElapsedMilliseconds < 250)              {                  string message;                  if (_algorithm.ErrorMessages.TryDequeue(out message))                  {                      ErrorMessage(message);                  }              }
Magic Number,QuantConnect.Lean.Engine.Results,DesktopResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\DesktopResultHandler.cs,ProcessSynchronousEvents,The following statement contains a magic number: while (_algorithm.LogMessages.Count > 0 && logStopWatch.ElapsedMilliseconds < 250)              {                  string message;                  if (_algorithm.LogMessages.TryDequeue(out message))                  {                      LogMessage(message);                  }              }
Magic Number,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,BacktestingResultHandler,The following statement contains a magic number: _notificationPeriod = TimeSpan.FromSeconds(2);
Magic Number,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,Run,The following statement contains a magic number: _lastDaysProcessed = 5;
Magic Number,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,Run,The following statement contains a magic number: try              {                  while (!(_exitTriggered && Messages.Count == 0))                  {                      //While there's no work to do' go back to the algorithm:                      if (Messages.Count == 0)                      {                          Thread.Sleep(50);                      }                      else                      {                          //1. Process Simple Messages in Queue                          Packet packet;                          if (Messages.TryDequeue(out packet))                          {                              _messagingHandler.Send(packet);                          }                      }                        //2. Update the packet scanner:                      Update();                    } // While !End.              }              catch (Exception err)              {                  // unexpected error' we need to close down shop                  Log.Error(err);                  // quit the algorithm due to error                  _algorithm.RunTimeError = err;              }
Magic Number,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,Update,The following statement contains a magic number: try              {                  //Sometimes don't run the update' if not ready or we're ending.                  if (Algorithm == null || Algorithm.Transactions == null || _processingFinalPacket)                  {                      return;                  }                    if (DateTime.Now <= _nextUpdate || !(_daysProcessed > (_lastDaysProcessed + 1))) return;                    //Extract the orders since last update                  var deltaOrders = new Dictionary<int' Order>();                    try                  {                      deltaOrders = (from order in _transactionHandler.Orders                          where order.Value.Time.Date >= _lastUpdate && order.Value.Status == OrderStatus.Filled                          select order).ToDictionary(t => t.Key' t => t.Value);                  }                  catch (Exception err)                  {                      Log.Error(err' "Transactions");                  }                    //Limit length of orders we pass back dynamically to avoid flooding.                  if (deltaOrders.Count > 50) deltaOrders.Clear();                    //Reset loop variables:                  try                  {                      _lastUpdate = Algorithm.Time.Date;                      _lastDaysProcessed = _daysProcessed;                      _nextUpdate = DateTime.Now.AddSeconds(0.5);                  }                  catch (Exception err)                  {                      Log.Error(err' "Can't update variables");                  }                    var deltaCharts = new Dictionary<string' Chart>();                  lock (_chartLock)                  {                      //Get the updates since the last chart                      foreach (var chart in Charts.Values)                      {                          deltaCharts.Add(chart.Name' chart.GetUpdates());                      }                  }                    //Get the runtime statistics from the user algorithm:                  var runtimeStatistics = new Dictionary<string' string>();                  lock (_runtimeLock)                  {                      foreach (var pair in _runtimeStatistics)                      {                          runtimeStatistics.Add(pair.Key' pair.Value);                      }                  }                  runtimeStatistics.Add("Unrealized"' "$" + _algorithm.Portfolio.TotalUnrealizedProfit.ToString("N2"));                  runtimeStatistics.Add("Fees"' "-$" + _algorithm.Portfolio.TotalFees.ToString("N2"));                  runtimeStatistics.Add("Net Profit"' "$" + (_algorithm.Portfolio.TotalProfit - _algorithm.Portfolio.TotalFees).ToString("N2"));                  runtimeStatistics.Add("Return"' ((_algorithm.Portfolio.TotalPortfolioValue - _setupHandler.StartingPortfolioValue) / _setupHandler.StartingPortfolioValue).ToString("P"));                  runtimeStatistics.Add("Equity"' "$" + _algorithm.Portfolio.TotalPortfolioValue.ToString("N2"));                    //Profit Loss Changes:                  var progress = Convert.ToDecimal(_daysProcessed / _jobDays);                  if (progress > 0.999m) progress = 0.999m;                    //1. Cloud Upload -> Upload the whole packet to S3  Immediately:                  var completeResult = new BacktestResult(Charts' _transactionHandler.Orders' Algorithm.Transactions.TransactionRecord' new Dictionary<string' string>()' runtimeStatistics' new Dictionary<string' AlgorithmPerformance>());                  var complete = new BacktestResultPacket(_job' completeResult' progress);                    if (DateTime.Now > _nextS3Update)                  {                      _nextS3Update = DateTime.Now.AddSeconds(30);                      StoreResult(complete' false);                  }                    //2. Backtest Update -> Send the truncated packet to the backtester:                  var splitPackets = SplitPackets(deltaCharts' deltaOrders' runtimeStatistics' progress);                    foreach (var backtestingPacket in splitPackets)                  {                      _messagingHandler.Send(backtestingPacket);                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,Update,The following statement contains a magic number: try              {                  //Sometimes don't run the update' if not ready or we're ending.                  if (Algorithm == null || Algorithm.Transactions == null || _processingFinalPacket)                  {                      return;                  }                    if (DateTime.Now <= _nextUpdate || !(_daysProcessed > (_lastDaysProcessed + 1))) return;                    //Extract the orders since last update                  var deltaOrders = new Dictionary<int' Order>();                    try                  {                      deltaOrders = (from order in _transactionHandler.Orders                          where order.Value.Time.Date >= _lastUpdate && order.Value.Status == OrderStatus.Filled                          select order).ToDictionary(t => t.Key' t => t.Value);                  }                  catch (Exception err)                  {                      Log.Error(err' "Transactions");                  }                    //Limit length of orders we pass back dynamically to avoid flooding.                  if (deltaOrders.Count > 50) deltaOrders.Clear();                    //Reset loop variables:                  try                  {                      _lastUpdate = Algorithm.Time.Date;                      _lastDaysProcessed = _daysProcessed;                      _nextUpdate = DateTime.Now.AddSeconds(0.5);                  }                  catch (Exception err)                  {                      Log.Error(err' "Can't update variables");                  }                    var deltaCharts = new Dictionary<string' Chart>();                  lock (_chartLock)                  {                      //Get the updates since the last chart                      foreach (var chart in Charts.Values)                      {                          deltaCharts.Add(chart.Name' chart.GetUpdates());                      }                  }                    //Get the runtime statistics from the user algorithm:                  var runtimeStatistics = new Dictionary<string' string>();                  lock (_runtimeLock)                  {                      foreach (var pair in _runtimeStatistics)                      {                          runtimeStatistics.Add(pair.Key' pair.Value);                      }                  }                  runtimeStatistics.Add("Unrealized"' "$" + _algorithm.Portfolio.TotalUnrealizedProfit.ToString("N2"));                  runtimeStatistics.Add("Fees"' "-$" + _algorithm.Portfolio.TotalFees.ToString("N2"));                  runtimeStatistics.Add("Net Profit"' "$" + (_algorithm.Portfolio.TotalProfit - _algorithm.Portfolio.TotalFees).ToString("N2"));                  runtimeStatistics.Add("Return"' ((_algorithm.Portfolio.TotalPortfolioValue - _setupHandler.StartingPortfolioValue) / _setupHandler.StartingPortfolioValue).ToString("P"));                  runtimeStatistics.Add("Equity"' "$" + _algorithm.Portfolio.TotalPortfolioValue.ToString("N2"));                    //Profit Loss Changes:                  var progress = Convert.ToDecimal(_daysProcessed / _jobDays);                  if (progress > 0.999m) progress = 0.999m;                    //1. Cloud Upload -> Upload the whole packet to S3  Immediately:                  var completeResult = new BacktestResult(Charts' _transactionHandler.Orders' Algorithm.Transactions.TransactionRecord' new Dictionary<string' string>()' runtimeStatistics' new Dictionary<string' AlgorithmPerformance>());                  var complete = new BacktestResultPacket(_job' completeResult' progress);                    if (DateTime.Now > _nextS3Update)                  {                      _nextS3Update = DateTime.Now.AddSeconds(30);                      StoreResult(complete' false);                  }                    //2. Backtest Update -> Send the truncated packet to the backtester:                  var splitPackets = SplitPackets(deltaCharts' deltaOrders' runtimeStatistics' progress);                    foreach (var backtestingPacket in splitPackets)                  {                      _messagingHandler.Send(backtestingPacket);                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,Update,The following statement contains a magic number: try              {                  //Sometimes don't run the update' if not ready or we're ending.                  if (Algorithm == null || Algorithm.Transactions == null || _processingFinalPacket)                  {                      return;                  }                    if (DateTime.Now <= _nextUpdate || !(_daysProcessed > (_lastDaysProcessed + 1))) return;                    //Extract the orders since last update                  var deltaOrders = new Dictionary<int' Order>();                    try                  {                      deltaOrders = (from order in _transactionHandler.Orders                          where order.Value.Time.Date >= _lastUpdate && order.Value.Status == OrderStatus.Filled                          select order).ToDictionary(t => t.Key' t => t.Value);                  }                  catch (Exception err)                  {                      Log.Error(err' "Transactions");                  }                    //Limit length of orders we pass back dynamically to avoid flooding.                  if (deltaOrders.Count > 50) deltaOrders.Clear();                    //Reset loop variables:                  try                  {                      _lastUpdate = Algorithm.Time.Date;                      _lastDaysProcessed = _daysProcessed;                      _nextUpdate = DateTime.Now.AddSeconds(0.5);                  }                  catch (Exception err)                  {                      Log.Error(err' "Can't update variables");                  }                    var deltaCharts = new Dictionary<string' Chart>();                  lock (_chartLock)                  {                      //Get the updates since the last chart                      foreach (var chart in Charts.Values)                      {                          deltaCharts.Add(chart.Name' chart.GetUpdates());                      }                  }                    //Get the runtime statistics from the user algorithm:                  var runtimeStatistics = new Dictionary<string' string>();                  lock (_runtimeLock)                  {                      foreach (var pair in _runtimeStatistics)                      {                          runtimeStatistics.Add(pair.Key' pair.Value);                      }                  }                  runtimeStatistics.Add("Unrealized"' "$" + _algorithm.Portfolio.TotalUnrealizedProfit.ToString("N2"));                  runtimeStatistics.Add("Fees"' "-$" + _algorithm.Portfolio.TotalFees.ToString("N2"));                  runtimeStatistics.Add("Net Profit"' "$" + (_algorithm.Portfolio.TotalProfit - _algorithm.Portfolio.TotalFees).ToString("N2"));                  runtimeStatistics.Add("Return"' ((_algorithm.Portfolio.TotalPortfolioValue - _setupHandler.StartingPortfolioValue) / _setupHandler.StartingPortfolioValue).ToString("P"));                  runtimeStatistics.Add("Equity"' "$" + _algorithm.Portfolio.TotalPortfolioValue.ToString("N2"));                    //Profit Loss Changes:                  var progress = Convert.ToDecimal(_daysProcessed / _jobDays);                  if (progress > 0.999m) progress = 0.999m;                    //1. Cloud Upload -> Upload the whole packet to S3  Immediately:                  var completeResult = new BacktestResult(Charts' _transactionHandler.Orders' Algorithm.Transactions.TransactionRecord' new Dictionary<string' string>()' runtimeStatistics' new Dictionary<string' AlgorithmPerformance>());                  var complete = new BacktestResultPacket(_job' completeResult' progress);                    if (DateTime.Now > _nextS3Update)                  {                      _nextS3Update = DateTime.Now.AddSeconds(30);                      StoreResult(complete' false);                  }                    //2. Backtest Update -> Send the truncated packet to the backtester:                  var splitPackets = SplitPackets(deltaCharts' deltaOrders' runtimeStatistics' progress);                    foreach (var backtestingPacket in splitPackets)                  {                      _messagingHandler.Send(backtestingPacket);                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,SetAlgorithm,The following statement contains a magic number: _debugMessageMax = Convert.ToInt32(10 * _jobDays);
Magic Number,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,ErrorMessage,The following statement contains a magic number: if (Messages.Count > 500) return;
Magic Number,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,ProcessSynchronousEvents,The following statement contains a magic number: if (time > _nextSample || forceProcess)              {                  //Set next sample time: 4000 samples per backtest                  _nextSample = time.Add(ResamplePeriod);                    //Sample the portfolio value over time for chart.                  SampleEquity(time' Math.Round(_algorithm.Portfolio.TotalPortfolioValue' 4));                    //Also add the user samples / plots to the result handler tracking:                  SampleRange(_algorithm.GetChartUpdates());                    //Sample the asset pricing:                  foreach (var security in _algorithm.Securities.Values)                  {                      SampleAssetPrices(security.Symbol' time' security.Price);                  }              }
Magic Number,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,ProcessSynchronousEvents,The following statement contains a magic number: while (_algorithm.DebugMessages.Count > 0 && debugStopWatch.ElapsedMilliseconds < 250)              {                  string message;                  if (_algorithm.DebugMessages.TryDequeue(out message))                  {                      DebugMessage(message);                  }              }
Magic Number,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,ProcessSynchronousEvents,The following statement contains a magic number: while (_algorithm.ErrorMessages.Count > 0 && errorStopWatch.ElapsedMilliseconds < 250)              {                  string message;                  if (_algorithm.ErrorMessages.TryDequeue(out message))                  {                      ErrorMessage(message);                  }              }
Magic Number,QuantConnect.Lean.Engine.Results,BacktestingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\BacktestingResultHandler.cs,ProcessSynchronousEvents,The following statement contains a magic number: while (_algorithm.LogMessages.Count > 0 && logStopWatch.ElapsedMilliseconds < 250)              {                  string message;                  if (_algorithm.LogMessages.TryDequeue(out message))                  {                      LogMessage(message);                  }              }
Magic Number,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Run,The following statement contains a magic number: while (!(_exitTriggered && Messages.Count == 0))              {                  try                  {                      //1. Process Simple Messages in Queue                      Packet packet;                      if (Messages.TryDequeue(out packet))                      {                          _messagingHandler.Send(packet);                      }                        //2. Update the packet scanner:                      Update();                        if (Messages.Count == 0)                      {                          // prevent thread lock/tight loop when there's no work to be done                          Thread.Sleep(10);                      }                  }                  catch (Exception err)                  {                      Log.Error(err);                  }              }
Magic Number,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Update,The following statement contains a magic number: try              {                  if (DateTime.Now > _nextUpdate || _exitTriggered)                  {                      //Extract the orders created since last update                      OrderEvent orderEvent;                      deltaOrders = new Dictionary<int' Order>();                        var stopwatch = Stopwatch.StartNew();                      while (_orderEvents.TryDequeue(out orderEvent) && stopwatch.ElapsedMilliseconds < 15)                      {                          var order = _algorithm.Transactions.GetOrderById(orderEvent.OrderId);                          deltaOrders[orderEvent.OrderId] = order.Clone();                      }                        //For charting convert to UTC                      foreach (var order in deltaOrders)                      {                          order.Value.Price = order.Value.Price.SmartRounding();                          order.Value.Time = order.Value.Time.ToUniversalTime();                      }                        //Reset loop variables:                      _lastOrderId = (from order in deltaOrders.Values select order.Id).DefaultIfEmpty(_lastOrderId).Max();                        //Limit length of orders we pass back dynamically to avoid flooding.                      //if (deltaOrders.Count > 50) deltaOrders.Clear();                        //Create and send back the changes in chart since the algorithm started.                      var deltaCharts = new Dictionary<string' Chart>();                      Log.Debug("LiveTradingResultHandler.Update(): Build delta charts");                      lock (_chartLock)                      {                          //Get the updates since the last chart                          foreach (var chart in _charts)                          {                              // remove directory pathing characters from chart names                              var safeName = chart.Value.Name.Replace('/'' '-');                              deltaCharts.Add(safeName' chart.Value.GetUpdates());                          }                      }                      Log.Debug("LiveTradingResultHandler.Update(): End build delta charts");                        //Profit loss changes' get the banner statistics' summary information on the performance for the headers.                      var holdings = new Dictionary<string' Holding>();                      var deltaStatistics = new Dictionary<string' string>();                      var runtimeStatistics = new Dictionary<string' string>();                      var serverStatistics = OS.GetServerStatistics();                      var upTime = DateTime.UtcNow - _launchTimeUtc;                      serverStatistics["Up Time"] = string.Format("{0}d {1:hh\\:mm\\:ss}"' upTime.Days' upTime);                      serverStatistics["Total RAM (MB)"] = _job.Controls.RamAllocation.ToString();                        // Only send holdings updates when we have changes in orders' except for first time' then we want to send all                      foreach (var asset in _algorithm.Securities.Values.Where(x => !x.IsInternalFeed() && !x.Symbol.IsCanonical()).OrderBy(x => x.Symbol.Value))                      {                          holdings.Add(asset.Symbol.Value' new Holding(asset));                      }                        //Add the algorithm statistics first.                      Log.Debug("LiveTradingResultHandler.Update(): Build run time stats");                      lock (_runtimeLock)                      {                          foreach (var pair in _runtimeStatistics)                          {                              runtimeStatistics.Add(pair.Key' pair.Value);                          }                      }                      Log.Debug("LiveTradingResultHandler.Update(): End build run time stats");                        //Some users have $0 in their brokerage account / starting cash of $0. Prevent divide by zero errors                      var netReturn = _setupHandler.StartingPortfolioValue > 0 ?                                      (_algorithm.Portfolio.TotalPortfolioValue - _setupHandler.StartingPortfolioValue) / _setupHandler.StartingPortfolioValue                                      : 0;                        //Add other fixed parameters.                      runtimeStatistics.Add("Unrealized:"' "$" + _algorithm.Portfolio.TotalUnrealizedProfit.ToString("N2"));                      runtimeStatistics.Add("Fees:"' "-$" + _algorithm.Portfolio.TotalFees.ToString("N2"));                      runtimeStatistics.Add("Net Profit:"' "$" + (_algorithm.Portfolio.TotalProfit - _algorithm.Portfolio.TotalFees).ToString("N2"));                      runtimeStatistics.Add("Return:"' netReturn.ToString("P"));                      runtimeStatistics.Add("Equity:"' "$" + _algorithm.Portfolio.TotalPortfolioValue.ToString("N2"));                      runtimeStatistics.Add("Holdings:"' "$" + _algorithm.Portfolio.TotalHoldingsValue.ToString("N2"));                      runtimeStatistics.Add("Volume:"' "$" + _algorithm.Portfolio.TotalSaleVolume.ToString("N2"));                        // since we're sending multiple packets' let's do it async and forget about it                      // chart data can get big so let's break them up into groups                      var splitPackets = SplitPackets(deltaCharts' deltaOrders' holdings' _algorithm.Portfolio.CashBook' deltaStatistics' runtimeStatistics' serverStatistics);                        foreach (var liveResultPacket in splitPackets)                      {                          _messagingHandler.Send(liveResultPacket);                      }                        //Send full packet to storage.                      if (DateTime.Now > _nextChartsUpdate || _exitTriggered)                      {                          Log.Debug("LiveTradingResultHandler.Update(): Pre-store result");                          _nextChartsUpdate = DateTime.Now.AddMinutes(1);                          var chartComplete = new Dictionary<string' Chart>();                          lock (_chartLock)                          {                              foreach (var chart in Charts)                              {                                  // remove directory pathing characters from chart names                                  var safeName = chart.Value.Name.Replace('/'' '-');                                  chartComplete.Add(safeName' chart.Value.Clone());                              }                          }                          var orders = new Dictionary<int' Order>(_transactionHandler.Orders);                          var complete = new LiveResultPacket(_job' new LiveResult(chartComplete' orders' _algorithm.Transactions.TransactionRecord' holdings' _algorithm.Portfolio.CashBook' deltaStatistics' runtimeStatistics' serverStatistics));                          StoreResult(complete);                          Log.Debug("LiveTradingResultHandler.Update(): End-store result");                      }                        // Upload the logs every 1-2 minutes; this can be a heavy operation depending on amount of live logging and should probably be done asynchronously.                      if (DateTime.Now > _nextLogStoreUpdate || _exitTriggered)                      {                          List<LogEntry> logs;                          Log.Debug("LiveTradingResultHandler.Update(): Storing log...");                          lock (_logStoreLock)                          {                              var utc = DateTime.UtcNow;                              logs = (from log in _logStore                                      where log.Time >= utc.RoundDown(TimeSpan.FromHours(1))                                      select log).ToList();                              //Override the log master to delete the old entries and prevent memory creep.                              _logStore = logs;                          }                          StoreLog(logs);                          _nextLogStoreUpdate = DateTime.Now.AddMinutes(2);                          Log.Debug("LiveTradingResultHandler.Update(): Finished storing log");                      }                        // Every minute send usage statistics:                      if (DateTime.Now > _nextStatisticsUpdate || _exitTriggered)                      {                          try                          {                              _api.SendStatistics(                                  _job.AlgorithmId'                                  _algorithm.Portfolio.TotalUnrealizedProfit'                                  _algorithm.Portfolio.TotalFees'                                  _algorithm.Portfolio.TotalProfit'                                  _algorithm.Portfolio.TotalHoldingsValue'                                  _algorithm.Portfolio.TotalPortfolioValue'                                  netReturn'                                  _algorithm.Portfolio.TotalSaleVolume'                                  _lastOrderId' 0);                          }                          catch (Exception err)                          {                              Log.Error(err' "Error sending statistics:");                          }                          _nextStatisticsUpdate = DateTime.Now.AddMinutes(1);                      }                          Log.Debug("LiveTradingResultHandler.Update(): Trimming charts");                      lock (_chartLock)                      {                          foreach (var chart in Charts)                          {                              foreach (var series in chart.Value.Series)                              {                                  // trim data that's older than 2 days                                  series.Value.Values =                                      (from v in series.Value.Values                                       where v.x > Time.DateTimeToUnixTimeStamp(DateTime.UtcNow.AddDays(-2))                                       select v).ToList();                              }                          }                      }                      Log.Debug("LiveTradingResultHandler.Update(): Finished trimming charts");                          //Set the new update time after we've finished processing.                      // The processing can takes time depending on how large the packets are.                      _nextUpdate = DateTime.Now.AddSeconds(2);                    } // End Update Charts:              }              catch (Exception err)              {                  Log.Error(err' "LiveTradingResultHandler().Update(): "' true);              }
Magic Number,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Update,The following statement contains a magic number: try              {                  if (DateTime.Now > _nextUpdate || _exitTriggered)                  {                      //Extract the orders created since last update                      OrderEvent orderEvent;                      deltaOrders = new Dictionary<int' Order>();                        var stopwatch = Stopwatch.StartNew();                      while (_orderEvents.TryDequeue(out orderEvent) && stopwatch.ElapsedMilliseconds < 15)                      {                          var order = _algorithm.Transactions.GetOrderById(orderEvent.OrderId);                          deltaOrders[orderEvent.OrderId] = order.Clone();                      }                        //For charting convert to UTC                      foreach (var order in deltaOrders)                      {                          order.Value.Price = order.Value.Price.SmartRounding();                          order.Value.Time = order.Value.Time.ToUniversalTime();                      }                        //Reset loop variables:                      _lastOrderId = (from order in deltaOrders.Values select order.Id).DefaultIfEmpty(_lastOrderId).Max();                        //Limit length of orders we pass back dynamically to avoid flooding.                      //if (deltaOrders.Count > 50) deltaOrders.Clear();                        //Create and send back the changes in chart since the algorithm started.                      var deltaCharts = new Dictionary<string' Chart>();                      Log.Debug("LiveTradingResultHandler.Update(): Build delta charts");                      lock (_chartLock)                      {                          //Get the updates since the last chart                          foreach (var chart in _charts)                          {                              // remove directory pathing characters from chart names                              var safeName = chart.Value.Name.Replace('/'' '-');                              deltaCharts.Add(safeName' chart.Value.GetUpdates());                          }                      }                      Log.Debug("LiveTradingResultHandler.Update(): End build delta charts");                        //Profit loss changes' get the banner statistics' summary information on the performance for the headers.                      var holdings = new Dictionary<string' Holding>();                      var deltaStatistics = new Dictionary<string' string>();                      var runtimeStatistics = new Dictionary<string' string>();                      var serverStatistics = OS.GetServerStatistics();                      var upTime = DateTime.UtcNow - _launchTimeUtc;                      serverStatistics["Up Time"] = string.Format("{0}d {1:hh\\:mm\\:ss}"' upTime.Days' upTime);                      serverStatistics["Total RAM (MB)"] = _job.Controls.RamAllocation.ToString();                        // Only send holdings updates when we have changes in orders' except for first time' then we want to send all                      foreach (var asset in _algorithm.Securities.Values.Where(x => !x.IsInternalFeed() && !x.Symbol.IsCanonical()).OrderBy(x => x.Symbol.Value))                      {                          holdings.Add(asset.Symbol.Value' new Holding(asset));                      }                        //Add the algorithm statistics first.                      Log.Debug("LiveTradingResultHandler.Update(): Build run time stats");                      lock (_runtimeLock)                      {                          foreach (var pair in _runtimeStatistics)                          {                              runtimeStatistics.Add(pair.Key' pair.Value);                          }                      }                      Log.Debug("LiveTradingResultHandler.Update(): End build run time stats");                        //Some users have $0 in their brokerage account / starting cash of $0. Prevent divide by zero errors                      var netReturn = _setupHandler.StartingPortfolioValue > 0 ?                                      (_algorithm.Portfolio.TotalPortfolioValue - _setupHandler.StartingPortfolioValue) / _setupHandler.StartingPortfolioValue                                      : 0;                        //Add other fixed parameters.                      runtimeStatistics.Add("Unrealized:"' "$" + _algorithm.Portfolio.TotalUnrealizedProfit.ToString("N2"));                      runtimeStatistics.Add("Fees:"' "-$" + _algorithm.Portfolio.TotalFees.ToString("N2"));                      runtimeStatistics.Add("Net Profit:"' "$" + (_algorithm.Portfolio.TotalProfit - _algorithm.Portfolio.TotalFees).ToString("N2"));                      runtimeStatistics.Add("Return:"' netReturn.ToString("P"));                      runtimeStatistics.Add("Equity:"' "$" + _algorithm.Portfolio.TotalPortfolioValue.ToString("N2"));                      runtimeStatistics.Add("Holdings:"' "$" + _algorithm.Portfolio.TotalHoldingsValue.ToString("N2"));                      runtimeStatistics.Add("Volume:"' "$" + _algorithm.Portfolio.TotalSaleVolume.ToString("N2"));                        // since we're sending multiple packets' let's do it async and forget about it                      // chart data can get big so let's break them up into groups                      var splitPackets = SplitPackets(deltaCharts' deltaOrders' holdings' _algorithm.Portfolio.CashBook' deltaStatistics' runtimeStatistics' serverStatistics);                        foreach (var liveResultPacket in splitPackets)                      {                          _messagingHandler.Send(liveResultPacket);                      }                        //Send full packet to storage.                      if (DateTime.Now > _nextChartsUpdate || _exitTriggered)                      {                          Log.Debug("LiveTradingResultHandler.Update(): Pre-store result");                          _nextChartsUpdate = DateTime.Now.AddMinutes(1);                          var chartComplete = new Dictionary<string' Chart>();                          lock (_chartLock)                          {                              foreach (var chart in Charts)                              {                                  // remove directory pathing characters from chart names                                  var safeName = chart.Value.Name.Replace('/'' '-');                                  chartComplete.Add(safeName' chart.Value.Clone());                              }                          }                          var orders = new Dictionary<int' Order>(_transactionHandler.Orders);                          var complete = new LiveResultPacket(_job' new LiveResult(chartComplete' orders' _algorithm.Transactions.TransactionRecord' holdings' _algorithm.Portfolio.CashBook' deltaStatistics' runtimeStatistics' serverStatistics));                          StoreResult(complete);                          Log.Debug("LiveTradingResultHandler.Update(): End-store result");                      }                        // Upload the logs every 1-2 minutes; this can be a heavy operation depending on amount of live logging and should probably be done asynchronously.                      if (DateTime.Now > _nextLogStoreUpdate || _exitTriggered)                      {                          List<LogEntry> logs;                          Log.Debug("LiveTradingResultHandler.Update(): Storing log...");                          lock (_logStoreLock)                          {                              var utc = DateTime.UtcNow;                              logs = (from log in _logStore                                      where log.Time >= utc.RoundDown(TimeSpan.FromHours(1))                                      select log).ToList();                              //Override the log master to delete the old entries and prevent memory creep.                              _logStore = logs;                          }                          StoreLog(logs);                          _nextLogStoreUpdate = DateTime.Now.AddMinutes(2);                          Log.Debug("LiveTradingResultHandler.Update(): Finished storing log");                      }                        // Every minute send usage statistics:                      if (DateTime.Now > _nextStatisticsUpdate || _exitTriggered)                      {                          try                          {                              _api.SendStatistics(                                  _job.AlgorithmId'                                  _algorithm.Portfolio.TotalUnrealizedProfit'                                  _algorithm.Portfolio.TotalFees'                                  _algorithm.Portfolio.TotalProfit'                                  _algorithm.Portfolio.TotalHoldingsValue'                                  _algorithm.Portfolio.TotalPortfolioValue'                                  netReturn'                                  _algorithm.Portfolio.TotalSaleVolume'                                  _lastOrderId' 0);                          }                          catch (Exception err)                          {                              Log.Error(err' "Error sending statistics:");                          }                          _nextStatisticsUpdate = DateTime.Now.AddMinutes(1);                      }                          Log.Debug("LiveTradingResultHandler.Update(): Trimming charts");                      lock (_chartLock)                      {                          foreach (var chart in Charts)                          {                              foreach (var series in chart.Value.Series)                              {                                  // trim data that's older than 2 days                                  series.Value.Values =                                      (from v in series.Value.Values                                       where v.x > Time.DateTimeToUnixTimeStamp(DateTime.UtcNow.AddDays(-2))                                       select v).ToList();                              }                          }                      }                      Log.Debug("LiveTradingResultHandler.Update(): Finished trimming charts");                          //Set the new update time after we've finished processing.                      // The processing can takes time depending on how large the packets are.                      _nextUpdate = DateTime.Now.AddSeconds(2);                    } // End Update Charts:              }              catch (Exception err)              {                  Log.Error(err' "LiveTradingResultHandler().Update(): "' true);              }
Magic Number,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Update,The following statement contains a magic number: try              {                  if (DateTime.Now > _nextUpdate || _exitTriggered)                  {                      //Extract the orders created since last update                      OrderEvent orderEvent;                      deltaOrders = new Dictionary<int' Order>();                        var stopwatch = Stopwatch.StartNew();                      while (_orderEvents.TryDequeue(out orderEvent) && stopwatch.ElapsedMilliseconds < 15)                      {                          var order = _algorithm.Transactions.GetOrderById(orderEvent.OrderId);                          deltaOrders[orderEvent.OrderId] = order.Clone();                      }                        //For charting convert to UTC                      foreach (var order in deltaOrders)                      {                          order.Value.Price = order.Value.Price.SmartRounding();                          order.Value.Time = order.Value.Time.ToUniversalTime();                      }                        //Reset loop variables:                      _lastOrderId = (from order in deltaOrders.Values select order.Id).DefaultIfEmpty(_lastOrderId).Max();                        //Limit length of orders we pass back dynamically to avoid flooding.                      //if (deltaOrders.Count > 50) deltaOrders.Clear();                        //Create and send back the changes in chart since the algorithm started.                      var deltaCharts = new Dictionary<string' Chart>();                      Log.Debug("LiveTradingResultHandler.Update(): Build delta charts");                      lock (_chartLock)                      {                          //Get the updates since the last chart                          foreach (var chart in _charts)                          {                              // remove directory pathing characters from chart names                              var safeName = chart.Value.Name.Replace('/'' '-');                              deltaCharts.Add(safeName' chart.Value.GetUpdates());                          }                      }                      Log.Debug("LiveTradingResultHandler.Update(): End build delta charts");                        //Profit loss changes' get the banner statistics' summary information on the performance for the headers.                      var holdings = new Dictionary<string' Holding>();                      var deltaStatistics = new Dictionary<string' string>();                      var runtimeStatistics = new Dictionary<string' string>();                      var serverStatistics = OS.GetServerStatistics();                      var upTime = DateTime.UtcNow - _launchTimeUtc;                      serverStatistics["Up Time"] = string.Format("{0}d {1:hh\\:mm\\:ss}"' upTime.Days' upTime);                      serverStatistics["Total RAM (MB)"] = _job.Controls.RamAllocation.ToString();                        // Only send holdings updates when we have changes in orders' except for first time' then we want to send all                      foreach (var asset in _algorithm.Securities.Values.Where(x => !x.IsInternalFeed() && !x.Symbol.IsCanonical()).OrderBy(x => x.Symbol.Value))                      {                          holdings.Add(asset.Symbol.Value' new Holding(asset));                      }                        //Add the algorithm statistics first.                      Log.Debug("LiveTradingResultHandler.Update(): Build run time stats");                      lock (_runtimeLock)                      {                          foreach (var pair in _runtimeStatistics)                          {                              runtimeStatistics.Add(pair.Key' pair.Value);                          }                      }                      Log.Debug("LiveTradingResultHandler.Update(): End build run time stats");                        //Some users have $0 in their brokerage account / starting cash of $0. Prevent divide by zero errors                      var netReturn = _setupHandler.StartingPortfolioValue > 0 ?                                      (_algorithm.Portfolio.TotalPortfolioValue - _setupHandler.StartingPortfolioValue) / _setupHandler.StartingPortfolioValue                                      : 0;                        //Add other fixed parameters.                      runtimeStatistics.Add("Unrealized:"' "$" + _algorithm.Portfolio.TotalUnrealizedProfit.ToString("N2"));                      runtimeStatistics.Add("Fees:"' "-$" + _algorithm.Portfolio.TotalFees.ToString("N2"));                      runtimeStatistics.Add("Net Profit:"' "$" + (_algorithm.Portfolio.TotalProfit - _algorithm.Portfolio.TotalFees).ToString("N2"));                      runtimeStatistics.Add("Return:"' netReturn.ToString("P"));                      runtimeStatistics.Add("Equity:"' "$" + _algorithm.Portfolio.TotalPortfolioValue.ToString("N2"));                      runtimeStatistics.Add("Holdings:"' "$" + _algorithm.Portfolio.TotalHoldingsValue.ToString("N2"));                      runtimeStatistics.Add("Volume:"' "$" + _algorithm.Portfolio.TotalSaleVolume.ToString("N2"));                        // since we're sending multiple packets' let's do it async and forget about it                      // chart data can get big so let's break them up into groups                      var splitPackets = SplitPackets(deltaCharts' deltaOrders' holdings' _algorithm.Portfolio.CashBook' deltaStatistics' runtimeStatistics' serverStatistics);                        foreach (var liveResultPacket in splitPackets)                      {                          _messagingHandler.Send(liveResultPacket);                      }                        //Send full packet to storage.                      if (DateTime.Now > _nextChartsUpdate || _exitTriggered)                      {                          Log.Debug("LiveTradingResultHandler.Update(): Pre-store result");                          _nextChartsUpdate = DateTime.Now.AddMinutes(1);                          var chartComplete = new Dictionary<string' Chart>();                          lock (_chartLock)                          {                              foreach (var chart in Charts)                              {                                  // remove directory pathing characters from chart names                                  var safeName = chart.Value.Name.Replace('/'' '-');                                  chartComplete.Add(safeName' chart.Value.Clone());                              }                          }                          var orders = new Dictionary<int' Order>(_transactionHandler.Orders);                          var complete = new LiveResultPacket(_job' new LiveResult(chartComplete' orders' _algorithm.Transactions.TransactionRecord' holdings' _algorithm.Portfolio.CashBook' deltaStatistics' runtimeStatistics' serverStatistics));                          StoreResult(complete);                          Log.Debug("LiveTradingResultHandler.Update(): End-store result");                      }                        // Upload the logs every 1-2 minutes; this can be a heavy operation depending on amount of live logging and should probably be done asynchronously.                      if (DateTime.Now > _nextLogStoreUpdate || _exitTriggered)                      {                          List<LogEntry> logs;                          Log.Debug("LiveTradingResultHandler.Update(): Storing log...");                          lock (_logStoreLock)                          {                              var utc = DateTime.UtcNow;                              logs = (from log in _logStore                                      where log.Time >= utc.RoundDown(TimeSpan.FromHours(1))                                      select log).ToList();                              //Override the log master to delete the old entries and prevent memory creep.                              _logStore = logs;                          }                          StoreLog(logs);                          _nextLogStoreUpdate = DateTime.Now.AddMinutes(2);                          Log.Debug("LiveTradingResultHandler.Update(): Finished storing log");                      }                        // Every minute send usage statistics:                      if (DateTime.Now > _nextStatisticsUpdate || _exitTriggered)                      {                          try                          {                              _api.SendStatistics(                                  _job.AlgorithmId'                                  _algorithm.Portfolio.TotalUnrealizedProfit'                                  _algorithm.Portfolio.TotalFees'                                  _algorithm.Portfolio.TotalProfit'                                  _algorithm.Portfolio.TotalHoldingsValue'                                  _algorithm.Portfolio.TotalPortfolioValue'                                  netReturn'                                  _algorithm.Portfolio.TotalSaleVolume'                                  _lastOrderId' 0);                          }                          catch (Exception err)                          {                              Log.Error(err' "Error sending statistics:");                          }                          _nextStatisticsUpdate = DateTime.Now.AddMinutes(1);                      }                          Log.Debug("LiveTradingResultHandler.Update(): Trimming charts");                      lock (_chartLock)                      {                          foreach (var chart in Charts)                          {                              foreach (var series in chart.Value.Series)                              {                                  // trim data that's older than 2 days                                  series.Value.Values =                                      (from v in series.Value.Values                                       where v.x > Time.DateTimeToUnixTimeStamp(DateTime.UtcNow.AddDays(-2))                                       select v).ToList();                              }                          }                      }                      Log.Debug("LiveTradingResultHandler.Update(): Finished trimming charts");                          //Set the new update time after we've finished processing.                      // The processing can takes time depending on how large the packets are.                      _nextUpdate = DateTime.Now.AddSeconds(2);                    } // End Update Charts:              }              catch (Exception err)              {                  Log.Error(err' "LiveTradingResultHandler().Update(): "' true);              }
Magic Number,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,Update,The following statement contains a magic number: try              {                  if (DateTime.Now > _nextUpdate || _exitTriggered)                  {                      //Extract the orders created since last update                      OrderEvent orderEvent;                      deltaOrders = new Dictionary<int' Order>();                        var stopwatch = Stopwatch.StartNew();                      while (_orderEvents.TryDequeue(out orderEvent) && stopwatch.ElapsedMilliseconds < 15)                      {                          var order = _algorithm.Transactions.GetOrderById(orderEvent.OrderId);                          deltaOrders[orderEvent.OrderId] = order.Clone();                      }                        //For charting convert to UTC                      foreach (var order in deltaOrders)                      {                          order.Value.Price = order.Value.Price.SmartRounding();                          order.Value.Time = order.Value.Time.ToUniversalTime();                      }                        //Reset loop variables:                      _lastOrderId = (from order in deltaOrders.Values select order.Id).DefaultIfEmpty(_lastOrderId).Max();                        //Limit length of orders we pass back dynamically to avoid flooding.                      //if (deltaOrders.Count > 50) deltaOrders.Clear();                        //Create and send back the changes in chart since the algorithm started.                      var deltaCharts = new Dictionary<string' Chart>();                      Log.Debug("LiveTradingResultHandler.Update(): Build delta charts");                      lock (_chartLock)                      {                          //Get the updates since the last chart                          foreach (var chart in _charts)                          {                              // remove directory pathing characters from chart names                              var safeName = chart.Value.Name.Replace('/'' '-');                              deltaCharts.Add(safeName' chart.Value.GetUpdates());                          }                      }                      Log.Debug("LiveTradingResultHandler.Update(): End build delta charts");                        //Profit loss changes' get the banner statistics' summary information on the performance for the headers.                      var holdings = new Dictionary<string' Holding>();                      var deltaStatistics = new Dictionary<string' string>();                      var runtimeStatistics = new Dictionary<string' string>();                      var serverStatistics = OS.GetServerStatistics();                      var upTime = DateTime.UtcNow - _launchTimeUtc;                      serverStatistics["Up Time"] = string.Format("{0}d {1:hh\\:mm\\:ss}"' upTime.Days' upTime);                      serverStatistics["Total RAM (MB)"] = _job.Controls.RamAllocation.ToString();                        // Only send holdings updates when we have changes in orders' except for first time' then we want to send all                      foreach (var asset in _algorithm.Securities.Values.Where(x => !x.IsInternalFeed() && !x.Symbol.IsCanonical()).OrderBy(x => x.Symbol.Value))                      {                          holdings.Add(asset.Symbol.Value' new Holding(asset));                      }                        //Add the algorithm statistics first.                      Log.Debug("LiveTradingResultHandler.Update(): Build run time stats");                      lock (_runtimeLock)                      {                          foreach (var pair in _runtimeStatistics)                          {                              runtimeStatistics.Add(pair.Key' pair.Value);                          }                      }                      Log.Debug("LiveTradingResultHandler.Update(): End build run time stats");                        //Some users have $0 in their brokerage account / starting cash of $0. Prevent divide by zero errors                      var netReturn = _setupHandler.StartingPortfolioValue > 0 ?                                      (_algorithm.Portfolio.TotalPortfolioValue - _setupHandler.StartingPortfolioValue) / _setupHandler.StartingPortfolioValue                                      : 0;                        //Add other fixed parameters.                      runtimeStatistics.Add("Unrealized:"' "$" + _algorithm.Portfolio.TotalUnrealizedProfit.ToString("N2"));                      runtimeStatistics.Add("Fees:"' "-$" + _algorithm.Portfolio.TotalFees.ToString("N2"));                      runtimeStatistics.Add("Net Profit:"' "$" + (_algorithm.Portfolio.TotalProfit - _algorithm.Portfolio.TotalFees).ToString("N2"));                      runtimeStatistics.Add("Return:"' netReturn.ToString("P"));                      runtimeStatistics.Add("Equity:"' "$" + _algorithm.Portfolio.TotalPortfolioValue.ToString("N2"));                      runtimeStatistics.Add("Holdings:"' "$" + _algorithm.Portfolio.TotalHoldingsValue.ToString("N2"));                      runtimeStatistics.Add("Volume:"' "$" + _algorithm.Portfolio.TotalSaleVolume.ToString("N2"));                        // since we're sending multiple packets' let's do it async and forget about it                      // chart data can get big so let's break them up into groups                      var splitPackets = SplitPackets(deltaCharts' deltaOrders' holdings' _algorithm.Portfolio.CashBook' deltaStatistics' runtimeStatistics' serverStatistics);                        foreach (var liveResultPacket in splitPackets)                      {                          _messagingHandler.Send(liveResultPacket);                      }                        //Send full packet to storage.                      if (DateTime.Now > _nextChartsUpdate || _exitTriggered)                      {                          Log.Debug("LiveTradingResultHandler.Update(): Pre-store result");                          _nextChartsUpdate = DateTime.Now.AddMinutes(1);                          var chartComplete = new Dictionary<string' Chart>();                          lock (_chartLock)                          {                              foreach (var chart in Charts)                              {                                  // remove directory pathing characters from chart names                                  var safeName = chart.Value.Name.Replace('/'' '-');                                  chartComplete.Add(safeName' chart.Value.Clone());                              }                          }                          var orders = new Dictionary<int' Order>(_transactionHandler.Orders);                          var complete = new LiveResultPacket(_job' new LiveResult(chartComplete' orders' _algorithm.Transactions.TransactionRecord' holdings' _algorithm.Portfolio.CashBook' deltaStatistics' runtimeStatistics' serverStatistics));                          StoreResult(complete);                          Log.Debug("LiveTradingResultHandler.Update(): End-store result");                      }                        // Upload the logs every 1-2 minutes; this can be a heavy operation depending on amount of live logging and should probably be done asynchronously.                      if (DateTime.Now > _nextLogStoreUpdate || _exitTriggered)                      {                          List<LogEntry> logs;                          Log.Debug("LiveTradingResultHandler.Update(): Storing log...");                          lock (_logStoreLock)                          {                              var utc = DateTime.UtcNow;                              logs = (from log in _logStore                                      where log.Time >= utc.RoundDown(TimeSpan.FromHours(1))                                      select log).ToList();                              //Override the log master to delete the old entries and prevent memory creep.                              _logStore = logs;                          }                          StoreLog(logs);                          _nextLogStoreUpdate = DateTime.Now.AddMinutes(2);                          Log.Debug("LiveTradingResultHandler.Update(): Finished storing log");                      }                        // Every minute send usage statistics:                      if (DateTime.Now > _nextStatisticsUpdate || _exitTriggered)                      {                          try                          {                              _api.SendStatistics(                                  _job.AlgorithmId'                                  _algorithm.Portfolio.TotalUnrealizedProfit'                                  _algorithm.Portfolio.TotalFees'                                  _algorithm.Portfolio.TotalProfit'                                  _algorithm.Portfolio.TotalHoldingsValue'                                  _algorithm.Portfolio.TotalPortfolioValue'                                  netReturn'                                  _algorithm.Portfolio.TotalSaleVolume'                                  _lastOrderId' 0);                          }                          catch (Exception err)                          {                              Log.Error(err' "Error sending statistics:");                          }                          _nextStatisticsUpdate = DateTime.Now.AddMinutes(1);                      }                          Log.Debug("LiveTradingResultHandler.Update(): Trimming charts");                      lock (_chartLock)                      {                          foreach (var chart in Charts)                          {                              foreach (var series in chart.Value.Series)                              {                                  // trim data that's older than 2 days                                  series.Value.Values =                                      (from v in series.Value.Values                                       where v.x > Time.DateTimeToUnixTimeStamp(DateTime.UtcNow.AddDays(-2))                                       select v).ToList();                              }                          }                      }                      Log.Debug("LiveTradingResultHandler.Update(): Finished trimming charts");                          //Set the new update time after we've finished processing.                      // The processing can takes time depending on how large the packets are.                      _nextUpdate = DateTime.Now.AddSeconds(2);                    } // End Update Charts:              }              catch (Exception err)              {                  Log.Error(err' "LiveTradingResultHandler().Update(): "' true);              }
Magic Number,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,SplitPackets,The following statement contains a magic number: var groupSize = 3;
Magic Number,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,DebugMessage,The following statement contains a magic number: if (Messages.Count > 500) return;
Magic Number,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,LogMessage,The following statement contains a magic number: if (Messages.Count > 500) return;
Magic Number,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,ErrorMessage,The following statement contains a magic number: if (Messages.Count > 500) return;
Magic Number,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,StoreResult,The following statement contains a magic number: try              {                  Log.Debug("LiveTradingResultHandler.StoreResult(): Begin store result sampling");                    // Make sure this is the right type of packet:                  if (packet.Type != PacketType.LiveResult) return;                    // Port to packet format:                  var live = packet as LiveResultPacket;                    if (live != null)                  {                      // we need to down sample                      var start = DateTime.UtcNow.Date;                      var stop = start.AddDays(1);                        // truncate to just today' we don't need more than this for anyone                      Truncate(live.Results' start' stop);                        var highResolutionCharts = new Dictionary<string' Chart>(live.Results.Charts);                        // minute resoluton data' save today                      var minuteSampler = new SeriesSampler(TimeSpan.FromMinutes(1));                      var minuteCharts = minuteSampler.SampleCharts(live.Results.Charts' start' stop);                        // swap out our charts with the sampeld data                      live.Results.Charts = minuteCharts;                      SaveResults(CreateKey("minute")' live.Results);                        // 10 minute resolution data' save today                      var tenminuteSampler = new SeriesSampler(TimeSpan.FromMinutes(10));                      var tenminuteCharts = tenminuteSampler.SampleCharts(live.Results.Charts' start' stop);                        live.Results.Charts = tenminuteCharts;                      SaveResults(CreateKey("10minute")' live.Results);                        // high resolution data' we only want to save an hour                      live.Results.Charts = highResolutionCharts;                      start = DateTime.UtcNow.RoundDown(TimeSpan.FromHours(1));                      stop = DateTime.UtcNow.RoundUp(TimeSpan.FromHours(1));                        Truncate(live.Results' start' stop);                        foreach (var name in live.Results.Charts.Keys)                      {                          var result = new LiveResult();                          result.Orders = new Dictionary<int' Order>(live.Results.Orders);                          result.Holdings = new Dictionary<string' Holding>(live.Results.Holdings);                          result.Charts = new Dictionary<string' Chart>();                          result.Charts.Add(name' live.Results.Charts[name]);                            SaveResults(CreateKey("second_" + CreateSafeChartName(name)' "yyyy-MM-dd-HH")' result);                      }                  }                  else                  {                      Log.Error("LiveResultHandler.StoreResult(): Result Null.");                  }                    Log.Debug("LiveTradingResultHandler.StoreResult(): End store result sampling");              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,ProcessSynchronousEvents,The following statement contains a magic number: if (time > _nextSample || forceProcess)              {                  Log.Debug("LiveTradingResultHandler.ProcessSynchronousEvents(): Enter");                    //Set next sample time: 4000 samples per backtest                  _nextSample = time.Add(ResamplePeriod);                    //Update the asset prices to take a real time sample of the market price even though we're using minute bars                  if (_dataFeed != null)                  {                      foreach (var subscription in _dataFeed.Subscriptions)                      {                          // OI subscription doesn't contain asset market prices                          if (subscription.Configuration.TickType == TickType.OpenInterest)                              continue;                            Security security;                          if (_algorithm.Securities.TryGetValue(subscription.Configuration.Symbol' out security))                          {                              //Sample Portfolio Value:                              var price = subscription.RealtimePrice;                                var last = security.GetLastData();                              if (last != null && price > 0)                              {                                  // Prevents changes in previous bar                                  last = last.Clone(last.IsFillForward);                                    last.Value = price;                                  security.SetRealTimePrice(last);                                    // Update CashBook for Forex securities                                  var cash = (from c in _algorithm.Portfolio.CashBook.Values                                      where c.SecuritySymbol == last.Symbol                                      select c).SingleOrDefault();                                    if (cash != null)                                  {                                      cash.Update(last);                                  }                              }                              else                              {                                  // we haven't gotten data yet so just spoof a tick to push through the system to start with                                  if (price > 0)                                  {                                      security.SetMarketPrice(new Tick(time' subscription.Configuration.Symbol' price' price));                                  }                              }                                //Sample Asset Pricing:                              SampleAssetPrices(subscription.Configuration.Symbol' time' price);                          }                      }                  }                    //Sample the portfolio value over time for chart.                  SampleEquity(time' Math.Round(_algorithm.Portfolio.TotalPortfolioValue' 4));                    //Also add the user samples / plots to the result handler tracking:                  SampleRange(_algorithm.GetChartUpdates(true));              }
Magic Number,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,ProcessSynchronousEvents,The following statement contains a magic number: while (_algorithm.DebugMessages.Count > 0 && debugStopWatch.ElapsedMilliseconds < 250)              {                  string message;                  if (_algorithm.DebugMessages.TryDequeue(out message))                  {                      DebugMessage(message);                  }              }
Magic Number,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,ProcessSynchronousEvents,The following statement contains a magic number: while (_algorithm.ErrorMessages.Count > 0 && errorStopWatch.ElapsedMilliseconds < 250)              {                  string message;                  if (_algorithm.ErrorMessages.TryDequeue(out message))                  {                      ErrorMessage(message);                  }              }
Magic Number,QuantConnect.Lean.Engine.Results,LiveTradingResultHandler,C:\repos\QuantConnect_Lean\Engine\Results\LiveTradingResultHandler.cs,ProcessSynchronousEvents,The following statement contains a magic number: while (_algorithm.LogMessages.Count > 0 && logStopWatch.ElapsedMilliseconds < 250)              {                  string message;                  if (_algorithm.LogMessages.TryDequeue(out message))                  {                      LogMessage(message);                  }              }
Magic Number,QuantConnect.Lean.Engine.Setup,BrokerageSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BrokerageSetupHandler.cs,BrokerageSetupHandler,The following statement contains a magic number: MaximumRuntime = TimeSpan.FromDays(10*365);
Magic Number,QuantConnect.Lean.Engine.Setup,BrokerageSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BrokerageSetupHandler.cs,BrokerageSetupHandler,The following statement contains a magic number: MaximumRuntime = TimeSpan.FromDays(10*365);
Magic Number,QuantConnect.Lean.Engine.Setup,BrokerageSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BrokerageSetupHandler.cs,CreateAlgorithmInstance,The following statement contains a magic number: var loader = new Loader(algorithmNodePacket.Language' TimeSpan.FromSeconds(15)' names => names.SingleOrAlgorithmTypeName(Config.Get("algorithm-type-name")));
Magic Number,QuantConnect.Lean.Engine.Setup,BrokerageSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BrokerageSetupHandler.cs,Setup,The following statement contains a magic number: try              {                  Log.Trace("BrokerageSetupHandler.Setup(): Initializing algorithm...");                    resultHandler.SendStatusUpdate(AlgorithmStatus.Initializing' "Initializing algorithm...");                    //Execute the initialize code:                  var controls = job.Controls;                  var isolator = new Isolator();                  var initializeComplete = isolator.ExecuteWithTimeLimit(TimeSpan.FromSeconds(300)' () =>                  {                      try                      {                          //Set the default brokerage model before initialize                          algorithm.SetBrokerageModel(_factory.BrokerageModel);                            //Margin calls are disabled by default in live mode                          algorithm.Portfolio.MarginCallModel = MarginCallModel.Null;                            //Set our parameters                          algorithm.SetParameters(job.Parameters);                          algorithm.SetAvailableDataTypes(GetConfiguredDataFeeds());                            //Algorithm is live' not backtesting:                          algorithm.SetLiveMode(true);                            //Initialize the algorithm's starting date                          algorithm.SetDateTime(DateTime.UtcNow);                            //Set the source impl for the event scheduling                          algorithm.Schedule.SetEventSchedule(realTimeHandler);                            // set the option chain provider                          algorithm.SetOptionChainProvider(new CachingOptionChainProvider(new LiveOptionChainProvider()));                            // set the future chain provider                          algorithm.SetFutureChainProvider(new CachingFutureChainProvider(new LiveFutureChainProvider()));                            // If we're going to receive market data from IB'                          // set the default subscription limit to 100'                          // algorithms can override this setting in the Initialize method                          if (brokerage is InteractiveBrokersBrokerage &&                              liveJob.DataQueueHandler.EndsWith("InteractiveBrokersBrokerage"))                          {                              algorithm.Settings.DataSubscriptionLimit = 100;                          }                            //Initialise the algorithm' get the required data:                          algorithm.Initialize();                          if (liveJob.Brokerage != "PaperBrokerage")                          {                              //Zero the CashBook - we'll populate directly from brokerage                              foreach (var kvp in algorithm.Portfolio.CashBook)                              {                                  kvp.Value.SetAmount(0);                              }                          }                      }                      catch (Exception err)                      {                          AddInitializationError(err.ToString());                      }                  }' controls.RamAllocation);                    if (!initializeComplete)                  {                      AddInitializationError("Initialization timed out.");                      return false;                  }                    // let the world know what we're doing since logging in can take a minute                  resultHandler.SendStatusUpdate(AlgorithmStatus.LoggingIn' "Logging into brokerage...");                    brokerage.Message += brokerageOnMessage;                    Log.Trace("BrokerageSetupHandler.Setup(): Connecting to brokerage...");                  try                  {                      // this can fail for various reasons' such as already being logged in somewhere else                      brokerage.Connect();                  }                  catch (Exception err)                  {                      Log.Error(err);                      AddInitializationError(string.Format("Error connecting to brokerage: {0}. " +                          "This may be caused by incorrect login credentials or an unsupported account type."' err.Message));                      return false;                  }                    if (!brokerage.IsConnected)                  {                      // if we're reporting that we're not connected' bail                      AddInitializationError("Unable to connect to brokerage.");                      return false;                  }                    Log.Trace("BrokerageSetupHandler.Setup(): Fetching cash balance from brokerage...");                  try                  {                      // set the algorithm's cash balance for each currency                      var cashBalance = brokerage.GetCashBalance();                      foreach (var cash in cashBalance)                      {                          Log.Trace("BrokerageSetupHandler.Setup(): Setting " + cash.Symbol + " cash to " + cash.Amount);                          algorithm.Portfolio.SetCash(cash.Symbol' cash.Amount' cash.ConversionRate);                      }                  }                  catch (Exception err)                  {                      Log.Error(err);                      AddInitializationError("Error getting cash balance from brokerage: " + err.Message);                      return false;                  }                    Log.Trace("BrokerageSetupHandler.Setup(): Fetching open orders from brokerage...");                  try                  {                      GetOpenOrders(algorithm' resultHandler' transactionHandler' brokerage);                  }                  catch (Exception err)                  {                      Log.Error(err);                      AddInitializationError("Error getting open orders from brokerage: " + err.Message);                      return false;                  }                    Log.Trace("BrokerageSetupHandler.Setup(): Fetching holdings from brokerage...");                  try                  {                      // populate the algorithm with the account's current holdings                      var holdings = brokerage.GetAccountHoldings();                      var supportedSecurityTypes = new HashSet<SecurityType>                      {                          SecurityType.Equity' SecurityType.Forex' SecurityType.Cfd' SecurityType.Option' SecurityType.Future' SecurityType.Crypto                      };                      var minResolution = new Lazy<Resolution>(() => algorithm.Securities.Select(x => x.Value.Resolution).DefaultIfEmpty(Resolution.Second).Min());                      foreach (var holding in holdings)                      {                          Log.Trace("BrokerageSetupHandler.Setup(): Has existing holding: " + holding);                            // verify existing holding security type                          if (!supportedSecurityTypes.Contains(holding.Type))                          {                              Log.Error("BrokerageSetupHandler.Setup(): Unsupported security type: " + holding.Type + "-" + holding.Symbol.Value);                              AddInitializationError("Found unsupported security type in existing brokerage holdings: " + holding.Type + ". " +                                  "QuantConnect currently supports the following security types: " + string.Join("'"' supportedSecurityTypes));                                // keep aggregating these errors                              continue;                          }                            if (!algorithm.Portfolio.ContainsKey(holding.Symbol))                          {                              Log.Trace("BrokerageSetupHandler.Setup(): Adding unrequested security: " + holding.Symbol.Value);                                if (holding.Type == SecurityType.Option)                              {                                  // add current option contract to the system                                  algorithm.AddOptionContract(holding.Symbol' minResolution.Value' true' 1.0m);                              }                              else if (holding.Type == SecurityType.Future)                              {                                  // add current future contract to the system                                  algorithm.AddFutureContract(holding.Symbol' minResolution.Value' true' 1.0m);                              }                              else                              {                                  // for items not directly requested set leverage to 1 and at the min resolution                                  algorithm.AddSecurity(holding.Type' holding.Symbol.Value' minResolution.Value' null' true' 1.0m' false);                              }                          }                            algorithm.Portfolio[holding.Symbol].SetHoldings(holding.AveragePrice' holding.Quantity);                          algorithm.Securities[holding.Symbol].SetMarketPrice(new TradeBar                          {                              Time = DateTime.Now'                              Open = holding.MarketPrice'                              High = holding.MarketPrice'                              Low = holding.MarketPrice'                              Close = holding.MarketPrice'                              Volume = 0'                              Symbol = holding.Symbol'                              DataType = MarketDataType.TradeBar                          });                      }                  }                  catch (Exception err)                  {                      Log.Error(err);                      AddInitializationError("Error getting account holdings from brokerage: " + err.Message);                      return false;                  }                    algorithm.PostInitialize();                    //Set the starting portfolio value for the strategy to calculate performance:                  StartingPortfolioValue = algorithm.Portfolio.TotalPortfolioValue;                  StartingDate = DateTime.Now;              }              catch (Exception err)              {                  AddInitializationError(err.ToString());              }              finally              {                  if (brokerage != null)                  {                      brokerage.Message -= brokerageOnMessage;                  }              }
Magic Number,QuantConnect.Lean.Engine.Setup,BrokerageSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BrokerageSetupHandler.cs,Setup,The following statement contains a magic number: try              {                  Log.Trace("BrokerageSetupHandler.Setup(): Initializing algorithm...");                    resultHandler.SendStatusUpdate(AlgorithmStatus.Initializing' "Initializing algorithm...");                    //Execute the initialize code:                  var controls = job.Controls;                  var isolator = new Isolator();                  var initializeComplete = isolator.ExecuteWithTimeLimit(TimeSpan.FromSeconds(300)' () =>                  {                      try                      {                          //Set the default brokerage model before initialize                          algorithm.SetBrokerageModel(_factory.BrokerageModel);                            //Margin calls are disabled by default in live mode                          algorithm.Portfolio.MarginCallModel = MarginCallModel.Null;                            //Set our parameters                          algorithm.SetParameters(job.Parameters);                          algorithm.SetAvailableDataTypes(GetConfiguredDataFeeds());                            //Algorithm is live' not backtesting:                          algorithm.SetLiveMode(true);                            //Initialize the algorithm's starting date                          algorithm.SetDateTime(DateTime.UtcNow);                            //Set the source impl for the event scheduling                          algorithm.Schedule.SetEventSchedule(realTimeHandler);                            // set the option chain provider                          algorithm.SetOptionChainProvider(new CachingOptionChainProvider(new LiveOptionChainProvider()));                            // set the future chain provider                          algorithm.SetFutureChainProvider(new CachingFutureChainProvider(new LiveFutureChainProvider()));                            // If we're going to receive market data from IB'                          // set the default subscription limit to 100'                          // algorithms can override this setting in the Initialize method                          if (brokerage is InteractiveBrokersBrokerage &&                              liveJob.DataQueueHandler.EndsWith("InteractiveBrokersBrokerage"))                          {                              algorithm.Settings.DataSubscriptionLimit = 100;                          }                            //Initialise the algorithm' get the required data:                          algorithm.Initialize();                          if (liveJob.Brokerage != "PaperBrokerage")                          {                              //Zero the CashBook - we'll populate directly from brokerage                              foreach (var kvp in algorithm.Portfolio.CashBook)                              {                                  kvp.Value.SetAmount(0);                              }                          }                      }                      catch (Exception err)                      {                          AddInitializationError(err.ToString());                      }                  }' controls.RamAllocation);                    if (!initializeComplete)                  {                      AddInitializationError("Initialization timed out.");                      return false;                  }                    // let the world know what we're doing since logging in can take a minute                  resultHandler.SendStatusUpdate(AlgorithmStatus.LoggingIn' "Logging into brokerage...");                    brokerage.Message += brokerageOnMessage;                    Log.Trace("BrokerageSetupHandler.Setup(): Connecting to brokerage...");                  try                  {                      // this can fail for various reasons' such as already being logged in somewhere else                      brokerage.Connect();                  }                  catch (Exception err)                  {                      Log.Error(err);                      AddInitializationError(string.Format("Error connecting to brokerage: {0}. " +                          "This may be caused by incorrect login credentials or an unsupported account type."' err.Message));                      return false;                  }                    if (!brokerage.IsConnected)                  {                      // if we're reporting that we're not connected' bail                      AddInitializationError("Unable to connect to brokerage.");                      return false;                  }                    Log.Trace("BrokerageSetupHandler.Setup(): Fetching cash balance from brokerage...");                  try                  {                      // set the algorithm's cash balance for each currency                      var cashBalance = brokerage.GetCashBalance();                      foreach (var cash in cashBalance)                      {                          Log.Trace("BrokerageSetupHandler.Setup(): Setting " + cash.Symbol + " cash to " + cash.Amount);                          algorithm.Portfolio.SetCash(cash.Symbol' cash.Amount' cash.ConversionRate);                      }                  }                  catch (Exception err)                  {                      Log.Error(err);                      AddInitializationError("Error getting cash balance from brokerage: " + err.Message);                      return false;                  }                    Log.Trace("BrokerageSetupHandler.Setup(): Fetching open orders from brokerage...");                  try                  {                      GetOpenOrders(algorithm' resultHandler' transactionHandler' brokerage);                  }                  catch (Exception err)                  {                      Log.Error(err);                      AddInitializationError("Error getting open orders from brokerage: " + err.Message);                      return false;                  }                    Log.Trace("BrokerageSetupHandler.Setup(): Fetching holdings from brokerage...");                  try                  {                      // populate the algorithm with the account's current holdings                      var holdings = brokerage.GetAccountHoldings();                      var supportedSecurityTypes = new HashSet<SecurityType>                      {                          SecurityType.Equity' SecurityType.Forex' SecurityType.Cfd' SecurityType.Option' SecurityType.Future' SecurityType.Crypto                      };                      var minResolution = new Lazy<Resolution>(() => algorithm.Securities.Select(x => x.Value.Resolution).DefaultIfEmpty(Resolution.Second).Min());                      foreach (var holding in holdings)                      {                          Log.Trace("BrokerageSetupHandler.Setup(): Has existing holding: " + holding);                            // verify existing holding security type                          if (!supportedSecurityTypes.Contains(holding.Type))                          {                              Log.Error("BrokerageSetupHandler.Setup(): Unsupported security type: " + holding.Type + "-" + holding.Symbol.Value);                              AddInitializationError("Found unsupported security type in existing brokerage holdings: " + holding.Type + ". " +                                  "QuantConnect currently supports the following security types: " + string.Join("'"' supportedSecurityTypes));                                // keep aggregating these errors                              continue;                          }                            if (!algorithm.Portfolio.ContainsKey(holding.Symbol))                          {                              Log.Trace("BrokerageSetupHandler.Setup(): Adding unrequested security: " + holding.Symbol.Value);                                if (holding.Type == SecurityType.Option)                              {                                  // add current option contract to the system                                  algorithm.AddOptionContract(holding.Symbol' minResolution.Value' true' 1.0m);                              }                              else if (holding.Type == SecurityType.Future)                              {                                  // add current future contract to the system                                  algorithm.AddFutureContract(holding.Symbol' minResolution.Value' true' 1.0m);                              }                              else                              {                                  // for items not directly requested set leverage to 1 and at the min resolution                                  algorithm.AddSecurity(holding.Type' holding.Symbol.Value' minResolution.Value' null' true' 1.0m' false);                              }                          }                            algorithm.Portfolio[holding.Symbol].SetHoldings(holding.AveragePrice' holding.Quantity);                          algorithm.Securities[holding.Symbol].SetMarketPrice(new TradeBar                          {                              Time = DateTime.Now'                              Open = holding.MarketPrice'                              High = holding.MarketPrice'                              Low = holding.MarketPrice'                              Close = holding.MarketPrice'                              Volume = 0'                              Symbol = holding.Symbol'                              DataType = MarketDataType.TradeBar                          });                      }                  }                  catch (Exception err)                  {                      Log.Error(err);                      AddInitializationError("Error getting account holdings from brokerage: " + err.Message);                      return false;                  }                    algorithm.PostInitialize();                    //Set the starting portfolio value for the strategy to calculate performance:                  StartingPortfolioValue = algorithm.Portfolio.TotalPortfolioValue;                  StartingDate = DateTime.Now;              }              catch (Exception err)              {                  AddInitializationError(err.ToString());              }              finally              {                  if (brokerage != null)                  {                      brokerage.Message -= brokerageOnMessage;                  }              }
Magic Number,QuantConnect.Lean.Engine.Setup,ConsoleSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\ConsoleSetupHandler.cs,ConsoleSetupHandler,The following statement contains a magic number: StartingDate = new DateTime(1998' 01' 01);
Magic Number,QuantConnect.Lean.Engine.Setup,ConsoleSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\ConsoleSetupHandler.cs,ConsoleSetupHandler,The following statement contains a magic number: MaximumRuntime = TimeSpan.FromDays(10 * 365);
Magic Number,QuantConnect.Lean.Engine.Setup,ConsoleSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\ConsoleSetupHandler.cs,ConsoleSetupHandler,The following statement contains a magic number: MaximumRuntime = TimeSpan.FromDays(10 * 365);
Magic Number,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,CreateAlgorithmInstance,The following statement contains a magic number: var loader = new Loader(algorithmNodePacket.Language' TimeSpan.FromSeconds(60)' names => names.SingleOrAlgorithmTypeName(Config.Get("algorithm-type-name")));
Magic Number,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,Setup,The following statement contains a magic number: var initializeComplete = isolator.ExecuteWithTimeLimit(TimeSpan.FromMinutes(5)' () =>              {                  try                  {                      resultHandler.SendStatusUpdate(AlgorithmStatus.Initializing' "Initializing algorithm...");                        //Set our parameters                      algorithm.SetParameters(job.Parameters);                        //Algorithm is backtesting' not live:                      algorithm.SetLiveMode(false);                        //Set the source impl for the event scheduling                      algorithm.Schedule.SetEventSchedule(realTimeHandler);                        // set the option chain provider                      algorithm.SetOptionChainProvider(new CachingOptionChainProvider(new BacktestingOptionChainProvider()));                        // set the future chain provider                      algorithm.SetFutureChainProvider(new CachingFutureChainProvider(new BacktestingFutureChainProvider()));                        //Initialise the algorithm' get the required data:                      algorithm.Initialize();                  }                  catch (Exception err)                  {                      Log.Error(err);                      Errors.Add("Failed to initialize algorithm: Initialize(): " + err);                  }              }' controls.RamAllocation);
Magic Number,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,Setup,The following statement contains a magic number: if (job.Language == Language.Python)              {                  _maxRuntime = _maxRuntime.Add(TimeSpan.FromSeconds(_maxRuntime.TotalSeconds * 9));              }
Magic Number,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,Setup,The following statement contains a magic number: if (job.UserPlan == UserPlan.Free)              {                  _maxOrders = 10000;              }              else              {                  _maxOrders = int.MaxValue;                  _maxRuntime += _maxRuntime;              }
Magic Number,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,GetMaximumRuntime,The following statement contains a magic number: maxRunTime = 10 * subscriptionCount * jobDays;
Magic Number,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,GetMaximumRuntime,The following statement contains a magic number: if ((maxRunTime / 3600) > 12)              {                  //12 hours maximum                  maxRunTime = 3600 * 12;              }              else if (maxRunTime < 60)              {                  //If less than 60 seconds.                  maxRunTime = 60;              }
Magic Number,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,GetMaximumRuntime,The following statement contains a magic number: if ((maxRunTime / 3600) > 12)              {                  //12 hours maximum                  maxRunTime = 3600 * 12;              }              else if (maxRunTime < 60)              {                  //If less than 60 seconds.                  maxRunTime = 60;              }
Magic Number,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,GetMaximumRuntime,The following statement contains a magic number: if ((maxRunTime / 3600) > 12)              {                  //12 hours maximum                  maxRunTime = 3600 * 12;              }              else if (maxRunTime < 60)              {                  //If less than 60 seconds.                  maxRunTime = 60;              }
Magic Number,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,GetMaximumRuntime,The following statement contains a magic number: if ((maxRunTime / 3600) > 12)              {                  //12 hours maximum                  maxRunTime = 3600 * 12;              }              else if (maxRunTime < 60)              {                  //If less than 60 seconds.                  maxRunTime = 60;              }
Magic Number,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,GetMaximumRuntime,The following statement contains a magic number: if ((maxRunTime / 3600) > 12)              {                  //12 hours maximum                  maxRunTime = 3600 * 12;              }              else if (maxRunTime < 60)              {                  //If less than 60 seconds.                  maxRunTime = 60;              }
Magic Number,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,GetMaximumRuntime,The following statement contains a magic number: if ((maxRunTime / 3600) > 12)              {                  //12 hours maximum                  maxRunTime = 3600 * 12;              }              else if (maxRunTime < 60)              {                  //If less than 60 seconds.                  maxRunTime = 60;              }
Magic Number,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,GetMaximumRuntime,The following statement contains a magic number: Log.Trace("BacktestingSetupHandler.GetMaxRunTime(): Job Days: " + jobDays + " Max Runtime: " + Math.Round(maxRunTime / 60) + " min");
Magic Number,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,GetMaximumRuntime,The following statement contains a magic number: if (OS.IsWindows)              {                  maxRunTime = 24 * 60 * 60;              }
Magic Number,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,GetMaximumRuntime,The following statement contains a magic number: if (OS.IsWindows)              {                  maxRunTime = 24 * 60 * 60;              }
Magic Number,QuantConnect.Lean.Engine.Setup,BacktestingSetupHandler,C:\repos\QuantConnect_Lean\Engine\Setup\BacktestingSetupHandler.cs,GetMaximumRuntime,The following statement contains a magic number: if (OS.IsWindows)              {                  maxRunTime = 24 * 60 * 60;              }
Magic Number,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,ProcessSynchronousEvents,The following statement contains a magic number: if (_algorithm.LiveMode && !_syncedLiveBrokerageCashToday && currentTimeNewYork.TimeOfDay >= LiveBrokerageCashSyncTime)              {                  try                  {                      // only perform cash syncs if we haven't had a fill for at least 10 seconds                      if (TimeSinceLastFill > TimeSpan.FromSeconds(10))                      {                          PerformCashSync();                      }                  }                  catch (Exception err)                  {                      Log.Error(err' "Updating cash balances");                  }              }
Magic Number,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,ProcessSynchronousEvents,The following statement contains a magic number: const int maxOrdersToKeep = 10000;
Magic Number,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,PerformCashSync,The following statement contains a magic number: try              {                  // prevent reentrance in this method                  if (!Monitor.TryEnter(_performCashSyncReentranceGuard))                  {                      return;                  }                    Log.Trace("BrokerageTransactionHandler.PerformCashSync(): Sync cash balance");                    var balances = new List<Cash>();                  try                  {                      balances = _brokerage.GetCashBalance();                  }                  catch (Exception err)                  {                      Log.Error(err);                  }                    if (balances.Count == 0)                  {                      return;                  }                    //Adds currency to the cashbook that the user might have deposited                  foreach (var balance in balances)                  {                      Cash cash;                      if (!_algorithm.Portfolio.CashBook.TryGetValue(balance.Symbol' out cash))                      {                          Log.LogHandler.Trace("BrokerageTransactionHandler.PerformCashSync(): Unexpected cash found {0} {1}"' balance.Amount' balance.Symbol);                          _algorithm.Portfolio.SetCash(balance.Symbol' balance.Amount' balance.ConversionRate);                      }                  }                    // if we were returned our balances' update everything and flip our flag as having performed sync today                  foreach (var cash in _algorithm.Portfolio.CashBook.Values)                  {                      var balanceCash = balances.FirstOrDefault(balance => balance.Symbol == cash.Symbol);                      //update the cash if the entry if found in the balances                      if (balanceCash != null)                      {                          // compare in dollars                          var delta = cash.Amount - balanceCash.Amount;                          if (Math.Abs(_algorithm.Portfolio.CashBook.ConvertToAccountCurrency(delta' cash.Symbol)) > 5)                          {                              // log the delta between                              Log.LogHandler.Trace("BrokerageTransactionHandler.PerformCashSync(): {0} Delta: {1}"' balanceCash.Symbol'                                  delta.ToString("0.00"));                          }                          _algorithm.Portfolio.SetCash(balanceCash.Symbol' balanceCash.Amount' balanceCash.ConversionRate);                      }                      else                      {                          //Set the cash amount to zero if cash entry not found in the balances                          _algorithm.Portfolio.SetCash(cash.Symbol' 0' cash.ConversionRate);                      }                  }                  _syncedLiveBrokerageCashToday = true;              }              finally              {                  Monitor.Exit(_performCashSyncReentranceGuard);              }
Magic Number,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,PerformCashSync,The following statement contains a magic number: Task.Delay(TimeSpan.FromSeconds(10)).ContinueWith(_ =>              {                  // we want to make sure this is a good value' so check for any recent fills                  if (TimeSinceLastFill <= TimeSpan.FromSeconds(20))                  {                      // this will cause us to come back in and reset cash again until we                      // haven't processed a fill for +- 10 seconds of the set cash time                      _syncedLiveBrokerageCashToday = false;                      Log.Trace("BrokerageTransactionHandler.PerformCashSync(): Unverified cash sync - resync required.");                  }                  else                  {                      _lastSyncTimeTicks = DateTime.UtcNow.Ticks;                      Log.Trace("BrokerageTransactionHandler.PerformCashSync(): Verified cash sync.");                  }              });
Magic Number,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,PerformCashSync,The following statement contains a magic number: Task.Delay(TimeSpan.FromSeconds(10)).ContinueWith(_ =>              {                  // we want to make sure this is a good value' so check for any recent fills                  if (TimeSinceLastFill <= TimeSpan.FromSeconds(20))                  {                      // this will cause us to come back in and reset cash again until we                      // haven't processed a fill for +- 10 seconds of the set cash time                      _syncedLiveBrokerageCashToday = false;                      Log.Trace("BrokerageTransactionHandler.PerformCashSync(): Unverified cash sync - resync required.");                  }                  else                  {                      _lastSyncTimeTicks = DateTime.UtcNow.Ticks;                      Log.Trace("BrokerageTransactionHandler.PerformCashSync(): Verified cash sync.");                  }              });
Magic Number,QuantConnect.Lean.Engine.TransactionHandlers,BrokerageTransactionHandler,C:\repos\QuantConnect_Lean\Engine\TransactionHandlers\BrokerageTransactionHandler.cs,Exit,The following statement contains a magic number: var timeout = TimeSpan.FromSeconds(60);
Missing Default,QuantConnect.Lean.Engine,Engine,C:\repos\QuantConnect_Lean\Engine\Engine.cs,Run,The following switch statement is missing a default case: switch (message.Type)                          {                              case BrokerageMessageType.Disconnect:                                  algorithm.OnBrokerageDisconnect();                                  break;                              case BrokerageMessageType.Reconnect:                                  algorithm.OnBrokerageReconnect();                                  break;                          }
Missing Default,QuantConnect.Lean.Engine.DataFeeds,TimeSlice,C:\repos\QuantConnect_Lean\Engine\DataFeeds\TimeSlice.cs,PopulateDataDictionaries,The following switch statement is missing a default case: switch (baseData.DataType)              {                  case MarketDataType.Tick:                      ticks.Add(symbol' (Tick)baseData);                      break;                    case MarketDataType.TradeBar:                      tradeBars[symbol] = (TradeBar) baseData;                      break;                    case MarketDataType.QuoteBar:                      quoteBars[symbol] = (QuoteBar) baseData;                      break;                    case MarketDataType.OptionChain:                      optionChains[symbol] = (OptionChain) baseData;                      break;                    case MarketDataType.FuturesChain:                      futuresChains[symbol] = (FuturesChain)baseData;                      break;              }
Missing Default,QuantConnect.Lean.Engine.DataFeeds,TimeSlice,C:\repos\QuantConnect_Lean\Engine\DataFeeds\TimeSlice.cs,HandleOptionData,The following switch statement is missing a default case: switch (baseData.DataType)              {                  case MarketDataType.Tick:                      var tick = (Tick)baseData;                      chain.Ticks.Add(tick.Symbol' tick);                      UpdateContract(contract' tick);                      break;                    case MarketDataType.TradeBar:                      var tradeBar = (TradeBar)baseData;                      chain.TradeBars[symbol] = tradeBar;                      contract.LastPrice = tradeBar.Close;                      break;                    case MarketDataType.QuoteBar:                      var quote = (QuoteBar)baseData;                      chain.QuoteBars[symbol] = quote;                      UpdateContract(contract' quote);                      break;                    case MarketDataType.Base:                      chain.AddAuxData(baseData);                      break;              }
Missing Default,QuantConnect.Lean.Engine.DataFeeds,TimeSlice,C:\repos\QuantConnect_Lean\Engine\DataFeeds\TimeSlice.cs,HandleFuturesData,The following switch statement is missing a default case: switch (baseData.DataType)              {                  case MarketDataType.Tick:                      var tick = (Tick)baseData;                      chain.Ticks.Add(tick.Symbol' tick);                      UpdateContract(contract' tick);                      break;                    case MarketDataType.TradeBar:                      var tradeBar = (TradeBar)baseData;                      chain.TradeBars[symbol] = tradeBar;                      contract.LastPrice = tradeBar.Close;                      break;                    case MarketDataType.QuoteBar:                      var quote = (QuoteBar)baseData;                      chain.QuoteBars[symbol] = quote;                      UpdateContract(contract' quote);                      break;                    case MarketDataType.Base:                      chain.AddAuxData(baseData);                      break;              }
