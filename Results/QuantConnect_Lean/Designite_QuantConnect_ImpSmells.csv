Implementation smell,Namespace,Class,File,Method,Description
Long Method,QuantConnect.Securities,SecurityPortfolioModel,C:\repos\QuantConnect_Lean\Common\Securities\SecurityPortfolioModel.cs,ProcessFill,The method has 135 lines of code.
Long Method,QuantConnect.Securities.Option,QLOptionPriceModel,C:\repos\QuantConnect_Lean\Common\Securities\Option\QLOptionPriceModel.cs,Evaluate,The method has 120 lines of code.
Long Method,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The method has 120 lines of code.
Long Method,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,BalanceSheet,The method has 372 lines of code.
Long Method,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The method has 373 lines of code.
Long Method,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,CashFlowStatement,The method has 247 lines of code.
Long Method,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The method has 248 lines of code.
Long Method,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,IncomeStatement,The method has 264 lines of code.
Long Method,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The method has 265 lines of code.
Long Method,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The method has 215 lines of code.
Long Method,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFillToFill,The method has 109 lines of code.
Long Method,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,GenerateLine,The method has 236 lines of code.
Complex Method,QuantConnect,Isolator,C:\repos\QuantConnect_Lean\Common\Isolator.cs,ExecuteWithTimeLimit,Cyclomatic complexity of the method is 8
Complex Method,QuantConnect.Orders.Fills,ImmediateFillModel,C:\repos\QuantConnect_Lean\Common\Orders\Fills\ImmediateFillModel.cs,GetPrices,Cyclomatic complexity of the method is 8
Complex Method,QuantConnect.Python,PandasData,C:\repos\QuantConnect_Lean\Common\Python\PandasData.cs,Add,Cyclomatic complexity of the method is 12
Complex Method,QuantConnect.Securities,Cash,C:\repos\QuantConnect_Lean\Common\Securities\Cash.cs,EnsureCurrencyDataFeed,Cyclomatic complexity of the method is 11
Complex Method,QuantConnect.Securities,SecurityCache,C:\repos\QuantConnect_Lean\Common\Securities\SecurityCache.cs,AddData,Cyclomatic complexity of the method is 22
Complex Method,QuantConnect.Securities,SecurityManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityManager.cs,CreateSecurity,Cyclomatic complexity of the method is 11
Complex Method,QuantConnect.Data.Market,FuturesChain,C:\repos\QuantConnect_Lean\Common\Data\Market\FuturesChain.cs,FuturesChain,Cyclomatic complexity of the method is 10
Complex Method,QuantConnect.Data.Market,OptionChain,C:\repos\QuantConnect_Lean\Common\Data\Market\OptionChain.cs,OptionChain,Cyclomatic complexity of the method is 10
Complex Method,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,Update,Cyclomatic complexity of the method is 8
Complex Method,QuantConnect.Data.Consolidators,PeriodCountConsolidatorBase<T;TConsolidated>,C:\repos\QuantConnect_Lean\Common\Data\Consolidators\PeriodCountConsolidatorBase.cs,Update,Cyclomatic complexity of the method is 15
Complex Method,QuantConnect.Data.Fundamental,FineFundamental,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\FineFundamental.cs,UpdateValues,Cyclomatic complexity of the method is 9
Complex Method,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,Cyclomatic complexity of the method is 372
Complex Method,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,Cyclomatic complexity of the method is 247
Complex Method,QuantConnect.Data.Fundamental,EarningReports,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\EarningReports.cs,UpdateValues,Cyclomatic complexity of the method is 24
Complex Method,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,Cyclomatic complexity of the method is 264
Complex Method,QuantConnect.Data.Fundamental,OperationRatios,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\OperationRatios.cs,UpdateValues,Cyclomatic complexity of the method is 53
Complex Method,QuantConnect.Parameters,ParameterAttribute,C:\repos\QuantConnect_Lean\Common\Parameters\ParameterAttribute.cs,ApplyAttributes,Cyclomatic complexity of the method is 8
Complex Method,QuantConnect.Statistics,TradeStatistics,C:\repos\QuantConnect_Lean\Common\Statistics\TradeStatistics.cs,TradeStatistics,Cyclomatic complexity of the method is 15
Complex Method,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,Cyclomatic complexity of the method is 13
Complex Method,QuantConnect.Util,LeanDataPathComponents,C:\repos\QuantConnect_Lean\Common\Util\LeanDataPathComponents.cs,Parse,Cyclomatic complexity of the method is 9
Long Parameter List,QuantConnect,SecurityIdentifier,C:\repos\QuantConnect_Lean\Common\SecurityIdentifier.cs,GenerateOption,The method has 6 parameters. Parameters: expiry' underlying' market' strike' optionRight' optionStyle
Long Parameter List,QuantConnect,SecurityIdentifier,C:\repos\QuantConnect_Lean\Common\SecurityIdentifier.cs,Generate,The method has 8 parameters. Parameters: date' symbol' securityType' market' strike' optionRight' optionStyle' underlying
Long Parameter List,QuantConnect,Series,C:\repos\QuantConnect_Lean\Common\Charting.cs,Series,The method has 5 parameters. Parameters: name' type' unit' color' symbol
Long Parameter List,QuantConnect,Extensions,C:\repos\QuantConnect_Lean\Common\Extensions.cs,ExchangeRoundDownInTimeZone,The method has 5 parameters. Parameters: dateTime' interval' exchangeHours' roundingTimeZone' extendedMarket
Long Parameter List,QuantConnect,Symbol,C:\repos\QuantConnect_Lean\Common\Symbol.cs,CreateOption,The method has 8 parameters. Parameters: underlying' market' style' right' strike' expiry' alias' mapSymbol
Long Parameter List,QuantConnect,Symbol,C:\repos\QuantConnect_Lean\Common\Symbol.cs,CreateOption,The method has 7 parameters. Parameters: underlyingSymbol' market' style' right' strike' expiry' alias
Long Parameter List,QuantConnect,Time,C:\repos\QuantConnect_Lean\Common\Time.cs,EachTradeableDayInTimeZone,The method has 5 parameters. Parameters: exchange' from' thru' timeZone' includeExtendedMarketHours
Long Parameter List,QuantConnect,Time,C:\repos\QuantConnect_Lean\Common\Time.cs,GetStartTimeForTradeBars,The method has 5 parameters. Parameters: exchange' end' barSize' barCount' extendedMarketHours
Long Parameter List,QuantConnect.API,LiveAlgorithmApiSettingsWrapper,C:\repos\QuantConnect_Lean\Common\API\LiveAlgorithmSettings.cs,LiveAlgorithmApiSettingsWrapper,The method has 5 parameters. Parameters: projectId' compileId' serverType' settings' version
Long Parameter List,QuantConnect.Brokerages,DefaultBrokerageMessageHandler,C:\repos\QuantConnect_Lean\Common\Brokerages\DefaultBrokerageMessageHandler.cs,DefaultBrokerageMessageHandler,The method has 5 parameters. Parameters: algorithm' job' api' initialDelay' openThreshold
Long Parameter List,QuantConnect.Brokerages,FxcmBrokerageModel,C:\repos\QuantConnect_Lean\Common\Brokerages\FxcmBrokerageModel.cs,IsValidOrderPrices,The method has 6 parameters. Parameters: security' orderType' orderDirection' stopPrice' limitPrice' message
Long Parameter List,QuantConnect.Interfaces,IAlgorithm,C:\repos\QuantConnect_Lean\Common\Interfaces\IAlgorithm.cs,AddSecurity,The method has 7 parameters. Parameters: securityType' symbol' resolution' market' fillDataForward' leverage' extendedMarketHours
Long Parameter List,QuantConnect.Interfaces,IApi,C:\repos\QuantConnect_Lean\Common\Interfaces\IApi.cs,CreateLiveAlgorithm,The method has 5 parameters. Parameters: projectId' compileId' serverType' baseLiveAlgorithmSettings' versionId
Long Parameter List,QuantConnect.Interfaces,IApi,C:\repos\QuantConnect_Lean\Common\Interfaces\IApi.cs,SendStatistics,The method has 10 parameters. Parameters: algorithmId' unrealized' fees' netProfit' holdings' equity' netReturn' volume' trades' sharpe
Long Parameter List,QuantConnect.Interfaces,IHistoryProvider,C:\repos\QuantConnect_Lean\Common\Interfaces\IHistoryProvider.cs,Initialize,The method has 6 parameters. Parameters: job' dataProvider' dataCacheProvider' mapFileProvider' factorFileProvider' statusUpdate
Long Parameter List,QuantConnect.Orders.Fills,Prices,C:\repos\QuantConnect_Lean\Common\Orders\Fills\ImmediateFillModel.cs,Prices,The method has 5 parameters. Parameters: current' open' high' low' close
Long Parameter List,QuantConnect.Orders,MarketOnCloseOrder,C:\repos\QuantConnect_Lean\Common\Orders\MarketOnCloseOrder.cs,MarketOnCloseOrder,The method has 5 parameters. Parameters: symbol' quantity' time' tag' properties
Long Parameter List,QuantConnect.Orders,MarketOnOpenOrder,C:\repos\QuantConnect_Lean\Common\Orders\MarketOnOpenOrder.cs,MarketOnOpenOrder,The method has 5 parameters. Parameters: symbol' quantity' time' tag' properties
Long Parameter List,QuantConnect.Orders,OptionExerciseOrder,C:\repos\QuantConnect_Lean\Common\Orders\OptionExerciseOrder.cs,OptionExerciseOrder,The method has 5 parameters. Parameters: symbol' quantity' time' tag' properties
Long Parameter List,QuantConnect.Orders,StopLimitOrder,C:\repos\QuantConnect_Lean\Common\Orders\StopLimitOrder.cs,StopLimitOrder,The method has 7 parameters. Parameters: symbol' quantity' stopPrice' limitPrice' time' tag' properties
Long Parameter List,QuantConnect.Orders,StopMarketOrder,C:\repos\QuantConnect_Lean\Common\Orders\StopMarketOrder.cs,StopMarketOrder,The method has 6 parameters. Parameters: symbol' quantity' stopPrice' time' tag' properties
Long Parameter List,QuantConnect.Orders,LimitOrder,C:\repos\QuantConnect_Lean\Common\Orders\LimitOrder.cs,LimitOrder,The method has 6 parameters. Parameters: symbol' quantity' limitPrice' time' tag' properties
Long Parameter List,QuantConnect.Orders,MarketOrder,C:\repos\QuantConnect_Lean\Common\Orders\MarketOrder.cs,MarketOrder,The method has 5 parameters. Parameters: symbol' quantity' time' tag' properties
Long Parameter List,QuantConnect.Orders,SubmitOrderRequest,C:\repos\QuantConnect_Lean\Common\Orders\SubmitOrderRequest.cs,SubmitOrderRequest,The method has 9 parameters. Parameters: orderType' securityType' symbol' quantity' stopPrice' limitPrice' time' tag' properties
Long Parameter List,QuantConnect.Orders,OrderEvent,C:\repos\QuantConnect_Lean\Common\Orders\OrderEvent.cs,OrderEvent,The method has 9 parameters. Parameters: orderId' symbol' utcTime' status' direction' fillPrice' fillQuantity' orderFee' message
Long Parameter List,QuantConnect.Orders,Order,C:\repos\QuantConnect_Lean\Common\Orders\Order.cs,Order,The method has 5 parameters. Parameters: symbol' quantity' time' tag' properties
Long Parameter List,QuantConnect.Securities,Cash,C:\repos\QuantConnect_Lean\Common\Securities\Cash.cs,EnsureCurrencyDataFeed,The method has 6 parameters. Parameters: securities' subscriptions' marketHoursDatabase' symbolPropertiesDatabase' marketMap' cashBook
Long Parameter List,QuantConnect.Securities,CashBook,C:\repos\QuantConnect_Lean\Common\Securities\CashBook.cs,EnsureCurrencyDataFeeds,The method has 5 parameters. Parameters: securities' subscriptions' marketHoursDatabase' symbolPropertiesDatabase' marketMap
Long Parameter List,QuantConnect.Securities,DelayedSettlementModel,C:\repos\QuantConnect_Lean\Common\Securities\DelayedSettlementModel.cs,ApplyFunds,The method has 5 parameters. Parameters: portfolio' security' applicationTimeUtc' currency' amount
Long Parameter List,QuantConnect.Securities,ISettlementModel,C:\repos\QuantConnect_Lean\Common\Securities\ISettlementModel.cs,ApplyFunds,The method has 5 parameters. Parameters: portfolio' security' applicationTimeUtc' currency' amount
Long Parameter List,QuantConnect.Securities,LocalMarketHours,C:\repos\QuantConnect_Lean\Common\Securities\LocalMarketHours.cs,LocalMarketHours,The method has 5 parameters. Parameters: day' extendedMarketOpen' marketOpen' marketClose' extendedMarketClose
Long Parameter List,QuantConnect.Securities,ImmediateSettlementModel,C:\repos\QuantConnect_Lean\Common\Securities\ImmediateSettlementModel.cs,ApplyFunds,The method has 5 parameters. Parameters: portfolio' security' applicationTimeUtc' currency' amount
Long Parameter List,QuantConnect.Securities,SymbolProperties,C:\repos\QuantConnect_Lean\Common\Securities\SymbolProperties.cs,SymbolProperties,The method has 5 parameters. Parameters: description' quoteCurrency' contractMultiplier' minimumPriceVariation' lotSize
Long Parameter List,QuantConnect.Securities,Security,C:\repos\QuantConnect_Lean\Common\Securities\Security.cs,Security,The method has 14 parameters. Parameters: symbol' quoteCurrency' symbolProperties' exchange' cache' portfolioModel' fillModel' feeModel' slippageModel' settlementModel' volatilityModel' marginModel' dataFilter' priceVariationModel
Long Parameter List,QuantConnect.Securities,Security,C:\repos\QuantConnect_Lean\Common\Securities\Security.cs,Security,The method has 14 parameters. Parameters: config' quoteCurrency' symbolProperties' exchange' cache' portfolioModel' fillModel' feeModel' slippageModel' settlementModel' volatilityModel' marginModel' dataFilter' priceVariationModel
Long Parameter List,QuantConnect.Securities,SecurityManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityManager.cs,CreateSecurity,The method has 17 parameters. Parameters: subscriptionDataTypes' securityPortfolioManager' subscriptionManager' exchangeHours' dataTimeZone' symbolProperties' securityInitializer' symbol' resolution' fillDataForward' leverage' extendedMarketHours' isInternalFeed' isCustomData' isLiveMode' addToSymbolCache' isFilteredSubscription
Long Parameter List,QuantConnect.Securities,SecurityManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityManager.cs,CreateSecurity,The method has 17 parameters. Parameters: dataType' securityPortfolioManager' subscriptionManager' exchangeHours' dataTimeZone' symbolProperties' securityInitializer' symbol' resolution' fillDataForward' leverage' extendedMarketHours' isInternalFeed' isCustomData' isLiveMode' addToSymbolCache' isFilteredSubscription
Long Parameter List,QuantConnect.Securities,SecurityManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityManager.cs,CreateSecurity,The method has 14 parameters. Parameters: securityPortfolioManager' subscriptionManager' marketHoursDatabase' symbolPropertiesDatabase' securityInitializer' symbol' resolution' fillDataForward' leverage' extendedMarketHours' isInternalFeed' isCustomData' isLiveMode' addToSymbolCache
Long Parameter List,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,CallButterfly,The method has 5 parameters. Parameters: canonicalOption' leg1Strike' leg2Strike' leg3Strike' expiration
Long Parameter List,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,PutButterfly,The method has 5 parameters. Parameters: canonicalOption' leg1Strike' leg2Strike' leg3Strike' expiration
Long Parameter List,QuantConnect.Securities.Option,OptionSymbolProperties,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionSymbolProperties.cs,OptionSymbolProperties,The method has 5 parameters. Parameters: description' quoteCurrency' contractMultiplier' pipSize' lotSize
Long Parameter List,QuantConnect.Data.Market,Greeks,C:\repos\QuantConnect_Lean\Common\Data\Market\Greeks.cs,Greeks,The method has 6 parameters. Parameters: delta' gamma' vega' theta' rho' lambda
Long Parameter List,QuantConnect.Data.Market,Greeks,C:\repos\QuantConnect_Lean\Common\Data\Market\Greeks.cs,Greeks,The method has 6 parameters. Parameters: delta' gamma' vega' theta' rho' lambda
Long Parameter List,QuantConnect.Data.Market,Greeks,C:\repos\QuantConnect_Lean\Common\Data\Market\Greeks.cs,Greeks,The method has 5 parameters. Parameters: deltaGamma' vega' theta' rho' lambda
Long Parameter List,QuantConnect.Data.Market,FuturesChain,C:\repos\QuantConnect_Lean\Common\Data\Market\FuturesChain.cs,FuturesChain,The method has 6 parameters. Parameters: canonicalFutureSymbol' time' trades' quotes' contracts' filteredContracts
Long Parameter List,QuantConnect.Data.Market,OptionChain,C:\repos\QuantConnect_Lean\Common\Data\Market\OptionChain.cs,OptionChain,The method has 7 parameters. Parameters: canonicalOptionSymbol' time' underlying' trades' quotes' contracts' filteredContracts
Long Parameter List,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,QuoteBar,The method has 7 parameters. Parameters: time' symbol' bid' lastBidSize' ask' lastAskSize' period
Long Parameter List,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,Update,The method has 6 parameters. Parameters: lastTrade' bidPrice' askPrice' volume' bidSize' askSize
Long Parameter List,QuantConnect.Data.Market,RenkoBar,C:\repos\QuantConnect_Lean\Common\Data\Market\RenkoBar.cs,RenkoBar,The method has 5 parameters. Parameters: symbol' time' brickSize' open' volume
Long Parameter List,QuantConnect.Data.Market,RenkoBar,C:\repos\QuantConnect_Lean\Common\Data\Market\RenkoBar.cs,RenkoBar,The method has 8 parameters. Parameters: symbol' start' endTime' brickSize' open' high' low' close
Long Parameter List,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The method has 5 parameters. Parameters: time' symbol' last' bid' ask
Long Parameter List,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Update,The method has 6 parameters. Parameters: lastTrade' bidPrice' askPrice' volume' bidSize' askSize
Long Parameter List,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,TradeBar,The method has 8 parameters. Parameters: time' symbol' open' high' low' close' volume' period
Long Parameter List,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,Update,The method has 6 parameters. Parameters: lastTrade' bidPrice' askPrice' volume' bidSize' askSize
Long Parameter List,QuantConnect.Data,HistoryRequest,C:\repos\QuantConnect_Lean\Common\Data\HistoryRequest.cs,HistoryRequest,The method has 12 parameters. Parameters: startTimeUtc' endTimeUtc' dataType' symbol' resolution' exchangeHours' dataTimeZone' fillForwardResolution' includeExtendedMarketHours' isCustomData' dataNormalizationMode' tickType
Long Parameter List,QuantConnect.Data,Slice,C:\repos\QuantConnect_Lean\Common\Data\Slice.cs,Slice,The method has 12 parameters. Parameters: time' data' tradeBars' quoteBars' ticks' optionChains' futuresChains' splits' dividends' delistings' symbolChanges' hasData
Long Parameter List,QuantConnect.Data,BaseData,C:\repos\QuantConnect_Lean\Common\Data\BaseData.cs,Update,The method has 6 parameters. Parameters: lastTrade' bidPrice' askPrice' volume' bidSize' askSize
Long Parameter List,QuantConnect.Data,SubscriptionDataConfig,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionDataConfig.cs,SubscriptionDataConfig,The method has 12 parameters. Parameters: objectType' symbol' resolution' dataTimeZone' exchangeTimeZone' fillForward' extendedHours' isInternalFeed' isCustom' tickType' isFilteredSubscription' dataNormalizationMode
Long Parameter List,QuantConnect.Data,SubscriptionDataConfig,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionDataConfig.cs,SubscriptionDataConfig,The method has 13 parameters. Parameters: config' objectType' symbol' resolution' dataTimeZone' exchangeTimeZone' fillForward' extendedHours' isInternalFeed' isCustom' tickType' isFilteredSubscription' dataNormalizationMode
Long Parameter List,QuantConnect.Data,SubscriptionManager,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionManager.cs,Add,The method has 7 parameters. Parameters: symbol' resolution' timeZone' exchangeTimeZone' isCustomData' fillDataForward' extendedMarketHours
Long Parameter List,QuantConnect.Data,SubscriptionManager,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionManager.cs,Add,The method has 11 parameters. Parameters: dataType' tickType' symbol' resolution' dataTimeZone' exchangeTimeZone' isCustomData' fillDataForward' extendedMarketHours' isInternalFeed' isFilteredSubscription
Long Parameter List,QuantConnect.Data.UniverseSelection,SubscriptionRequest,C:\repos\QuantConnect_Lean\Common\Data\UniverseSelection\SubscriptionRequest.cs,SubscriptionRequest,The method has 6 parameters. Parameters: isUniverseSubscription' universe' security' configuration' startTimeUtc' endTimeUtc
Long Parameter List,QuantConnect.Data.UniverseSelection,SubscriptionRequest,C:\repos\QuantConnect_Lean\Common\Data\UniverseSelection\SubscriptionRequest.cs,SubscriptionRequest,The method has 7 parameters. Parameters: template' isUniverseSubscription' universe' security' configuration' startTimeUtc' endTimeUtc
Long Parameter List,QuantConnect.Data.UniverseSelection,OptionChainUniverseDataCollection,C:\repos\QuantConnect_Lean\Common\Data\UniverseSelection\OptionChainUniverseDataCollection.cs,OptionChainUniverseDataCollection,The method has 5 parameters. Parameters: time' endTime' symbol' data' underlying
Long Parameter List,QuantConnect.Data.UniverseSelection,UserDefinedUniverse,C:\repos\QuantConnect_Lean\Common\Data\UniverseSelection\UserDefinedUniverse.cs,UserDefinedUniverse,The method has 5 parameters. Parameters: configuration' universeSettings' securityInitializer' interval' symbols
Long Parameter List,QuantConnect.Data.UniverseSelection,UserDefinedUniverse,C:\repos\QuantConnect_Lean\Common\Data\UniverseSelection\UserDefinedUniverse.cs,UserDefinedUniverse,The method has 5 parameters. Parameters: configuration' universeSettings' securityInitializer' interval' selector
Long Parameter List,QuantConnect.Data.UniverseSelection,UniverseSettings,C:\repos\QuantConnect_Lean\Common\Data\UniverseSelection\UniverseSettings.cs,UniverseSettings,The method has 5 parameters. Parameters: resolution' leverage' fillForward' extendedMarketHours' minimumTimeInUniverse
Long Parameter List,QuantConnect.Packets,SystemDebugPacket,C:\repos\QuantConnect_Lean\Common\Packets\SystemDebugPacket.cs,SystemDebugPacket,The method has 5 parameters. Parameters: projectId' algorithmId' compileId' message' toast
Long Parameter List,QuantConnect.Packets,BacktestNodePacket,C:\repos\QuantConnect_Lean\Common\Packets\BacktestNodePacket.cs,BacktestNodePacket,The method has 7 parameters. Parameters: userId' projectId' sessionId' algorithmData' startingCapital' name' userPlan
Long Parameter List,QuantConnect.Packets,BacktestResult,C:\repos\QuantConnect_Lean\Common\Packets\BacktestResultPacket.cs,BacktestResult,The method has 7 parameters. Parameters: charts' orders' profitLoss' statistics' runtimeStatistics' rollingWindow' totalPerformance
Long Parameter List,QuantConnect.Packets,DebugPacket,C:\repos\QuantConnect_Lean\Common\Packets\DebugPacket.cs,DebugPacket,The method has 5 parameters. Parameters: projectId' algorithmId' compileId' message' toast
Long Parameter List,QuantConnect.Packets,LiveResult,C:\repos\QuantConnect_Lean\Common\Packets\LiveResultPacket.cs,LiveResult,The method has 8 parameters. Parameters: charts' orders' profitLoss' holdings' cashbook' statistics' runtime' serverStatistics
Long Parameter List,QuantConnect.Statistics,AlgorithmPerformance,C:\repos\QuantConnect_Lean\Common\Statistics\AlgorithmPerformance.cs,AlgorithmPerformance,The method has 6 parameters. Parameters: trades' profitLoss' equity' listPerformance' listBenchmark' startingCapital
Long Parameter List,QuantConnect.Statistics,PortfolioStatistics,C:\repos\QuantConnect_Lean\Common\Statistics\PortfolioStatistics.cs,PortfolioStatistics,The method has 6 parameters. Parameters: profitLoss' equity' listPerformance' listBenchmark' startingCapital' tradingDaysPerYear
Long Parameter List,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,Generate,The method has 8 parameters. Parameters: trades' profitLoss' pointsEquity' pointsPerformance' pointsBenchmark' startingCapital' totalFees' totalTransactions
Long Parameter List,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetAlgorithmPerformance,The method has 8 parameters. Parameters: fromDate' toDate' trades' profitLoss' equity' pointsPerformance' pointsBenchmark' startingCapital
Long Parameter List,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetRollingPerformances,The method has 8 parameters. Parameters: firstDate' lastDate' trades' profitLoss' equity' pointsPerformance' pointsBenchmark' startingCapital
Long Parameter List,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The method has 8 parameters. Parameters: pointsEquity' profitLoss' pointsPerformance' unsortedBenchmark' startingCash' totalFees' totalTrades' tradingDaysPerYear
Long Parameter List,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,GenerateZipFilePath,The method has 5 parameters. Parameters: dataDirectory' symbol' date' resolution' tickType
Long Parameter List,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,GenerateZipFilePath,The method has 6 parameters. Parameters: dataDirectory' symbol' securityType' market' date' resolution
Long Parameter List,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,GenerateRelativeZipFilePath,The method has 5 parameters. Parameters: symbol' securityType' market' date' resolution
Long Parameter List,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,GenerateZipEntryName,The method has 5 parameters. Parameters: symbol' securityType' date' resolution' dataType
Long Parameter List,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,GenerateZipFileName,The method has 5 parameters. Parameters: symbol' securityType' date' resolution' tickType
Long Parameter List,QuantConnect.Util,LeanDataPathComponents,C:\repos\QuantConnect_Lean\Common\Util\LeanDataPathComponents.cs,LeanDataPathComponents,The method has 7 parameters. Parameters: securityType' market' resolution' symbol' filename' date' tickType
Long Identifier,QuantConnect,Extensions,C:\repos\QuantConnect_Lean\Common\Extensions.cs,RoundDownInTimeZone,The length of the parameter roundedDateTimeInRoundingTimeZone is 33.
Long Identifier,QuantConnect.Securities,OptionMarginModel,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionMarginModel.cs,,The length of the parameter NakedPositionMarginRequirement is 30.
Long Identifier,QuantConnect.Securities,OptionMarginModel,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionMarginModel.cs,,The length of the parameter NakedPositionMarginRequirementOtm is 33.
Long Identifier,QuantConnect.Securities,MarketHoursDatabase,C:\repos\QuantConnect_Lean\Common\Securities\MarketHoursDatabase.cs,,The length of the parameter _dataFolderMarketHoursDatabase is 30.
Long Identifier,QuantConnect.Securities,MarketHoursDatabase,C:\repos\QuantConnect_Lean\Common\Securities\MarketHoursDatabase.cs,,The length of the parameter DataFolderMarketHoursDatabaseLock is 33.
Long Identifier,QuantConnect.Securities,SecurityPortfolioModel,C:\repos\QuantConnect_Lean\Common\Securities\SecurityPortfolioModel.cs,ProcessFill,The length of the parameter closedSaleValueInQuoteCurrency is 30.
Long Identifier,QuantConnect.Securities,SymbolPropertiesDatabase,C:\repos\QuantConnect_Lean\Common\Securities\SymbolPropertiesDatabase.cs,,The length of the parameter _dataFolderSymbolPropertiesDatabase is 35.
Long Identifier,QuantConnect.Securities,SymbolPropertiesDatabase,C:\repos\QuantConnect_Lean\Common\Securities\SymbolPropertiesDatabase.cs,,The length of the parameter DataFolderSymbolPropertiesDatabaseLock is 38.
Long Identifier,QuantConnect.Securities,SecurityTransactionManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityTransactionManager.cs,GetSufficientCapitalForOrder,The length of the parameter initialMarginRequiredForRemainderOfOrder is 40.
Long Identifier,QuantConnect.Orders.Fees,InteractiveBrokersFeeModel,C:\repos\QuantConnect_Lean\Common\Orders\Fees\InteractiveBrokersFeeModel.cs,InteractiveBrokersFeeModel,The length of the parameter monthlyForexTradeAmountInUSDollars is 34.
Long Identifier,QuantConnect.Orders.Fees,InteractiveBrokersFeeModel,C:\repos\QuantConnect_Lean\Common\Orders\Fees\InteractiveBrokersFeeModel.cs,InteractiveBrokersFeeModel,The length of the parameter monthlyOptionsTradeAmountInContracts is 36.
Long Identifier,QuantConnect.Orders.Fees,InteractiveBrokersFeeModel,C:\repos\QuantConnect_Lean\Common\Orders\Fees\InteractiveBrokersFeeModel.cs,ProcessForexRateSchedule,The length of the parameter monthlyForexTradeAmountInUSDollars is 34.
Long Identifier,QuantConnect.Orders.Fees,InteractiveBrokersFeeModel,C:\repos\QuantConnect_Lean\Common\Orders\Fees\InteractiveBrokersFeeModel.cs,ProcessOptionsRateSchedule,The length of the parameter monthlyOptionsTradeAmountInContracts is 36.
Long Identifier,QuantConnect.Parameters,ParameterAttribute,C:\repos\QuantConnect_Lean\Common\Parameters\ParameterAttribute.cs,,The length of the parameter ParameterAttributeNameProperty is 30.
Long Statement,QuantConnect,Market,C:\repos\QuantConnect_Lean\Common\Market.cs,Add,The length of the statement  "                    throw new ArgumentException("Attempted to add a market identifier that is already in use. New Market: " + market + " Existing Market: " + existingMarket); " is 154.
Long Statement,QuantConnect,SecurityIdentifier,C:\repos\QuantConnect_Lean\Common\SecurityIdentifier.cs,Generate,The length of the statement  "                throw new ArgumentOutOfRangeException("market"' string.Format("The specified market wasn't found in the markets lookup. Requested: {0}. " + " is 139.
Long Statement,QuantConnect,SecurityIdentifier,C:\repos\QuantConnect_Lean\Common\SecurityIdentifier.cs,TryParseProperties,The length of the statement  "                Log.Error("SecurityIdentifier.TryParseProperties(): Error parsing SecurityIdentifier: '{0}'' Exception: {1}"' value' exception); " is 128.
Long Statement,QuantConnect,Isolator,C:\repos\QuantConnect_Lean\Common\Isolator.cs,ExecuteWithTimeLimit,The length of the statement  "                    message = "Execution Security Error: Memory Usage Maxed Out - " + PrettyFormatRam(memoryCap) + "MB max' with last sample of " + PrettyFormatRam((long)sample) + "MB."; " is 166.
Long Statement,QuantConnect,Isolator,C:\repos\QuantConnect_Lean\Common\Isolator.cs,ExecuteWithTimeLimit,The length of the statement  "                    Log.Trace("{0} Isolator.ExecuteWithTimeLimit(): Used: {1} Sample: {2}"' DateTime.Now.ToString("u")' PrettyFormatRam(memoryUsed)' PrettyFormatRam((long)sample)); " is 160.
Long Statement,QuantConnect,Isolator,C:\repos\QuantConnect_Lean\Common\Isolator.cs,ExecuteWithTimeLimit,The length of the statement  "                message = "Execution Security Error: Operation timed out - " + timeSpan.TotalMinutes + " minutes max. Check for recursive loops."; " is 130.
Long Statement,QuantConnect,Holding,C:\repos\QuantConnect_Lean\Common\Global.cs,ToString,The length of the statement  "            var value = string.Format("{0}: {1} @ {2}{3} - Market: {2}{4}"' Symbol.Value' Quantity' CurrencySymbol' AveragePrice' MarketPrice); " is 131.
Long Statement,QuantConnect,Extensions,C:\repos\QuantConnect_Lean\Common\Extensions.cs,AddOrUpdate,The length of the statement  "            var result = dictionary.AddOrUpdate(key' new Lazy<TValue>(() => addValueFactory(key))' (key2' old) => new Lazy<TValue>(() => updateValueFactory(key2' old.Value))); " is 163.
Long Statement,QuantConnect,Extensions,C:\repos\QuantConnect_Lean\Common\Extensions.cs,WithEmbeddedHtmlAnchors,The length of the statement  "            var regx = new Regex("http(s)?://([\\w+?\\.\\w+])+([a-zA-Z0-9\\~\\!\\@\\#\\$\\%\\^\\&amp;\\*\\(\\)_\\-\\=\\+\\\\\\/\\?\\.\\:\\;\\'\\']*([a-zA-Z0-9\\?\\#\\=\\/]){1})?"' RegexOptions.IgnoreCase); " is 193.
Long Statement,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,GenerateOptionTickerOSI,The length of the statement  "            return string.Format("{0'-6}{1}{2}{3:00000000}"' underlying' expiration.ToString(DateFormat.SixCharacter)' right.ToString()[0]' strikePrice * 1000m); " is 149.
Long Statement,QuantConnect,SymbolValueJsonConverter,C:\repos\QuantConnect_Lean\Common\SymbolValueJsonConverter.cs,CanConvert,The length of the statement  "            throw new NotImplementedException("The SymbolValueJsonConverter is intended to be decorated on the appropriate member directly."); " is 130.
Long Statement,QuantConnect,Time,C:\repos\QuantConnect_Lean\Common\Time.cs,ParseDate,The length of the statement  "                if (DateTime.TryParseExact(dateToParse' DateFormat.SixCharacter' CultureInfo.InvariantCulture' DateTimeStyles.None' out date)) " is 126.
Long Statement,QuantConnect,Time,C:\repos\QuantConnect_Lean\Common\Time.cs,ParseDate,The length of the statement  "                if (DateTime.TryParseExact(dateToParse' DateFormat.EightCharacter' CultureInfo.InvariantCulture' DateTimeStyles.None' out date)) " is 128.
Long Statement,QuantConnect,Time,C:\repos\QuantConnect_Lean\Common\Time.cs,ParseDate,The length of the statement  "                if (DateTime.TryParseExact(dateToParse.Substring(0' 19)' DateFormat.JsonFormat' CultureInfo.InvariantCulture' DateTimeStyles.None' out date)) " is 141.
Long Statement,QuantConnect.Brokerages,DefaultBrokerageMessageHandler,C:\repos\QuantConnect_Lean\Common\Brokerages\DefaultBrokerageMessageHandler.cs,Handle,The length of the statement  "                        Log.Trace("DefaultBrokerageMessageHandler.Handle(): Disconnect when exchanges are open' trying to reconnect for " + _initialDelay.TotalMinutes + " minutes."); " is 158.
Long Statement,QuantConnect.Brokerages,DefaultBrokerageMessageHandler,C:\repos\QuantConnect_Lean\Common\Brokerages\DefaultBrokerageMessageHandler.cs,Handle,The length of the statement  "                        Log.Trace("DefaultBrokerageMessageHandler.Handle(): Disconnect when exchanges are closed' checking back before exchange open."); " is 128.
Long Statement,QuantConnect.Brokerages,FxcmBrokerageModel,C:\repos\QuantConnect_Lean\Common\Brokerages\FxcmBrokerageModel.cs,CanSubmitOrder,The length of the statement  "                return IsValidOrderPrices(security' OrderType.StopMarket' stopMarket.Direction' stopMarket.StopPrice' security.Price' ref message); " is 131.
Long Statement,QuantConnect.Brokerages,FxcmBrokerageModel,C:\repos\QuantConnect_Lean\Common\Brokerages\FxcmBrokerageModel.cs,CanSubmitOrder,The length of the statement  "                return IsValidOrderPrices(security' OrderType.StopLimit' stopLimit.Direction' stopLimit.StopPrice' stopLimit.LimitPrice' ref message); " is 134.
Long Statement,QuantConnect.Brokerages,FxcmBrokerageModel,C:\repos\QuantConnect_Lean\Common\Brokerages\FxcmBrokerageModel.cs,IsValidOrderPrices,The length of the statement  "            var invalidPrice = orderType == OrderType.Limit && orderDirection == OrderDirection.Buy && limitPrice > security.Price || " is 121.
Long Statement,QuantConnect.Brokerages,FxcmBrokerageModel,C:\repos\QuantConnect_Lean\Common\Brokerages\FxcmBrokerageModel.cs,IsValidOrderPrices,The length of the statement  "                    "Limit Buy orders and Stop Sell orders must be below market' Limit Sell orders and Stop Buy orders must be above market." " is 121.
Long Statement,QuantConnect.Orders.Fills,ImmediateFillModel,C:\repos\QuantConnect_Lean\Common\Orders\Fills\ImmediateFillModel.cs,IsExchangeOpen,The length of the statement  "                if (asset.LocalTime.Date != currentBar.EndTime.Date || !asset.Exchange.IsOpenDuringBar(currentBar.Time' currentBar.EndTime' false)) " is 131.
Long Statement,QuantConnect.Orders,OrderTicket,C:\repos\QuantConnect_Lean\Common\Orders\OrderTicket.cs,AddOrderEvent,The length of the statement  "                    var quantityWeightedFillPrice = _orderEvents.Where(x => x.Status.IsFill()).Sum(x => x.AbsoluteFillQuantity*x.FillPrice); " is 120.
Long Statement,QuantConnect.Orders,OrderTicket,C:\repos\QuantConnect_Lean\Common\Orders\OrderTicket.cs,InvalidCancelOrderId,The length of the statement  "            var submit = new SubmitOrderRequest(OrderType.Market' SecurityType.Base' Symbol.Empty' 0' 0' 0' DateTime.MaxValue' string.Empty); " is 129.
Long Statement,QuantConnect.Orders,OrderTicket,C:\repos\QuantConnect_Lean\Common\Orders\OrderTicket.cs,InvalidUpdateOrderId,The length of the statement  "            var submit = new SubmitOrderRequest(OrderType.Market' SecurityType.Base' Symbol.Empty' 0' 0' 0' DateTime.MaxValue' string.Empty); " is 129.
Long Statement,QuantConnect.Orders,StopLimitOrder,C:\repos\QuantConnect_Lean\Common\Orders\StopLimitOrder.cs,ToString,The length of the statement  "            return string.Format("{0} at stop {1} limit {2}"' base.ToString()' StopPrice.SmartRounding()' LimitPrice.SmartRounding()); " is 122.
Long Statement,QuantConnect.Orders,UpdateOrderRequest,C:\repos\QuantConnect_Lean\Common\Orders\UpdateOrderRequest.cs,ToString,The length of the statement  "            return string.Format("{0} UTC: Update Order: ({1}) - {2} {3} Status: {4}"' Time' OrderId' string.Join("' "' updates)' Tag' Status); " is 131.
Long Statement,QuantConnect.Orders,OrderEvent,C:\repos\QuantConnect_Lean\Common\Orders\OrderEvent.cs,ToString,The length of the statement  "                : string.Format("Time: {0} OrderID: {1} Symbol: {2} Status: {3} Quantity: {4} FillPrice: {5} {6}"' UtcTime' OrderId' Symbol.Value' Status' FillQuantity' FillPrice.SmartRounding()' FillPriceCurrency); " is 199.
Long Statement,QuantConnect.Orders,Order,C:\repos\QuantConnect_Lean\Common\Orders\Order.cs,ToString,The length of the statement  "            return string.Format("OrderId: {0} {1} {2} order for {3} unit{4} of {5}"' Id' Status' Type' Quantity' Quantity == 1 ? "" : "s"' Symbol); " is 136.
Long Statement,QuantConnect.Orders,Order,C:\repos\QuantConnect_Lean\Common\Orders\Order.cs,CreateOrder,The length of the statement  "                    order = new LimitOrder(request.Symbol' request.Quantity' request.LimitPrice' request.Time' request.Tag' request.OrderProperties); " is 129.
Long Statement,QuantConnect.Orders,Order,C:\repos\QuantConnect_Lean\Common\Orders\Order.cs,CreateOrder,The length of the statement  "                    order = new StopMarketOrder(request.Symbol' request.Quantity' request.StopPrice' request.Time' request.Tag' request.OrderProperties); " is 133.
Long Statement,QuantConnect.Orders,Order,C:\repos\QuantConnect_Lean\Common\Orders\Order.cs,CreateOrder,The length of the statement  "                    order = new StopLimitOrder(request.Symbol' request.Quantity' request.StopPrice' request.LimitPrice' request.Time' request.Tag' request.OrderProperties); " is 152.
Long Statement,QuantConnect.Securities,BrokerageModelSecurityInitializer,C:\repos\QuantConnect_Lean\Common\Securities\BrokerageModelSecurityInitializer.cs,Initialize,The length of the statement  "                        Log.Trace("BrokerageModelSecurityInitializer.Initialize(): Seeded security: " + seedData.Symbol.Value + ": " + seedData.Value); " is 127.
Long Statement,QuantConnect.Securities,Cash,C:\repos\QuantConnect_Lean\Common\Securities\Cash.cs,EnsureCurrencyDataFeed,The length of the statement  "            foreach (var config in subscriptions.Subscriptions.Where(config => config.SecurityType == SecurityType.Forex || config.SecurityType == SecurityType.Cfd || " is 154.
Long Statement,QuantConnect.Securities,Cash,C:\repos\QuantConnect_Lean\Common\Securities\Cash.cs,EnsureCurrencyDataFeed,The length of the statement  "                .Concat(Currencies.CryptoCurrencyPairs.Select(crypto => CreateSymbol(marketMap' crypto' markets' SecurityType.Crypto))); " is 120.
Long Statement,QuantConnect.Securities,Cash,C:\repos\QuantConnect_Lean\Common\Securities\Cash.cs,EnsureCurrencyDataFeed,The length of the statement  "                    var symbolProperties = symbolPropertiesDatabase.GetSymbolProperties(symbol.ID.Market' symbol.Value' securityType' Symbol); " is 122.
Long Statement,QuantConnect.Securities,Cash,C:\repos\QuantConnect_Lean\Common\Securities\Cash.cs,EnsureCurrencyDataFeed,The length of the statement  "                        throw new Exception("Unable to resolve quote cash: " + symbolProperties.QuoteCurrency + ". This is required to add conversion feed: " + symbol.Value); " is 150.
Long Statement,QuantConnect.Securities,Cash,C:\repos\QuantConnect_Lean\Common\Securities\Cash.cs,EnsureCurrencyDataFeed,The length of the statement  "                    var config = subscriptions.Add(objectType' TickType.Quote' symbol' minimumResolution' marketHoursDbEntry.DataTimeZone' exchangeHours.TimeZone' false' true' false' true); " is 169.
Long Statement,QuantConnect.Securities,Cash,C:\repos\QuantConnect_Lean\Common\Securities\Cash.cs,EnsureCurrencyDataFeed,The length of the statement  "            throw new ArgumentException(string.Format("In order to maintain cash in {0} you are required to add a subscription for Forex pair {0}{1} or {1}{0}"' Symbol' CashBook.AccountCurrency)); " is 184.
Long Statement,QuantConnect.Securities,Cash,C:\repos\QuantConnect_Lean\Common\Securities\Cash.cs,ToString,The length of the statement  "            return $"{Symbol}: {Currencies.GetCurrencySymbol(Symbol)}{Amount'15:0.00} @ {rate'10:0.00####} = ${Math.Round(ValueInAccountCurrency' 2)}"; " is 139.
Long Statement,QuantConnect.Securities,CashBook,C:\repos\QuantConnect_Lean\Common\Securities\CashBook.cs,EnsureCurrencyDataFeeds,The length of the statement  "                var security = cash.EnsureCurrencyDataFeed(securities' subscriptions' marketHoursDatabase' symbolPropertiesDatabase' marketMap' this); " is 134.
Long Statement,QuantConnect.Securities,CashBook,C:\repos\QuantConnect_Lean\Common\Securities\CashBook.cs,ToString,The length of the statement  "            sb.AppendLine(string.Format("{0} {1'13}    {2'10} = {3}"' "Symbol"' "Quantity"' "Conversion"' "Value in " + AccountCurrency)); " is 126.
Long Statement,QuantConnect.Securities,CashBook,C:\repos\QuantConnect_Lean\Common\Securities\CashBook.cs,Remove,The length of the statement  "                Log.Error(string.Format("CashBook.Remove(): Failed to remove the cash book record for symbol {0} - {1}"' item.Key' item.Value != null ? item.Value.ToString() : "(null)")); " is 171.
Long Statement,QuantConnect.Securities,FuncSecuritySeeder,C:\repos\QuantConnect_Lean\Common\Securities\FuncSecuritySeeder.cs,GetSeedData,The length of the statement  "                Log.Error("FuncSecuritySeeder.GetSeedPrice():  Could not seed price for security {0}: {1}"' security.Symbol' ex.GetBaseException()); " is 132.
Long Statement,QuantConnect.Securities,EquityPriceVariationModel,C:\repos\QuantConnect_Lean\Common\Securities\EquityPriceVariationModel.cs,GetMinimumPriceVariation,The length of the statement  "                throw new ArgumentException("EquityPriceVariationModel.GetMinimumPriceVariation(): Invalid SecurityType " + security.Type); " is 123.
Long Statement,QuantConnect.Securities,FutureMarginModel,C:\repos\QuantConnect_Lean\Common\Securities\Future\FutureMarginModel.cs,FromCsvFile,The length of the statement  "                Log.Trace("Unable to locate future margin requirements file. Defaulting to zero margin for this symbol. File: {0}" ' file); " is 123.
Long Statement,QuantConnect.Securities,FutureMarginModel,C:\repos\QuantConnect_Lean\Common\Securities\Future\FutureMarginModel.cs,FromCsvLine,The length of the statement  "            if(!DateTime.TryParseExact(line[0]' DateFormat.EightCharacter' CultureInfo.InvariantCulture' DateTimeStyles.None' out date)) " is 124.
Long Statement,QuantConnect.Securities,FutureMarginModel,C:\repos\QuantConnect_Lean\Common\Securities\Future\FutureMarginModel.cs,FromCsvLine,The length of the statement  "                Log.Trace("Couldn't parse date/time while reading future margin requirement file. Date {0}. Line: {1}"' line[0]' csvLine); " is 122.
Long Statement,QuantConnect.Securities,FutureMarginModel,C:\repos\QuantConnect_Lean\Common\Securities\Future\FutureMarginModel.cs,FromCsvLine,The length of the statement  "                Log.Trace("Couldn't parse Initial margin requirements while reading future margin requirement file. Date {0}. Line: {1}"' line[1]' csvLine); " is 140.
Long Statement,QuantConnect.Securities,FutureMarginModel,C:\repos\QuantConnect_Lean\Common\Securities\Future\FutureMarginModel.cs,FromCsvLine,The length of the statement  "                Log.Trace("Couldn't parse Maintenance margin requirements while reading future margin requirement file. Date {0}. Line: {1}"' line[2]' csvLine); " is 144.
Long Statement,QuantConnect.Securities,OptionMarginModel,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionMarginModel.cs,GetMaintenanceMargin,The length of the statement  "            return security.Holdings.AbsoluteHoldingsCost * GetMaintenanceMarginRequirement(security' security.Holdings.HoldingsCost); " is 122.
Long Statement,QuantConnect.Securities,StandardDeviationOfReturnsVolatilityModel,C:\repos\QuantConnect_Lean\Common\Securities\Volatility\StandardDeviationOfReturnsVolatilityModel.cs,GetHistoryRequirements,The length of the statement  "            var localStartTime = Time.GetStartTimeForTradeBars(security.Exchange.Hours' utcTime.ConvertFromUtc(security.Exchange.TimeZone)' _periodSpan' barCount' security.IsExtendedMarketHours); " is 183.
Long Statement,QuantConnect.Securities,RelativeStandardDeviationVolatilityModel,C:\repos\QuantConnect_Lean\Common\Securities\Volatility\RelativeStandardDeviationVolatilityModel.cs,GetHistoryRequirements,The length of the statement  "            var localStartTime = Time.GetStartTimeForTradeBars(security.Exchange.Hours' utcTime.ConvertFromUtc(security.Exchange.TimeZone)' _periodSpan' barCount' security.IsExtendedMarketHours); " is 183.
Long Statement,QuantConnect.Securities,MarketHoursDatabase,C:\repos\QuantConnect_Lean\Common\Securities\MarketHoursDatabase.cs,GetExchangeHours,The length of the statement  "            if (configuration.SecurityType == SecurityType.Base && overrideTimeZone == null) overrideTimeZone = configuration.ExchangeTimeZone; " is 131.
Long Statement,QuantConnect.Securities,MarketHoursDatabase,C:\repos\QuantConnect_Lean\Common\Securities\MarketHoursDatabase.cs,GetEntry,The length of the statement  "                    Log.Error(string.Format("MarketHoursDatabase.GetExchangeHours(): Unable to locate exchange hours for {0}." + "Available keys: {1}"' key' string.Join("' "' _entries.Keys))); " is 172.
Long Statement,QuantConnect.Securities,MarketHoursDatabase,C:\repos\QuantConnect_Lean\Common\Securities\MarketHoursDatabase.cs,GetEntry,The length of the statement  "                    return new Entry(overrideTimeZone' new SecurityExchangeHours(overrideTimeZone' entry.ExchangeHours.Holidays' entry.ExchangeHours.MarketHours' entry.ExchangeHours.EarlyCloses)); " is 176.
Long Statement,QuantConnect.Securities,DefaultMarginCallModel,C:\repos\QuantConnect_Lean\Common\Securities\DefaultMarginCallModel.cs,GenerateMarginCallOrder,The length of the statement  "            var quantity = Math.Round(deltaInQuoteCurrency / unitPriceInQuoteCurrency' MidpointRounding.AwayFromZero) / maintenanceMarginRequirement; " is 137.
Long Statement,QuantConnect.Securities,DefaultMarginCallModel,C:\repos\QuantConnect_Lean\Common\Securities\DefaultMarginCallModel.cs,GenerateMarginCallOrder,The length of the statement  "            // don't try and liquidate more share than we currently hold' minimum value of LotSize' maximum value for absolute quantity " is 123.
Long Statement,QuantConnect.Securities,DefaultMarginCallModel,C:\repos\QuantConnect_Lean\Common\Securities\DefaultMarginCallModel.cs,GenerateMarginCallOrder,The length of the statement  "            return new SubmitOrderRequest(OrderType.Market' security.Type' security.Symbol' quantity' 0' 0' security.LocalTime.ConvertToUtc(security.Exchange.TimeZone)' "Margin Call"' DefaultOrderProperties?.Clone()); " is 205.
Long Statement,QuantConnect.Securities,SecurityPortfolioModel,C:\repos\QuantConnect_Lean\Common\Securities\SecurityPortfolioModel.cs,ProcessFill,The length of the statement  "                    var saleValueInQuoteCurrency = fill.FillPrice * Convert.ToDecimal(fill.AbsoluteFillQuantity) * security.SymbolProperties.ContractMultiplier; " is 140.
Long Statement,QuantConnect.Securities,SecurityPortfolioModel,C:\repos\QuantConnect_Lean\Common\Securities\SecurityPortfolioModel.cs,ProcessFill,The length of the statement  "                    security.SettlementModel.ApplyFunds(portfolio' security' fill.UtcTime' quoteCash.Symbol' -fill.FillQuantity * fill.FillPrice * security.SymbolProperties.ContractMultiplier); " is 173.
Long Statement,QuantConnect.Securities,SecurityPortfolioModel,C:\repos\QuantConnect_Lean\Common\Securities\SecurityPortfolioModel.cs,ProcessFill,The length of the statement  "                    portfolio.AddTransactionRecord(security.LocalTime.ConvertToUtc(security.Exchange.TimeZone)' lastTradeProfit - 2*feeThisOrder); " is 126.
Long Statement,QuantConnect.Securities,SecurityPortfolioModel,C:\repos\QuantConnect_Lean\Common\Securities\SecurityPortfolioModel.cs,ProcessFill,The length of the statement  "                            averageHoldingsPrice = ((averageHoldingsPrice*quantityHoldings) + (fill.FillQuantity*fill.FillPrice))/(quantityHoldings + fill.FillQuantity); " is 141.
Long Statement,QuantConnect.Securities,SecurityPortfolioModel,C:\repos\QuantConnect_Lean\Common\Securities\SecurityPortfolioModel.cs,ProcessFill,The length of the statement  "                            averageHoldingsPrice = ((averageHoldingsPrice*quantityHoldings) + (fill.FillQuantity*fill.FillPrice))/(quantityHoldings + fill.FillQuantity); " is 141.
Long Statement,QuantConnect.Securities,Security,C:\repos\QuantConnect_Lean\Common\Securities\Security.cs,AddData,The length of the statement  "            if (!subscription.ExchangeTimeZone.Equals(Exchange.TimeZone)) throw new ArgumentException("ExchangeTimeZones must match."' "subscription.ExchangeTimeZone"); " is 156.
Long Statement,QuantConnect.Securities,Security,C:\repos\QuantConnect_Lean\Common\Securities\Security.cs,AddData,The length of the statement  "                if (!subscription.ExchangeTimeZone.Equals(Exchange.TimeZone)) throw new ArgumentException("ExchangeTimeZones must match."' "subscription.ExchangeTimeZone"); " is 156.
Long Statement,QuantConnect.Securities,SecurityExchange,C:\repos\QuantConnect_Lean\Common\Securities\SecurityExchange.cs,SetMarketHours,The length of the statement  "            _exchangeHours = new SecurityExchangeHours(_exchangeHours.TimeZone' _exchangeHours.Holidays' marketHours' _exchangeHours.EarlyCloses); " is 134.
Long Statement,QuantConnect.Securities,SecurityHolding,C:\repos\QuantConnect_Lean\Common\Securities\SecurityHolding.cs,TotalCloseProfit,The length of the statement  "            var marketOrder = new MarketOrder(_security.Symbol' -Quantity' _security.LocalTime.ConvertToUtc(_security.Exchange.TimeZone)); " is 126.
Long Statement,QuantConnect.Securities,SecurityHolding,C:\repos\QuantConnect_Lean\Common\Securities\SecurityHolding.cs,TotalCloseProfit,The length of the statement  "            return (Price - AveragePrice)*Quantity*_security.QuoteCurrency.ConversionRate*_security.SymbolProperties.ContractMultiplier - orderFee; " is 135.
Long Statement,QuantConnect.Securities,SecurityManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityManager.cs,CreateSecurity,The length of the statement  "                    security = new Option.Option(symbol' exchangeHours' securityPortfolioManager.CashBook[CashBook.AccountCurrency]' new Option.OptionSymbolProperties(symbolProperties)); " is 166.
Long Statement,QuantConnect.Securities,SecurityManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityManager.cs,CreateSecurity,The length of the statement  "                    security = new Future.Future(symbol' exchangeHours' securityPortfolioManager.CashBook[CashBook.AccountCurrency]' symbolProperties); " is 131.
Long Statement,QuantConnect.Securities,SecurityManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityManager.cs,CreateSecurity,The length of the statement  "            if (symbol.ID.SecurityType == SecurityType.Forex || symbol.ID.SecurityType == SecurityType.Crypto) defaultQuoteCurrency = symbol.Value.Substring(3); " is 148.
Long Statement,QuantConnect.Securities,SecurityManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityManager.cs,CreateSecurity,The length of the statement  "            var symbolProperties = symbolPropertiesDatabase.GetSymbolProperties(symbol.ID.Market' symbol' symbol.ID.SecurityType' defaultQuoteCurrency); " is 140.
Long Statement,QuantConnect.Securities,SecurityManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityManager.cs,CreateSecurity,The length of the statement  "            var types = subscriptionManager.LookupSubscriptionConfigDataTypes(symbol.SecurityType' resolution' symbol.IsCanonical()); " is 121.
Long Statement,QuantConnect.Securities,SecurityManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityManager.cs,CreateSecurity,The length of the statement  "            return CreateSecurity(types' securityPortfolioManager' subscriptionManager' exchangeHours' marketHoursDbEntry.DataTimeZone' symbolProperties' securityInitializer' symbol' resolution' " is 182.
Long Statement,QuantConnect.Securities,SecurityPortfolioManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityPortfolioManager.cs,Add,The length of the statement  "{ throw new NotImplementedException("Portfolio object is an adaptor for Security Manager. To add a new asset add the required data during initialization."); }" is 158.
Long Statement,QuantConnect.Securities,SecurityPortfolioManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityPortfolioManager.cs,Add,The length of the statement  "{ throw new NotImplementedException("Portfolio object is an adaptor for Security Manager. To add a new asset add the required data during initialization."); }" is 158.
Long Statement,QuantConnect.Securities,SecurityPortfolioManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityPortfolioManager.cs,Remove,The length of the statement  "{ throw new NotImplementedException("Portfolio object is an adaptor for Security Manager and objects cannot be removed."); }" is 124.
Long Statement,QuantConnect.Securities,SecurityPortfolioManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityPortfolioManager.cs,Remove,The length of the statement  "{ throw new NotImplementedException("Portfolio object is an adaptor for Security Manager and objects cannot be removed."); }" is 124.
Long Statement,QuantConnect.Securities,SecurityPortfolioManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityPortfolioManager.cs,ScanForMarginCall,The length of the statement  "                    var marginCallOrder = MarginCallModel.GenerateMarginCallOrder(security' totalPortfolioValue' totalMarginUsed' maintenanceMarginRequirement); " is 140.
Long Statement,QuantConnect.Securities,SecurityTransactionManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityTransactionManager.cs,WaitForOrder,The length of the statement  "                Log.Error("SecurityTransactionManager.WaitForOrder(): Order did not fill within {0} seconds."' _marketOrderFillTimeout.TotalSeconds); " is 133.
Long Statement,QuantConnect.Securities,SecurityTransactionManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityTransactionManager.cs,GetSufficientCapitalForOrder,The length of the statement  "                // for option assignment and exercise orders we look into the requirements to process the underlying security transaction " is 121.
Long Statement,QuantConnect.Securities,SecurityTransactionManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityTransactionManager.cs,GetSufficientCapitalForOrder,The length of the statement  "            if (security.Holdings.Quantity * order.Quantity < 0 && Math.Abs(security.Holdings.Quantity) >= Math.Abs(order.Quantity)) return true; " is 133.
Long Statement,QuantConnect.Securities,SecurityTransactionManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityTransactionManager.cs,GetSufficientCapitalForOrder,The length of the statement  "                Log.Error(string.Format("SecurityTransactionManager.GetSufficientCapitalForOrder(): Id: {0}' Initial Margin: {1}' Free Margin: {2}"' order.Id' initialMarginRequiredForOrder' freeMargin)); " is 187.
Long Statement,QuantConnect.Securities,SecurityTransactionManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityTransactionManager.cs,Completed,The length of the statement  "            return order.Status == OrderStatus.Filled || order.Status == OrderStatus.PartiallyFilled || order.Status == OrderStatus.Invalid || order.Status == OrderStatus.Canceled; " is 168.
Long Statement,QuantConnect.Securities.Future,FuturesExpiryUtilityFunctions,C:\repos\QuantConnect_Lean\Common\Securities\Future\FuturesExpiryUtilityFunctions.cs,NthLastBusinessDay,The length of the statement  "                throw new ArgumentOutOfRangeException("n"'String.Format("Number of days ({0}) is larger than the size of month({1})"' n' daysInMonth)); " is 135.
Long Statement,QuantConnect.Securities.Option,OptionPortfolioModel,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionPortfolioModel.cs,ProcessExerciseFill,The length of the statement  "                    var cashQuantity = option.GetIntrinsicValue(underlying.Close) * option.ContractUnitOfTrade * option.QuoteCurrency.ConversionRate * optionQuantity; " is 146.
Long Statement,QuantConnect.Securities.Option,OptionPriceModels,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionPriceModels.cs,AdditiveEquiprobabilities,The length of the statement  "            return new QLOptionPriceModel(process => new BinomialVanillaEngine<AdditiveEQPBinomialTree>(process' _timeStepsBinomial)' " is 121.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,BearCallSpread,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Call' Strike = leg1Strike' Quantity = -1' OrderType = Orders.OrderType.Market' Expiration = expiration }' " is 160.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,BearCallSpread,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Call' Strike = leg2Strike' Quantity = 1' OrderType = Orders.OrderType.Market' Expiration = expiration } " is 158.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,BearPutSpread,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Put' Strike = leg1Strike' Quantity = 1' OrderType = Orders.OrderType.Market' Expiration = expiration }' " is 158.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,BearPutSpread,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Put' Strike = leg2Strike' Quantity = -1' OrderType = Orders.OrderType.Market' Expiration = expiration } " is 158.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,BullCallSpread,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Call' Strike = leg1Strike' Quantity = 1' OrderType = Orders.OrderType.Market' Expiration = expiration }' " is 159.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,BullCallSpread,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Call' Strike = leg2Strike' Quantity = -1' OrderType = Orders.OrderType.Market' Expiration = expiration } " is 159.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,BullPutSpread,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Put' Strike = leg1Strike' Quantity = -1' OrderType = Orders.OrderType.Market' Expiration = expiration }' " is 159.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,BullPutSpread,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Put' Strike = leg2Strike' Quantity = 1' OrderType = Orders.OrderType.Market' Expiration = expiration } " is 157.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,Straddle,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Call' Strike = strike' Quantity = 1' OrderType = Orders.OrderType.Market' Expiration = expiration }' " is 155.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,Straddle,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Put' Strike = strike' Quantity = 1' OrderType = Orders.OrderType.Market' Expiration = expiration } " is 153.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,Strangle,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Call' Strike = leg1Strike' Quantity = 1' OrderType = Orders.OrderType.Market' Expiration = expiration }' " is 159.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,Strangle,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Put' Strike = leg2Strike' Quantity = 1' OrderType = Orders.OrderType.Market' Expiration = expiration } " is 157.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,CallButterfly,The length of the statement  "                throw new ArgumentException("CallButterfly: upper and lower strikes must both be equidistant from the middle strike"' "leg1Strike' leg2Strike' leg3Strike"); " is 156.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,CallButterfly,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Call' Strike = leg1Strike' Quantity = 1' OrderType = Orders.OrderType.Market' Expiration = expiration }' " is 159.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,CallButterfly,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Call' Strike = leg2Strike' Quantity = -2' OrderType = Orders.OrderType.Market' Expiration = expiration }' " is 160.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,CallButterfly,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Call' Strike = leg3Strike' Quantity = 1' OrderType = Orders.OrderType.Market' Expiration = expiration } " is 158.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,PutButterfly,The length of the statement  "                throw new ArgumentException("PutButterfly: upper and lower strikes must both be equidistant from the middle strike"' "leg1Strike' leg2Strike' leg3Strike"); " is 155.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,PutButterfly,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Put' Strike = leg1Strike' Quantity = 1' OrderType = Orders.OrderType.Market' Expiration = expiration }' " is 158.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,PutButterfly,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Put' Strike = leg2Strike' Quantity = -2' OrderType = Orders.OrderType.Market' Expiration = expiration }' " is 159.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,PutButterfly,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Put' Strike = leg3Strike' Quantity = 1' OrderType = Orders.OrderType.Market' Expiration = expiration } " is 157.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,CallCalendarSpread,The length of the statement  "                throw new ArgumentException("CallCalendarSpread: canonicalOption must contain canonical option symbol"' "canonicalOption"); " is 123.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,CallCalendarSpread,The length of the statement  "                throw new ArgumentException("CallCalendarSpread: near expiration must be less than far expiration"' "expiration1' expiration2"); " is 128.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,CallCalendarSpread,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Call' Strike = strike' Quantity = -1' OrderType = Orders.OrderType.Market' Expiration = expiration1 }' " is 157.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,CallCalendarSpread,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Call' Strike = strike' Quantity = 1' OrderType = Orders.OrderType.Market' Expiration = expiration2 } " is 155.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,PutCalendarSpread,The length of the statement  "                throw new ArgumentException("PutCalendarSpread: canonicalOption must contain canonical option symbol"' "canonicalOption"); " is 122.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,PutCalendarSpread,The length of the statement  "                throw new ArgumentException("PutCalendarSpread: near expiration must be less than far expiration"' "expiration1' expiration2"); " is 127.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,PutCalendarSpread,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Put' Strike = strike' Quantity = -1' OrderType = Orders.OrderType.Market' Expiration = expiration1 }' " is 156.
Long Statement,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,PutCalendarSpread,The length of the statement  "                                            new OptionStrategy.OptionLegData { Right = OptionRight.Put' Strike = strike' Quantity = 1' OrderType = Orders.OrderType.Market' Expiration = expiration2 } " is 154.
Long Statement,QuantConnect.Securities.Option,QLOptionPriceModel,C:\repos\QuantConnect_Lean\Common\Securities\Option\QLOptionPriceModel.cs,Evaluate,The length of the statement  "                var underlyingVol = new Handle<BlackVolTermStructure>(new BlackConstantVol(0' calendar' new Handle<Quote>(underlyingVolValue)' dayCounter)); " is 140.
Long Statement,QuantConnect.Securities.Option,QLOptionPriceModel,C:\repos\QuantConnect_Lean\Common\Securities\Option\QLOptionPriceModel.cs,Evaluate,The length of the statement  "                var stochasticProcess = new BlackScholesMertonProcess(new Handle<Quote>(underlyingQuoteValue)' dividendYield' riskFreeRate' underlyingVol); " is 139.
Long Statement,QuantConnect.Securities.Option,QLOptionPriceModel,C:\repos\QuantConnect_Lean\Common\Securities\Option\QLOptionPriceModel.cs,Evaluate,The length of the statement  "                var payoff = new PlainVanillaPayoff(contract.Right == OptionRight.Call ? QLNet.Option.Type.Call : QLNet.Option.Type.Put' (double)contract.Strike); " is 146.
Long Statement,QuantConnect.Securities.Option,QLOptionPriceModel,C:\repos\QuantConnect_Lean\Common\Securities\Option\QLOptionPriceModel.cs,Evaluate,The length of the statement  "                // function extracts QL greeks catching exception if greek is not generated by the pricing engine and reevaluates option to get numerical estimate of the seisitivity " is 165.
Long Statement,QuantConnect.Data.Market,OptionContract,C:\repos\QuantConnect_Lean\Common\Data\Market\OptionContract.cs,ToString,The length of the statement  "            return string.Format("{0}{1}{2}{3:00000000}"' Symbol.ID.Symbol' Expiry.ToString(DateFormat.EightCharacter)' Right.ToString()[0]' Strike*1000m); " is 143.
Long Statement,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,Reader,The length of the statement  "                Log.Error("QuoteBar.Reader(): Error parsing line: '{0}'' Symbol: {1}' SecurityType: {2}' Resolution: {3}' Date: {4}' Message: {5}"'  " is 131.
Long Statement,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseTradeAsQuoteBar,The length of the statement  "                Logging.Log.Error("QuoteBar.ParseTradeAsQuoteBar(): Data formatted as Trade when Quote format was expected.  Support for this will disappear June 2017."); " is 154.
Long Statement,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseTradeAsQuoteBar,The length of the statement  "                quoteBar.Time = DateTime.ParseExact(csv[0]' DateFormat.TwelveCharacter' CultureInfo.InvariantCulture).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone); " is 158.
Long Statement,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The length of the statement  "                quoteBar.Time = DateTime.ParseExact(csv[0]' DateFormat.TwelveCharacter' CultureInfo.InvariantCulture).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone); " is 158.
Long Statement,QuantConnect.Data.Market,RenkoBar,C:\repos\QuantConnect_Lean\Common\Data\Market\RenkoBar.cs,Reader,The length of the statement  "            throw new NotSupportedException("RenkoBar does not support the Reader function. This function should never be called on this type."); " is 133.
Long Statement,QuantConnect.Data.Market,RenkoBar,C:\repos\QuantConnect_Lean\Common\Data\Market\RenkoBar.cs,GetSource,The length of the statement  "            throw new NotSupportedException("RenkoBar does not support the GetSource function. This function should never be called on this type."); " is 136.
Long Statement,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,Reader,The length of the statement  "                Log.Error("TradeBar.Reader(): Error parsing line: '{0}'' Symbol: {1}' SecurityType: {2}' Resolution: {3}' Date: {4}' Message: {5}"' " is 131.
Long Statement,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseEquity,The length of the statement  "                tradeBar.Time = DateTime.ParseExact(csv[0]' DateFormat.TwelveCharacter' CultureInfo.InvariantCulture).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone); " is 158.
Long Statement,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseForex,The length of the statement  "                tradeBar.Time = DateTime.ParseExact(csv[0]' DateFormat.TwelveCharacter' CultureInfo.InvariantCulture).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone); " is 158.
Long Statement,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseCrypto,The length of the statement  "                tradeBar.Time = DateTime.ParseExact(csv[0]' DateFormat.TwelveCharacter' CultureInfo.InvariantCulture).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone); " is 158.
Long Statement,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseOption,The length of the statement  "                tradeBar.Time = DateTime.ParseExact(csv[0]' DateFormat.TwelveCharacter' CultureInfo.InvariantCulture).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone); " is 158.
Long Statement,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseFuture,The length of the statement  "                tradeBar.Time = DateTime.ParseExact(csv[0]' DateFormat.TwelveCharacter' CultureInfo.InvariantCulture).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone); " is 158.
Long Statement,QuantConnect.Data.Consolidators,PeriodCountConsolidatorBase<T;TConsolidated>,C:\repos\QuantConnect_Lean\Common\Data\Consolidators\PeriodCountConsolidatorBase.cs,Scan,The length of the statement  "                    if (_period.Value != TimeSpan.Zero && currentLocalTime - _workingBar.Time >= _period.Value && currentLocalTime > _lastEmit) " is 123.
Long Statement,QuantConnect.Data.Consolidators,DataConsolidator<TInput>,C:\repos\QuantConnect_Lean\Common\Data\Consolidators\DataConsolidator.cs,Update,The length of the statement  "                throw new ArgumentNullException("data"' "Received type of " + data.GetType().Name + " but expected " + typeof (TInput).Name); " is 125.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (GainsLossesNotAffectingRetainedEarnings != null) GainsLossesNotAffectingRetainedEarnings.UpdateValues(previous.GainsLossesNotAffectingRetainedEarnings); " is 156.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (AllowanceForLoansAndLeaseLosses != null) AllowanceForLoansAndLeaseLosses.UpdateValues(previous.AllowanceForLoansAndLeaseLosses); " is 132.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (CashCashEquivalentsAndFederalFundsSold != null) CashCashEquivalentsAndFederalFundsSold.UpdateValues(previous.CashCashEquivalentsAndFederalFundsSold); " is 153.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (CashCashEquivalentsAndMarketableSecurities != null) CashCashEquivalentsAndMarketableSecurities.UpdateValues(previous.CashCashEquivalentsAndMarketableSecurities); " is 165.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (CurrentDebtAndCapitalLeaseObligation != null) CurrentDebtAndCapitalLeaseObligation.UpdateValues(previous.CurrentDebtAndCapitalLeaseObligation); " is 147.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (CurrentCapitalLeaseObligation != null) CurrentCapitalLeaseObligation.UpdateValues(previous.CurrentCapitalLeaseObligation); " is 126.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (NonCurrentDeferredLiabilities != null) NonCurrentDeferredLiabilities.UpdateValues(previous.NonCurrentDeferredLiabilities); " is 126.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (DeferredPolicyAcquisitionCosts != null) DeferredPolicyAcquisitionCosts.UpdateValues(previous.DeferredPolicyAcquisitionCosts); " is 129.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (CurrentDeferredTaxesLiabilities != null) CurrentDeferredTaxesLiabilities.UpdateValues(previous.CurrentDeferredTaxesLiabilities); " is 132.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (NonCurrentDeferredTaxesAssets != null) NonCurrentDeferredTaxesAssets.UpdateValues(previous.NonCurrentDeferredTaxesAssets); " is 126.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (NonCurrentDeferredTaxesLiabilities != null) NonCurrentDeferredTaxesLiabilities.UpdateValues(previous.NonCurrentDeferredTaxesLiabilities); " is 141.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (FederalFundsPurchasedAndSecuritiesSoldUnderAgreementToRepurchase != null) FederalFundsPurchasedAndSecuritiesSoldUnderAgreementToRepurchase.UpdateValues(previous.FederalFundsPurchasedAndSecuritiesSoldUnderAgreementToRepurchase); " is 231.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (FederalFundsSoldAndSecuritiesPurchaseUnderAgreementsToResell != null) FederalFundsSoldAndSecuritiesPurchaseUnderAgreementsToResell.UpdateValues(previous.FederalFundsSoldAndSecuritiesPurchaseUnderAgreementsToResell); " is 219.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (FixedMaturitiesAvailableForSale != null) FixedMaturitiesAvailableForSale.UpdateValues(previous.FixedMaturitiesAvailableForSale); " is 132.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (FixedMaturitiesHeldToMaturity != null) FixedMaturitiesHeldToMaturity.UpdateValues(previous.FixedMaturitiesHeldToMaturity); " is 126.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (GoodwillAndOtherIntangibleAssets != null) GoodwillAndOtherIntangibleAssets.UpdateValues(previous.GoodwillAndOtherIntangibleAssets); " is 135.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (InterestBearingDepositsLiabilities != null) InterestBearingDepositsLiabilities.UpdateValues(previous.InterestBearingDepositsLiabilities); " is 141.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (InterestBearingDepositsAssets != null) InterestBearingDepositsAssets.UpdateValues(previous.InterestBearingDepositsAssets); " is 126.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (LongTermDebtAndCapitalLeaseObligation != null) LongTermDebtAndCapitalLeaseObligation.UpdateValues(previous.LongTermDebtAndCapitalLeaseObligation); " is 150.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (LongTermCapitalLeaseObligation != null) LongTermCapitalLeaseObligation.UpdateValues(previous.LongTermCapitalLeaseObligation); " is 129.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (PreferredSecuritiesOutsideStockEquity != null) PreferredSecuritiesOutsideStockEquity.UpdateValues(previous.PreferredSecuritiesOutsideStockEquity); " is 150.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (SecuritiesLendingCollateral != null) SecuritiesLendingCollateral.UpdateValues(previous.SecuritiesLendingCollateral); " is 120.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (SecuritySoldNotYetRepurchased != null) SecuritySoldNotYetRepurchased.UpdateValues(previous.SecuritySoldNotYetRepurchased); " is 126.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (ShortTermInvestmentsAvailableForSale != null) ShortTermInvestmentsAvailableForSale.UpdateValues(previous.ShortTermInvestmentsAvailableForSale); " is 147.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (ShortTermInvestmentsHeldToMaturity != null) ShortTermInvestmentsHeldToMaturity.UpdateValues(previous.ShortTermInvestmentsHeldToMaturity); " is 141.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (ShortTermInvestmentsTrading != null) ShortTermInvestmentsTrading.UpdateValues(previous.ShortTermInvestmentsTrading); " is 120.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (TotalLiabilitiesNetMinorityInterest != null) TotalLiabilitiesNetMinorityInterest.UpdateValues(previous.TotalLiabilitiesNetMinorityInterest); " is 144.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (TotalNonCurrentLiabilitiesNetMinorityInterest != null) TotalNonCurrentLiabilitiesNetMinorityInterest.UpdateValues(previous.TotalNonCurrentLiabilitiesNetMinorityInterest); " is 174.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (TotalEquityGrossMinorityInterest != null) TotalEquityGrossMinorityInterest.UpdateValues(previous.TotalEquityGrossMinorityInterest); " is 135.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (NonCurrentAccountsReceivable != null) NonCurrentAccountsReceivable.UpdateValues(previous.NonCurrentAccountsReceivable); " is 123.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (AdvanceFromFederalHomeLoanBanks != null) AdvanceFromFederalHomeLoanBanks.UpdateValues(previous.AdvanceFromFederalHomeLoanBanks); " is 132.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (AllowanceForDoubtfulAccountsReceivable != null) AllowanceForDoubtfulAccountsReceivable.UpdateValues(previous.AllowanceForDoubtfulAccountsReceivable); " is 153.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (AllowanceForNotesReceivable != null) AllowanceForNotesReceivable.UpdateValues(previous.AllowanceForNotesReceivable); " is 120.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (AssetsOfDiscontinuedOperations != null) AssetsOfDiscontinuedOperations.UpdateValues(previous.AssetsOfDiscontinuedOperations); " is 129.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (BankAcceptanceExecutedAndOutstanding != null) BankAcceptanceExecutedAndOutstanding.UpdateValues(previous.BankAcceptanceExecutedAndOutstanding); " is 147.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (CommonStocksAvailableForSale != null) CommonStocksAvailableForSale.UpdateValues(previous.CommonStocksAvailableForSale); " is 123.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (DerivativeProductLiabilities != null) DerivativeProductLiabilities.UpdateValues(previous.DerivativeProductLiabilities); " is 123.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (FinancialInstrumentsSoldUnderAgreementsToRepurchase != null) FinancialInstrumentsSoldUnderAgreementsToRepurchase.UpdateValues(previous.FinancialInstrumentsSoldUnderAgreementsToRepurchase); " is 192.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (FlightFleetVehicleAndRelatedEquipments != null) FlightFleetVehicleAndRelatedEquipments.UpdateValues(previous.FlightFleetVehicleAndRelatedEquipments); " is 153.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (ForeignCurrencyTranslationAdjustments != null) ForeignCurrencyTranslationAdjustments.UpdateValues(previous.ForeignCurrencyTranslationAdjustments); " is 150.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (GuaranteedInvestmentContract != null) GuaranteedInvestmentContract.UpdateValues(previous.GuaranteedInvestmentContract); " is 123.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (InventoriesAdjustmentsAllowances != null) InventoriesAdjustmentsAllowances.UpdateValues(previous.InventoriesAdjustmentsAllowances); " is 135.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (InvestmentsInAffiliatesSubsidiariesAssociatesAndJointVentures != null) InvestmentsInAffiliatesSubsidiariesAssociatesAndJointVentures.UpdateValues(previous.InvestmentsInAffiliatesSubsidiariesAssociatesAndJointVentures); " is 222.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (InvestmentsInOtherVenturesUnderEquityMethod != null) InvestmentsInOtherVenturesUnderEquityMethod.UpdateValues(previous.InvestmentsInOtherVenturesUnderEquityMethod); " is 168.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (InvestmentsInVariableInterestEntity != null) InvestmentsInVariableInterestEntity.UpdateValues(previous.InvestmentsInVariableInterestEntity); " is 144.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (LiabilitiesOfDiscontinuedOperations != null) LiabilitiesOfDiscontinuedOperations.UpdateValues(previous.LiabilitiesOfDiscontinuedOperations); " is 144.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (MachineryFurnitureEquipment != null) MachineryFurnitureEquipment.UpdateValues(previous.MachineryFurnitureEquipment); " is 120.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (NetUnrealizedGainLossForeignCurrency != null) NetUnrealizedGainLossForeignCurrency.UpdateValues(previous.NetUnrealizedGainLossForeignCurrency); " is 147.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (NetUnrealizedGainLossInvestments != null) NetUnrealizedGainLossInvestments.UpdateValues(previous.NetUnrealizedGainLossInvestments); " is 135.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (NonCurrentPensionAndOtherPostretirementBenefitPlans != null) NonCurrentPensionAndOtherPostretirementBenefitPlans.UpdateValues(previous.NonCurrentPensionAndOtherPostretirementBenefitPlans); " is 192.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (PreferredStocksAvailableForSale != null) PreferredStocksAvailableForSale.UpdateValues(previous.PreferredStocksAvailableForSale); " is 132.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (RealEstateAndRealEstateJointVenturesHeldForInvestment != null) RealEstateAndRealEstateJointVenturesHeldForInvestment.UpdateValues(previous.RealEstateAndRealEstateJointVenturesHeldForInvestment); " is 198.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (ReceivablesAdjustmentsAllowances != null) ReceivablesAdjustmentsAllowances.UpdateValues(previous.ReceivablesAdjustmentsAllowances); " is 135.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (ReinsuranceRecoverableForPaidLosses != null) ReinsuranceRecoverableForPaidLosses.UpdateValues(previous.ReinsuranceRecoverableForPaidLosses); " is 144.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (ReinsuranceRecoverableForUnpaidLosses != null) ReinsuranceRecoverableForUnpaidLosses.UpdateValues(previous.ReinsuranceRecoverableForUnpaidLosses); " is 150.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (RestrictedCashAndCashEquivalents != null) RestrictedCashAndCashEquivalents.UpdateValues(previous.RestrictedCashAndCashEquivalents); " is 135.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (RestrictedCashAndInvestments != null) RestrictedCashAndInvestments.UpdateValues(previous.RestrictedCashAndInvestments); " is 123.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (TotalDeferredCreditsAndOtherNonCurrentLiabilities != null) TotalDeferredCreditsAndOtherNonCurrentLiabilities.UpdateValues(previous.TotalDeferredCreditsAndOtherNonCurrentLiabilities); " is 186.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (EquityAttributableToOwnersOfParent != null) EquityAttributableToOwnersOfParent.UpdateValues(previous.EquityAttributableToOwnersOfParent); " is 141.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (ParticipatingPolicyholderEquity != null) ParticipatingPolicyholderEquity.UpdateValues(previous.ParticipatingPolicyholderEquity); " is 132.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (DuefromRelatedPartiesCurrent != null) DuefromRelatedPartiesCurrent.UpdateValues(previous.DuefromRelatedPartiesCurrent); " is 123.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (DuefromRelatedPartiesNonCurrent != null) DuefromRelatedPartiesNonCurrent.UpdateValues(previous.DuefromRelatedPartiesNonCurrent); " is 132.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (DuetoRelatedPartiesNonCurrent != null) DuetoRelatedPartiesNonCurrent.UpdateValues(previous.DuetoRelatedPartiesNonCurrent); " is 126.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (InvestmentsinSubsidiariesatCost != null) InvestmentsinSubsidiariesatCost.UpdateValues(previous.InvestmentsinSubsidiariesatCost); " is 132.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (InvestmentsinAssociatesatCost != null) InvestmentsinAssociatesatCost.UpdateValues(previous.InvestmentsinAssociatesatCost); " is 126.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (InvestmentsinJointVenturesatCost != null) InvestmentsinJointVenturesatCost.UpdateValues(previous.InvestmentsinJointVenturesatCost); " is 135.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (InvestmentinFinancialAssets != null) InvestmentinFinancialAssets.UpdateValues(previous.InvestmentinFinancialAssets); " is 120.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (TreasuryBillsandOtherEligibleBills != null) TreasuryBillsandOtherEligibleBills.UpdateValues(previous.TreasuryBillsandOtherEligibleBills); " is 141.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (ItemsinTheCourseofTransmissiontoOtherBanks != null) ItemsinTheCourseofTransmissiontoOtherBanks.UpdateValues(previous.ItemsinTheCourseofTransmissiontoOtherBanks); " is 165.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (TradingandFinancialLiabilities != null) TradingandFinancialLiabilities.UpdateValues(previous.TradingandFinancialLiabilities); " is 129.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (LiabilitiesHeldforSaleCurrent != null) LiabilitiesHeldforSaleCurrent.UpdateValues(previous.LiabilitiesHeldforSaleCurrent); " is 126.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (LiabilitiesHeldforSaleNonCurrent != null) LiabilitiesHeldforSaleNonCurrent.UpdateValues(previous.LiabilitiesHeldforSaleNonCurrent); " is 135.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (TotalFinancialLeaseObligations != null) TotalFinancialLeaseObligations.UpdateValues(previous.TotalFinancialLeaseObligations); " is 129.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (AccruedandDeferredIncomeCurrent != null) AccruedandDeferredIncomeCurrent.UpdateValues(previous.AccruedandDeferredIncomeCurrent); " is 132.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (AccruedandDeferredIncomeNonCurrent != null) AccruedandDeferredIncomeNonCurrent.UpdateValues(previous.AccruedandDeferredIncomeNonCurrent); " is 141.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (FinanceLeaseReceivablesCurrent != null) FinanceLeaseReceivablesCurrent.UpdateValues(previous.FinanceLeaseReceivablesCurrent); " is 129.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (FinanceLeaseReceivablesNonCurrent != null) FinanceLeaseReceivablesNonCurrent.UpdateValues(previous.FinanceLeaseReceivablesNonCurrent); " is 138.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (FinancialLiabilitiesCurrent != null) FinancialLiabilitiesCurrent.UpdateValues(previous.FinancialLiabilitiesCurrent); " is 120.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (FinancialLiabilitiesNonCurrent != null) FinancialLiabilitiesNonCurrent.UpdateValues(previous.FinancialLiabilitiesNonCurrent); " is 129.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (FinancialAssetsDesignatedasFairValueThroughProfitorLossTotal != null) FinancialAssetsDesignatedasFairValueThroughProfitorLossTotal.UpdateValues(previous.FinancialAssetsDesignatedasFairValueThroughProfitorLossTotal); " is 219.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (InterestBearingBorrowingsNonCurrent != null) InterestBearingBorrowingsNonCurrent.UpdateValues(previous.InterestBearingBorrowingsNonCurrent); " is 144.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (NonInterestBearingBorrowingsNonCurrent != null) NonInterestBearingBorrowingsNonCurrent.UpdateValues(previous.NonInterestBearingBorrowingsNonCurrent); " is 153.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (TradeandOtherPayablesNonCurrent != null) TradeandOtherPayablesNonCurrent.UpdateValues(previous.TradeandOtherPayablesNonCurrent); " is 132.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (InterestBearingBorrowingsCurrent != null) InterestBearingBorrowingsCurrent.UpdateValues(previous.InterestBearingBorrowingsCurrent); " is 135.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (NonInterestBearingBorrowingsCurrent != null) NonInterestBearingBorrowingsCurrent.UpdateValues(previous.NonInterestBearingBorrowingsCurrent); " is 144.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (PensionandOtherPostRetirementBenefitPlansCurrent != null) PensionandOtherPostRetirementBenefitPlansCurrent.UpdateValues(previous.PensionandOtherPostRetirementBenefitPlansCurrent); " is 183.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (CashandBalanceswithCentralBanks != null) CashandBalanceswithCentralBanks.UpdateValues(previous.CashandBalanceswithCentralBanks); " is 132.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (PlacementwithBanksandOtherFinancialInstitutions != null) PlacementwithBanksandOtherFinancialInstitutions.UpdateValues(previous.PlacementwithBanksandOtherFinancialInstitutions); " is 180.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (AssetsPledgedasCollateralSubjecttoSaleorRepledgingTotal != null) AssetsPledgedasCollateralSubjecttoSaleorRepledgingTotal.UpdateValues(previous.AssetsPledgedasCollateralSubjecttoSaleorRepledgingTotal); " is 204.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (CertificatesofDepositsandOtherDebtSecuritiesIssued != null) CertificatesofDepositsandOtherDebtSecuritiesIssued.UpdateValues(previous.CertificatesofDepositsandOtherDebtSecuritiesIssued); " is 189.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (DebenturesandDebtCertificates != null) DebenturesandDebtCertificates.UpdateValues(previous.DebenturesandDebtCertificates); " is 126.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (InterestBearingBorrowingsTotal != null) InterestBearingBorrowingsTotal.UpdateValues(previous.InterestBearingBorrowingsTotal); " is 129.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (NonInterestBearingBorrowingsTotal != null) NonInterestBearingBorrowingsTotal.UpdateValues(previous.NonInterestBearingBorrowingsTotal); " is 138.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (FinancialLiabilitiesDesignatedasFairValueThroughProfitorLossTotal != null) FinancialLiabilitiesDesignatedasFairValueThroughProfitorLossTotal.UpdateValues(previous.FinancialLiabilitiesDesignatedasFairValueThroughProfitorLossTotal); " is 234.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (FinancialLiabilitiesMeasuredatAmortizedCostTotal != null) FinancialLiabilitiesMeasuredatAmortizedCostTotal.UpdateValues(previous.FinancialLiabilitiesMeasuredatAmortizedCostTotal); " is 183.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (LiabilitiesRecognizedforFairValueChangesinPortfolioHedgeofInterestRateRisk != null) LiabilitiesRecognizedforFairValueChangesinPortfolioHedgeofInterestRateRisk.UpdateValues(previous.LiabilitiesRecognizedforFairValueChangesinPortfolioHedgeofInterestRateRisk); " is 261.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (DeferredTaxLiabilitiesTotal != null) DeferredTaxLiabilitiesTotal.UpdateValues(previous.DeferredTaxLiabilitiesTotal); " is 120.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (ReinsuranceShareofInsuranceContract != null) ReinsuranceShareofInsuranceContract.UpdateValues(previous.ReinsuranceShareofInsuranceContract); " is 144.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (ReinsuranceShareofAccruedPolicyholderClaims != null) ReinsuranceShareofAccruedPolicyholderClaims.UpdateValues(previous.ReinsuranceShareofAccruedPolicyholderClaims); " is 168.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (DepositsMadeunderAssumedReinsuranceContract != null) DepositsMadeunderAssumedReinsuranceContract.UpdateValues(previous.DepositsMadeunderAssumedReinsuranceContract); " is 168.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (InsuranceContractLiabilities != null) InsuranceContractLiabilities.UpdateValues(previous.InsuranceContractLiabilities); " is 123.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (DepositsReceivedunderCededInsuranceContract != null) DepositsReceivedunderCededInsuranceContract.UpdateValues(previous.DepositsReceivedunderCededInsuranceContract); " is 168.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (InvestmentContractLiabilities != null) InvestmentContractLiabilities.UpdateValues(previous.InvestmentContractLiabilities); " is 126.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (PensionAndOtherPostretirementBenefitPlansTotal != null) PensionAndOtherPostretirementBenefitPlansTotal.UpdateValues(previous.PensionAndOtherPostretirementBenefitPlansTotal); " is 177.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (LiabilitiesHeldforSaleTotal != null) LiabilitiesHeldforSaleTotal.UpdateValues(previous.LiabilitiesHeldforSaleTotal); " is 120.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (HedgingLiabilitiesNonCurrent != null) HedgingLiabilitiesNonCurrent.UpdateValues(previous.HedgingLiabilitiesNonCurrent); " is 123.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (AssetsHeldForSaleNonCurrent != null) AssetsHeldForSaleNonCurrent.UpdateValues(previous.AssetsHeldForSaleNonCurrent); " is 120.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (FinancialOrDerivativeInvestmentCurrentLiabilities != null) FinancialOrDerivativeInvestmentCurrentLiabilities.UpdateValues(previous.FinancialOrDerivativeInvestmentCurrentLiabilities); " is 186.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (TradeAndOtherReceivablesNonCurrent != null) TradeAndOtherReceivablesNonCurrent.UpdateValues(previous.TradeAndOtherReceivablesNonCurrent); " is 141.
Long Statement,QuantConnect.Data.Fundamental,BalanceSheet,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\BalanceSheet.cs,UpdateValues,The length of the statement  "			if (CooperativesShareCapitalRepayableonDemand != null) CooperativesShareCapitalRepayableonDemand.UpdateValues(previous.CooperativesShareCapitalRepayableonDemand); " is 162.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CallsMaturitiesOfMaturitySecurities != null) CallsMaturitiesOfMaturitySecurities.UpdateValues(previous.CallsMaturitiesOfMaturitySecurities); " is 144.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (NetCapitalExpenditureDisposals != null) NetCapitalExpenditureDisposals.UpdateValues(previous.NetCapitalExpenditureDisposals); " is 129.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashFlowFromContinuingFinancingActivities != null) CashFlowFromContinuingFinancingActivities.UpdateValues(previous.CashFlowFromContinuingFinancingActivities); " is 162.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashFlowFromContinuingInvestingActivities != null) CashFlowFromContinuingInvestingActivities.UpdateValues(previous.CashFlowFromContinuingInvestingActivities); " is 162.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashFlowFromContinuingOperatingActivities != null) CashFlowFromContinuingOperatingActivities.UpdateValues(previous.CashFlowFromContinuingOperatingActivities); " is 162.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashFlowFromDiscontinuedOperation != null) CashFlowFromDiscontinuedOperation.UpdateValues(previous.CashFlowFromDiscontinuedOperation); " is 138.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashFromDiscontinuedFinancing != null) CashFromDiscontinuedFinancing.UpdateValues(previous.CashFromDiscontinuedFinancing); " is 126.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashFromDiscontinuedFinancingActivities != null) CashFromDiscontinuedFinancingActivities.UpdateValues(previous.CashFromDiscontinuedFinancingActivities); " is 156.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashFromDiscontinuedInvesting != null) CashFromDiscontinuedInvesting.UpdateValues(previous.CashFromDiscontinuedInvesting); " is 126.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashFromDiscontinuedInvestingActivities != null) CashFromDiscontinuedInvestingActivities.UpdateValues(previous.CashFromDiscontinuedInvestingActivities); " is 156.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashFromDiscontinuedOperating != null) CashFromDiscontinuedOperating.UpdateValues(previous.CashFromDiscontinuedOperating); " is 126.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeInAccruedInvestmentIncome != null) ChangeInAccruedInvestmentIncome.UpdateValues(previous.ChangeInAccruedInvestmentIncome); " is 132.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeInDeferredAcquisitionCosts != null) ChangeInDeferredAcquisitionCosts.UpdateValues(previous.ChangeInDeferredAcquisitionCosts); " is 135.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeInFederalFundsAndSecuritiesSoldForRepurchase != null) ChangeInFederalFundsAndSecuritiesSoldForRepurchase.UpdateValues(previous.ChangeInFederalFundsAndSecuritiesSoldForRepurchase); " is 189.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeInLossAndLossAdjustmentExpenseReserves != null) ChangeInLossAndLossAdjustmentExpenseReserves.UpdateValues(previous.ChangeInLossAndLossAdjustmentExpenseReserves); " is 171.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeInPayablesAndAccruedExpense != null) ChangeInPayablesAndAccruedExpense.UpdateValues(previous.ChangeInPayablesAndAccruedExpense); " is 138.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeInReinsuranceRecoverableOnPaidAndUnpaidLosses != null) ChangeInReinsuranceRecoverableOnPaidAndUnpaidLosses.UpdateValues(previous.ChangeInReinsuranceRecoverableOnPaidAndUnpaidLosses); " is 192.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeInTradingAccountSecurities != null) ChangeInTradingAccountSecurities.UpdateValues(previous.ChangeInTradingAccountSecurities); " is 135.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CumulativeEffectOfAccountingChange != null) CumulativeEffectOfAccountingChange.UpdateValues(previous.CumulativeEffectOfAccountingChange); " is 141.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (DepreciationAndAmortization != null) DepreciationAndAmortization.UpdateValues(previous.DepreciationAndAmortization); " is 120.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (DepreciationAmortizationDepletion != null) DepreciationAmortizationDepletion.UpdateValues(previous.DepreciationAmortizationDepletion); " is 138.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (EffectOfExchangeRateChanges != null) EffectOfExchangeRateChanges.UpdateValues(previous.EffectOfExchangeRateChanges); " is 120.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (NetCashFromDiscontinuedOperations != null) NetCashFromDiscontinuedOperations.UpdateValues(previous.NetCashFromDiscontinuedOperations); " is 138.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (NetForeignCurrencyExchangeGainLoss != null) NetForeignCurrencyExchangeGainLoss.UpdateValues(previous.NetForeignCurrencyExchangeGainLoss); " is 141.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (NetIncomeFromContinuingOperations != null) NetIncomeFromContinuingOperations.UpdateValues(previous.NetIncomeFromContinuingOperations); " is 138.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ProceedsFromIssuanceOfWarrants != null) ProceedsFromIssuanceOfWarrants.UpdateValues(previous.ProceedsFromIssuanceOfWarrants); " is 129.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ProceedsFromStockOptionExercised != null) ProceedsFromStockOptionExercised.UpdateValues(previous.ProceedsFromStockOptionExercised); " is 135.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ProceedsPaymentInInterestBearingDepositsInBank != null) ProceedsPaymentInInterestBearingDepositsInBank.UpdateValues(previous.ProceedsPaymentInInterestBearingDepositsInBank); " is 177.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (PurchaseOfFixedMaturitySecurities != null) PurchaseOfFixedMaturitySecurities.UpdateValues(previous.PurchaseOfFixedMaturitySecurities); " is 138.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (PurchaseOfLongTermInvestments != null) PurchaseOfLongTermInvestments.UpdateValues(previous.PurchaseOfLongTermInvestments); " is 126.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (PurchaseOfShortTermInvestments != null) PurchaseOfShortTermInvestments.UpdateValues(previous.PurchaseOfShortTermInvestments); " is 129.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (NetIntangiblesPurchaseAndSale != null) NetIntangiblesPurchaseAndSale.UpdateValues(previous.NetIntangiblesPurchaseAndSale); " is 126.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (NetInvestmentPurchaseAndSale != null) NetInvestmentPurchaseAndSale.UpdateValues(previous.NetInvestmentPurchaseAndSale); " is 123.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (NetTechnologyPurchaseAndSale != null) NetTechnologyPurchaseAndSale.UpdateValues(previous.NetTechnologyPurchaseAndSale); " is 123.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (SalesOfFixedMaturitySecurities != null) SalesOfFixedMaturitySecurities.UpdateValues(previous.SalesOfFixedMaturitySecurities); " is 129.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangesInAccountReceivables != null) ChangesInAccountReceivables.UpdateValues(previous.ChangesInAccountReceivables); " is 120.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (AmortizationOfFinancingCostsAndDiscounts != null) AmortizationOfFinancingCostsAndDiscounts.UpdateValues(previous.AmortizationOfFinancingCostsAndDiscounts); " is 159.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeInOtherCurrentLiabilities != null) ChangeInOtherCurrentLiabilities.UpdateValues(previous.ChangeInOtherCurrentLiabilities); " is 132.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeInOtherWorkingCapital != null) ChangeInOtherWorkingCapital.UpdateValues(previous.ChangeInOtherWorkingCapital); " is 120.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeInPrepaidReinsurancePremiums != null) ChangeInPrepaidReinsurancePremiums.UpdateValues(previous.ChangeInPrepaidReinsurancePremiums); " is 141.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeInReinsuranceReceivableOnPaidLosses != null) ChangeInReinsuranceReceivableOnPaidLosses.UpdateValues(previous.ChangeInReinsuranceReceivableOnPaidLosses); " is 162.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeInReinsuranceRecoverableOnUnpaidLosses != null) ChangeInReinsuranceRecoverableOnUnpaidLosses.UpdateValues(previous.ChangeInReinsuranceRecoverableOnUnpaidLosses); " is 171.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeInUnearnedPremiumsCeded != null) ChangeInUnearnedPremiumsCeded.UpdateValues(previous.ChangeInUnearnedPremiumsCeded); " is 126.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (EarningsLossesFromEquityInvestments != null) EarningsLossesFromEquityInvestments.UpdateValues(previous.EarningsLossesFromEquityInvestments); " is 144.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ExcessTaxBenefitFromStockBasedCompensation != null) ExcessTaxBenefitFromStockBasedCompensation.UpdateValues(previous.ExcessTaxBenefitFromStockBasedCompensation); " is 165.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (GainLossOnInvestmentSecurities != null) GainLossOnInvestmentSecurities.UpdateValues(previous.GainLossOnInvestmentSecurities); " is 129.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (InterestCreditedOnPolicyholderDeposits != null) InterestCreditedOnPolicyholderDeposits.UpdateValues(previous.InterestCreditedOnPolicyholderDeposits); " is 153.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashFromDiscontinuedOperatingActivities != null) CashFromDiscontinuedOperatingActivities.UpdateValues(previous.CashFromDiscontinuedOperatingActivities); " is 156.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (PensionAndEmployeeBenefitExpense != null) PensionAndEmployeeBenefitExpense.UpdateValues(previous.PensionAndEmployeeBenefitExpense); " is 135.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ProceedsPaymentFederalFundsSoldAndSecuritiesPurchasedUnderAgreementToResell != null) ProceedsPaymentFederalFundsSoldAndSecuritiesPurchasedUnderAgreementToResell.UpdateValues(previous.ProceedsPaymentFederalFundsSoldAndSecuritiesPurchasedUnderAgreementToResell); " is 264.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ProvisionForLoanLeaseAndOtherLosses != null) ProvisionForLoanLeaseAndOtherLosses.UpdateValues(previous.ProvisionForLoanLeaseAndOtherLosses); " is 144.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (RealizedGainLossOnSaleOfLoansAndLease != null) RealizedGainLossOnSaleOfLoansAndLease.UpdateValues(previous.RealizedGainLossOnSaleOfLoansAndLease); " is 150.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (UnrealizedGainLossOnInvestmentSecurities != null) UnrealizedGainLossOnInvestmentSecurities.UpdateValues(previous.UnrealizedGainLossOnInvestmentSecurities); " is 159.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (UnrealizedGainsLossesOnDerivatives != null) UnrealizedGainsLossesOnDerivatives.UpdateValues(previous.UnrealizedGainsLossesOnDerivatives); " is 141.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (AllowanceForFundsConstruction != null) AllowanceForFundsConstruction.UpdateValues(previous.AllowanceForFundsConstruction); " is 126.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (IncomeTaxPaidSupplementalData != null) IncomeTaxPaidSupplementalData.UpdateValues(previous.IncomeTaxPaidSupplementalData); " is 126.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (InterestPaidSupplementalData != null) InterestPaidSupplementalData.UpdateValues(previous.InterestPaidSupplementalData); " is 123.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (DecreaseinInterestBearingDepositsinBank != null) DecreaseinInterestBearingDepositsinBank.UpdateValues(previous.DecreaseinInterestBearingDepositsinBank); " is 156.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (IncreaseinInterestBearingDepositsinBank != null) IncreaseinInterestBearingDepositsinBank.UpdateValues(previous.IncreaseinInterestBearingDepositsinBank); " is 156.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (AdjustedGeographySegmentData != null) AdjustedGeographySegmentData.UpdateValues(previous.AdjustedGeographySegmentData); " is 123.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (PurchaseofJointVentureAssociate != null) PurchaseofJointVentureAssociate.UpdateValues(previous.PurchaseofJointVentureAssociate); " is 132.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (SaleofJointVentureAssociate != null) SaleofJointVentureAssociate.UpdateValues(previous.SaleofJointVentureAssociate); " is 120.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (IncreaseDecreaseinLeaseFinancing != null) IncreaseDecreaseinLeaseFinancing.UpdateValues(previous.IncreaseDecreaseinLeaseFinancing); " is 135.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeinCertificatesofDepositsandDebtSecuritiesIssued != null) ChangeinCertificatesofDepositsandDebtSecuritiesIssued.UpdateValues(previous.ChangeinCertificatesofDepositsandDebtSecuritiesIssued); " is 198.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (PaymentstoAcquireHeldToMaturityInvestments != null) PaymentstoAcquireHeldToMaturityInvestments.UpdateValues(previous.PaymentstoAcquireHeldToMaturityInvestments); " is 165.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (PaymentstoAcquireAvailableForSaleFinancialAssets != null) PaymentstoAcquireAvailableForSaleFinancialAssets.UpdateValues(previous.PaymentstoAcquireAvailableForSaleFinancialAssets); " is 183.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (PaymentstoAcquireFinancialAssetsDesignatedasFairValue != null) PaymentstoAcquireFinancialAssetsDesignatedasFairValue.UpdateValues(previous.PaymentstoAcquireFinancialAssetsDesignatedasFairValue); " is 198.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ProceedsfromDisposalofHeldToMaturityInvestments != null) ProceedsfromDisposalofHeldToMaturityInvestments.UpdateValues(previous.ProceedsfromDisposalofHeldToMaturityInvestments); " is 180.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ProceedsfromDisposalofAvailableForSaleFinancialAssets != null) ProceedsfromDisposalofAvailableForSaleFinancialAssets.UpdateValues(previous.ProceedsfromDisposalofAvailableForSaleFinancialAssets); " is 198.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ProceedsfromDisposalofFinancialAssetsDesignatedasFairValue != null) ProceedsfromDisposalofFinancialAssetsDesignatedasFairValue.UpdateValues(previous.ProceedsfromDisposalofFinancialAssetsDesignatedasFairValue); " is 213.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeinFairValueofInvestmentProperties != null) ChangeinFairValueofInvestmentProperties.UpdateValues(previous.ChangeinFairValueofInvestmentProperties); " is 156.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeinDepositsbyBanksandCustomers != null) ChangeinDepositsbyBanksandCustomers.UpdateValues(previous.ChangeinDepositsbyBanksandCustomers); " is 144.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashFlowsfromusedinOperatingActivitiesDirect != null) CashFlowsfromusedinOperatingActivitiesDirect.UpdateValues(previous.CashFlowsfromusedinOperatingActivitiesDirect); " is 171.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ClassesofCashReceiptsfromOperatingActivities != null) ClassesofCashReceiptsfromOperatingActivities.UpdateValues(previous.ClassesofCashReceiptsfromOperatingActivities); " is 171.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (OtherCashReceiptsfromOperatingActivities != null) OtherCashReceiptsfromOperatingActivities.UpdateValues(previous.OtherCashReceiptsfromOperatingActivities); " is 159.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (PaymentstoSuppliersforGoodsandServices != null) PaymentstoSuppliersforGoodsandServices.UpdateValues(previous.PaymentstoSuppliersforGoodsandServices); " is 153.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (PaymentsfromContractsHeldforDealingorTradingPurpose != null) PaymentsfromContractsHeldforDealingorTradingPurpose.UpdateValues(previous.PaymentsfromContractsHeldforDealingorTradingPurpose); " is 192.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (PaymentsonBehalfofEmployees != null) PaymentsonBehalfofEmployees.UpdateValues(previous.PaymentsonBehalfofEmployees); " is 120.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (PaymentsforPremiumsandClaimsAnnuitiesandOtherPolicyBenefits != null) PaymentsforPremiumsandClaimsAnnuitiesandOtherPolicyBenefits.UpdateValues(previous.PaymentsforPremiumsandClaimsAnnuitiesandOtherPolicyBenefits); " is 216.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (OtherCashPaymentsfromOperatingActivities != null) OtherCashPaymentsfromOperatingActivities.UpdateValues(previous.OtherCashPaymentsfromOperatingActivities); " is 159.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (TotalAdjustmentsforNonCashItems != null) TotalAdjustmentsforNonCashItems.UpdateValues(previous.TotalAdjustmentsforNonCashItems); " is 132.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ImpairmentLossReversalRecognizedinProfitorLoss != null) ImpairmentLossReversalRecognizedinProfitorLoss.UpdateValues(previous.ImpairmentLossReversalRecognizedinProfitorLoss); " is 177.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (AdjustmentsforUndistributedProfitsofAssociates != null) AdjustmentsforUndistributedProfitsofAssociates.UpdateValues(previous.AdjustmentsforUndistributedProfitsofAssociates); " is 177.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (OtherAdjustmentsforWhichCashEffectsAreInvestingorFinancingCashFlow != null) OtherAdjustmentsforWhichCashEffectsAreInvestingorFinancingCashFlow.UpdateValues(previous.OtherAdjustmentsforWhichCashEffectsAreInvestingorFinancingCashFlow); " is 237.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (OtherOperatingInflowsOutflowsofCash != null) OtherOperatingInflowsOutflowsofCash.UpdateValues(previous.OtherOperatingInflowsOutflowsofCash); " is 144.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ProceedsfromGovernmentGrantsCFI != null) ProceedsfromGovernmentGrantsCFI.UpdateValues(previous.ProceedsfromGovernmentGrantsCFI); " is 132.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashAdvancesandLoansMadetoOtherParties != null) CashAdvancesandLoansMadetoOtherParties.UpdateValues(previous.CashAdvancesandLoansMadetoOtherParties); " is 153.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashReceiptsfromRepaymentofAdvancesandLoansMadetoOtherParties != null) CashReceiptsfromRepaymentofAdvancesandLoansMadetoOtherParties.UpdateValues(previous.CashReceiptsfromRepaymentofAdvancesandLoansMadetoOtherParties); " is 222.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashReceiptsfromPaymentsforFinancialDerivativeContracts != null) CashReceiptsfromPaymentsforFinancialDerivativeContracts.UpdateValues(previous.CashReceiptsfromPaymentsforFinancialDerivativeContracts); " is 204.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (IssuancePaymentofOtherEquityInstrumentsNet != null) IssuancePaymentofOtherEquityInstrumentsNet.UpdateValues(previous.IssuancePaymentofOtherEquityInstrumentsNet); " is 165.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (PaymentsofOtherEquityInstruments != null) PaymentsofOtherEquityInstruments.UpdateValues(previous.PaymentsofOtherEquityInstruments); " is 135.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ProceedsfromIssuingOtherEquityInstruments != null) ProceedsfromIssuingOtherEquityInstruments.UpdateValues(previous.ProceedsfromIssuingOtherEquityInstruments); " is 162.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ProceedsfromGovernmentGrantsCFF != null) ProceedsfromGovernmentGrantsCFF.UpdateValues(previous.ProceedsfromGovernmentGrantsCFF); " is 132.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeinAdvancesfromCentralBanks != null) ChangeinAdvancesfromCentralBanks.UpdateValues(previous.ChangeinAdvancesfromCentralBanks); " is 135.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeinFinancialLiabilities != null) ChangeinFinancialLiabilities.UpdateValues(previous.ChangeinFinancialLiabilities); " is 123.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeinInsuranceContractAssets != null) ChangeinInsuranceContractAssets.UpdateValues(previous.ChangeinInsuranceContractAssets); " is 132.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeinReinsuranceReceivables != null) ChangeinReinsuranceReceivables.UpdateValues(previous.ChangeinReinsuranceReceivables); " is 129.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeinDeferredAcquisitionCostsNet != null) ChangeinDeferredAcquisitionCostsNet.UpdateValues(previous.ChangeinDeferredAcquisitionCostsNet); " is 144.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeinReinsurancePayables != null) ChangeinReinsurancePayables.UpdateValues(previous.ChangeinReinsurancePayables); " is 120.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeinInvestmentContractLiabilities != null) ChangeinInvestmentContractLiabilities.UpdateValues(previous.ChangeinInvestmentContractLiabilities); " is 150.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ChangeinInsuranceContractLiabilities != null) ChangeinInsuranceContractLiabilities.UpdateValues(previous.ChangeinInsuranceContractLiabilities); " is 147.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ProvisionandWriteOffofAssets != null) ProvisionandWriteOffofAssets.UpdateValues(previous.ProvisionandWriteOffofAssets); " is 123.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ReceiptsfromGovernmentGrants != null) ReceiptsfromGovernmentGrants.UpdateValues(previous.ReceiptsfromGovernmentGrants); " is 123.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashReceiptsfromDepositsbyBanksandCustomers != null) CashReceiptsfromDepositsbyBanksandCustomers.UpdateValues(previous.CashReceiptsfromDepositsbyBanksandCustomers); " is 168.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashReceiptsfromSecuritiesRelatedActivities != null) CashReceiptsfromSecuritiesRelatedActivities.UpdateValues(previous.CashReceiptsfromSecuritiesRelatedActivities); " is 168.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashReceiptsfromDecreaseinAssets != null) CashReceiptsfromDecreaseinAssets.UpdateValues(previous.CashReceiptsfromDecreaseinAssets); " is 135.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashReceiptsfromFeesandCommissions != null) CashReceiptsfromFeesandCommissions.UpdateValues(previous.CashReceiptsfromFeesandCommissions); " is 141.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashPaymentsforDepositsbyBanksandCustomers != null) CashPaymentsforDepositsbyBanksandCustomers.UpdateValues(previous.CashPaymentsforDepositsbyBanksandCustomers); " is 165.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashReceivedfromInsuranceActivities != null) CashReceivedfromInsuranceActivities.UpdateValues(previous.CashReceivedfromInsuranceActivities); " is 144.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (ReinsuranceandOtherRecoveriesReceived != null) ReinsuranceandOtherRecoveriesReceived.UpdateValues(previous.ReinsuranceandOtherRecoveriesReceived); " is 150.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (PolicyholderDepositInvestmentReceived != null) PolicyholderDepositInvestmentReceived.UpdateValues(previous.PolicyholderDepositInvestmentReceived); " is 150.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashPaidforInsuranceActivities != null) CashPaidforInsuranceActivities.UpdateValues(previous.CashPaidforInsuranceActivities); " is 129.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (OtherUnderwritingExpensesPaid != null) OtherUnderwritingExpensesPaid.UpdateValues(previous.OtherUnderwritingExpensesPaid); " is 126.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (NetIncomeFromDiscontinuedOperations != null) NetIncomeFromDiscontinuedOperations.UpdateValues(previous.NetIncomeFromDiscontinuedOperations); " is 144.
Long Statement,QuantConnect.Data.Fundamental,CashFlowStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\CashFlowStatement.cs,UpdateValues,The length of the statement  "			if (CashGeneratedfromOperatingActivities != null) CashGeneratedfromOperatingActivities.UpdateValues(previous.CashGeneratedfromOperatingActivities); " is 147.
Long Statement,QuantConnect.Data.Fundamental,EarningRatios,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\EarningRatios.cs,UpdateValues,The length of the statement  "			if (RegressionGrowthofDividends5Years != null) RegressionGrowthofDividends5Years.UpdateValues(previous.RegressionGrowthofDividends5Years); " is 138.
Long Statement,QuantConnect.Data.Fundamental,EarningReports,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\EarningReports.cs,UpdateValues,The length of the statement  "			if (BasicDiscontinuousOperations != null) BasicDiscontinuousOperations.UpdateValues(previous.BasicDiscontinuousOperations); " is 123.
Long Statement,QuantConnect.Data.Fundamental,EarningReports,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\EarningReports.cs,UpdateValues,The length of the statement  "			if (DilutedContinuousOperations != null) DilutedContinuousOperations.UpdateValues(previous.DilutedContinuousOperations); " is 120.
Long Statement,QuantConnect.Data.Fundamental,EarningReports,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\EarningReports.cs,UpdateValues,The length of the statement  "			if (DilutedDiscontinuousOperations != null) DilutedDiscontinuousOperations.UpdateValues(previous.DilutedDiscontinuousOperations); " is 129.
Long Statement,QuantConnect.Data.Fundamental,EarningReports,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\EarningReports.cs,UpdateValues,The length of the statement  "			if (ContinuingAndDiscontinuedBasicEPS != null) ContinuingAndDiscontinuedBasicEPS.UpdateValues(previous.ContinuingAndDiscontinuedBasicEPS); " is 138.
Long Statement,QuantConnect.Data.Fundamental,EarningReports,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\EarningReports.cs,UpdateValues,The length of the statement  "			if (TaxLossCarryforwardBasicEPS != null) TaxLossCarryforwardBasicEPS.UpdateValues(previous.TaxLossCarryforwardBasicEPS); " is 120.
Long Statement,QuantConnect.Data.Fundamental,EarningReports,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\EarningReports.cs,UpdateValues,The length of the statement  "			if (ContinuingAndDiscontinuedDilutedEPS != null) ContinuingAndDiscontinuedDilutedEPS.UpdateValues(previous.ContinuingAndDiscontinuedDilutedEPS); " is 144.
Long Statement,QuantConnect.Data.Fundamental,EarningReports,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\EarningReports.cs,UpdateValues,The length of the statement  "			if (TaxLossCarryforwardDilutedEPS != null) TaxLossCarryforwardDilutedEPS.UpdateValues(previous.TaxLossCarryforwardDilutedEPS); " is 126.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (CumulativeEffectOfAccountingChange != null) CumulativeEffectOfAccountingChange.UpdateValues(previous.CumulativeEffectOfAccountingChange); " is 141.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (DepreciationAndAmortization != null) DepreciationAndAmortization.UpdateValues(previous.DepreciationAndAmortization); " is 120.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (DepreciationAmortizationDepletion != null) DepreciationAmortizationDepletion.UpdateValues(previous.DepreciationAmortizationDepletion); " is 138.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (NetIncomeDiscontinuousOperations != null) NetIncomeDiscontinuousOperations.UpdateValues(previous.NetIncomeDiscontinuousOperations); " is 135.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (GeneralAndAdministrativeExpense != null) GeneralAndAdministrativeExpense.UpdateValues(previous.GeneralAndAdministrativeExpense); " is 132.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (InterestExpenseNonOperating != null) InterestExpenseNonOperating.UpdateValues(previous.InterestExpenseNonOperating); " is 120.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (InterestIncomeAfterProvisionForLoanLoss != null) InterestIncomeAfterProvisionForLoanLoss.UpdateValues(previous.InterestIncomeAfterProvisionForLoanLoss); " is 156.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (NetNonOperatingInterestIncomeExpense != null) NetNonOperatingInterestIncomeExpense.UpdateValues(previous.NetNonOperatingInterestIncomeExpense); " is 147.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (NetOperatingInterestIncomeExpense != null) NetOperatingInterestIncomeExpense.UpdateValues(previous.NetOperatingInterestIncomeExpense); " is 138.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (NetIncomeCommonStockholders != null) NetIncomeCommonStockholders.UpdateValues(previous.NetIncomeCommonStockholders); " is 120.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (NetIncomeContinuousOperations != null) NetIncomeContinuousOperations.UpdateValues(previous.NetIncomeContinuousOperations); " is 126.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (NetPolicyholderBenefitsAndClaims != null) NetPolicyholderBenefitsAndClaims.UpdateValues(previous.NetPolicyholderBenefitsAndClaims); " is 135.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (SellingGeneralAndAdministration != null) SellingGeneralAndAdministration.UpdateValues(previous.SellingGeneralAndAdministration); " is 132.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (AmortizationOfDeferredAcquisitionCosts != null) AmortizationOfDeferredAcquisitionCosts.UpdateValues(previous.AmortizationOfDeferredAcquisitionCosts); " is 153.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (PropertyLiabilityInsuranceClaims != null) PropertyLiabilityInsuranceClaims.UpdateValues(previous.PropertyLiabilityInsuranceClaims); " is 135.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (NetIncomeContinuousOperationsNetMinorityInterest != null) NetIncomeContinuousOperationsNetMinorityInterest.UpdateValues(previous.NetIncomeContinuousOperationsNetMinorityInterest); " is 183.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (AccruedPreferredStockDividends != null) AccruedPreferredStockDividends.UpdateValues(previous.AccruedPreferredStockDividends); " is 129.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (EarningLossOfEquityInvestments != null) EarningLossOfEquityInvestments.UpdateValues(previous.EarningLossOfEquityInvestments); " is 129.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (ExplorationDevelopmentAndMineralPropertyLeaseExpenses != null) ExplorationDevelopmentAndMineralPropertyLeaseExpenses.UpdateValues(previous.ExplorationDevelopmentAndMineralPropertyLeaseExpenses); " is 198.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (ForeignExchangeTradingGains != null) ForeignExchangeTradingGains.UpdateValues(previous.ForeignExchangeTradingGains); " is 120.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (GainsLossOnDisposalOfDiscontinuedOperations != null) GainsLossOnDisposalOfDiscontinuedOperations.UpdateValues(previous.GainsLossOnDisposalOfDiscontinuedOperations); " is 168.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (OtherImpairmentOfCapitalAssets != null) OtherImpairmentOfCapitalAssets.UpdateValues(previous.OtherImpairmentOfCapitalAssets); " is 129.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (IncomeFromEquityMethodInvestments != null) IncomeFromEquityMethodInvestments.UpdateValues(previous.IncomeFromEquityMethodInvestments); " is 138.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (IncreaseDecreaseInNetUnearnedPremiumReserves != null) IncreaseDecreaseInNetUnearnedPremiumReserves.UpdateValues(previous.IncreaseDecreaseInNetUnearnedPremiumReserves); " is 171.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (InterestIncomeFromInterestBearingDeposits != null) InterestIncomeFromInterestBearingDeposits.UpdateValues(previous.InterestIncomeFromInterestBearingDeposits); " is 162.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (InterestExpenseForCapitalizedLeaseObligations != null) InterestExpenseForCapitalizedLeaseObligations.UpdateValues(previous.InterestExpenseForCapitalizedLeaseObligations); " is 174.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (InterestExpenseForFederalFundsSoldAndSecuritiesPurchaseUnderAgreementsToResell != null) InterestExpenseForFederalFundsSoldAndSecuritiesPurchaseUnderAgreementsToResell.UpdateValues(previous.InterestExpenseForFederalFundsSoldAndSecuritiesPurchaseUnderAgreementsToResell); " is 273.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (InterestExpenseForLongTermDebt != null) InterestExpenseForLongTermDebt.UpdateValues(previous.InterestExpenseForLongTermDebt); " is 129.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (InterestExpenseForLongTermDebtAndCapitalSecurities != null) InterestExpenseForLongTermDebtAndCapitalSecurities.UpdateValues(previous.InterestExpenseForLongTermDebtAndCapitalSecurities); " is 189.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (InterestExpenseForShortTermDebt != null) InterestExpenseForShortTermDebt.UpdateValues(previous.InterestExpenseForShortTermDebt); " is 132.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (InterestIncomeFromFederalFundsSoldAndSecuritiesPurchaseUnderAgreementsToResell != null) InterestIncomeFromFederalFundsSoldAndSecuritiesPurchaseUnderAgreementsToResell.UpdateValues(previous.InterestIncomeFromFederalFundsSoldAndSecuritiesPurchaseUnderAgreementsToResell); " is 273.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (InterestIncomeFromInvestmentSecurities != null) InterestIncomeFromInvestmentSecurities.UpdateValues(previous.InterestIncomeFromInvestmentSecurities); " is 153.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (InterestIncomeFromLoansAndLease != null) InterestIncomeFromLoansAndLease.UpdateValues(previous.InterestIncomeFromLoansAndLease); " is 132.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (InterestIncomeFromSecurities != null) InterestIncomeFromSecurities.UpdateValues(previous.InterestIncomeFromSecurities); " is 123.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (InterestIncomeFromTradingAccountSecurities != null) InterestIncomeFromTradingAccountSecurities.UpdateValues(previous.InterestIncomeFromTradingAccountSecurities); " is 165.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (LossAndLossAdjustmentExpectedIncurred != null) LossAndLossAdjustmentExpectedIncurred.UpdateValues(previous.LossAndLossAdjustmentExpectedIncurred); " is 150.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (InterestIncomeFromOtherMoneyMarketInvestments != null) InterestIncomeFromOtherMoneyMarketInvestments.UpdateValues(previous.InterestIncomeFromOtherMoneyMarketInvestments); " is 174.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (NetRealizedGainLossOnInvestments != null) NetRealizedGainLossOnInvestments.UpdateValues(previous.NetRealizedGainLossOnInvestments); " is 135.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (NonRecurringOperationExpense != null) NonRecurringOperationExpense.UpdateValues(previous.NonRecurringOperationExpense); " is 123.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (OtherGainLossFromDispositionOfDiscontinuedOperations != null) OtherGainLossFromDispositionOfDiscontinuedOperations.UpdateValues(previous.OtherGainLossFromDispositionOfDiscontinuedOperations); " is 195.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (PolicyholderAndReinsurerAccounts != null) PolicyholderAndReinsurerAccounts.UpdateValues(previous.PolicyholderAndReinsurerAccounts); " is 135.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (PrincipleTransactionRevenue != null) PrincipleTransactionRevenue.UpdateValues(previous.PrincipleTransactionRevenue); " is 120.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (ProfessionalExpenseAndContractServicesExpense != null) ProfessionalExpenseAndContractServicesExpense.UpdateValues(previous.ProfessionalExpenseAndContractServicesExpense); " is 174.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (ProvisionForDoubtfulAccounts != null) ProvisionForDoubtfulAccounts.UpdateValues(previous.ProvisionForDoubtfulAccounts); " is 123.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (ProvisionForGainLossOnDisposal != null) ProvisionForGainLossOnDisposal.UpdateValues(previous.ProvisionForGainLossOnDisposal); " is 129.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (PurchasedTransportationServices != null) PurchasedTransportationServices.UpdateValues(previous.PurchasedTransportationServices); " is 132.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (RestructuringAndMergernAcquisition != null) RestructuringAndMergernAcquisition.UpdateValues(previous.RestructuringAndMergernAcquisition); " is 141.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (ServiceChargeOnDepositorAccounts != null) ServiceChargeOnDepositorAccounts.UpdateValues(previous.ServiceChargeOnDepositorAccounts); " is 135.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (ShareInNetIncomeOfUnconsolidatedEntities != null) ShareInNetIncomeOfUnconsolidatedEntities.UpdateValues(previous.ShareInNetIncomeOfUnconsolidatedEntities); " is 159.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (NetIncomeFromContinuingAndDiscontinuedOperation != null) NetIncomeFromContinuingAndDiscontinuedOperation.UpdateValues(previous.NetIncomeFromContinuingAndDiscontinuedOperation); " is 180.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (NetIncomeFromOtherGainsLosses != null) NetIncomeFromOtherGainsLosses.UpdateValues(previous.NetIncomeFromOtherGainsLosses); " is 126.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (NetIncomeFromTaxLossCarryforward != null) NetIncomeFromTaxLossCarryforward.UpdateValues(previous.NetIncomeFromTaxLossCarryforward); " is 135.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (TotalMoneyMarketInvestments != null) TotalMoneyMarketInvestments.UpdateValues(previous.TotalMoneyMarketInvestments); " is 120.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (NetIncomeFromContinuingOperationNetMinorityInterest != null) NetIncomeFromContinuingOperationNetMinorityInterest.UpdateValues(previous.NetIncomeFromContinuingOperationNetMinorityInterest); " is 192.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (PrincipleInvestmentGainLoss != null) PrincipleInvestmentGainLoss.UpdateValues(previous.PrincipleInvestmentGainLoss); " is 120.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (GainonSaleofInvestmentProperty != null) GainonSaleofInvestmentProperty.UpdateValues(previous.GainonSaleofInvestmentProperty); " is 129.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (AcquiredinProcessRnDIncomeBanks != null) AcquiredinProcessRnDIncomeBanks.UpdateValues(previous.AcquiredinProcessRnDIncomeBanks); " is 132.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (RestructuringAndMergerAndAcquisitionIncome != null) RestructuringAndMergerAndAcquisitionIncome.UpdateValues(previous.RestructuringAndMergerAndAcquisitionIncome); " is 165.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (ImpairmentofCapitalAssetsIncome != null) ImpairmentofCapitalAssetsIncome.UpdateValues(previous.ImpairmentofCapitalAssetsIncome); " is 132.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (EarningsfromEquityInterestNetOfTax != null) EarningsfromEquityInterestNetOfTax.UpdateValues(previous.EarningsfromEquityInterestNetOfTax); " is 141.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (NetIncomeIncludingNoncontrollingInterests != null) NetIncomeIncludingNoncontrollingInterests.UpdateValues(previous.NetIncomeIncludingNoncontrollingInterests); " is 162.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (OtherunderPreferredStockDividend != null) OtherunderPreferredStockDividend.UpdateValues(previous.OtherunderPreferredStockDividend); " is 135.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (EarningsfromEquityInterestRevenue != null) EarningsfromEquityInterestRevenue.UpdateValues(previous.EarningsfromEquityInterestRevenue); " is 138.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (GainLossfromDisposalSaleofAssets != null) GainLossfromDisposalSaleofAssets.UpdateValues(previous.GainLossfromDisposalSaleofAssets); " is 135.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (GainLossfromDisposalSaleofAssetsOther != null) GainLossfromDisposalSaleofAssetsOther.UpdateValues(previous.GainLossfromDisposalSaleofAssetsOther); " is 150.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (GainonSaleofOtherRealEstateOwned != null) GainonSaleofOtherRealEstateOwned.UpdateValues(previous.GainonSaleofOtherRealEstateOwned); " is 135.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (OtherthanTemporaryImpairmentLossesInvestments != null) OtherthanTemporaryImpairmentLossesInvestments.UpdateValues(previous.OtherthanTemporaryImpairmentLossesInvestments); " is 174.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (ChangesinInventoriesofFinishedGoodsandWorkinProgress != null) ChangesinInventoriesofFinishedGoodsandWorkinProgress.UpdateValues(previous.ChangesinInventoriesofFinishedGoodsandWorkinProgress); " is 195.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (WorkPerformedbyEntityandCapitalized != null) WorkPerformedbyEntityandCapitalized.UpdateValues(previous.WorkPerformedbyEntityandCapitalized); " is 144.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (ShareofOperatingProfitLossfromJointVenturesAndAssociates != null) ShareofOperatingProfitLossfromJointVenturesAndAssociates.UpdateValues(previous.ShareofOperatingProfitLossfromJointVenturesAndAssociates); " is 207.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (IncomefromSharesinSubsidiariesGroupUndertakings != null) IncomefromSharesinSubsidiariesGroupUndertakings.UpdateValues(previous.IncomefromSharesinSubsidiariesGroupUndertakings); " is 180.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (IncomefromAssociatesandOtherParticipatingInterests != null) IncomefromAssociatesandOtherParticipatingInterests.UpdateValues(previous.IncomefromAssociatesandOtherParticipatingInterests); " is 189.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (GainonRedemptionandExtinguishmentofDebt != null) GainonRedemptionandExtinguishmentofDebt.UpdateValues(previous.GainonRedemptionandExtinguishmentofDebt); " is 156.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (MiscellaneousOtherOperatingIncome != null) MiscellaneousOtherOperatingIncome.UpdateValues(previous.MiscellaneousOtherOperatingIncome); " is 138.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (GainLossonFinancialInstrumentsDesignatedasCashFlowHedges != null) GainLossonFinancialInstrumentsDesignatedasCashFlowHedges.UpdateValues(previous.GainLossonFinancialInstrumentsDesignatedasCashFlowHedges); " is 207.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (GainLossonDerecognitionofAvailableForSaleFinancialAssets != null) GainLossonDerecognitionofAvailableForSaleFinancialAssets.UpdateValues(previous.GainLossonDerecognitionofAvailableForSaleFinancialAssets); " is 207.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (GainLossonDerecognitionofNonCurrentAssetsNotHeldforSaleTotal != null) GainLossonDerecognitionofNonCurrentAssetsNotHeldforSaleTotal.UpdateValues(previous.GainLossonDerecognitionofNonCurrentAssetsNotHeldforSaleTotal); " is 219.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (NegativeGoodwillImmediatelyRecognized != null) NegativeGoodwillImmediatelyRecognized.UpdateValues(previous.NegativeGoodwillImmediatelyRecognized); " is 150.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (GainsLossesonFinancialInstrumentsDuetoFairValueAdjustmentsinHedgeAccountingTotal != null) GainsLossesonFinancialInstrumentsDuetoFairValueAdjustmentsinHedgeAccountingTotal.UpdateValues(previous.GainsLossesonFinancialInstrumentsDuetoFairValueAdjustmentsinHedgeAccountingTotal); " is 279.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (ImpairmentLossesReversalsFinancialInstrumentsNet != null) ImpairmentLossesReversalsFinancialInstrumentsNet.UpdateValues(previous.ImpairmentLossesReversalsFinancialInstrumentsNet); " is 183.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (ShareofProfitLossfromEquityAccountedInvestments != null) ShareofProfitLossfromEquityAccountedInvestments.UpdateValues(previous.ShareofProfitLossfromEquityAccountedInvestments); " is 180.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (ReinsuranceRecoveriesClaimsandBenefits != null) ReinsuranceRecoveriesClaimsandBenefits.UpdateValues(previous.ReinsuranceRecoveriesClaimsandBenefits); " is 153.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (ChangeinInsuranceLiabilitiesNetofReinsurance != null) ChangeinInsuranceLiabilitiesNetofReinsurance.UpdateValues(previous.ChangeinInsuranceLiabilitiesNetofReinsurance); " is 171.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (OtherNonOperatingIncomeExpenses != null) OtherNonOperatingIncomeExpenses.UpdateValues(previous.OtherNonOperatingIncomeExpenses); " is 132.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (InterestIncomeOtherOperatingIncome != null) InterestIncomeOtherOperatingIncome.UpdateValues(previous.InterestIncomeOtherOperatingIncome); " is 141.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (TotalUnusualItemsExcludingGoodwill != null) TotalUnusualItemsExcludingGoodwill.UpdateValues(previous.TotalUnusualItemsExcludingGoodwill); " is 141.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (GainOnForeignCurrencyExchangeFromBorrowingsRelatingToInterestCosts != null) GainOnForeignCurrencyExchangeFromBorrowingsRelatingToInterestCosts.UpdateValues(previous.GainOnForeignCurrencyExchangeFromBorrowingsRelatingToInterestCosts); " is 237.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (DilutedNIAvailtoComStockholders != null) DilutedNIAvailtoComStockholders.UpdateValues(previous.DilutedNIAvailtoComStockholders); " is 132.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (InvestmentContractLiabilitiesIncurred != null) InvestmentContractLiabilitiesIncurred.UpdateValues(previous.InvestmentContractLiabilitiesIncurred); " is 150.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (ReinsuranceRecoveriesofInvestmentContract != null) ReinsuranceRecoveriesofInvestmentContract.UpdateValues(previous.ReinsuranceRecoveriesofInvestmentContract); " is 162.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (TotalDividendPaymentofEquityShares != null) TotalDividendPaymentofEquityShares.UpdateValues(previous.TotalDividendPaymentofEquityShares); " is 141.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (TotalDividendPaymentofNonEquityShares != null) TotalDividendPaymentofNonEquityShares.UpdateValues(previous.TotalDividendPaymentofNonEquityShares); " is 150.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (ChangeinTheGrossProvisionforUnearnedPremiums != null) ChangeinTheGrossProvisionforUnearnedPremiums.UpdateValues(previous.ChangeinTheGrossProvisionforUnearnedPremiums); " is 171.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (ChangeinTheGrossProvisionforUnearnedPremiumsReinsurersShare != null) ChangeinTheGrossProvisionforUnearnedPremiumsReinsurersShare.UpdateValues(previous.ChangeinTheGrossProvisionforUnearnedPremiumsReinsurersShare); " is 216.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (ClaimsandChangeinInsuranceLiabilities != null) ClaimsandChangeinInsuranceLiabilities.UpdateValues(previous.ClaimsandChangeinInsuranceLiabilities); " is 150.
Long Statement,QuantConnect.Data.Fundamental,IncomeStatement,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\IncomeStatement.cs,UpdateValues,The length of the statement  "			if (ReinsuranceRecoveriesofInsuranceLiabilities != null) ReinsuranceRecoveriesofInsuranceLiabilities.UpdateValues(previous.ReinsuranceRecoveriesofInsuranceLiabilities); " is 168.
Long Statement,QuantConnect.Data.Fundamental,OperationRatios,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\OperationRatios.cs,UpdateValues,The length of the statement  "			if (OperationRevenueGrowth3MonthAvg != null) OperationRevenueGrowth3MonthAvg.UpdateValues(previous.OperationRevenueGrowth3MonthAvg); " is 132.
Long Statement,QuantConnect.Data.Fundamental,OperationRatios,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\OperationRatios.cs,UpdateValues,The length of the statement  "			if (LongTermDebtTotalCapitalRatio != null) LongTermDebtTotalCapitalRatio.UpdateValues(previous.LongTermDebtTotalCapitalRatio); " is 126.
Long Statement,QuantConnect.Data.Fundamental,OperationRatios,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\OperationRatios.cs,UpdateValues,The length of the statement  "			if (CapitalExpenditureAnnual5YrGrowth != null) CapitalExpenditureAnnual5YrGrowth.UpdateValues(previous.CapitalExpenditureAnnual5YrGrowth); " is 138.
Long Statement,QuantConnect.Data.Fundamental,OperationRatios,C:\repos\QuantConnect_Lean\Common\Data\Fundamental\Generated\OperationRatios.cs,UpdateValues,The length of the statement  "			if (RegressionGrowthOperatingRevenue5Years != null) RegressionGrowthOperatingRevenue5Years.UpdateValues(previous.RegressionGrowthOperatingRevenue5Years); " is 153.
Long Statement,QuantConnect.Data,Slice,C:\repos\QuantConnect_Lean\Common\Data\Slice.cs,Get,The length of the statement  "                    dictionary = new Lazy<object>(() => new DataDictionary<T>(_data.Value.Values.SelectMany<dynamic' dynamic>(x => x.GetData()).OfType<T>()' x => x.Symbol)); " is 153.
Long Statement,QuantConnect.Data,Slice,C:\repos\QuantConnect_Lean\Common\Data\Slice.cs,Get,The length of the statement  "                    dictionary = new Lazy<object>(() => new DataDictionary<T>(_data.Value.Values.Select(x => x.GetData()).OfType<T>()' x => x.Symbol)); " is 131.
Long Statement,QuantConnect.Data,DynamicData,C:\repos\QuantConnect_Lean\Common\Data\DynamicData.cs,GetProperty,The length of the statement  "                throw new Exception("Property with name '" + name + "' does not exist. Properties: Time' Symbol' Value " + string.Join("' "' _storage.Keys)); " is 141.
Long Statement,QuantConnect.Data,BaseData,C:\repos\QuantConnect_Lean\Common\Data\BaseData.cs,Reader,The length of the statement  "            throw new InvalidOperationException("Please implement Reader(SubscriptionDataConfig' string' DateTime' bool) on your custom data type: " + GetType().Name); " is 155.
Long Statement,QuantConnect.Data,BaseData,C:\repos\QuantConnect_Lean\Common\Data\BaseData.cs,GetSource,The length of the statement  "            throw new InvalidOperationException("Please implement GetSource(SubscriptionDataConfig' DateTime' bool) on your custom data type: " + GetType().Name); " is 150.
Long Statement,QuantConnect.Data,SubscriptionManager,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionManager.cs,Add,The length of the statement  "            return Add(dataType' tickType' symbol' resolution' timeZone' exchangeTimeZone' isCustomData' fillDataForward' extendedMarketHours); " is 131.
Long Statement,QuantConnect.Data,SubscriptionManager,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionManager.cs,Add,The length of the statement  "                throw new ArgumentNullException("dataTimeZone"' "DataTimeZone is a required parameter for new subscriptions.  Set to the time zone the raw data is time stamped in."); " is 166.
Long Statement,QuantConnect.Data,SubscriptionManager,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionManager.cs,Add,The length of the statement  "                throw new ArgumentNullException("exchangeTimeZone"' "ExchangeTimeZone is a required parameter for new subscriptions.  Set to the time zone the security exchange resides in."); " is 175.
Long Statement,QuantConnect.Data,SubscriptionManager,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionManager.cs,Add,The length of the statement  "            var newConfig = new SubscriptionDataConfig(dataType' symbol' resolution' dataTimeZone' exchangeTimeZone' fillDataForward' extendedMarketHours' isInternalFeed' isCustomData' isFilteredSubscription: isFilteredSubscription' tickType: tickType); " is 241.
Long Statement,QuantConnect.Data,SubscriptionManager,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionManager.cs,Add,The length of the statement  "                        "The maximum number of concurrent market data subscriptions was exceeded ({0}). Please reduce the number of symbols requested or increase the limit using Settings.DataSubscriptionLimit."' " is 187.
Long Statement,QuantConnect.Data,SubscriptionManager,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionManager.cs,AddConsolidator,The length of the statement  "                throw new ArgumentException("Please subscribe to this symbol before adding a consolidator for it. Symbol: " + symbol.Value); " is 124.
Long Statement,QuantConnect.Data,SubscriptionManager,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionManager.cs,LookupSubscriptionConfigDataTypes,The length of the statement  "            return AvailableDataTypes[symbolSecurityType].Select(tickType => new Tuple<Type' TickType>(LeanData.GetDataType(resolution' tickType)' tickType)).ToList(); " is 155.
Long Statement,QuantConnect.Data.UniverseSelection,FuturesChainUniverse,C:\repos\QuantConnect_Lean\Common\Data\UniverseSelection\FuturesChainUniverse.cs,SelectSymbols,The length of the statement  "                throw new ArgumentException(string.Format("Expected data of type '{0}'"' typeof (FuturesChainUniverseDataCollection).Name)); " is 124.
Long Statement,QuantConnect.Data.UniverseSelection,FuturesChainUniverse,C:\repos\QuantConnect_Lean\Common\Data\UniverseSelection\FuturesChainUniverse.cs,SelectSymbols,The length of the statement  "            var results = (FutureFilterUniverse)_future.ContractFilter.Filter(new FutureFilterUniverse(availableContracts' underlying)); " is 124.
Long Statement,QuantConnect.Data.UniverseSelection,UniverseExtensions,C:\repos\QuantConnect_Lean\Common\Data\UniverseSelection\UniverseExtensions.cs,ChainedTo,The length of the statement  "                return first.GetSubscriptionRequests(security' currentTimeUtc' maximumEndTimeUtc).Select(request => new SubscriptionRequest( " is 124.
Long Statement,QuantConnect.Data.UniverseSelection,UniverseExtensions,C:\repos\QuantConnect_Lean\Common\Data\UniverseSelection\UniverseExtensions.cs,ChainedTo,The length of the statement  "                    configuration: configurationPerSymbol ? new SubscriptionDataConfig(prefilteredSecond.Configuration' symbol: security.Symbol) : prefilteredSecond.Configuration' " is 159.
Long Statement,QuantConnect.Data.UniverseSelection,CoarseFundamental,C:\repos\QuantConnect_Lean\Common\Data\UniverseSelection\CoarseFundamental.cs,GetSource,The length of the statement  "            var path = Path.Combine(Globals.DataFolder' "equity"' config.Market' "fundamental"' "coarse"' date.ToString("yyyyMMdd") + ".csv"); " is 130.
Long Statement,QuantConnect.Data.UniverseSelection,OptionChainUniverse,C:\repos\QuantConnect_Lean\Common\Data\UniverseSelection\OptionChainUniverse.cs,SelectSymbols,The length of the statement  "                throw new ArgumentException(string.Format("Expected data of type '{0}'"' typeof (OptionChainUniverseDataCollection).Name)); " is 123.
Long Statement,QuantConnect.Data.UniverseSelection,OptionChainUniverse,C:\repos\QuantConnect_Lean\Common\Data\UniverseSelection\OptionChainUniverse.cs,SelectSymbols,The length of the statement  "            var results = (OptionFilterUniverse)_option.ContractFilter.Filter(new OptionFilterUniverse(availableContracts' _underlying)); " is 125.
Long Statement,QuantConnect.Data.UniverseSelection,Universe,C:\repos\QuantConnect_Lean\Common\Data\UniverseSelection\Universe.cs,CreateSecurity,The length of the statement  "            return SecurityManager.CreateSecurity(algorithm.Portfolio' algorithm.SubscriptionManager' marketHoursDatabase' symbolPropertiesDatabase' " is 136.
Long Statement,QuantConnect.Data.Auxiliary,FactorFile,C:\repos\QuantConnect_Lean\Common\Data\Auxiliary\FactorFile.cs,Read,The length of the statement  "            return new FactorFile(permtick' FactorFileRow.Read(permtick' market' out factorFileMinimumDate)' factorFileMinimumDate); " is 120.
Long Statement,QuantConnect.Data.Auxiliary,LocalDiskMapFileProvider,C:\repos\QuantConnect_Lean\Common\Data\Auxiliary\LocalDiskMapFileProvider.cs,GetMapFileResolver,The length of the statement  "                    Log.Error("LocalDiskMapFileProvider.GetMapFileResolver({0}): The specified directory does not exist: {1}"' market' mapFileDirectory); " is 133.
Long Statement,QuantConnect.Indicators,IndicatorDataPoint,C:\repos\QuantConnect_Lean\Common\Indicators\IndicatorDataPoint.cs,Reader,The length of the statement  "            throw new NotImplementedException("IndicatorDataPoint does not support the Reader function. This function should never be called on this type."); " is 145.
Long Statement,QuantConnect.Indicators,IndicatorDataPoint,C:\repos\QuantConnect_Lean\Common\Indicators\IndicatorDataPoint.cs,GetSource,The length of the statement  "            throw new NotImplementedException("IndicatorDataPoint does not support the GetSource function. This function should never be called on this type."); " is 148.
Long Statement,QuantConnect.Orders.Slippage,VolumeShareSlippageModel,C:\repos\QuantConnect_Lean\Common\Orders\Slippage\VolumeShareSlippageModel.cs,GetSlippageApproximation,The length of the statement  "                    throw new Exception("VolumeShareSlippageModel.GetSlippageApproximation: Cannot use this model with market data type " + lastData.GetType()); " is 140.
Long Statement,QuantConnect.Parameters,ParameterAttribute,C:\repos\QuantConnect_Lean\Common\Parameters\ParameterAttribute.cs,ApplyAttributes,The length of the statement  "                    var message = string.Format("The specified property is read only: {0}.{1}"' propertyInfo.DeclaringType' propertyInfo.Name); " is 123.
Long Statement,QuantConnect.Scheduling,DateRules,C:\repos\QuantConnect_Lean\Common\Scheduling\DateRules.cs,Every,The length of the statement  "            return new FuncDateRule(string.Join("'"' days)' (start' end) => Time.EachDay(start' end).Where(date => hash.Contains(date.DayOfWeek))); " is 135.
Long Statement,QuantConnect.Scheduling,DateRules,C:\repos\QuantConnect_Lean\Common\Scheduling\DateRules.cs,MonthStart,The length of the statement  "            return new FuncDateRule(symbol.Value + ": MonthStart"' (start' end) => MonthStartIterator(GetSecurity(symbol)' start' end)); " is 124.
Long Statement,QuantConnect.Scheduling,DateRules,C:\repos\QuantConnect_Lean\Common\Scheduling\DateRules.cs,MonthEnd,The length of the statement  "            return new FuncDateRule(symbol.Value + ": MonthEnd"' (start' end) => MonthEndIterator(GetSecurity(symbol)' start' end)); " is 120.
Long Statement,QuantConnect.Scheduling,DateRules,C:\repos\QuantConnect_Lean\Common\Scheduling\DateRules.cs,WeekStart,The length of the statement  "            return new FuncDateRule(symbol.Value + ": WeekStart"' (start' end) => WeekStartIterator(GetSecurity(symbol)' start' end)); " is 122.
Long Statement,QuantConnect.Scheduling,ScheduledEvent,C:\repos\QuantConnect_Lean\Common\Scheduling\ScheduledEvent.cs,Scan,The length of the statement  "                        Log.Trace(string.Format("ScheduledEvent.{0}: Next event: {1} UTC"' Name' _orderedEventUtcTimes.Current.ToString(DateFormat.UI))); " is 129.
Long Statement,QuantConnect.Statistics,PortfolioStatistics,C:\repos\QuantConnect_Lean\Common\Statistics\PortfolioStatistics.cs,CompoundingAnnualPerformance,The length of the statement  "            return (years == 0 ? 0d : Math.Pow((double)finalCapital / (double)startingCapital' 1 / (double)years) - 1).SafeDecimalCast(); " is 125.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,Generate,The length of the statement  "            var totalPerformance = GetAlgorithmPerformance(firstDate' lastDate' trades' profitLoss' equity' pointsPerformance' pointsBenchmark' startingCapital); " is 149.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,Generate,The length of the statement  "            var rollingPerformances = GetRollingPerformances(firstDate' lastDate' trades' profitLoss' equity' pointsPerformance' pointsBenchmark' startingCapital); " is 151.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetAlgorithmPerformance,The length of the statement  "            var periodProfitLoss = new SortedDictionary<DateTime' decimal>(profitLoss.Where(x => x.Key >= fromDate && x.Key.Date < toDate.AddDays(1)).ToDictionary(x => x.Key' y => y.Value)); " is 178.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetAlgorithmPerformance,The length of the statement  "            var periodEquity = new SortedDictionary<DateTime' decimal>(equity.Where(x => x.Key.Date >= fromDate && x.Key.Date < toDate.AddDays(1)).ToDictionary(x => x.Key' y => y.Value)); " is 175.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetAlgorithmPerformance,The length of the statement  "            return new AlgorithmPerformance(periodTrades' periodProfitLoss' periodEquity' listPerformance' listBenchmark' runningCapital); " is 126.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetRollingPerformances,The length of the statement  "                    var periodPerformance = GetAlgorithmPerformance(period.StartDate' period.EndDate' trades' profitLoss' equity' pointsPerformance' pointsBenchmark' startingCapital); " is 163.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The length of the statement  "                { "Average Win"' Math.Round(totalPerformance.PortfolioStatistics.AverageWinRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%"  }' " is 150.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The length of the statement  "                { "Average Loss"' Math.Round(totalPerformance.PortfolioStatistics.AverageLossRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%" }' " is 151.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The length of the statement  "                { "Compounding Annual Return"' Math.Round(totalPerformance.PortfolioStatistics.CompoundingAnnualReturn.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }' " is 172.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The length of the statement  "                { "Drawdown"' Math.Round(totalPerformance.PortfolioStatistics.Drawdown.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }' " is 140.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The length of the statement  "                { "Expectancy"' Math.Round(totalPerformance.PortfolioStatistics.Expectancy' 3).ToString(CultureInfo.InvariantCulture) }' " is 120.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The length of the statement  "                { "Net Profit"' Math.Round(totalPerformance.PortfolioStatistics.TotalNetProfit.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%"}' " is 147.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The length of the statement  "                { "Sharpe Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.SharpeRatio' 3).ToString(CultureInfo.InvariantCulture) }' " is 131.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The length of the statement  "                { "Loss Rate"' Math.Round(totalPerformance.PortfolioStatistics.LossRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }' " is 138.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The length of the statement  "                { "Win Rate"' Math.Round(totalPerformance.PortfolioStatistics.WinRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'  " is 136.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The length of the statement  "                { "Profit-Loss Ratio"' Math.Round(totalPerformance.PortfolioStatistics.ProfitLossRatio' 2).ToString(CultureInfo.InvariantCulture) }' " is 132.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The length of the statement  "                { "Annual Standard Deviation"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualStandardDeviation' 3).ToString(CultureInfo.InvariantCulture) }' " is 156.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The length of the statement  "                { "Annual Variance"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualVariance' 3).ToString(CultureInfo.InvariantCulture) }' " is 137.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The length of the statement  "                { "Information Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.InformationRatio' 3).ToString(CultureInfo.InvariantCulture) }' " is 141.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The length of the statement  "                { "Tracking Error"' Math.Round((double)totalPerformance.PortfolioStatistics.TrackingError' 3).ToString(CultureInfo.InvariantCulture) }' " is 135.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The length of the statement  "                { "Treynor Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.TreynorRatio' 3).ToString(CultureInfo.InvariantCulture) }' " is 133.
Long Statement,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetPeriodRanges,The length of the statement  "            var ranges = new List<PeriodRange> { new PeriodRange { StartDate = firstDate' EndDate = endDates[endDates.Count - 1] } }; " is 121.
Long Statement,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The length of the statement  "                // TODO : if these lists are required to be the same length then we should create structure to pair the values' this way' by contract it will be enforced. " is 154.
Long Statement,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The length of the statement  "                    algoCompoundingPerformance = CompoundingAnnualPerformance(startingCash' equity.Values.LastOrDefault()' (decimal) fractionOfYears); " is 130.
Long Statement,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The length of the statement  "                    benchCompoundingPerformance = CompoundingAnnualPerformance(startingCash' finalBenchmarkCash' (decimal) fractionOfYears); " is 120.
Long Statement,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The length of the statement  "                    { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }' " is 148.
Long Statement,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The length of the statement  "                    { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }' " is 129.
Long Statement,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The length of the statement  "                    { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }' " is 128.
Long Statement,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The length of the statement  "                    { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }' " is 122.
Long Statement,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The length of the statement  "                    { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }' " is 134.
Long Statement,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Alpha,The length of the statement  "            return AnnualPerformance(algoPerformance) - (riskFreeRate + Beta(algoPerformance' benchmarkPerformance) * (AnnualPerformance(benchmarkPerformance) - riskFreeRate)); " is 164.
Long Statement,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,TrackingError,The length of the statement  "            return Math.Sqrt(AnnualVariance(algoPerformance) - 2 * Correlation.Pearson(algoPerformance' benchmarkPerformance) * AnnualStandardDeviation(algoPerformance) * AnnualStandardDeviation(benchmarkPerformance) + AnnualVariance(benchmarkPerformance)); " is 245.
Long Statement,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,InformationRatio,The length of the statement  "            return (AnnualPerformance(algoPerformance) - AnnualPerformance(benchmarkPerformance)) / (TrackingError(algoPerformance' benchmarkPerformance)); " is 143.
Long Statement,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFillToFill,The length of the statement  "                        trade.ProfitLoss = Math.Round((trade.ExitPrice - trade.EntryPrice) * trade.Quantity * (trade.Direction == TradeDirection.Long ? +1 : -1) * conversionRate * multiplier' 2); " is 171.
Long Statement,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFillToFill,The length of the statement  "                        trade.MAE = Math.Round((trade.Direction == TradeDirection.Long ? position.MinPrice - trade.EntryPrice : trade.EntryPrice - position.MaxPrice) * trade.Quantity * conversionRate * multiplier' 2); " is 193.
Long Statement,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFillToFill,The length of the statement  "                        trade.MFE = Math.Round((trade.Direction == TradeDirection.Long ? position.MaxPrice - trade.EntryPrice : trade.EntryPrice - position.MinPrice) * trade.Quantity * conversionRate * multiplier' 2); " is 193.
Long Statement,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFillToFill,The length of the statement  "                            ProfitLoss = Math.Round((fill.FillPrice - trade.EntryPrice) * fill.AbsoluteFillQuantity * (trade.Direction == TradeDirection.Long ? +1 : -1) * conversionRate * multiplier' 2)' " is 175.
Long Statement,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFillToFill,The length of the statement  "                            MAE = Math.Round((trade.Direction == TradeDirection.Long ? position.MinPrice - trade.EntryPrice : trade.EntryPrice - position.MaxPrice) * fill.AbsoluteFillQuantity * conversionRate * multiplier' 2)' " is 198.
Long Statement,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFillToFill,The length of the statement  "                            MFE = Math.Round((trade.Direction == TradeDirection.Long ? position.MaxPrice - trade.EntryPrice : trade.EntryPrice - position.MinPrice) * fill.AbsoluteFillQuantity * conversionRate * multiplier' 2) " is 197.
Long Statement,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFlatToFlat,The length of the statement  "                if (position.PendingFills.Sum(x => x.FillQuantity) + fill.FillQuantity == 0 || fill.AbsoluteFillQuantity > Math.Abs(position.PendingFills.Sum(x => x.FillQuantity))) " is 164.
Long Statement,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFlatToFlat,The length of the statement  "                            entryAveragePrice += (position.PendingFills[index].FillPrice - entryAveragePrice) * position.PendingFills[index].FillQuantity / totalEntryQuantity; " is 147.
Long Statement,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFlatToFlat,The length of the statement  "                            exitAveragePrice += (position.PendingFills[index].FillPrice - exitAveragePrice) * position.PendingFills[index].FillQuantity / totalExitQuantity; " is 144.
Long Statement,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFlatToFlat,The length of the statement  "                        ProfitLoss = Math.Round((exitAveragePrice - entryAveragePrice) * Math.Abs(totalEntryQuantity) * Math.Sign(totalEntryQuantity) * conversionRate * multiplier' 2)' " is 160.
Long Statement,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFlatToFlat,The length of the statement  "                        MAE = Math.Round((direction == TradeDirection.Long ? position.MinPrice - entryAveragePrice : entryAveragePrice - position.MaxPrice) * Math.Abs(totalEntryQuantity) * conversionRate * multiplier' 2)' " is 197.
Long Statement,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFlatToFlat,The length of the statement  "                        MFE = Math.Round((direction == TradeDirection.Long ? position.MaxPrice - entryAveragePrice : entryAveragePrice - position.MinPrice) * Math.Abs(totalEntryQuantity) * conversionRate * multiplier' 2) " is 196.
Long Statement,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFlatToReduced,The length of the statement  "                        entryPrice -= (position.PendingFills[index].FillPrice - entryPrice) * position.PendingFills[index].FillQuantity / totalExecutedQuantity; " is 136.
Long Statement,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFlatToReduced,The length of the statement  "                    ProfitLoss = Math.Round((fill.FillPrice - entryPrice) * Math.Abs(totalExecutedQuantity) * Math.Sign(-totalExecutedQuantity) * conversionRate * multiplier' 2)' " is 158.
Long Statement,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFlatToReduced,The length of the statement  "                    MAE = Math.Round((direction == TradeDirection.Long ? position.MinPrice - entryPrice : entryPrice - position.MaxPrice) * Math.Abs(totalExecutedQuantity) * conversionRate * multiplier' 2)' " is 186.
Long Statement,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFlatToReduced,The length of the statement  "                    MFE = Math.Round((direction == TradeDirection.Long ? position.MaxPrice - entryPrice : entryPrice - position.MinPrice) * Math.Abs(totalExecutedQuantity) * conversionRate * multiplier' 2) " is 185.
Long Statement,QuantConnect.Util,Composer,C:\repos\QuantConnect_Lean\Common\Util\Composer.cs,Reset,The length of the statement  "                if (!string.IsNullOrWhiteSpace(PluginDirectory) && Directory.Exists(PluginDirectory) && new DirectoryInfo(PluginDirectory).FullName != AppDomain.CurrentDomain.BaseDirectory) " is 173.
Long Statement,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,GenerateLine,The length of the statement  "                            return ToCsv(milliseconds' Scale(tick.LastPrice)' tick.Quantity' tick.Exchange' tick.SaleCondition' tick.Suspicious ? "1" : "0"); " is 129.
Long Statement,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,GenerateLine,The length of the statement  "            throw new NotImplementedException("LeanData.GenerateLine has not yet been implemented for security type: " + securityType + " at resolution: " + resolution); " is 157.
Long Statement,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,GenerateRelativeZipFilePath,The length of the statement  "            return Path.Combine(GenerateRelativeZipFileDirectory(symbol' resolution)' GenerateZipFileName(symbol' date' resolution' tickType)); " is 131.
Long Statement,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,GenerateZipEntryName,The length of the statement  "            if (securityType != SecurityType.Base && securityType != SecurityType.Equity && securityType != SecurityType.Forex && securityType != SecurityType.Cfd && securityType != SecurityType.Crypto) " is 190.
Long Statement,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,GenerateZipEntryName,The length of the statement  "            return string.Format("{0}_{1}_{2}_{3}.csv"' date.ToString(DateFormat.EightCharacter)' symbol' resolution.ToLower()' dataType.ToLower()); " is 136.
Long Statement,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,GenerateZipFileName,The length of the statement  "            tickType = tickType ?? (securityType == SecurityType.Forex || securityType == SecurityType.Cfd ? TickType.Quote : TickType.Trade); " is 130.
Long Statement,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,ReadSymbolFromZipEntry,The length of the statement  "                    throw new NotImplementedException("ReadSymbolFromZipEntry is not implemented for " + symbol.ID.SecurityType + " " + resolution); " is 128.
Long Statement,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,TryParsePath,The length of the statement  "                Log.Error("LeanData.TryParsePath(): Error encountered while parsing the path {0}. Error: {1}"' fileName' ex.GetBaseException()); " is 128.
Long Statement,QuantConnect.Util,LeanDataPathComponents,C:\repos\QuantConnect_Lean\Common\Util\LeanDataPathComponents.cs,Parse,The length of the statement  "            var resolution = (Resolution) Enum.Parse(typeof (Resolution)' parts[parts.Length - securityTypeOffset + ResolutionOffset]' true); " is 129.
Long Statement,QuantConnect.Util,LeanDataPathComponents,C:\repos\QuantConnect_Lean\Common\Util\LeanDataPathComponents.cs,Parse,The length of the statement  "            var date = securityTypeOffset == LowResSecurityTypeOffset ? DateTime.MinValue : DateTime.ParseExact(filename.Substring(0' filename.IndexOf("_"' StringComparison.Ordinal))' DateFormat.EightCharacter' null); " is 205.
Long Statement,QuantConnect.Util,LeanDataPathComponents,C:\repos\QuantConnect_Lean\Common\Util\LeanDataPathComponents.cs,Parse,The length of the statement  "                symbol = Symbol.CreateOption(ticker' market' style' OptionRight.Call | OptionRight.Put' 0' SecurityIdentifier.DefaultDate); " is 123.
Long Statement,QuantConnect.Util,LeanDataPathComponents,C:\repos\QuantConnect_Lean\Common\Util\LeanDataPathComponents.cs,Parse,The length of the statement  "            var tickType = filename.Contains("_quote") ? TickType.Quote : (filename.Contains("_openinterest") ? TickType.OpenInterest : TickType.Trade); " is 140.
Long Statement,QuantConnect.Util,MarketHoursDatabaseEntryJson,C:\repos\QuantConnect_Lean\Common\Util\MarketHoursDatabaseJsonConverter.cs,Convert,The length of the statement  "                var earlyCloses = EarlyCloses.ToDictionary(x => DateTime.ParseExact(x.Key' "M/d/yyyy"' CultureInfo.InvariantCulture)' x => x.Value); " is 132.
Long Statement,QuantConnect.Util,MarketHoursDatabaseEntryJson,C:\repos\QuantConnect_Lean\Common\Util\MarketHoursDatabaseJsonConverter.cs,Convert,The length of the statement  "                var exchangeHours = new SecurityExchangeHours(DateTimeZoneProviders.Tzdb[ExchangeTimeZone]' holidayDates' hours' earlyCloses); " is 126.
Long Statement,QuantConnect.Util,ColorJsonConverter,C:\repos\QuantConnect_Lean\Common\Util\ColorJsonConverter.cs,Convert,The length of the statement  "                var message = string.Format("Unable to convert '{0}' to a Color. Requires string length of 7 including the leading hashtag."' value); " is 133.
Long Statement,QuantConnect.Util,ObjectActivator,C:\repos\QuantConnect_Lean\Common\Util\ObjectActivator.cs,Clone,The length of the statement  "            var method = typeof (CloneFactory).GetMethods().FirstOrDefault(x => x.Name == "GetClone" && x.GetParameters().Length == 1); " is 123.
Complex Conditional,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,GenerateFutureTicker,The conditional expression  "underlying == Futures.Energies.CrudeOilWTI ||                  underlying == Futures.Energies.Gasoline ||                  underlying == Futures.Energies.HeatingOil ||                  underlying == Futures.Energies.NaturalGas"  is complex.
Complex Conditional,QuantConnect.Securities,OptionMarginModel,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionMarginModel.cs,GetMarginRequirement,The conditional expression  "value == 0m ||                  option.Close == 0m ||                  option.StrikePrice == 0m ||                  option.Underlying == null ||                  option.Underlying.Close == 0m"  is complex.
Complex Conditional,QuantConnect.Securities.Option,ConstantQLUnderlyingVolatilityEstimator,C:\repos\QuantConnect_Lean\Common\Securities\Option\ConstantQLUnderlyingVolatilityEstimator.cs,Estimate,The conditional expression  "option != null &&                  option.Underlying != null &&                  option.Underlying.VolatilityModel != null &&                  option.Underlying.VolatilityModel.Volatility > 0m"  is complex.
Complex Conditional,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,CallCalendarSpread,The conditional expression  "expiration1 == DateTime.MaxValue ||                  expiration1 == DateTime.MinValue ||                  expiration2 == DateTime.MaxValue ||                  expiration2 == DateTime.MinValue"  is complex.
Complex Conditional,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,PutCalendarSpread,The conditional expression  "expiration1 == DateTime.MaxValue ||                  expiration1 == DateTime.MinValue ||                  expiration2 == DateTime.MaxValue ||                  expiration2 == DateTime.MinValue"  is complex.
Complex Conditional,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The conditional expression  "csv[1].Length != 0 || csv[2].Length != 0 || csv[3].Length != 0 || csv[4].Length != 0"  is complex.
Complex Conditional,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The conditional expression  "csv[6].Length != 0 || csv[7].Length != 0 || csv[8].Length != 0 || csv[9].Length != 0"  is complex.
Complex Conditional,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,GenerateZipEntryName,The conditional expression  "securityType != SecurityType.Base && securityType != SecurityType.Equity && securityType != SecurityType.Forex && securityType != SecurityType.Cfd && securityType != SecurityType.Crypto"  is complex.
Virtual Method Call from Constructor,QuantConnect.Data.Consolidators,SequentialConsolidator,C:\repos\QuantConnect_Lean\Common\Data\Consolidators\SequentialConsolidator.cs,SequentialConsolidator,The constructor "SequentialConsolidator" calls a virtual method "OnDataConsolidated".
Virtual Method Call from Constructor,QuantConnect.Util,ReaderWriterLockSlimToken,C:\repos\QuantConnect_Lean\Common\Util\ReaderWriterLockSlimExtensions.cs,ReaderWriterLockSlimToken,The constructor "ReaderWriterLockSlimToken" calls a virtual method "EnterLock".
Empty Catch Block,QuantConnect.Data.Custom,DailyFx,C:\repos\QuantConnect_Lean\Common\Data\Custom\DailyFx.cs,Reader,The method has an empty catch block.
Magic Number,QuantConnect,SecurityIdentifier,C:\repos\QuantConnect_Lean\Common\SecurityIdentifier.cs,DecodeBase36,The following statement contains a magic number: for (int i = symbol.Length - 1; i > -1; i--)              {                  var c = symbol[i];                    // assumes alpha numeric upper case only strings                  var value = (uint)(c <= 57                      ? c - '0'                      : c - 'A' + 10);                    result += value * Pow(36' pos++);              }
Magic Number,QuantConnect,SecurityIdentifier,C:\repos\QuantConnect_Lean\Common\SecurityIdentifier.cs,DecodeBase36,The following statement contains a magic number: for (int i = symbol.Length - 1; i > -1; i--)              {                  var c = symbol[i];                    // assumes alpha numeric upper case only strings                  var value = (uint)(c <= 57                      ? c - '0'                      : c - 'A' + 10);                    result += value * Pow(36' pos++);              }
Magic Number,QuantConnect,SecurityIdentifier,C:\repos\QuantConnect_Lean\Common\SecurityIdentifier.cs,DecodeBase36,The following statement contains a magic number: for (int i = symbol.Length - 1; i > -1; i--)              {                  var c = symbol[i];                    // assumes alpha numeric upper case only strings                  var value = (uint)(c <= 57                      ? c - '0'                      : c - 'A' + 10);                    result += value * Pow(36' pos++);              }
Magic Number,QuantConnect,SecurityIdentifier,C:\repos\QuantConnect_Lean\Common\SecurityIdentifier.cs,EncodeBase36,The following statement contains a magic number: while (data != 0)              {                  var value = data % 36;                  var c = value < 10                      ? (char)(value + '0')                      : (char)(value - 10 + 'A');                    stack.Push(c);                  data /= 36;              }
Magic Number,QuantConnect,SecurityIdentifier,C:\repos\QuantConnect_Lean\Common\SecurityIdentifier.cs,EncodeBase36,The following statement contains a magic number: while (data != 0)              {                  var value = data % 36;                  var c = value < 10                      ? (char)(value + '0')                      : (char)(value - 10 + 'A');                    stack.Push(c);                  data /= 36;              }
Magic Number,QuantConnect,SecurityIdentifier,C:\repos\QuantConnect_Lean\Common\SecurityIdentifier.cs,EncodeBase36,The following statement contains a magic number: while (data != 0)              {                  var value = data % 36;                  var c = value < 10                      ? (char)(value + '0')                      : (char)(value - 10 + 'A');                    stack.Push(c);                  data /= 36;              }
Magic Number,QuantConnect,SecurityIdentifier,C:\repos\QuantConnect_Lean\Common\SecurityIdentifier.cs,EncodeBase36,The following statement contains a magic number: while (data != 0)              {                  var value = data % 36;                  var c = value < 10                      ? (char)(value + '0')                      : (char)(value - 10 + 'A');                    stack.Push(c);                  data /= 36;              }
Magic Number,QuantConnect,SecurityIdentifier,C:\repos\QuantConnect_Lean\Common\SecurityIdentifier.cs,NormalizeStrike,The following statement contains a magic number: while (strike % 10 == 0)              {                  strike /= 10;                  scale++;              }
Magic Number,QuantConnect,SecurityIdentifier,C:\repos\QuantConnect_Lean\Common\SecurityIdentifier.cs,NormalizeStrike,The following statement contains a magic number: while (strike % 10 == 0)              {                  strike /= 10;                  scale++;              }
Magic Number,QuantConnect,SecurityIdentifier,C:\repos\QuantConnect_Lean\Common\SecurityIdentifier.cs,NormalizeStrike,The following statement contains a magic number: if (strike >= 1000000)              {                  throw new ArgumentException("The specified strike price's precision is too high: " + str);              }
Magic Number,QuantConnect,SecurityIdentifier,C:\repos\QuantConnect_Lean\Common\SecurityIdentifier.cs,TryParseProperties,The following statement contains a magic number: try              {                  var sids = value.Split('|');                  for (var i = sids.Length - 1; i > -1; i--)                  {                      var current = sids[i];                      var parts = current.Split(new[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                      if (parts.Length != 2)                      {                          exception = new FormatException("The string must be splittable on space into two parts.");                          return false;                      }                        var symbol = parts[0];                      var otherData = parts[1];                      var props = DecodeBase36(otherData);                        // toss the previous in as the underlying' if Empty' ignored by ctor                      identifier = new SecurityIdentifier(symbol' props' identifier);                  }              }              catch (Exception error)              {                  exception = error;                  Log.Error("SecurityIdentifier.TryParseProperties(): Error parsing SecurityIdentifier: '{0}'' Exception: {1}"' value' exception);                  return false;              }
Magic Number,QuantConnect,SecurityIdentifier,C:\repos\QuantConnect_Lean\Common\SecurityIdentifier.cs,GetHashCode,The following statement contains a magic number: unchecked { return (_symbol.GetHashCode()*397) ^ _properties.GetHashCode(); }
Magic Number,QuantConnect,SeriesSampler,C:\repos\QuantConnect_Lean\Common\SeriesSampler.cs,Sample,The following statement contains a magic number: if (series.Values.Count < 2 || series.SeriesType == SeriesType.Scatter)              {                  // we can minimally verify we're within the start/stop interval                  foreach (var point in series.Values)                  {                      if (point.x >= nextSample && point.x <= unixStopDate)                      {                          sampled.Values.Add(point);                      }                  }                  return sampled;              }
Magic Number,QuantConnect,Series,C:\repos\QuantConnect_Lean\Common\Charting.cs,AddPoint,The following statement contains a magic number: if (Values.Count >= 4000 && !liveMode)              {                  // perform rate limiting in backtest mode                  return;              }
Magic Number,QuantConnect,Isolator,C:\repos\QuantConnect_Lean\Common\Isolator.cs,ExecuteWithTimeLimit,The following statement contains a magic number: memoryCap *= 1024 * 1024;
Magic Number,QuantConnect,Isolator,C:\repos\QuantConnect_Lean\Common\Isolator.cs,ExecuteWithTimeLimit,The following statement contains a magic number: memoryCap *= 1024 * 1024;
Magic Number,QuantConnect,Isolator,C:\repos\QuantConnect_Lean\Common\Isolator.cs,ExecuteWithTimeLimit,The following statement contains a magic number: var spikeLimit = memoryCap*2;
Magic Number,QuantConnect,Isolator,C:\repos\QuantConnect_Lean\Common\Isolator.cs,ExecuteWithTimeLimit,The following statement contains a magic number: while (!task.IsCompleted && DateTime.Now < end)              {                  // if over 80% allocation force GC then sample                  var sample = Convert.ToDouble(GC.GetTotalMemory(memoryUsed > memoryCap * 0.8));                    // find the EMA of the memory used to prevent spikes killing stategy                  memoryUsed = Convert.ToInt64((emaPeriod-1)/emaPeriod * memoryUsed + (1/emaPeriod)*sample);                    // if the rolling EMA > cap; or the spike is more than 2x the allocation.                  if (memoryUsed > memoryCap || sample > spikeLimit)                  {                      message = "Execution Security Error: Memory Usage Maxed Out - " + PrettyFormatRam(memoryCap) + "MB max' with last sample of " + PrettyFormatRam((long)sample) + "MB.";                      break;                  }                    if (DateTime.Now > memoryLogger)                  {                      if (memoryUsed > memoryCap * 0.8)                      {                          Log.Error("Execution Security Error: Memory usage over 80% capacity. Sampled at {0}"' sample);                      }                      Log.Trace("{0} Isolator.ExecuteWithTimeLimit(): Used: {1} Sample: {2}"' DateTime.Now.ToString("u")' PrettyFormatRam(memoryUsed)' PrettyFormatRam((long)sample));                      memoryLogger = DateTime.Now.AddMinutes(1);                  }                    // check to see if we're within other custom limits defined by the caller                  var possibleMessage = withinCustomLimits();                  if (!string.IsNullOrEmpty(possibleMessage))                  {                      message = possibleMessage;                      break;                  }                    Thread.Sleep(1000);              }
Magic Number,QuantConnect,Isolator,C:\repos\QuantConnect_Lean\Common\Isolator.cs,ExecuteWithTimeLimit,The following statement contains a magic number: while (!task.IsCompleted && DateTime.Now < end)              {                  // if over 80% allocation force GC then sample                  var sample = Convert.ToDouble(GC.GetTotalMemory(memoryUsed > memoryCap * 0.8));                    // find the EMA of the memory used to prevent spikes killing stategy                  memoryUsed = Convert.ToInt64((emaPeriod-1)/emaPeriod * memoryUsed + (1/emaPeriod)*sample);                    // if the rolling EMA > cap; or the spike is more than 2x the allocation.                  if (memoryUsed > memoryCap || sample > spikeLimit)                  {                      message = "Execution Security Error: Memory Usage Maxed Out - " + PrettyFormatRam(memoryCap) + "MB max' with last sample of " + PrettyFormatRam((long)sample) + "MB.";                      break;                  }                    if (DateTime.Now > memoryLogger)                  {                      if (memoryUsed > memoryCap * 0.8)                      {                          Log.Error("Execution Security Error: Memory usage over 80% capacity. Sampled at {0}"' sample);                      }                      Log.Trace("{0} Isolator.ExecuteWithTimeLimit(): Used: {1} Sample: {2}"' DateTime.Now.ToString("u")' PrettyFormatRam(memoryUsed)' PrettyFormatRam((long)sample));                      memoryLogger = DateTime.Now.AddMinutes(1);                  }                    // check to see if we're within other custom limits defined by the caller                  var possibleMessage = withinCustomLimits();                  if (!string.IsNullOrEmpty(possibleMessage))                  {                      message = possibleMessage;                      break;                  }                    Thread.Sleep(1000);              }
Magic Number,QuantConnect,Isolator,C:\repos\QuantConnect_Lean\Common\Isolator.cs,ExecuteWithTimeLimit,The following statement contains a magic number: while (!task.IsCompleted && DateTime.Now < end)              {                  // if over 80% allocation force GC then sample                  var sample = Convert.ToDouble(GC.GetTotalMemory(memoryUsed > memoryCap * 0.8));                    // find the EMA of the memory used to prevent spikes killing stategy                  memoryUsed = Convert.ToInt64((emaPeriod-1)/emaPeriod * memoryUsed + (1/emaPeriod)*sample);                    // if the rolling EMA > cap; or the spike is more than 2x the allocation.                  if (memoryUsed > memoryCap || sample > spikeLimit)                  {                      message = "Execution Security Error: Memory Usage Maxed Out - " + PrettyFormatRam(memoryCap) + "MB max' with last sample of " + PrettyFormatRam((long)sample) + "MB.";                      break;                  }                    if (DateTime.Now > memoryLogger)                  {                      if (memoryUsed > memoryCap * 0.8)                      {                          Log.Error("Execution Security Error: Memory usage over 80% capacity. Sampled at {0}"' sample);                      }                      Log.Trace("{0} Isolator.ExecuteWithTimeLimit(): Used: {1} Sample: {2}"' DateTime.Now.ToString("u")' PrettyFormatRam(memoryUsed)' PrettyFormatRam((long)sample));                      memoryLogger = DateTime.Now.AddMinutes(1);                  }                    // check to see if we're within other custom limits defined by the caller                  var possibleMessage = withinCustomLimits();                  if (!string.IsNullOrEmpty(possibleMessage))                  {                      message = possibleMessage;                      break;                  }                    Thread.Sleep(1000);              }
Magic Number,QuantConnect,Isolator,C:\repos\QuantConnect_Lean\Common\Isolator.cs,PrettyFormatRam,The following statement contains a magic number: return Math.Round(Convert.ToDouble(ramInBytes/(1024*1024)));
Magic Number,QuantConnect,Isolator,C:\repos\QuantConnect_Lean\Common\Isolator.cs,PrettyFormatRam,The following statement contains a magic number: return Math.Round(Convert.ToDouble(ramInBytes/(1024*1024)));
Magic Number,QuantConnect,Holding,C:\repos\QuantConnect_Lean\Common\Global.cs,Holding,The following statement contains a magic number: var rounding = 2;
Magic Number,QuantConnect,Holding,C:\repos\QuantConnect_Lean\Common\Global.cs,Holding,The following statement contains a magic number: if (holding.Type == SecurityType.Forex || holding.Type == SecurityType.Cfd)              {                  rounding = 5;              }              //do not round crypto              else if (holding.Type == SecurityType.Crypto)              {                  rounding = 28;              }
Magic Number,QuantConnect,Holding,C:\repos\QuantConnect_Lean\Common\Global.cs,Holding,The following statement contains a magic number: if (holding.Type == SecurityType.Forex || holding.Type == SecurityType.Cfd)              {                  rounding = 5;              }              //do not round crypto              else if (holding.Type == SecurityType.Crypto)              {                  rounding = 28;              }
Magic Number,QuantConnect,Holding,C:\repos\QuantConnect_Lean\Common\Global.cs,Holding,The following statement contains a magic number: UnrealizedPnL = Math.Round(holding.UnrealizedProfit' 2);
Magic Number,QuantConnect,Extensions,C:\repos\QuantConnect_Lean\Common\Extensions.cs,RoundToSignificantDigits,The following statement contains a magic number: var scale = Math.Pow(10' Math.Floor(Math.Log10(Math.Abs(d))) + 1);
Magic Number,QuantConnect,Extensions,C:\repos\QuantConnect_Lean\Common\Extensions.cs,RoundToSignificantDigits,The following statement contains a magic number: var scale = (decimal)Math.Pow(10' Math.Floor(Math.Log10((double) Math.Abs(d))) + 1);
Magic Number,QuantConnect,Extensions,C:\repos\QuantConnect_Lean\Common\Extensions.cs,SmartRounding,The following statement contains a magic number: if (input > 1000)              {                  return Math.Round(input' 4);              }
Magic Number,QuantConnect,Extensions,C:\repos\QuantConnect_Lean\Common\Extensions.cs,SmartRounding,The following statement contains a magic number: if (input > 1000)              {                  return Math.Round(input' 4);              }
Magic Number,QuantConnect,Extensions,C:\repos\QuantConnect_Lean\Common\Extensions.cs,SmartRounding,The following statement contains a magic number: return (decimal)d.RoundToSignificantDigits(7);
Magic Number,QuantConnect,Extensions,C:\repos\QuantConnect_Lean\Common\Extensions.cs,ToDecimal,The following statement contains a magic number: while (index < length)              {                  var ch = str[index++];                  if (ch == '.')                  {                      hasDecimals = true;                      decimalPlaces = 0;                  }                  else if (char.IsWhiteSpace(ch))                  {                      break;                  }                  else                  {                      value = value * 10 + (ch - '0');                      decimalPlaces++;                  }              }
Magic Number,QuantConnect,Extensions,C:\repos\QuantConnect_Lean\Common\Extensions.cs,ToDecimal,The following statement contains a magic number: var mid = (int)(value >> 32);
Magic Number,QuantConnect,Extensions,C:\repos\QuantConnect_Lean\Common\Extensions.cs,ToInt32,The following statement contains a magic number: for (var i = 0; i < str.Length; i++)              {                  value = value * 10 + (str[i] - '0');              }
Magic Number,QuantConnect,Extensions,C:\repos\QuantConnect_Lean\Common\Extensions.cs,ToInt64,The following statement contains a magic number: for (var i = 0; i < str.Length; i++)              {                  value = value * 10 + (str[i] - '0');              }
Magic Number,QuantConnect,Extensions,C:\repos\QuantConnect_Lean\Common\Extensions.cs,GetDecimalEpsilon,The following statement contains a magic number: return new decimal(1' 0' 0' false' 27);
Magic Number,QuantConnect,Extensions,C:\repos\QuantConnect_Lean\Common\Extensions.cs,GetExtension,The following statement contains a magic number: var ext = str.Substring(Math.Max(0' str.Length - 4));
Magic Number,QuantConnect,RealTimeSynchronizedTimer,C:\repos\QuantConnect_Lean\Common\RealTimeSynchronizedTimer.cs,Scanner,The following statement contains a magic number: while (!_stopped)              {                  if (_callback != null && DateTime.UtcNow >= _triggerTime)                  {                      _timer.Restart();                      var triggeredAt = _triggerTime;                      _triggerTime = DateTime.UtcNow.RoundDown(_period).Add(_period);                      _callback(triggeredAt);                  }                    while (_paused && !_stopped) Thread.Sleep(10);                  Thread.Sleep(1);              }
Magic Number,QuantConnect,Symbol,C:\repos\QuantConnect_Lean\Common\Symbol.cs,CreateOption,The following statement contains a magic number: if (expiry == SecurityIdentifier.DefaultDate)              {                  alias = alias ?? "?" + underlyingSymbol.Value.ToUpper();              }              else              {                  var sym = underlyingSymbol.Value;                  if (sym.Length > 5) sym += " ";                    alias = alias ?? SymbolRepresentation.GenerateOptionTickerOSI(sym' sid.OptionRight' sid.StrikePrice' sid.Date);              }
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseFutureTicker,The following statement contains a magic number: if (char.IsDigit(ticker.Substring(ticker.Length - 2' 1)[0]))              {                  // XYZH16 format                  var expirationYearString = ticker.Substring(ticker.Length - 2' 2);                  var expirationMonthString = ticker.Substring(ticker.Length - 3' 1);                  var underlyingString = ticker.Substring(0' ticker.Length - 3);                    int expirationYearShort;                    if (!int.TryParse(expirationYearString' out expirationYearShort))                  {                      return null;                  }                    if (!_futuresMonthCodeLookup.ContainsKey(expirationMonthString))                  {                      return null;                  }                    var expirationMonth = _futuresMonthCodeLookup[expirationMonthString];                    return new FutureTickerProperties                  {                      Underlying = underlyingString'                      ExpirationYearShort = expirationYearShort'                      ExpirationMonth = expirationMonth                  };              }              else              {                  // XYZH6 format                  var expirationYearString = ticker.Substring(ticker.Length - 1' 1);                  var expirationMonthString = ticker.Substring(ticker.Length - 2' 1);                  var underlyingString = ticker.Substring(0' ticker.Length - 2);                    int expirationYearShort;                    if (!int.TryParse(expirationYearString' out expirationYearShort))                  {                      return null;                  }                    if (!_futuresMonthCodeLookup.ContainsKey(expirationMonthString))                  {                      return null;                  }                    var expirationMonth = _futuresMonthCodeLookup[expirationMonthString];                    return new FutureTickerProperties                  {                      Underlying = underlyingString'                      ExpirationYearShort = expirationYearShort'                      ExpirationMonth = expirationMonth                  };              }
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseFutureTicker,The following statement contains a magic number: if (char.IsDigit(ticker.Substring(ticker.Length - 2' 1)[0]))              {                  // XYZH16 format                  var expirationYearString = ticker.Substring(ticker.Length - 2' 2);                  var expirationMonthString = ticker.Substring(ticker.Length - 3' 1);                  var underlyingString = ticker.Substring(0' ticker.Length - 3);                    int expirationYearShort;                    if (!int.TryParse(expirationYearString' out expirationYearShort))                  {                      return null;                  }                    if (!_futuresMonthCodeLookup.ContainsKey(expirationMonthString))                  {                      return null;                  }                    var expirationMonth = _futuresMonthCodeLookup[expirationMonthString];                    return new FutureTickerProperties                  {                      Underlying = underlyingString'                      ExpirationYearShort = expirationYearShort'                      ExpirationMonth = expirationMonth                  };              }              else              {                  // XYZH6 format                  var expirationYearString = ticker.Substring(ticker.Length - 1' 1);                  var expirationMonthString = ticker.Substring(ticker.Length - 2' 1);                  var underlyingString = ticker.Substring(0' ticker.Length - 2);                    int expirationYearShort;                    if (!int.TryParse(expirationYearString' out expirationYearShort))                  {                      return null;                  }                    if (!_futuresMonthCodeLookup.ContainsKey(expirationMonthString))                  {                      return null;                  }                    var expirationMonth = _futuresMonthCodeLookup[expirationMonthString];                    return new FutureTickerProperties                  {                      Underlying = underlyingString'                      ExpirationYearShort = expirationYearShort'                      ExpirationMonth = expirationMonth                  };              }
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseFutureTicker,The following statement contains a magic number: if (char.IsDigit(ticker.Substring(ticker.Length - 2' 1)[0]))              {                  // XYZH16 format                  var expirationYearString = ticker.Substring(ticker.Length - 2' 2);                  var expirationMonthString = ticker.Substring(ticker.Length - 3' 1);                  var underlyingString = ticker.Substring(0' ticker.Length - 3);                    int expirationYearShort;                    if (!int.TryParse(expirationYearString' out expirationYearShort))                  {                      return null;                  }                    if (!_futuresMonthCodeLookup.ContainsKey(expirationMonthString))                  {                      return null;                  }                    var expirationMonth = _futuresMonthCodeLookup[expirationMonthString];                    return new FutureTickerProperties                  {                      Underlying = underlyingString'                      ExpirationYearShort = expirationYearShort'                      ExpirationMonth = expirationMonth                  };              }              else              {                  // XYZH6 format                  var expirationYearString = ticker.Substring(ticker.Length - 1' 1);                  var expirationMonthString = ticker.Substring(ticker.Length - 2' 1);                  var underlyingString = ticker.Substring(0' ticker.Length - 2);                    int expirationYearShort;                    if (!int.TryParse(expirationYearString' out expirationYearShort))                  {                      return null;                  }                    if (!_futuresMonthCodeLookup.ContainsKey(expirationMonthString))                  {                      return null;                  }                    var expirationMonth = _futuresMonthCodeLookup[expirationMonthString];                    return new FutureTickerProperties                  {                      Underlying = underlyingString'                      ExpirationYearShort = expirationYearShort'                      ExpirationMonth = expirationMonth                  };              }
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseFutureTicker,The following statement contains a magic number: if (char.IsDigit(ticker.Substring(ticker.Length - 2' 1)[0]))              {                  // XYZH16 format                  var expirationYearString = ticker.Substring(ticker.Length - 2' 2);                  var expirationMonthString = ticker.Substring(ticker.Length - 3' 1);                  var underlyingString = ticker.Substring(0' ticker.Length - 3);                    int expirationYearShort;                    if (!int.TryParse(expirationYearString' out expirationYearShort))                  {                      return null;                  }                    if (!_futuresMonthCodeLookup.ContainsKey(expirationMonthString))                  {                      return null;                  }                    var expirationMonth = _futuresMonthCodeLookup[expirationMonthString];                    return new FutureTickerProperties                  {                      Underlying = underlyingString'                      ExpirationYearShort = expirationYearShort'                      ExpirationMonth = expirationMonth                  };              }              else              {                  // XYZH6 format                  var expirationYearString = ticker.Substring(ticker.Length - 1' 1);                  var expirationMonthString = ticker.Substring(ticker.Length - 2' 1);                  var underlyingString = ticker.Substring(0' ticker.Length - 2);                    int expirationYearShort;                    if (!int.TryParse(expirationYearString' out expirationYearShort))                  {                      return null;                  }                    if (!_futuresMonthCodeLookup.ContainsKey(expirationMonthString))                  {                      return null;                  }                    var expirationMonth = _futuresMonthCodeLookup[expirationMonthString];                    return new FutureTickerProperties                  {                      Underlying = underlyingString'                      ExpirationYearShort = expirationYearShort'                      ExpirationMonth = expirationMonth                  };              }
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseFutureTicker,The following statement contains a magic number: if (char.IsDigit(ticker.Substring(ticker.Length - 2' 1)[0]))              {                  // XYZH16 format                  var expirationYearString = ticker.Substring(ticker.Length - 2' 2);                  var expirationMonthString = ticker.Substring(ticker.Length - 3' 1);                  var underlyingString = ticker.Substring(0' ticker.Length - 3);                    int expirationYearShort;                    if (!int.TryParse(expirationYearString' out expirationYearShort))                  {                      return null;                  }                    if (!_futuresMonthCodeLookup.ContainsKey(expirationMonthString))                  {                      return null;                  }                    var expirationMonth = _futuresMonthCodeLookup[expirationMonthString];                    return new FutureTickerProperties                  {                      Underlying = underlyingString'                      ExpirationYearShort = expirationYearShort'                      ExpirationMonth = expirationMonth                  };              }              else              {                  // XYZH6 format                  var expirationYearString = ticker.Substring(ticker.Length - 1' 1);                  var expirationMonthString = ticker.Substring(ticker.Length - 2' 1);                  var underlyingString = ticker.Substring(0' ticker.Length - 2);                    int expirationYearShort;                    if (!int.TryParse(expirationYearString' out expirationYearShort))                  {                      return null;                  }                    if (!_futuresMonthCodeLookup.ContainsKey(expirationMonthString))                  {                      return null;                  }                    var expirationMonth = _futuresMonthCodeLookup[expirationMonthString];                    return new FutureTickerProperties                  {                      Underlying = underlyingString'                      ExpirationYearShort = expirationYearShort'                      ExpirationMonth = expirationMonth                  };              }
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseFutureTicker,The following statement contains a magic number: if (char.IsDigit(ticker.Substring(ticker.Length - 2' 1)[0]))              {                  // XYZH16 format                  var expirationYearString = ticker.Substring(ticker.Length - 2' 2);                  var expirationMonthString = ticker.Substring(ticker.Length - 3' 1);                  var underlyingString = ticker.Substring(0' ticker.Length - 3);                    int expirationYearShort;                    if (!int.TryParse(expirationYearString' out expirationYearShort))                  {                      return null;                  }                    if (!_futuresMonthCodeLookup.ContainsKey(expirationMonthString))                  {                      return null;                  }                    var expirationMonth = _futuresMonthCodeLookup[expirationMonthString];                    return new FutureTickerProperties                  {                      Underlying = underlyingString'                      ExpirationYearShort = expirationYearShort'                      ExpirationMonth = expirationMonth                  };              }              else              {                  // XYZH6 format                  var expirationYearString = ticker.Substring(ticker.Length - 1' 1);                  var expirationMonthString = ticker.Substring(ticker.Length - 2' 1);                  var underlyingString = ticker.Substring(0' ticker.Length - 2);                    int expirationYearShort;                    if (!int.TryParse(expirationYearString' out expirationYearShort))                  {                      return null;                  }                    if (!_futuresMonthCodeLookup.ContainsKey(expirationMonthString))                  {                      return null;                  }                    var expirationMonth = _futuresMonthCodeLookup[expirationMonthString];                    return new FutureTickerProperties                  {                      Underlying = underlyingString'                      ExpirationYearShort = expirationYearShort'                      ExpirationMonth = expirationMonth                  };              }
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseFutureTicker,The following statement contains a magic number: if (char.IsDigit(ticker.Substring(ticker.Length - 2' 1)[0]))              {                  // XYZH16 format                  var expirationYearString = ticker.Substring(ticker.Length - 2' 2);                  var expirationMonthString = ticker.Substring(ticker.Length - 3' 1);                  var underlyingString = ticker.Substring(0' ticker.Length - 3);                    int expirationYearShort;                    if (!int.TryParse(expirationYearString' out expirationYearShort))                  {                      return null;                  }                    if (!_futuresMonthCodeLookup.ContainsKey(expirationMonthString))                  {                      return null;                  }                    var expirationMonth = _futuresMonthCodeLookup[expirationMonthString];                    return new FutureTickerProperties                  {                      Underlying = underlyingString'                      ExpirationYearShort = expirationYearShort'                      ExpirationMonth = expirationMonth                  };              }              else              {                  // XYZH6 format                  var expirationYearString = ticker.Substring(ticker.Length - 1' 1);                  var expirationMonthString = ticker.Substring(ticker.Length - 2' 1);                  var underlyingString = ticker.Substring(0' ticker.Length - 2);                    int expirationYearShort;                    if (!int.TryParse(expirationYearString' out expirationYearShort))                  {                      return null;                  }                    if (!_futuresMonthCodeLookup.ContainsKey(expirationMonthString))                  {                      return null;                  }                    var expirationMonth = _futuresMonthCodeLookup[expirationMonthString];                    return new FutureTickerProperties                  {                      Underlying = underlyingString'                      ExpirationYearShort = expirationYearShort'                      ExpirationMonth = expirationMonth                  };              }
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,GenerateFutureTicker,The following statement contains a magic number: var year = doubleDigitsYear ? expiration.Year % 100 : expiration.Year % 10;
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,GenerateFutureTicker,The following statement contains a magic number: var year = doubleDigitsYear ? expiration.Year % 100 : expiration.Year % 10;
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,GenerateFutureTicker,The following statement contains a magic number: if (underlying == Futures.Energies.CrudeOilWTI ||                  underlying == Futures.Energies.Gasoline ||                  underlying == Futures.Energies.HeatingOil ||                  underlying == Futures.Energies.NaturalGas)              {                  if (month < 12)                  {                      month++;                  }                  else                  {                      month = 1;                      year++;                  }              }
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,GenerateOptionTickerOSI,The following statement contains a magic number: if (underlying.Length > 5) underlying += " ";
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var symbology = new Dictionary<string' Tuple<int' OptionRight>>                          {                              { "A"' Tuple.Create(1' OptionRight.Call) }' { "M"' Tuple.Create(1' OptionRight.Put) }'                              { "B"' Tuple.Create(2' OptionRight.Call) }' { "N"' Tuple.Create(2' OptionRight.Put) }'                              { "C"' Tuple.Create(3' OptionRight.Call) }' { "O"' Tuple.Create(3' OptionRight.Put) }'                              { "D"' Tuple.Create(4' OptionRight.Call) }' { "P"' Tuple.Create(4' OptionRight.Put) }'                              { "E"' Tuple.Create(5' OptionRight.Call) }' { "Q"' Tuple.Create(5' OptionRight.Put) }'                              { "F"' Tuple.Create(6' OptionRight.Call) }' { "R"' Tuple.Create(6' OptionRight.Put) }'                              { "G"' Tuple.Create(7' OptionRight.Call) }' { "S"' Tuple.Create(7' OptionRight.Put) }'                              { "H"' Tuple.Create(8' OptionRight.Call) }' { "T"' Tuple.Create(8' OptionRight.Put) }'                              { "I"' Tuple.Create(9' OptionRight.Call) }' { "U"' Tuple.Create(9' OptionRight.Put) }'                              { "J"' Tuple.Create(10' OptionRight.Call) }' { "V"' Tuple.Create(10' OptionRight.Put) }'                              { "K"' Tuple.Create(11' OptionRight.Call) }' { "W"' Tuple.Create(11' OptionRight.Put) }'                              { "L"' Tuple.Create(12' OptionRight.Call) }' { "X"' Tuple.Create(12' OptionRight.Put) }'                            };
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var dayString = ticker.Substring(optionTypeDelimiter - 2' 2);
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var dayString = ticker.Substring(optionTypeDelimiter - 2' 2);
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var yearString = ticker.Substring(optionTypeDelimiter - 4' 2);
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var yearString = ticker.Substring(optionTypeDelimiter - 4' 2);
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var underlying = ticker.Substring(0' optionTypeDelimiter - 4);
Magic Number,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseOptionTickerIQFeed,The following statement contains a magic number: var expirationDate = new DateTime(2000 + year' month' day);
Magic Number,QuantConnect,Time,C:\repos\QuantConnect_Lean\Common\Time.cs,DateTimeToUnixTimeStamp,The following statement contains a magic number: try              {                  timestamp = (time - new DateTime(1970' 1' 1' 0' 0' 0' 0)).TotalSeconds;              }              catch (Exception err)              {                  Log.Error(err' time.ToString("o"));              }
Magic Number,QuantConnect,Time,C:\repos\QuantConnect_Lean\Common\Time.cs,ParseDate,The following statement contains a magic number: try              {                  //First try the exact options:                  DateTime date;                  if (DateTime.TryParseExact(dateToParse' DateFormat.SixCharacter' CultureInfo.InvariantCulture' DateTimeStyles.None' out date))                  {                      return date;                  }                  if (DateTime.TryParseExact(dateToParse' DateFormat.EightCharacter' CultureInfo.InvariantCulture' DateTimeStyles.None' out date))                  {                      return date;                  }                  if (DateTime.TryParseExact(dateToParse.Substring(0' 19)' DateFormat.JsonFormat' CultureInfo.InvariantCulture' DateTimeStyles.None' out date))                  {                      return date;                  }                  if (DateTime.TryParseExact(dateToParse' DateFormat.US' CultureInfo.InvariantCulture' DateTimeStyles.None' out date))                  {                      return date;                  }                  if (DateTime.TryParse(dateToParse' out date))                  {                      return date;                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect,TimeZoneOffsetProvider,C:\repos\QuantConnect_Lean\Common\TimeZoneOffsetProvider.cs,TimeZoneOffsetProvider,The following statement contains a magic number: utcEndTime += TimeSpan.FromDays(2*365);
Magic Number,QuantConnect,TimeZoneOffsetProvider,C:\repos\QuantConnect_Lean\Common\TimeZoneOffsetProvider.cs,TimeZoneOffsetProvider,The following statement contains a magic number: utcEndTime += TimeSpan.FromDays(2*365);
Magic Number,QuantConnect.API,InteractiveBrokersLiveAlgorithmSettings,C:\repos\QuantConnect_Lean\Common\API\LiveAlgorithmSettings.cs,InteractiveBrokersLiveAlgorithmSettings,The following statement contains a magic number: Environment = Account.Substring(0' 2) == "DU" ? BrokerageEnvironment.Paper : BrokerageEnvironment.Live;
Magic Number,QuantConnect.Brokerages,FxcmBrokerageModel,C:\repos\QuantConnect_Lean\Common\Brokerages\FxcmBrokerageModel.cs,CanSubmitOrder,The following statement contains a magic number: if (order.Quantity % 1000 != 0)              {                  message = new BrokerageMessageEvent(BrokerageMessageType.Warning' "NotSupported"'                      "The order quantity must be a multiple of 1000."                      );                    return false;              }
Magic Number,QuantConnect.Brokerages,FxcmBrokerageModel,C:\repos\QuantConnect_Lean\Common\Brokerages\FxcmBrokerageModel.cs,CanUpdateOrder,The following statement contains a magic number: if (request.Quantity != null && request.Quantity % 1000 != 0)              {                  message = new BrokerageMessageEvent(BrokerageMessageType.Warning' "NotSupported"'                      "The order quantity must be a multiple of 1000."                      );                    return false;              }
Magic Number,QuantConnect.Brokerages,OandaBrokerageModel,C:\repos\QuantConnect_Lean\Common\Brokerages\OandaBrokerageModel.cs,CanExecuteOrder,The following statement contains a magic number: return order.DurationValue == DateTime.MaxValue || order.DurationValue <= order.Time.AddMonths(3);
Magic Number,QuantConnect.Python,PandasData,C:\repos\QuantConnect_Lean\Common\Python\PandasData.cs,PandasData,The following statement contains a magic number: Levels = 2;
Magic Number,QuantConnect.Python,PandasData,C:\repos\QuantConnect_Lean\Common\Python\PandasData.cs,PandasData,The following statement contains a magic number: if (_symbol.SecurityType == SecurityType.Future) Levels = 3;
Magic Number,QuantConnect.Python,PandasData,C:\repos\QuantConnect_Lean\Common\Python\PandasData.cs,PandasData,The following statement contains a magic number: if (_symbol.SecurityType == SecurityType.Option) Levels = 5;
Magic Number,QuantConnect.Python,PandasData,C:\repos\QuantConnect_Lean\Common\Python\PandasData.cs,PandasData,The following statement contains a magic number: Levels = 2;
Magic Number,QuantConnect.Python,PandasData,C:\repos\QuantConnect_Lean\Common\Python\PandasData.cs,PandasData,The following statement contains a magic number: if (_symbol.SecurityType == SecurityType.Future) Levels = 3;
Magic Number,QuantConnect.Python,PandasData,C:\repos\QuantConnect_Lean\Common\Python\PandasData.cs,PandasData,The following statement contains a magic number: if (_symbol.SecurityType == SecurityType.Option) Levels = 5;
Magic Number,QuantConnect.Python,PandasData,C:\repos\QuantConnect_Lean\Common\Python\PandasData.cs,GetPandasSeries,The following statement contains a magic number: pyObjectArray[levels - 2] = _symbol.ToString().ToPython();
Magic Number,QuantConnect.Python,PandasData,C:\repos\QuantConnect_Lean\Common\Python\PandasData.cs,GetPandasSeries,The following statement contains a magic number: if (_symbol.SecurityType == SecurityType.Option)              {                  pyObjectArray[0] = _symbol.ID.Date.ToPython();                  pyObjectArray[1] = _symbol.ID.StrikePrice.ToPython();                  pyObjectArray[2] = _symbol.ID.OptionRight.ToString().ToPython();                  pyObjectArray[3] = _symbol.Value.ToPython();              }
Magic Number,QuantConnect.Python,PandasData,C:\repos\QuantConnect_Lean\Common\Python\PandasData.cs,GetPandasSeries,The following statement contains a magic number: if (_symbol.SecurityType == SecurityType.Option)              {                  pyObjectArray[0] = _symbol.ID.Date.ToPython();                  pyObjectArray[1] = _symbol.ID.StrikePrice.ToPython();                  pyObjectArray[2] = _symbol.ID.OptionRight.ToString().ToPython();                  pyObjectArray[3] = _symbol.Value.ToPython();              }
Magic Number,QuantConnect.Python,PandasData,C:\repos\QuantConnect_Lean\Common\Python\PandasData.cs,GetPandasSeries,The following statement contains a magic number: if (levels == 3) names = "expiry'symbol'time";
Magic Number,QuantConnect.Python,PandasData,C:\repos\QuantConnect_Lean\Common\Python\PandasData.cs,GetPandasSeries,The following statement contains a magic number: if (levels == 5) names = "expiry'strike'type'symbol'time";
Magic Number,QuantConnect.Securities,Cash,C:\repos\QuantConnect_Lean\Common\Securities\Cash.cs,Cash,The following statement contains a magic number: if (symbol == null || symbol.Length != 3)              {                  throw new ArgumentException("Cash symbols must be exactly 3 characters.");              }
Magic Number,QuantConnect.Securities,Cash,C:\repos\QuantConnect_Lean\Common\Securities\Cash.cs,ToString,The following statement contains a magic number: rate = rate < 1000 ? rate.RoundToSignificantDigits(5) : Math.Round(rate' 2);
Magic Number,QuantConnect.Securities,Cash,C:\repos\QuantConnect_Lean\Common\Securities\Cash.cs,ToString,The following statement contains a magic number: rate = rate < 1000 ? rate.RoundToSignificantDigits(5) : Math.Round(rate' 2);
Magic Number,QuantConnect.Securities,Cash,C:\repos\QuantConnect_Lean\Common\Securities\Cash.cs,ToString,The following statement contains a magic number: rate = rate < 1000 ? rate.RoundToSignificantDigits(5) : Math.Round(rate' 2);
Magic Number,QuantConnect.Securities,Cash,C:\repos\QuantConnect_Lean\Common\Securities\Cash.cs,ToString,The following statement contains a magic number: return $"{Symbol}: {Currencies.GetCurrencySymbol(Symbol)}{Amount'15:0.00} @ {rate'10:0.00####} = ${Math.Round(ValueInAccountCurrency' 2)}";
Magic Number,QuantConnect.Securities,Cash,C:\repos\QuantConnect_Lean\Common\Securities\Cash.cs,ToString,The following statement contains a magic number: return $"{Symbol}: {Currencies.GetCurrencySymbol(Symbol)}{Amount'15:0.00} @ {rate'10:0.00####} = ${Math.Round(ValueInAccountCurrency' 2)}";
Magic Number,QuantConnect.Securities,Cash,C:\repos\QuantConnect_Lean\Common\Securities\Cash.cs,ToString,The following statement contains a magic number: return $"{Symbol}: {Currencies.GetCurrencySymbol(Symbol)}{Amount'15:0.00} @ {rate'10:0.00####} = ${Math.Round(ValueInAccountCurrency' 2)}";
Magic Number,QuantConnect.Securities,CashBook,C:\repos\QuantConnect_Lean\Common\Securities\CashBook.cs,ToString,The following statement contains a magic number: sb.AppendLine(string.Format("CashBook Total Value:                {0}{1}"'                   Currencies.GetCurrencySymbol(AccountCurrency)'                   Math.Round(TotalValueInAccountCurrency' 2))                  );
Magic Number,QuantConnect.Securities,FutureMarginModel,C:\repos\QuantConnect_Lean\Common\Securities\Future\FutureMarginModel.cs,FromCsvLine,The following statement contains a magic number: if (!decimal.TryParse(line[2]' out maintenance))              {                  Log.Trace("Couldn't parse Maintenance margin requirements while reading future margin requirement file. Date {0}. Line: {1}"' line[2]' csvLine);              }
Magic Number,QuantConnect.Securities,FutureMarginModel,C:\repos\QuantConnect_Lean\Common\Securities\Future\FutureMarginModel.cs,FromCsvLine,The following statement contains a magic number: if (!decimal.TryParse(line[2]' out maintenance))              {                  Log.Trace("Couldn't parse Maintenance margin requirements while reading future margin requirement file. Date {0}. Line: {1}"' line[2]' csvLine);              }
Magic Number,QuantConnect.Securities,StandardDeviationOfReturnsVolatilityModel,C:\repos\QuantConnect_Lean\Common\Securities\Volatility\StandardDeviationOfReturnsVolatilityModel.cs,StandardDeviationOfReturnsVolatilityModel,The following statement contains a magic number: if (periods < 2) throw new ArgumentOutOfRangeException("periods"' "'periods' must be greater than or equal to 2.");
Magic Number,QuantConnect.Securities,RelativeStandardDeviationVolatilityModel,C:\repos\QuantConnect_Lean\Common\Securities\Volatility\RelativeStandardDeviationVolatilityModel.cs,RelativeStandardDeviationVolatilityModel,The following statement contains a magic number: if (periods < 2) throw new ArgumentOutOfRangeException("periods"' "'periods' must be greater than or equal to 2.");
Magic Number,QuantConnect.Securities,SecurityDatabaseKey,C:\repos\QuantConnect_Lean\Common\Securities\SecurityDatabaseKey.cs,Parse,The following statement contains a magic number: if (parts.Length != 3)              {                  throw new FormatException("The specified key was not in the expected format: " + key);              }
Magic Number,QuantConnect.Securities,SecurityDatabaseKey,C:\repos\QuantConnect_Lean\Common\Securities\SecurityDatabaseKey.cs,Parse,The following statement contains a magic number: if (!Enum.TryParse(parts[0]' out type))              {                  throw new ArgumentException("Unable to parse '" + parts[2] + "' as a SecurityType.");              }
Magic Number,QuantConnect.Securities,SecurityDatabaseKey,C:\repos\QuantConnect_Lean\Common\Securities\SecurityDatabaseKey.cs,Parse,The following statement contains a magic number: return new SecurityDatabaseKey(parts[1]' parts[2]' type);
Magic Number,QuantConnect.Securities,SecurityDatabaseKey,C:\repos\QuantConnect_Lean\Common\Securities\SecurityDatabaseKey.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = (Market != null ? Market.GetHashCode() : 0);                  hashCode = (hashCode*397) ^ (Symbol != null ? Symbol.GetHashCode() : 0);                  hashCode = (hashCode*397) ^ (int) SecurityType;                  return hashCode;              }
Magic Number,QuantConnect.Securities,SecurityDatabaseKey,C:\repos\QuantConnect_Lean\Common\Securities\SecurityDatabaseKey.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = (Market != null ? Market.GetHashCode() : 0);                  hashCode = (hashCode*397) ^ (Symbol != null ? Symbol.GetHashCode() : 0);                  hashCode = (hashCode*397) ^ (int) SecurityType;                  return hashCode;              }
Magic Number,QuantConnect.Securities,SecurityExchangeHours,C:\repos\QuantConnect_Lean\Common\Securities\SecurityExchangeHours.cs,GetNextMarketOpen,The following statement contains a magic number: var oneWeekLater = localDateTime.Date.AddDays(15);
Magic Number,QuantConnect.Securities,SecurityExchangeHours,C:\repos\QuantConnect_Lean\Common\Securities\SecurityExchangeHours.cs,GetNextMarketClose,The following statement contains a magic number: var oneWeekLater = localDateTime.Date.AddDays(15);
Magic Number,QuantConnect.Securities,SecurityPortfolioModel,C:\repos\QuantConnect_Lean\Common\Securities\SecurityPortfolioModel.cs,ProcessFill,The following statement contains a magic number: try              {                  // apply sales value to holdings in the account currency                  if (security.Type == SecurityType.Future)                  {                      // for futures' we measure volume of sales' not notionals                      var saleValueInQuoteCurrency = fill.FillPrice * Convert.ToDecimal(fill.AbsoluteFillQuantity);                      var saleValue = saleValueInQuoteCurrency * quoteCash.ConversionRate;                      security.Holdings.AddNewSale(saleValue);                  }                  else                  {                      var saleValueInQuoteCurrency = fill.FillPrice * Convert.ToDecimal(fill.AbsoluteFillQuantity) * security.SymbolProperties.ContractMultiplier;                      var saleValue = saleValueInQuoteCurrency * quoteCash.ConversionRate;                      security.Holdings.AddNewSale(saleValue);                  }                    // subtract transaction fees from the portfolio (assumes in account currency)                  var feeThisOrder = Math.Abs(fill.OrderFee);                  security.Holdings.AddNewFee(feeThisOrder);                  portfolio.CashBook[CashBook.AccountCurrency].AddAmount(-feeThisOrder);                    // apply the funds using the current settlement model                  // we dont adjust funds for futures: it is zero upfront payment derivative (margin applies though)                  if (security.Type != SecurityType.Future)                  {                      security.SettlementModel.ApplyFunds(portfolio' security' fill.UtcTime' quoteCash.Symbol' -fill.FillQuantity * fill.FillPrice * security.SymbolProperties.ContractMultiplier);                  }                  if (security.Type == SecurityType.Forex || security.Type == SecurityType.Crypto)                  {                      // model forex fills as currency swaps                      var forex = (IBaseCurrencySymbol) security;                      security.SettlementModel.ApplyFunds(portfolio' security' fill.UtcTime' forex.BaseCurrencySymbol' fill.FillQuantity);                  }                                    // did we close or open a position further?                  closedPosition = isLong && fill.Direction == OrderDirection.Sell                               || isShort && fill.Direction == OrderDirection.Buy;                    // calculate the last trade profit                  if (closedPosition)                  {                      // profit = (closed sale value - cost)*conversion to account currency                      // closed sale value = quantity closed * fill price       BUYs are deemed negative cash flow                      // cost = quantity closed * average holdings price        SELLS are deemed positive cash flow                      var absoluteQuantityClosed = Math.Min(fill.AbsoluteFillQuantity' absoluteHoldingsQuantity);                      var closedSaleValueInQuoteCurrency = Math.Sign(-fill.FillQuantity)*fill.FillPrice*absoluteQuantityClosed;                      var closedCost = Math.Sign(-fill.FillQuantity)*absoluteQuantityClosed*averageHoldingsPrice;                      var conversionFactor = security.QuoteCurrency.ConversionRate*security.SymbolProperties.ContractMultiplier;                      var lastTradeProfit = (closedSaleValueInQuoteCurrency - closedCost)*conversionFactor;                        // Reflect account cash adjustment for futures position                       if (security.Type == SecurityType.Future)                      {                          security.SettlementModel.ApplyFunds(portfolio' security' fill.UtcTime' quoteCash.Symbol' lastTradeProfit);                      }                        //Update Vehicle Profit Tracking:                      security.Holdings.AddNewProfit(lastTradeProfit);                      security.Holdings.SetLastTradeProfit(lastTradeProfit);                      portfolio.AddTransactionRecord(security.LocalTime.ConvertToUtc(security.Exchange.TimeZone)' lastTradeProfit - 2*feeThisOrder);                  }                    //UPDATE HOLDINGS QUANTITY' AVG PRICE:                  //Currently NO holdings. The order is ALL our holdings.                  if (quantityHoldings == 0)                  {                      //First transaction just subtract order from cash and set our holdings:                      averageHoldingsPrice = fill.FillPrice;                      quantityHoldings = fill.FillQuantity;                  }                  else if (isLong)                  {                      //If we're currently LONG on the stock.                      switch (fill.Direction)                      {                          case OrderDirection.Buy:                              //Update the Holding Average Price: Total Value / Total Quantity:                              averageHoldingsPrice = ((averageHoldingsPrice*quantityHoldings) + (fill.FillQuantity*fill.FillPrice))/(quantityHoldings + fill.FillQuantity);                              //Add the new quantity:                              quantityHoldings += fill.FillQuantity;                              break;                            case OrderDirection.Sell:                              quantityHoldings += fill.FillQuantity; //+ a short = a subtraction                              if (quantityHoldings < 0)                              {                                  //If we've now passed through zero from selling stock: new avg price:                                  averageHoldingsPrice = fill.FillPrice;                              }                              else if (quantityHoldings == 0)                              {                                  averageHoldingsPrice = 0;                              }                              break;                      }                  }                  else if (isShort)                  {                      //We're currently SHORTING the stock: What is the new position now?                      switch (fill.Direction)                      {                          case OrderDirection.Buy:                              //Buying when we're shorting moves to close position:                              quantityHoldings += fill.FillQuantity;                              if (quantityHoldings > 0)                              {                                  //If we were short but passed through zero' new average price is what we paid. The short position was closed.                                  averageHoldingsPrice = fill.FillPrice;                              }                              else if (quantityHoldings == 0)                              {                                  averageHoldingsPrice = 0;                              }                              break;                            case OrderDirection.Sell:                              //We are increasing a Short position:                              //E.g.  -100 @ $5' adding -100 @ $10: Avg: $7.5                              //      dAvg = (-500 + -1000) / -200 = 7.5                              averageHoldingsPrice = ((averageHoldingsPrice*quantityHoldings) + (fill.FillQuantity*fill.FillPrice))/(quantityHoldings + fill.FillQuantity);                              quantityHoldings += fill.FillQuantity;                              break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Securities,SymbolPropertiesDatabase,C:\repos\QuantConnect_Lean\Common\Securities\SymbolPropertiesDatabase.cs,FromCsvLine,The following statement contains a magic number: key = new SecurityDatabaseKey(                  market: csv[0]'                   symbol: csv[1]'                   securityType: (SecurityType)Enum.Parse(typeof(SecurityType)' csv[2]' true));
Magic Number,QuantConnect.Securities,SymbolPropertiesDatabase,C:\repos\QuantConnect_Lean\Common\Securities\SymbolPropertiesDatabase.cs,FromCsvLine,The following statement contains a magic number: return new SymbolProperties(                  description: csv[3]'                   quoteCurrency: csv[4]'                  contractMultiplier: csv[5].ToDecimal()'                  minimumPriceVariation: csv[6].ToDecimal()'                  lotSize: csv[7].ToDecimal());
Magic Number,QuantConnect.Securities,SymbolPropertiesDatabase,C:\repos\QuantConnect_Lean\Common\Securities\SymbolPropertiesDatabase.cs,FromCsvLine,The following statement contains a magic number: return new SymbolProperties(                  description: csv[3]'                   quoteCurrency: csv[4]'                  contractMultiplier: csv[5].ToDecimal()'                  minimumPriceVariation: csv[6].ToDecimal()'                  lotSize: csv[7].ToDecimal());
Magic Number,QuantConnect.Securities,SymbolPropertiesDatabase,C:\repos\QuantConnect_Lean\Common\Securities\SymbolPropertiesDatabase.cs,FromCsvLine,The following statement contains a magic number: return new SymbolProperties(                  description: csv[3]'                   quoteCurrency: csv[4]'                  contractMultiplier: csv[5].ToDecimal()'                  minimumPriceVariation: csv[6].ToDecimal()'                  lotSize: csv[7].ToDecimal());
Magic Number,QuantConnect.Securities,SymbolPropertiesDatabase,C:\repos\QuantConnect_Lean\Common\Securities\SymbolPropertiesDatabase.cs,FromCsvLine,The following statement contains a magic number: return new SymbolProperties(                  description: csv[3]'                   quoteCurrency: csv[4]'                  contractMultiplier: csv[5].ToDecimal()'                  minimumPriceVariation: csv[6].ToDecimal()'                  lotSize: csv[7].ToDecimal());
Magic Number,QuantConnect.Securities,SymbolPropertiesDatabase,C:\repos\QuantConnect_Lean\Common\Securities\SymbolPropertiesDatabase.cs,FromCsvLine,The following statement contains a magic number: return new SymbolProperties(                  description: csv[3]'                   quoteCurrency: csv[4]'                  contractMultiplier: csv[5].ToDecimal()'                  minimumPriceVariation: csv[6].ToDecimal()'                  lotSize: csv[7].ToDecimal());
Magic Number,QuantConnect.Securities,SecurityManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityManager.cs,CreateSecurity,The following statement contains a magic number: if (symbol.ID.SecurityType == SecurityType.Forex || symbol.ID.SecurityType == SecurityType.Crypto) defaultQuoteCurrency = symbol.Value.Substring(3);
Magic Number,QuantConnect.Securities,SecurityPortfolioManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityPortfolioManager.cs,SecurityPortfolioManager,The following statement contains a magic number: _baseCurrencyCash.SetAmount(100000);
Magic Number,QuantConnect.Securities,SecurityPortfolioManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityPortfolioManager.cs,GetSplitAdjustedSymbol,The following statement contains a magic number: if (inverseFactor.RoundToSignificantDigits(5) % 1 == 0)              {                  // even split (e.g. 2 for 1)                  newStrike = Math.Round(symbol.ID.StrikePrice / inverseFactor' 2);              }              else              {                  // odd split (e.g. 3 for 2)                  newStrike = Math.Round(symbol.ID.StrikePrice / inverseFactor' 2);                  newRootSymbol = symbol.Underlying.Value + "1";              }
Magic Number,QuantConnect.Securities,SecurityPortfolioManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityPortfolioManager.cs,GetSplitAdjustedSymbol,The following statement contains a magic number: if (inverseFactor.RoundToSignificantDigits(5) % 1 == 0)              {                  // even split (e.g. 2 for 1)                  newStrike = Math.Round(symbol.ID.StrikePrice / inverseFactor' 2);              }              else              {                  // odd split (e.g. 3 for 2)                  newStrike = Math.Round(symbol.ID.StrikePrice / inverseFactor' 2);                  newRootSymbol = symbol.Underlying.Value + "1";              }
Magic Number,QuantConnect.Securities,SecurityPortfolioManager,C:\repos\QuantConnect_Lean\Common\Securities\SecurityPortfolioManager.cs,GetSplitAdjustedSymbol,The following statement contains a magic number: if (inverseFactor.RoundToSignificantDigits(5) % 1 == 0)              {                  // even split (e.g. 2 for 1)                  newStrike = Math.Round(symbol.ID.StrikePrice / inverseFactor' 2);              }              else              {                  // odd split (e.g. 3 for 2)                  newStrike = Math.Round(symbol.ID.StrikePrice / inverseFactor' 2);                  newRootSymbol = symbol.Underlying.Value + "1";              }
Magic Number,QuantConnect.Securities.Future,FuturesExpiryUtilityFunctions,C:\repos\QuantConnect_Lean\Common\Securities\Future\FuturesExpiryUtilityFunctions.cs,ThirdFriday,The following statement contains a magic number: return (from day in Enumerable.Range(1' daysInMonth)                      where new DateTime(time.Year' time.Month' day).DayOfWeek == DayOfWeek.Friday                      select new DateTime(time.Year' time.Month' day)).ElementAt(2);
Magic Number,QuantConnect.Securities.Future,FuturesExpiryUtilityFunctions,C:\repos\QuantConnect_Lean\Common\Securities\Future\FuturesExpiryUtilityFunctions.cs,ThirdWednesday,The following statement contains a magic number: return (from day in Enumerable.Range(1' daysInMonth)                                    where new DateTime(time.Year' time.Month' day).DayOfWeek == DayOfWeek.Wednesday                                    select new DateTime(time.Year' time.Month' day)).ElementAt(2);
Magic Number,QuantConnect.Securities.Future,FuturesExpiryUtilityFunctions,C:\repos\QuantConnect_Lean\Common\Securities\Future\FuturesExpiryUtilityFunctions.cs,NotPrecededByHoliday,The following statement contains a magic number: for (var i = 1; i <= 3; i++)              {                  if (!NotHoliday(thursday.AddDays(-i)))                  {                      result = false;                  }              }
Magic Number,QuantConnect.Securities.Future,FuturesExpiryUtilityFunctions,C:\repos\QuantConnect_Lean\Common\Securities\Future\FuturesExpiryUtilityFunctions.cs,NotPrecededByHoliday,The following statement contains a magic number: if (!NotHoliday(thursday.AddDays(-6)))              {                  result = false;              }
Magic Number,QuantConnect.Securities.Future,Future,C:\repos\QuantConnect_Lean\Common\Securities\Future\Future.cs,Future,The following statement contains a magic number: SetFilter(TimeSpan.Zero' TimeSpan.FromDays(35));
Magic Number,QuantConnect.Securities.Future,Future,C:\repos\QuantConnect_Lean\Common\Securities\Future\Future.cs,Future,The following statement contains a magic number: SetFilter(TimeSpan.Zero' TimeSpan.FromDays(35));
Magic Number,QuantConnect.Securities.Option,OptionSymbol,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionSymbol.cs,IsStandardContract,The following statement contains a magic number: var firstFriday = firstDayOfMonth == DayOfWeek.Saturday ? 7 : 6 - (int)firstDayOfMonth;
Magic Number,QuantConnect.Securities.Option,OptionSymbol,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionSymbol.cs,IsStandardContract,The following statement contains a magic number: var firstFriday = firstDayOfMonth == DayOfWeek.Saturday ? 7 : 6 - (int)firstDayOfMonth;
Magic Number,QuantConnect.Securities.Option,OptionSymbol,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionSymbol.cs,IsStandardContract,The following statement contains a magic number: return firstFriday + 7 + 5 /*sat -> wed */ < date.Day && date.Day < firstFriday + 2 * 7 + 2 /* sat' sun*/;
Magic Number,QuantConnect.Securities.Option,OptionSymbol,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionSymbol.cs,IsStandardContract,The following statement contains a magic number: return firstFriday + 7 + 5 /*sat -> wed */ < date.Day && date.Day < firstFriday + 2 * 7 + 2 /* sat' sun*/;
Magic Number,QuantConnect.Securities.Option,OptionSymbol,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionSymbol.cs,IsStandardContract,The following statement contains a magic number: return firstFriday + 7 + 5 /*sat -> wed */ < date.Day && date.Day < firstFriday + 2 * 7 + 2 /* sat' sun*/;
Magic Number,QuantConnect.Securities.Option,OptionSymbol,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionSymbol.cs,IsStandardContract,The following statement contains a magic number: return firstFriday + 7 + 5 /*sat -> wed */ < date.Day && date.Day < firstFriday + 2 * 7 + 2 /* sat' sun*/;
Magic Number,QuantConnect.Securities.Option,OptionSymbol,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionSymbol.cs,IsStandardContract,The following statement contains a magic number: return firstFriday + 7 + 5 /*sat -> wed */ < date.Day && date.Day < firstFriday + 2 * 7 + 2 /* sat' sun*/;
Magic Number,QuantConnect.Securities.Option,OptionSymbol,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionSymbol.cs,GetLastDayOfTrading,The following statement contains a magic number: if (IsStandardContract(symbol) &&                  symbol.ID.Date.DayOfWeek == DayOfWeek.Saturday &&                  symbol.ID.Date < new DateTime(2015' 2' 1))              {                  return symbol.ID.Date.Date.AddDays(-1.0);              }
Magic Number,QuantConnect.Securities.Option,OptionSymbol,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionSymbol.cs,GetLastDayOfTrading,The following statement contains a magic number: if (IsStandardContract(symbol) &&                  symbol.ID.Date.DayOfWeek == DayOfWeek.Saturday &&                  symbol.ID.Date < new DateTime(2015' 2' 1))              {                  return symbol.ID.Date.Date.AddDays(-1.0);              }
Magic Number,QuantConnect.Securities.Option,Option,C:\repos\QuantConnect_Lean\Common\Securities\Option\Option.cs,Option,The following statement contains a magic number: SetFilter(-1' 1' TimeSpan.Zero' TimeSpan.FromDays(35));
Magic Number,QuantConnect.Securities.Option,Option,C:\repos\QuantConnect_Lean\Common\Securities\Option\Option.cs,Option,The following statement contains a magic number: SetFilter(-1' 1' TimeSpan.Zero' TimeSpan.FromDays(35));
Magic Number,QuantConnect.Securities.Option,OptionHolding,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionHolding.cs,SplitUnderlying,The following statement contains a magic number: if (inverseFactor.RoundToSignificantDigits(5) % 1 == 0)              {                  // even split (e.g. 2 for 1): we adjust position size and strike price                  Quantity = (int)(Quantity * inverseFactor);                  AveragePrice *= splitFactor;              }              else              {                  // odd split (e.g. 3 for 2): we adjust strike price' unit of trade' and multiplier                  optionSecurity.ContractUnitOfTrade *= (int)inverseFactor;                  optionSecurity.ContractMultiplier *= (int)inverseFactor;              }
Magic Number,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,CallButterfly,The following statement contains a magic number: return new OptionStrategy              {                  Name = "Call Butterfly"'                  Underlying = canonicalOption.Underlying'                  OptionLegs = new List<OptionStrategy.OptionLegData>                                          {                                              new OptionStrategy.OptionLegData { Right = OptionRight.Call' Strike = leg1Strike' Quantity = 1' OrderType = Orders.OrderType.Market' Expiration = expiration }'                                              new OptionStrategy.OptionLegData { Right = OptionRight.Call' Strike = leg2Strike' Quantity = -2' OrderType = Orders.OrderType.Market' Expiration = expiration }'                                              new OptionStrategy.OptionLegData { Right = OptionRight.Call' Strike = leg3Strike' Quantity = 1' OrderType = Orders.OrderType.Market' Expiration = expiration }                                          }              };
Magic Number,QuantConnect.Securities.Option,OptionStrategies,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionStrategies.cs,PutButterfly,The following statement contains a magic number: return new OptionStrategy              {                  Name = "Put Butterfly"'                  Underlying = canonicalOption.Underlying'                  OptionLegs = new List<OptionStrategy.OptionLegData>                                          {                                              new OptionStrategy.OptionLegData { Right = OptionRight.Put' Strike = leg1Strike' Quantity = 1' OrderType = Orders.OrderType.Market' Expiration = expiration }'                                              new OptionStrategy.OptionLegData { Right = OptionRight.Put' Strike = leg2Strike' Quantity = -2' OrderType = Orders.OrderType.Market' Expiration = expiration }'                                              new OptionStrategy.OptionLegData { Right = OptionRight.Put' Strike = leg3Strike' Quantity = 1' OrderType = Orders.OrderType.Market' Expiration = expiration }                                          }              };
Magic Number,QuantConnect.Securities.Option,QLOptionPriceModel,C:\repos\QuantConnect_Lean\Common\Securities\Option\QLOptionPriceModel.cs,Evaluate,The following statement contains a magic number: try              {                  // setting up option pricing parameters                  var calendar = new UnitedStates();                  var dayCounter = new Actual365Fixed();                  var optionSecurity = (Option)security;                    var settlementDate = contract.Time.Date.AddDays(Option.DefaultSettlementDays);                  var maturityDate = contract.Expiry.Date.AddDays(Option.DefaultSettlementDays);                  var underlyingQuoteValue = new SimpleQuote((double)optionSecurity.Underlying.Price);                    var dividendYieldValue = new SimpleQuote(_dividendYieldEstimator.Estimate(security' slice' contract));                  var dividendYield = new Handle<YieldTermStructure>(new FlatForward(0' calendar' dividendYieldValue' dayCounter));                    var riskFreeRateValue = new SimpleQuote(_riskFreeRateEstimator.Estimate(security' slice' contract));                  var riskFreeRate = new Handle<YieldTermStructure>(new FlatForward(0' calendar' riskFreeRateValue' dayCounter));                    var underlyingVolValue = new SimpleQuote(_underlyingVolEstimator.Estimate(security' slice' contract));                  var underlyingVol = new Handle<BlackVolTermStructure>(new BlackConstantVol(0' calendar' new Handle<Quote>(underlyingVolValue)' dayCounter));                    // preparing stochastic process and payoff functions                  var stochasticProcess = new BlackScholesMertonProcess(new Handle<Quote>(underlyingQuoteValue)' dividendYield' riskFreeRate' underlyingVol);                  var payoff = new PlainVanillaPayoff(contract.Right == OptionRight.Call ? QLNet.Option.Type.Call : QLNet.Option.Type.Put' (double)contract.Strike);                    // creating option QL object                  var option = contract.Symbol.ID.OptionStyle == OptionStyle.American ?                              new VanillaOption(payoff' new AmericanExercise(settlementDate' maturityDate)) :                              new VanillaOption(payoff' new EuropeanExercise(maturityDate));                    Settings.setEvaluationDate(settlementDate);                    // preparing pricing engine QL object                  option.setPricingEngine(_pricingEngineFunc(contract.Symbol' stochasticProcess));                    // running calculations                  var npv = EvaluateOption(option);                    // function extracts QL greeks catching exception if greek is not generated by the pricing engine and reevaluates option to get numerical estimate of the seisitivity                  Func<Func<double>' Func<double>' decimal> tryGetGreekOrReevaluate = (greek' reevalFunc) =>                  {                      try                      {                          return (decimal)greek();                      }                      catch (Exception)                      {                          return EnableGreekApproximation ? (decimal)reevalFunc() : 0.0m;                      }                  };                    // function extracts QL greeks catching exception if greek is not generated by the pricing engine                  Func<Func<double>' decimal> tryGetGreek = greek => tryGetGreekOrReevaluate(greek' () => 0.0);                    // function extracts QL IV catching exception if IV is not generated by the pricing engine                  Func<decimal> tryGetImpliedVol = () =>                  {                      try                      {                          return (decimal)option.impliedVolatility((double)optionSecurity.Price' stochasticProcess);                      }                      catch (Exception err)                      {                          Log.Debug("tryGetImpliedVol() error: " + err.Message);                          return 0m;                      }                  };                    Func<Tuple<decimal' decimal>> evalDeltaGamma = () =>                  {                      try                      {                          return Tuple.Create((decimal)option.delta()' (decimal)option.gamma());                      }                      catch (Exception)                      {                          if (EnableGreekApproximation)                          {                              var step = 0.01;                              var initial = underlyingQuoteValue.value();                              underlyingQuoteValue.setValue(initial - step);                              var npvMinus = EvaluateOption(option);                              underlyingQuoteValue.setValue(initial + step);                              var npvPlus = EvaluateOption(option);                              underlyingQuoteValue.setValue(initial);                                return Tuple.Create((decimal)((npvPlus - npvMinus) / (2 * step))'                                                  (decimal)((npvPlus - 2 * npv + npvMinus) / (step * step)));                          }                          else                              return Tuple.Create(0.0m' 0.0m);                      }                  };                    Func<double> reevalVega = () =>                  {                      var step = 0.001;                      var initial = underlyingVolValue.value();                      underlyingVolValue.setValue(initial + step);                      var npvPlus = EvaluateOption(option);                      underlyingVolValue.setValue(initial);                        return (npvPlus - npv) / step;                  };                    Func<double> reevalTheta = () =>                  {                      var step = 1.0 / 365.0;                        Settings.setEvaluationDate(settlementDate.AddDays(-1));                      var npvMinus = EvaluateOption(option);                      Settings.setEvaluationDate(settlementDate);                        return (npv - npvMinus) / step;                  };                    Func<double> reevalRho = () =>                  {                      var step = 0.001;                      var initial = riskFreeRateValue.value();                      riskFreeRateValue.setValue(initial + step);                      var npvPlus = EvaluateOption(option);                      riskFreeRateValue.setValue(initial);                        return (npvPlus - npv) / step;                  };                    // producing output with lazy calculations of IV and greeks                    return new OptionPriceModelResult((decimal)npv'                              tryGetImpliedVol'                              () => new Greeks(evalDeltaGamma'                                              () => tryGetGreekOrReevaluate(() => option.vega()' reevalVega)'                                              () => tryGetGreekOrReevaluate(() => option.theta()' reevalTheta)'                                              () => tryGetGreekOrReevaluate(() => option.rho()' reevalRho)'                                              () => tryGetGreek(() => option.elasticity())));              }              catch(Exception err)              {                  Log.Debug("QLOptionPriceModel.Evaluate() error: " + err.Message);                  return new OptionPriceModelResult(0m' new Greeks());              }
Magic Number,QuantConnect.Securities.Option,QLOptionPriceModel,C:\repos\QuantConnect_Lean\Common\Securities\Option\QLOptionPriceModel.cs,Evaluate,The following statement contains a magic number: try              {                  // setting up option pricing parameters                  var calendar = new UnitedStates();                  var dayCounter = new Actual365Fixed();                  var optionSecurity = (Option)security;                    var settlementDate = contract.Time.Date.AddDays(Option.DefaultSettlementDays);                  var maturityDate = contract.Expiry.Date.AddDays(Option.DefaultSettlementDays);                  var underlyingQuoteValue = new SimpleQuote((double)optionSecurity.Underlying.Price);                    var dividendYieldValue = new SimpleQuote(_dividendYieldEstimator.Estimate(security' slice' contract));                  var dividendYield = new Handle<YieldTermStructure>(new FlatForward(0' calendar' dividendYieldValue' dayCounter));                    var riskFreeRateValue = new SimpleQuote(_riskFreeRateEstimator.Estimate(security' slice' contract));                  var riskFreeRate = new Handle<YieldTermStructure>(new FlatForward(0' calendar' riskFreeRateValue' dayCounter));                    var underlyingVolValue = new SimpleQuote(_underlyingVolEstimator.Estimate(security' slice' contract));                  var underlyingVol = new Handle<BlackVolTermStructure>(new BlackConstantVol(0' calendar' new Handle<Quote>(underlyingVolValue)' dayCounter));                    // preparing stochastic process and payoff functions                  var stochasticProcess = new BlackScholesMertonProcess(new Handle<Quote>(underlyingQuoteValue)' dividendYield' riskFreeRate' underlyingVol);                  var payoff = new PlainVanillaPayoff(contract.Right == OptionRight.Call ? QLNet.Option.Type.Call : QLNet.Option.Type.Put' (double)contract.Strike);                    // creating option QL object                  var option = contract.Symbol.ID.OptionStyle == OptionStyle.American ?                              new VanillaOption(payoff' new AmericanExercise(settlementDate' maturityDate)) :                              new VanillaOption(payoff' new EuropeanExercise(maturityDate));                    Settings.setEvaluationDate(settlementDate);                    // preparing pricing engine QL object                  option.setPricingEngine(_pricingEngineFunc(contract.Symbol' stochasticProcess));                    // running calculations                  var npv = EvaluateOption(option);                    // function extracts QL greeks catching exception if greek is not generated by the pricing engine and reevaluates option to get numerical estimate of the seisitivity                  Func<Func<double>' Func<double>' decimal> tryGetGreekOrReevaluate = (greek' reevalFunc) =>                  {                      try                      {                          return (decimal)greek();                      }                      catch (Exception)                      {                          return EnableGreekApproximation ? (decimal)reevalFunc() : 0.0m;                      }                  };                    // function extracts QL greeks catching exception if greek is not generated by the pricing engine                  Func<Func<double>' decimal> tryGetGreek = greek => tryGetGreekOrReevaluate(greek' () => 0.0);                    // function extracts QL IV catching exception if IV is not generated by the pricing engine                  Func<decimal> tryGetImpliedVol = () =>                  {                      try                      {                          return (decimal)option.impliedVolatility((double)optionSecurity.Price' stochasticProcess);                      }                      catch (Exception err)                      {                          Log.Debug("tryGetImpliedVol() error: " + err.Message);                          return 0m;                      }                  };                    Func<Tuple<decimal' decimal>> evalDeltaGamma = () =>                  {                      try                      {                          return Tuple.Create((decimal)option.delta()' (decimal)option.gamma());                      }                      catch (Exception)                      {                          if (EnableGreekApproximation)                          {                              var step = 0.01;                              var initial = underlyingQuoteValue.value();                              underlyingQuoteValue.setValue(initial - step);                              var npvMinus = EvaluateOption(option);                              underlyingQuoteValue.setValue(initial + step);                              var npvPlus = EvaluateOption(option);                              underlyingQuoteValue.setValue(initial);                                return Tuple.Create((decimal)((npvPlus - npvMinus) / (2 * step))'                                                  (decimal)((npvPlus - 2 * npv + npvMinus) / (step * step)));                          }                          else                              return Tuple.Create(0.0m' 0.0m);                      }                  };                    Func<double> reevalVega = () =>                  {                      var step = 0.001;                      var initial = underlyingVolValue.value();                      underlyingVolValue.setValue(initial + step);                      var npvPlus = EvaluateOption(option);                      underlyingVolValue.setValue(initial);                        return (npvPlus - npv) / step;                  };                    Func<double> reevalTheta = () =>                  {                      var step = 1.0 / 365.0;                        Settings.setEvaluationDate(settlementDate.AddDays(-1));                      var npvMinus = EvaluateOption(option);                      Settings.setEvaluationDate(settlementDate);                        return (npv - npvMinus) / step;                  };                    Func<double> reevalRho = () =>                  {                      var step = 0.001;                      var initial = riskFreeRateValue.value();                      riskFreeRateValue.setValue(initial + step);                      var npvPlus = EvaluateOption(option);                      riskFreeRateValue.setValue(initial);                        return (npvPlus - npv) / step;                  };                    // producing output with lazy calculations of IV and greeks                    return new OptionPriceModelResult((decimal)npv'                              tryGetImpliedVol'                              () => new Greeks(evalDeltaGamma'                                              () => tryGetGreekOrReevaluate(() => option.vega()' reevalVega)'                                              () => tryGetGreekOrReevaluate(() => option.theta()' reevalTheta)'                                              () => tryGetGreekOrReevaluate(() => option.rho()' reevalRho)'                                              () => tryGetGreek(() => option.elasticity())));              }              catch(Exception err)              {                  Log.Debug("QLOptionPriceModel.Evaluate() error: " + err.Message);                  return new OptionPriceModelResult(0m' new Greeks());              }
Magic Number,QuantConnect.Securities.Option,QLOptionPriceModel,C:\repos\QuantConnect_Lean\Common\Securities\Option\QLOptionPriceModel.cs,Evaluate,The following statement contains a magic number: try              {                  // setting up option pricing parameters                  var calendar = new UnitedStates();                  var dayCounter = new Actual365Fixed();                  var optionSecurity = (Option)security;                    var settlementDate = contract.Time.Date.AddDays(Option.DefaultSettlementDays);                  var maturityDate = contract.Expiry.Date.AddDays(Option.DefaultSettlementDays);                  var underlyingQuoteValue = new SimpleQuote((double)optionSecurity.Underlying.Price);                    var dividendYieldValue = new SimpleQuote(_dividendYieldEstimator.Estimate(security' slice' contract));                  var dividendYield = new Handle<YieldTermStructure>(new FlatForward(0' calendar' dividendYieldValue' dayCounter));                    var riskFreeRateValue = new SimpleQuote(_riskFreeRateEstimator.Estimate(security' slice' contract));                  var riskFreeRate = new Handle<YieldTermStructure>(new FlatForward(0' calendar' riskFreeRateValue' dayCounter));                    var underlyingVolValue = new SimpleQuote(_underlyingVolEstimator.Estimate(security' slice' contract));                  var underlyingVol = new Handle<BlackVolTermStructure>(new BlackConstantVol(0' calendar' new Handle<Quote>(underlyingVolValue)' dayCounter));                    // preparing stochastic process and payoff functions                  var stochasticProcess = new BlackScholesMertonProcess(new Handle<Quote>(underlyingQuoteValue)' dividendYield' riskFreeRate' underlyingVol);                  var payoff = new PlainVanillaPayoff(contract.Right == OptionRight.Call ? QLNet.Option.Type.Call : QLNet.Option.Type.Put' (double)contract.Strike);                    // creating option QL object                  var option = contract.Symbol.ID.OptionStyle == OptionStyle.American ?                              new VanillaOption(payoff' new AmericanExercise(settlementDate' maturityDate)) :                              new VanillaOption(payoff' new EuropeanExercise(maturityDate));                    Settings.setEvaluationDate(settlementDate);                    // preparing pricing engine QL object                  option.setPricingEngine(_pricingEngineFunc(contract.Symbol' stochasticProcess));                    // running calculations                  var npv = EvaluateOption(option);                    // function extracts QL greeks catching exception if greek is not generated by the pricing engine and reevaluates option to get numerical estimate of the seisitivity                  Func<Func<double>' Func<double>' decimal> tryGetGreekOrReevaluate = (greek' reevalFunc) =>                  {                      try                      {                          return (decimal)greek();                      }                      catch (Exception)                      {                          return EnableGreekApproximation ? (decimal)reevalFunc() : 0.0m;                      }                  };                    // function extracts QL greeks catching exception if greek is not generated by the pricing engine                  Func<Func<double>' decimal> tryGetGreek = greek => tryGetGreekOrReevaluate(greek' () => 0.0);                    // function extracts QL IV catching exception if IV is not generated by the pricing engine                  Func<decimal> tryGetImpliedVol = () =>                  {                      try                      {                          return (decimal)option.impliedVolatility((double)optionSecurity.Price' stochasticProcess);                      }                      catch (Exception err)                      {                          Log.Debug("tryGetImpliedVol() error: " + err.Message);                          return 0m;                      }                  };                    Func<Tuple<decimal' decimal>> evalDeltaGamma = () =>                  {                      try                      {                          return Tuple.Create((decimal)option.delta()' (decimal)option.gamma());                      }                      catch (Exception)                      {                          if (EnableGreekApproximation)                          {                              var step = 0.01;                              var initial = underlyingQuoteValue.value();                              underlyingQuoteValue.setValue(initial - step);                              var npvMinus = EvaluateOption(option);                              underlyingQuoteValue.setValue(initial + step);                              var npvPlus = EvaluateOption(option);                              underlyingQuoteValue.setValue(initial);                                return Tuple.Create((decimal)((npvPlus - npvMinus) / (2 * step))'                                                  (decimal)((npvPlus - 2 * npv + npvMinus) / (step * step)));                          }                          else                              return Tuple.Create(0.0m' 0.0m);                      }                  };                    Func<double> reevalVega = () =>                  {                      var step = 0.001;                      var initial = underlyingVolValue.value();                      underlyingVolValue.setValue(initial + step);                      var npvPlus = EvaluateOption(option);                      underlyingVolValue.setValue(initial);                        return (npvPlus - npv) / step;                  };                    Func<double> reevalTheta = () =>                  {                      var step = 1.0 / 365.0;                        Settings.setEvaluationDate(settlementDate.AddDays(-1));                      var npvMinus = EvaluateOption(option);                      Settings.setEvaluationDate(settlementDate);                        return (npv - npvMinus) / step;                  };                    Func<double> reevalRho = () =>                  {                      var step = 0.001;                      var initial = riskFreeRateValue.value();                      riskFreeRateValue.setValue(initial + step);                      var npvPlus = EvaluateOption(option);                      riskFreeRateValue.setValue(initial);                        return (npvPlus - npv) / step;                  };                    // producing output with lazy calculations of IV and greeks                    return new OptionPriceModelResult((decimal)npv'                              tryGetImpliedVol'                              () => new Greeks(evalDeltaGamma'                                              () => tryGetGreekOrReevaluate(() => option.vega()' reevalVega)'                                              () => tryGetGreekOrReevaluate(() => option.theta()' reevalTheta)'                                              () => tryGetGreekOrReevaluate(() => option.rho()' reevalRho)'                                              () => tryGetGreek(() => option.elasticity())));              }              catch(Exception err)              {                  Log.Debug("QLOptionPriceModel.Evaluate() error: " + err.Message);                  return new OptionPriceModelResult(0m' new Greeks());              }
Magic Number,QuantConnect.Securities.Option,QLOptionPriceModel,C:\repos\QuantConnect_Lean\Common\Securities\Option\QLOptionPriceModel.cs,Evaluate,The following statement contains a magic number: try              {                  // setting up option pricing parameters                  var calendar = new UnitedStates();                  var dayCounter = new Actual365Fixed();                  var optionSecurity = (Option)security;                    var settlementDate = contract.Time.Date.AddDays(Option.DefaultSettlementDays);                  var maturityDate = contract.Expiry.Date.AddDays(Option.DefaultSettlementDays);                  var underlyingQuoteValue = new SimpleQuote((double)optionSecurity.Underlying.Price);                    var dividendYieldValue = new SimpleQuote(_dividendYieldEstimator.Estimate(security' slice' contract));                  var dividendYield = new Handle<YieldTermStructure>(new FlatForward(0' calendar' dividendYieldValue' dayCounter));                    var riskFreeRateValue = new SimpleQuote(_riskFreeRateEstimator.Estimate(security' slice' contract));                  var riskFreeRate = new Handle<YieldTermStructure>(new FlatForward(0' calendar' riskFreeRateValue' dayCounter));                    var underlyingVolValue = new SimpleQuote(_underlyingVolEstimator.Estimate(security' slice' contract));                  var underlyingVol = new Handle<BlackVolTermStructure>(new BlackConstantVol(0' calendar' new Handle<Quote>(underlyingVolValue)' dayCounter));                    // preparing stochastic process and payoff functions                  var stochasticProcess = new BlackScholesMertonProcess(new Handle<Quote>(underlyingQuoteValue)' dividendYield' riskFreeRate' underlyingVol);                  var payoff = new PlainVanillaPayoff(contract.Right == OptionRight.Call ? QLNet.Option.Type.Call : QLNet.Option.Type.Put' (double)contract.Strike);                    // creating option QL object                  var option = contract.Symbol.ID.OptionStyle == OptionStyle.American ?                              new VanillaOption(payoff' new AmericanExercise(settlementDate' maturityDate)) :                              new VanillaOption(payoff' new EuropeanExercise(maturityDate));                    Settings.setEvaluationDate(settlementDate);                    // preparing pricing engine QL object                  option.setPricingEngine(_pricingEngineFunc(contract.Symbol' stochasticProcess));                    // running calculations                  var npv = EvaluateOption(option);                    // function extracts QL greeks catching exception if greek is not generated by the pricing engine and reevaluates option to get numerical estimate of the seisitivity                  Func<Func<double>' Func<double>' decimal> tryGetGreekOrReevaluate = (greek' reevalFunc) =>                  {                      try                      {                          return (decimal)greek();                      }                      catch (Exception)                      {                          return EnableGreekApproximation ? (decimal)reevalFunc() : 0.0m;                      }                  };                    // function extracts QL greeks catching exception if greek is not generated by the pricing engine                  Func<Func<double>' decimal> tryGetGreek = greek => tryGetGreekOrReevaluate(greek' () => 0.0);                    // function extracts QL IV catching exception if IV is not generated by the pricing engine                  Func<decimal> tryGetImpliedVol = () =>                  {                      try                      {                          return (decimal)option.impliedVolatility((double)optionSecurity.Price' stochasticProcess);                      }                      catch (Exception err)                      {                          Log.Debug("tryGetImpliedVol() error: " + err.Message);                          return 0m;                      }                  };                    Func<Tuple<decimal' decimal>> evalDeltaGamma = () =>                  {                      try                      {                          return Tuple.Create((decimal)option.delta()' (decimal)option.gamma());                      }                      catch (Exception)                      {                          if (EnableGreekApproximation)                          {                              var step = 0.01;                              var initial = underlyingQuoteValue.value();                              underlyingQuoteValue.setValue(initial - step);                              var npvMinus = EvaluateOption(option);                              underlyingQuoteValue.setValue(initial + step);                              var npvPlus = EvaluateOption(option);                              underlyingQuoteValue.setValue(initial);                                return Tuple.Create((decimal)((npvPlus - npvMinus) / (2 * step))'                                                  (decimal)((npvPlus - 2 * npv + npvMinus) / (step * step)));                          }                          else                              return Tuple.Create(0.0m' 0.0m);                      }                  };                    Func<double> reevalVega = () =>                  {                      var step = 0.001;                      var initial = underlyingVolValue.value();                      underlyingVolValue.setValue(initial + step);                      var npvPlus = EvaluateOption(option);                      underlyingVolValue.setValue(initial);                        return (npvPlus - npv) / step;                  };                    Func<double> reevalTheta = () =>                  {                      var step = 1.0 / 365.0;                        Settings.setEvaluationDate(settlementDate.AddDays(-1));                      var npvMinus = EvaluateOption(option);                      Settings.setEvaluationDate(settlementDate);                        return (npv - npvMinus) / step;                  };                    Func<double> reevalRho = () =>                  {                      var step = 0.001;                      var initial = riskFreeRateValue.value();                      riskFreeRateValue.setValue(initial + step);                      var npvPlus = EvaluateOption(option);                      riskFreeRateValue.setValue(initial);                        return (npvPlus - npv) / step;                  };                    // producing output with lazy calculations of IV and greeks                    return new OptionPriceModelResult((decimal)npv'                              tryGetImpliedVol'                              () => new Greeks(evalDeltaGamma'                                              () => tryGetGreekOrReevaluate(() => option.vega()' reevalVega)'                                              () => tryGetGreekOrReevaluate(() => option.theta()' reevalTheta)'                                              () => tryGetGreekOrReevaluate(() => option.rho()' reevalRho)'                                              () => tryGetGreek(() => option.elasticity())));              }              catch(Exception err)              {                  Log.Debug("QLOptionPriceModel.Evaluate() error: " + err.Message);                  return new OptionPriceModelResult(0m' new Greeks());              }
Magic Number,QuantConnect.Securities.Option,QLOptionPriceModel,C:\repos\QuantConnect_Lean\Common\Securities\Option\QLOptionPriceModel.cs,Evaluate,The following statement contains a magic number: try              {                  // setting up option pricing parameters                  var calendar = new UnitedStates();                  var dayCounter = new Actual365Fixed();                  var optionSecurity = (Option)security;                    var settlementDate = contract.Time.Date.AddDays(Option.DefaultSettlementDays);                  var maturityDate = contract.Expiry.Date.AddDays(Option.DefaultSettlementDays);                  var underlyingQuoteValue = new SimpleQuote((double)optionSecurity.Underlying.Price);                    var dividendYieldValue = new SimpleQuote(_dividendYieldEstimator.Estimate(security' slice' contract));                  var dividendYield = new Handle<YieldTermStructure>(new FlatForward(0' calendar' dividendYieldValue' dayCounter));                    var riskFreeRateValue = new SimpleQuote(_riskFreeRateEstimator.Estimate(security' slice' contract));                  var riskFreeRate = new Handle<YieldTermStructure>(new FlatForward(0' calendar' riskFreeRateValue' dayCounter));                    var underlyingVolValue = new SimpleQuote(_underlyingVolEstimator.Estimate(security' slice' contract));                  var underlyingVol = new Handle<BlackVolTermStructure>(new BlackConstantVol(0' calendar' new Handle<Quote>(underlyingVolValue)' dayCounter));                    // preparing stochastic process and payoff functions                  var stochasticProcess = new BlackScholesMertonProcess(new Handle<Quote>(underlyingQuoteValue)' dividendYield' riskFreeRate' underlyingVol);                  var payoff = new PlainVanillaPayoff(contract.Right == OptionRight.Call ? QLNet.Option.Type.Call : QLNet.Option.Type.Put' (double)contract.Strike);                    // creating option QL object                  var option = contract.Symbol.ID.OptionStyle == OptionStyle.American ?                              new VanillaOption(payoff' new AmericanExercise(settlementDate' maturityDate)) :                              new VanillaOption(payoff' new EuropeanExercise(maturityDate));                    Settings.setEvaluationDate(settlementDate);                    // preparing pricing engine QL object                  option.setPricingEngine(_pricingEngineFunc(contract.Symbol' stochasticProcess));                    // running calculations                  var npv = EvaluateOption(option);                    // function extracts QL greeks catching exception if greek is not generated by the pricing engine and reevaluates option to get numerical estimate of the seisitivity                  Func<Func<double>' Func<double>' decimal> tryGetGreekOrReevaluate = (greek' reevalFunc) =>                  {                      try                      {                          return (decimal)greek();                      }                      catch (Exception)                      {                          return EnableGreekApproximation ? (decimal)reevalFunc() : 0.0m;                      }                  };                    // function extracts QL greeks catching exception if greek is not generated by the pricing engine                  Func<Func<double>' decimal> tryGetGreek = greek => tryGetGreekOrReevaluate(greek' () => 0.0);                    // function extracts QL IV catching exception if IV is not generated by the pricing engine                  Func<decimal> tryGetImpliedVol = () =>                  {                      try                      {                          return (decimal)option.impliedVolatility((double)optionSecurity.Price' stochasticProcess);                      }                      catch (Exception err)                      {                          Log.Debug("tryGetImpliedVol() error: " + err.Message);                          return 0m;                      }                  };                    Func<Tuple<decimal' decimal>> evalDeltaGamma = () =>                  {                      try                      {                          return Tuple.Create((decimal)option.delta()' (decimal)option.gamma());                      }                      catch (Exception)                      {                          if (EnableGreekApproximation)                          {                              var step = 0.01;                              var initial = underlyingQuoteValue.value();                              underlyingQuoteValue.setValue(initial - step);                              var npvMinus = EvaluateOption(option);                              underlyingQuoteValue.setValue(initial + step);                              var npvPlus = EvaluateOption(option);                              underlyingQuoteValue.setValue(initial);                                return Tuple.Create((decimal)((npvPlus - npvMinus) / (2 * step))'                                                  (decimal)((npvPlus - 2 * npv + npvMinus) / (step * step)));                          }                          else                              return Tuple.Create(0.0m' 0.0m);                      }                  };                    Func<double> reevalVega = () =>                  {                      var step = 0.001;                      var initial = underlyingVolValue.value();                      underlyingVolValue.setValue(initial + step);                      var npvPlus = EvaluateOption(option);                      underlyingVolValue.setValue(initial);                        return (npvPlus - npv) / step;                  };                    Func<double> reevalTheta = () =>                  {                      var step = 1.0 / 365.0;                        Settings.setEvaluationDate(settlementDate.AddDays(-1));                      var npvMinus = EvaluateOption(option);                      Settings.setEvaluationDate(settlementDate);                        return (npv - npvMinus) / step;                  };                    Func<double> reevalRho = () =>                  {                      var step = 0.001;                      var initial = riskFreeRateValue.value();                      riskFreeRateValue.setValue(initial + step);                      var npvPlus = EvaluateOption(option);                      riskFreeRateValue.setValue(initial);                        return (npvPlus - npv) / step;                  };                    // producing output with lazy calculations of IV and greeks                    return new OptionPriceModelResult((decimal)npv'                              tryGetImpliedVol'                              () => new Greeks(evalDeltaGamma'                                              () => tryGetGreekOrReevaluate(() => option.vega()' reevalVega)'                                              () => tryGetGreekOrReevaluate(() => option.theta()' reevalTheta)'                                              () => tryGetGreekOrReevaluate(() => option.rho()' reevalRho)'                                              () => tryGetGreek(() => option.elasticity())));              }              catch(Exception err)              {                  Log.Debug("QLOptionPriceModel.Evaluate() error: " + err.Message);                  return new OptionPriceModelResult(0m' new Greeks());              }
Magic Number,QuantConnect.Securities.Option,QLOptionPriceModel,C:\repos\QuantConnect_Lean\Common\Securities\Option\QLOptionPriceModel.cs,Evaluate,The following statement contains a magic number: try              {                  // setting up option pricing parameters                  var calendar = new UnitedStates();                  var dayCounter = new Actual365Fixed();                  var optionSecurity = (Option)security;                    var settlementDate = contract.Time.Date.AddDays(Option.DefaultSettlementDays);                  var maturityDate = contract.Expiry.Date.AddDays(Option.DefaultSettlementDays);                  var underlyingQuoteValue = new SimpleQuote((double)optionSecurity.Underlying.Price);                    var dividendYieldValue = new SimpleQuote(_dividendYieldEstimator.Estimate(security' slice' contract));                  var dividendYield = new Handle<YieldTermStructure>(new FlatForward(0' calendar' dividendYieldValue' dayCounter));                    var riskFreeRateValue = new SimpleQuote(_riskFreeRateEstimator.Estimate(security' slice' contract));                  var riskFreeRate = new Handle<YieldTermStructure>(new FlatForward(0' calendar' riskFreeRateValue' dayCounter));                    var underlyingVolValue = new SimpleQuote(_underlyingVolEstimator.Estimate(security' slice' contract));                  var underlyingVol = new Handle<BlackVolTermStructure>(new BlackConstantVol(0' calendar' new Handle<Quote>(underlyingVolValue)' dayCounter));                    // preparing stochastic process and payoff functions                  var stochasticProcess = new BlackScholesMertonProcess(new Handle<Quote>(underlyingQuoteValue)' dividendYield' riskFreeRate' underlyingVol);                  var payoff = new PlainVanillaPayoff(contract.Right == OptionRight.Call ? QLNet.Option.Type.Call : QLNet.Option.Type.Put' (double)contract.Strike);                    // creating option QL object                  var option = contract.Symbol.ID.OptionStyle == OptionStyle.American ?                              new VanillaOption(payoff' new AmericanExercise(settlementDate' maturityDate)) :                              new VanillaOption(payoff' new EuropeanExercise(maturityDate));                    Settings.setEvaluationDate(settlementDate);                    // preparing pricing engine QL object                  option.setPricingEngine(_pricingEngineFunc(contract.Symbol' stochasticProcess));                    // running calculations                  var npv = EvaluateOption(option);                    // function extracts QL greeks catching exception if greek is not generated by the pricing engine and reevaluates option to get numerical estimate of the seisitivity                  Func<Func<double>' Func<double>' decimal> tryGetGreekOrReevaluate = (greek' reevalFunc) =>                  {                      try                      {                          return (decimal)greek();                      }                      catch (Exception)                      {                          return EnableGreekApproximation ? (decimal)reevalFunc() : 0.0m;                      }                  };                    // function extracts QL greeks catching exception if greek is not generated by the pricing engine                  Func<Func<double>' decimal> tryGetGreek = greek => tryGetGreekOrReevaluate(greek' () => 0.0);                    // function extracts QL IV catching exception if IV is not generated by the pricing engine                  Func<decimal> tryGetImpliedVol = () =>                  {                      try                      {                          return (decimal)option.impliedVolatility((double)optionSecurity.Price' stochasticProcess);                      }                      catch (Exception err)                      {                          Log.Debug("tryGetImpliedVol() error: " + err.Message);                          return 0m;                      }                  };                    Func<Tuple<decimal' decimal>> evalDeltaGamma = () =>                  {                      try                      {                          return Tuple.Create((decimal)option.delta()' (decimal)option.gamma());                      }                      catch (Exception)                      {                          if (EnableGreekApproximation)                          {                              var step = 0.01;                              var initial = underlyingQuoteValue.value();                              underlyingQuoteValue.setValue(initial - step);                              var npvMinus = EvaluateOption(option);                              underlyingQuoteValue.setValue(initial + step);                              var npvPlus = EvaluateOption(option);                              underlyingQuoteValue.setValue(initial);                                return Tuple.Create((decimal)((npvPlus - npvMinus) / (2 * step))'                                                  (decimal)((npvPlus - 2 * npv + npvMinus) / (step * step)));                          }                          else                              return Tuple.Create(0.0m' 0.0m);                      }                  };                    Func<double> reevalVega = () =>                  {                      var step = 0.001;                      var initial = underlyingVolValue.value();                      underlyingVolValue.setValue(initial + step);                      var npvPlus = EvaluateOption(option);                      underlyingVolValue.setValue(initial);                        return (npvPlus - npv) / step;                  };                    Func<double> reevalTheta = () =>                  {                      var step = 1.0 / 365.0;                        Settings.setEvaluationDate(settlementDate.AddDays(-1));                      var npvMinus = EvaluateOption(option);                      Settings.setEvaluationDate(settlementDate);                        return (npv - npvMinus) / step;                  };                    Func<double> reevalRho = () =>                  {                      var step = 0.001;                      var initial = riskFreeRateValue.value();                      riskFreeRateValue.setValue(initial + step);                      var npvPlus = EvaluateOption(option);                      riskFreeRateValue.setValue(initial);                        return (npvPlus - npv) / step;                  };                    // producing output with lazy calculations of IV and greeks                    return new OptionPriceModelResult((decimal)npv'                              tryGetImpliedVol'                              () => new Greeks(evalDeltaGamma'                                              () => tryGetGreekOrReevaluate(() => option.vega()' reevalVega)'                                              () => tryGetGreekOrReevaluate(() => option.theta()' reevalTheta)'                                              () => tryGetGreekOrReevaluate(() => option.rho()' reevalRho)'                                              () => tryGetGreek(() => option.elasticity())));              }              catch(Exception err)              {                  Log.Debug("QLOptionPriceModel.Evaluate() error: " + err.Message);                  return new OptionPriceModelResult(0m' new Greeks());              }
Magic Number,QuantConnect.Data.Custom,FxcmVolume,C:\repos\QuantConnect_Lean\Common\Data\Custom\FxcmVolume.cs,Reader,The following statement contains a magic number: if (isLiveMode)              {                  try                  {                      var obs = line.Split('\n')[2].Split(';');                      var stringDate = obs[0].Substring(startIndex: 3);                      fxcmVolume.Time = DateTime.ParseExact(stringDate' "yyyyMMddHHmm"' DateTimeFormatInfo.InvariantInfo);                      fxcmVolume.Volume = _volumeIdx.Select(x => long.Parse(obs[x])).Sum();                      fxcmVolume.Transactions = _transactionsIdx.Select(x => int.Parse(obs[x])).Sum();                      fxcmVolume.Value = fxcmVolume.Volume;                  }                  catch (Exception exception)                  {                      Logging.Log.Error($"Invalid data. Line: {line}. Exception: {exception.Message}");                      return null;                  }              }              else              {                  var obs = line.Split(''');                  if (config.Resolution == Resolution.Minute)                  {                      fxcmVolume.Time = date.Date.AddMilliseconds(int.Parse(obs[0]));                  }                  else                  {                      fxcmVolume.Time = DateTime.ParseExact(obs[0]' "yyyyMMdd HH:mm"' CultureInfo.InvariantCulture);                  }                  fxcmVolume.Volume = long.Parse(obs[1]);                  fxcmVolume.Transactions = int.Parse(obs[2]);                  fxcmVolume.Value = fxcmVolume.Volume;              }
Magic Number,QuantConnect.Data.Custom,FxcmVolume,C:\repos\QuantConnect_Lean\Common\Data\Custom\FxcmVolume.cs,Reader,The following statement contains a magic number: if (isLiveMode)              {                  try                  {                      var obs = line.Split('\n')[2].Split(';');                      var stringDate = obs[0].Substring(startIndex: 3);                      fxcmVolume.Time = DateTime.ParseExact(stringDate' "yyyyMMddHHmm"' DateTimeFormatInfo.InvariantInfo);                      fxcmVolume.Volume = _volumeIdx.Select(x => long.Parse(obs[x])).Sum();                      fxcmVolume.Transactions = _transactionsIdx.Select(x => int.Parse(obs[x])).Sum();                      fxcmVolume.Value = fxcmVolume.Volume;                  }                  catch (Exception exception)                  {                      Logging.Log.Error($"Invalid data. Line: {line}. Exception: {exception.Message}");                      return null;                  }              }              else              {                  var obs = line.Split(''');                  if (config.Resolution == Resolution.Minute)                  {                      fxcmVolume.Time = date.Date.AddMilliseconds(int.Parse(obs[0]));                  }                  else                  {                      fxcmVolume.Time = DateTime.ParseExact(obs[0]' "yyyyMMdd HH:mm"' CultureInfo.InvariantCulture);                  }                  fxcmVolume.Volume = long.Parse(obs[1]);                  fxcmVolume.Transactions = int.Parse(obs[2]);                  fxcmVolume.Value = fxcmVolume.Volume;              }
Magic Number,QuantConnect.Data.Custom,FxcmVolume,C:\repos\QuantConnect_Lean\Common\Data\Custom\FxcmVolume.cs,Reader,The following statement contains a magic number: if (isLiveMode)              {                  try                  {                      var obs = line.Split('\n')[2].Split(';');                      var stringDate = obs[0].Substring(startIndex: 3);                      fxcmVolume.Time = DateTime.ParseExact(stringDate' "yyyyMMddHHmm"' DateTimeFormatInfo.InvariantInfo);                      fxcmVolume.Volume = _volumeIdx.Select(x => long.Parse(obs[x])).Sum();                      fxcmVolume.Transactions = _transactionsIdx.Select(x => int.Parse(obs[x])).Sum();                      fxcmVolume.Value = fxcmVolume.Volume;                  }                  catch (Exception exception)                  {                      Logging.Log.Error($"Invalid data. Line: {line}. Exception: {exception.Message}");                      return null;                  }              }              else              {                  var obs = line.Split(''');                  if (config.Resolution == Resolution.Minute)                  {                      fxcmVolume.Time = date.Date.AddMilliseconds(int.Parse(obs[0]));                  }                  else                  {                      fxcmVolume.Time = DateTime.ParseExact(obs[0]' "yyyyMMdd HH:mm"' CultureInfo.InvariantCulture);                  }                  fxcmVolume.Volume = long.Parse(obs[1]);                  fxcmVolume.Transactions = int.Parse(obs[2]);                  fxcmVolume.Value = fxcmVolume.Volume;              }
Magic Number,QuantConnect.Data.Custom,DailyFx,C:\repos\QuantConnect_Lean\Common\Data\Custom\DailyFx.cs,Reader,The following statement contains a magic number: var clearingDate = date.Date.AddDays(-2);
Magic Number,QuantConnect.Data.Custom,DailyFx,C:\repos\QuantConnect_Lean\Common\Data\Custom\DailyFx.cs,GetQuarter,The following statement contains a magic number: if (date.Month < 4)              {                  start += "0101";                  end += "03312359";              }              else if (date.Month < 7)              {                  start += "0401";                  end += "06302359";              }              else if (date.Month < 10)              {                  start += "0701";                  end += "09302359";              }              else              {                  start += "1001";                  end += "12312359";              }
Magic Number,QuantConnect.Data.Custom,DailyFx,C:\repos\QuantConnect_Lean\Common\Data\Custom\DailyFx.cs,GetQuarter,The following statement contains a magic number: if (date.Month < 4)              {                  start += "0101";                  end += "03312359";              }              else if (date.Month < 7)              {                  start += "0401";                  end += "06302359";              }              else if (date.Month < 10)              {                  start += "0701";                  end += "09302359";              }              else              {                  start += "1001";                  end += "12312359";              }
Magic Number,QuantConnect.Data.Custom,DailyFx,C:\repos\QuantConnect_Lean\Common\Data\Custom\DailyFx.cs,GetQuarter,The following statement contains a magic number: if (date.Month < 4)              {                  start += "0101";                  end += "03312359";              }              else if (date.Month < 7)              {                  start += "0401";                  end += "06302359";              }              else if (date.Month < 10)              {                  start += "0701";                  end += "09302359";              }              else              {                  start += "1001";                  end += "12312359";              }
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,Reader,The following statement contains a magic number: try              {                  // "Scaffold" code - simple check to see how the data is formatted and decide how to parse appropriately                  // TODO: Once all FX is reprocessed to QuoteBars' remove this check                  if (csvLength > 5)                  {                      switch (config.SecurityType)                      {                          case SecurityType.Equity:                              return ParseEquity(config' line' date);                            case SecurityType.Forex:                          case SecurityType.Crypto:                              return ParseForex(config' line' date);                            case SecurityType.Cfd:                              return ParseCfd(config' line' date);                            case SecurityType.Option:                              return ParseOption(config' line' date);                            case SecurityType.Future:                              return ParseFuture(config' line' date);                                                }                  }                    // Parse as trade                  return ParseTradeAsQuoteBar(config' date' line);              }              catch (Exception err)              {                  Log.Error("QuoteBar.Reader(): Error parsing line: '{0}'' Symbol: {1}' SecurityType: {2}' Resolution: {3}' Date: {4}' Message: {5}"'                       line' config.Symbol.Value' config.SecurityType' config.Resolution' date.ToString("yyyy-MM-dd")' err);              }
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseTradeAsQuoteBar,The following statement contains a magic number: var csv = line.ToCsv(5);
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseTradeAsQuoteBar,The following statement contains a magic number: var bid = new Bar              {                  Open = csv[1].ToDecimal()'                  High = csv[2].ToDecimal()'                  Low = csv[3].ToDecimal()'                  Close = csv[4].ToDecimal()              };
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseTradeAsQuoteBar,The following statement contains a magic number: var bid = new Bar              {                  Open = csv[1].ToDecimal()'                  High = csv[2].ToDecimal()'                  Low = csv[3].ToDecimal()'                  Close = csv[4].ToDecimal()              };
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseTradeAsQuoteBar,The following statement contains a magic number: var bid = new Bar              {                  Open = csv[1].ToDecimal()'                  High = csv[2].ToDecimal()'                  Low = csv[3].ToDecimal()'                  Close = csv[4].ToDecimal()              };
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseTradeAsQuoteBar,The following statement contains a magic number: var ask = new Bar              {                  Open = csv[1].ToDecimal()'                  High = csv[2].ToDecimal()'                  Low = csv[3].ToDecimal()'                  Close = csv[4].ToDecimal()              };
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseTradeAsQuoteBar,The following statement contains a magic number: var ask = new Bar              {                  Open = csv[1].ToDecimal()'                  High = csv[2].ToDecimal()'                  Low = csv[3].ToDecimal()'                  Close = csv[4].ToDecimal()              };
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseTradeAsQuoteBar,The following statement contains a magic number: var ask = new Bar              {                  Open = csv[1].ToDecimal()'                  High = csv[2].ToDecimal()'                  Low = csv[3].ToDecimal()'                  Close = csv[4].ToDecimal()              };
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The following statement contains a magic number: var csv = line.ToCsv(10);
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The following statement contains a magic number: if (csv[1].Length != 0 || csv[2].Length != 0 || csv[3].Length != 0 || csv[4].Length != 0)              {                  quoteBar.Bid = new Bar                  {                      Open = config.GetNormalizedPrice(csv[1].ToDecimal() * scaleFactor)'                      High = config.GetNormalizedPrice(csv[2].ToDecimal() * scaleFactor)'                      Low = config.GetNormalizedPrice(csv[3].ToDecimal() * scaleFactor)'                      Close = config.GetNormalizedPrice(csv[4].ToDecimal() * scaleFactor)                  };                  quoteBar.LastBidSize = csv[5].ToDecimal();              }              else              {                  quoteBar.Bid = null;              }
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The following statement contains a magic number: if (csv[1].Length != 0 || csv[2].Length != 0 || csv[3].Length != 0 || csv[4].Length != 0)              {                  quoteBar.Bid = new Bar                  {                      Open = config.GetNormalizedPrice(csv[1].ToDecimal() * scaleFactor)'                      High = config.GetNormalizedPrice(csv[2].ToDecimal() * scaleFactor)'                      Low = config.GetNormalizedPrice(csv[3].ToDecimal() * scaleFactor)'                      Close = config.GetNormalizedPrice(csv[4].ToDecimal() * scaleFactor)                  };                  quoteBar.LastBidSize = csv[5].ToDecimal();              }              else              {                  quoteBar.Bid = null;              }
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The following statement contains a magic number: if (csv[1].Length != 0 || csv[2].Length != 0 || csv[3].Length != 0 || csv[4].Length != 0)              {                  quoteBar.Bid = new Bar                  {                      Open = config.GetNormalizedPrice(csv[1].ToDecimal() * scaleFactor)'                      High = config.GetNormalizedPrice(csv[2].ToDecimal() * scaleFactor)'                      Low = config.GetNormalizedPrice(csv[3].ToDecimal() * scaleFactor)'                      Close = config.GetNormalizedPrice(csv[4].ToDecimal() * scaleFactor)                  };                  quoteBar.LastBidSize = csv[5].ToDecimal();              }              else              {                  quoteBar.Bid = null;              }
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The following statement contains a magic number: if (csv[1].Length != 0 || csv[2].Length != 0 || csv[3].Length != 0 || csv[4].Length != 0)              {                  quoteBar.Bid = new Bar                  {                      Open = config.GetNormalizedPrice(csv[1].ToDecimal() * scaleFactor)'                      High = config.GetNormalizedPrice(csv[2].ToDecimal() * scaleFactor)'                      Low = config.GetNormalizedPrice(csv[3].ToDecimal() * scaleFactor)'                      Close = config.GetNormalizedPrice(csv[4].ToDecimal() * scaleFactor)                  };                  quoteBar.LastBidSize = csv[5].ToDecimal();              }              else              {                  quoteBar.Bid = null;              }
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The following statement contains a magic number: if (csv[1].Length != 0 || csv[2].Length != 0 || csv[3].Length != 0 || csv[4].Length != 0)              {                  quoteBar.Bid = new Bar                  {                      Open = config.GetNormalizedPrice(csv[1].ToDecimal() * scaleFactor)'                      High = config.GetNormalizedPrice(csv[2].ToDecimal() * scaleFactor)'                      Low = config.GetNormalizedPrice(csv[3].ToDecimal() * scaleFactor)'                      Close = config.GetNormalizedPrice(csv[4].ToDecimal() * scaleFactor)                  };                  quoteBar.LastBidSize = csv[5].ToDecimal();              }              else              {                  quoteBar.Bid = null;              }
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The following statement contains a magic number: if (csv[1].Length != 0 || csv[2].Length != 0 || csv[3].Length != 0 || csv[4].Length != 0)              {                  quoteBar.Bid = new Bar                  {                      Open = config.GetNormalizedPrice(csv[1].ToDecimal() * scaleFactor)'                      High = config.GetNormalizedPrice(csv[2].ToDecimal() * scaleFactor)'                      Low = config.GetNormalizedPrice(csv[3].ToDecimal() * scaleFactor)'                      Close = config.GetNormalizedPrice(csv[4].ToDecimal() * scaleFactor)                  };                  quoteBar.LastBidSize = csv[5].ToDecimal();              }              else              {                  quoteBar.Bid = null;              }
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The following statement contains a magic number: if (csv[1].Length != 0 || csv[2].Length != 0 || csv[3].Length != 0 || csv[4].Length != 0)              {                  quoteBar.Bid = new Bar                  {                      Open = config.GetNormalizedPrice(csv[1].ToDecimal() * scaleFactor)'                      High = config.GetNormalizedPrice(csv[2].ToDecimal() * scaleFactor)'                      Low = config.GetNormalizedPrice(csv[3].ToDecimal() * scaleFactor)'                      Close = config.GetNormalizedPrice(csv[4].ToDecimal() * scaleFactor)                  };                  quoteBar.LastBidSize = csv[5].ToDecimal();              }              else              {                  quoteBar.Bid = null;              }
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The following statement contains a magic number: if (csv[6].Length != 0 || csv[7].Length != 0 || csv[8].Length != 0 || csv[9].Length != 0)              {                  quoteBar.Ask = new Bar                  {                      Open = config.GetNormalizedPrice(csv[6].ToDecimal() * scaleFactor)'                      High = config.GetNormalizedPrice(csv[7].ToDecimal() * scaleFactor)'                      Low = config.GetNormalizedPrice(csv[8].ToDecimal() * scaleFactor)'                      Close = config.GetNormalizedPrice(csv[9].ToDecimal() * scaleFactor)                  };                  quoteBar.LastAskSize = csv[10].ToDecimal();              }              else              {                  quoteBar.Ask = null;              }
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The following statement contains a magic number: if (csv[6].Length != 0 || csv[7].Length != 0 || csv[8].Length != 0 || csv[9].Length != 0)              {                  quoteBar.Ask = new Bar                  {                      Open = config.GetNormalizedPrice(csv[6].ToDecimal() * scaleFactor)'                      High = config.GetNormalizedPrice(csv[7].ToDecimal() * scaleFactor)'                      Low = config.GetNormalizedPrice(csv[8].ToDecimal() * scaleFactor)'                      Close = config.GetNormalizedPrice(csv[9].ToDecimal() * scaleFactor)                  };                  quoteBar.LastAskSize = csv[10].ToDecimal();              }              else              {                  quoteBar.Ask = null;              }
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The following statement contains a magic number: if (csv[6].Length != 0 || csv[7].Length != 0 || csv[8].Length != 0 || csv[9].Length != 0)              {                  quoteBar.Ask = new Bar                  {                      Open = config.GetNormalizedPrice(csv[6].ToDecimal() * scaleFactor)'                      High = config.GetNormalizedPrice(csv[7].ToDecimal() * scaleFactor)'                      Low = config.GetNormalizedPrice(csv[8].ToDecimal() * scaleFactor)'                      Close = config.GetNormalizedPrice(csv[9].ToDecimal() * scaleFactor)                  };                  quoteBar.LastAskSize = csv[10].ToDecimal();              }              else              {                  quoteBar.Ask = null;              }
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The following statement contains a magic number: if (csv[6].Length != 0 || csv[7].Length != 0 || csv[8].Length != 0 || csv[9].Length != 0)              {                  quoteBar.Ask = new Bar                  {                      Open = config.GetNormalizedPrice(csv[6].ToDecimal() * scaleFactor)'                      High = config.GetNormalizedPrice(csv[7].ToDecimal() * scaleFactor)'                      Low = config.GetNormalizedPrice(csv[8].ToDecimal() * scaleFactor)'                      Close = config.GetNormalizedPrice(csv[9].ToDecimal() * scaleFactor)                  };                  quoteBar.LastAskSize = csv[10].ToDecimal();              }              else              {                  quoteBar.Ask = null;              }
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The following statement contains a magic number: if (csv[6].Length != 0 || csv[7].Length != 0 || csv[8].Length != 0 || csv[9].Length != 0)              {                  quoteBar.Ask = new Bar                  {                      Open = config.GetNormalizedPrice(csv[6].ToDecimal() * scaleFactor)'                      High = config.GetNormalizedPrice(csv[7].ToDecimal() * scaleFactor)'                      Low = config.GetNormalizedPrice(csv[8].ToDecimal() * scaleFactor)'                      Close = config.GetNormalizedPrice(csv[9].ToDecimal() * scaleFactor)                  };                  quoteBar.LastAskSize = csv[10].ToDecimal();              }              else              {                  quoteBar.Ask = null;              }
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The following statement contains a magic number: if (csv[6].Length != 0 || csv[7].Length != 0 || csv[8].Length != 0 || csv[9].Length != 0)              {                  quoteBar.Ask = new Bar                  {                      Open = config.GetNormalizedPrice(csv[6].ToDecimal() * scaleFactor)'                      High = config.GetNormalizedPrice(csv[7].ToDecimal() * scaleFactor)'                      Low = config.GetNormalizedPrice(csv[8].ToDecimal() * scaleFactor)'                      Close = config.GetNormalizedPrice(csv[9].ToDecimal() * scaleFactor)                  };                  quoteBar.LastAskSize = csv[10].ToDecimal();              }              else              {                  quoteBar.Ask = null;              }
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The following statement contains a magic number: if (csv[6].Length != 0 || csv[7].Length != 0 || csv[8].Length != 0 || csv[9].Length != 0)              {                  quoteBar.Ask = new Bar                  {                      Open = config.GetNormalizedPrice(csv[6].ToDecimal() * scaleFactor)'                      High = config.GetNormalizedPrice(csv[7].ToDecimal() * scaleFactor)'                      Low = config.GetNormalizedPrice(csv[8].ToDecimal() * scaleFactor)'                      Close = config.GetNormalizedPrice(csv[9].ToDecimal() * scaleFactor)                  };                  quoteBar.LastAskSize = csv[10].ToDecimal();              }              else              {                  quoteBar.Ask = null;              }
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The following statement contains a magic number: if (csv[6].Length != 0 || csv[7].Length != 0 || csv[8].Length != 0 || csv[9].Length != 0)              {                  quoteBar.Ask = new Bar                  {                      Open = config.GetNormalizedPrice(csv[6].ToDecimal() * scaleFactor)'                      High = config.GetNormalizedPrice(csv[7].ToDecimal() * scaleFactor)'                      Low = config.GetNormalizedPrice(csv[8].ToDecimal() * scaleFactor)'                      Close = config.GetNormalizedPrice(csv[9].ToDecimal() * scaleFactor)                  };                  quoteBar.LastAskSize = csv[10].ToDecimal();              }              else              {                  quoteBar.Ask = null;              }
Magic Number,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,ParseQuote,The following statement contains a magic number: if (csv[6].Length != 0 || csv[7].Length != 0 || csv[8].Length != 0 || csv[9].Length != 0)              {                  quoteBar.Ask = new Bar                  {                      Open = config.GetNormalizedPrice(csv[6].ToDecimal() * scaleFactor)'                      High = config.GetNormalizedPrice(csv[7].ToDecimal() * scaleFactor)'                      Low = config.GetNormalizedPrice(csv[8].ToDecimal() * scaleFactor)'                      Close = config.GetNormalizedPrice(csv[9].ToDecimal() * scaleFactor)                  };                  quoteBar.LastAskSize = csv[10].ToDecimal();              }              else              {                  quoteBar.Ask = null;              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: Value = (bid + ask) / 2;
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: Value = (BidPrice + AskPrice) / 2;
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: AskPrice = Convert.ToDecimal(csv[2]' CultureInfo.InvariantCulture);
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: Quantity = csv[2].ToDecimal();
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: Exchange = csv[3].Trim();
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: SaleCondition = csv[4];
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: Suspicious = csv[5].ToInt32() == 1;
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following statement contains a magic number: try              {                  DataType = MarketDataType.Tick;                    // Which security type is this data feed:                  var scaleFactor = GetScaleFactor(config.SecurityType);                    switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseEquity,The following statement contains a magic number: var csv = line.ToCsv(6);
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseEquity,The following statement contains a magic number: tradeBar.High = config.GetNormalizedPrice(csv[2].ToDecimal()*_scaleFactor);
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseEquity,The following statement contains a magic number: tradeBar.Low = config.GetNormalizedPrice(csv[3].ToDecimal()*_scaleFactor);
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseEquity,The following statement contains a magic number: tradeBar.Close = config.GetNormalizedPrice(csv[4].ToDecimal()*_scaleFactor);
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseEquity,The following statement contains a magic number: tradeBar.Volume = csv[5].ToDecimal();
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseForex,The following statement contains a magic number: var csv = line.ToCsv(5);
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseForex,The following statement contains a magic number: tradeBar.High = csv[2].ToDecimal();
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseForex,The following statement contains a magic number: tradeBar.Low = csv[3].ToDecimal();
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseForex,The following statement contains a magic number: tradeBar.Close = csv[4].ToDecimal();
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseCrypto,The following statement contains a magic number: var csv = line.ToCsv(6);
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseCrypto,The following statement contains a magic number: tradeBar.High = csv[2].ToDecimal();
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseCrypto,The following statement contains a magic number: tradeBar.Low = csv[3].ToDecimal();
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseCrypto,The following statement contains a magic number: tradeBar.Close = csv[4].ToDecimal();
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseCrypto,The following statement contains a magic number: tradeBar.Volume = csv[5].ToDecimal();
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseOption,The following statement contains a magic number: var csv = line.ToCsv(6);
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseOption,The following statement contains a magic number: tradeBar.High = config.GetNormalizedPrice(csv[2].ToDecimal() * _scaleFactor);
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseOption,The following statement contains a magic number: tradeBar.Low = config.GetNormalizedPrice(csv[3].ToDecimal() * _scaleFactor);
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseOption,The following statement contains a magic number: tradeBar.Close = config.GetNormalizedPrice(csv[4].ToDecimal() * _scaleFactor);
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseOption,The following statement contains a magic number: tradeBar.Volume = csv[5].ToDecimal();
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseFuture,The following statement contains a magic number: var csv = line.ToCsv(6);
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseFuture,The following statement contains a magic number: tradeBar.High = config.GetNormalizedPrice(csv[2].ToDecimal());
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseFuture,The following statement contains a magic number: tradeBar.Low = config.GetNormalizedPrice(csv[3].ToDecimal());
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseFuture,The following statement contains a magic number: tradeBar.Close = config.GetNormalizedPrice(csv[4].ToDecimal());
Magic Number,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,ParseFuture,The following statement contains a magic number: tradeBar.Volume = csv[5].ToDecimal();
Magic Number,QuantConnect.Data,SubscriptionDataSource,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionDataSource.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return ((Source != null ? Source.GetHashCode() : 0)*397) ^ (int) TransportMedium;              }
Magic Number,QuantConnect.Data,SubscriptionDataConfig,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionDataConfig.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = _sid.GetHashCode();                  hashCode = (hashCode*397) ^ Type.GetHashCode();                  hashCode = (hashCode*397) ^ (int) TickType;                  hashCode = (hashCode*397) ^ (int) Resolution;                  hashCode = (hashCode*397) ^ FillDataForward.GetHashCode();                  hashCode = (hashCode*397) ^ ExtendedMarketHours.GetHashCode();                  hashCode = (hashCode*397) ^ IsInternalFeed.GetHashCode();                  hashCode = (hashCode*397) ^ IsCustomData.GetHashCode();                  hashCode = (hashCode*397) ^ DataTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ ExchangeTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ IsFilteredSubscription.GetHashCode();                  return hashCode;              }
Magic Number,QuantConnect.Data,SubscriptionDataConfig,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionDataConfig.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = _sid.GetHashCode();                  hashCode = (hashCode*397) ^ Type.GetHashCode();                  hashCode = (hashCode*397) ^ (int) TickType;                  hashCode = (hashCode*397) ^ (int) Resolution;                  hashCode = (hashCode*397) ^ FillDataForward.GetHashCode();                  hashCode = (hashCode*397) ^ ExtendedMarketHours.GetHashCode();                  hashCode = (hashCode*397) ^ IsInternalFeed.GetHashCode();                  hashCode = (hashCode*397) ^ IsCustomData.GetHashCode();                  hashCode = (hashCode*397) ^ DataTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ ExchangeTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ IsFilteredSubscription.GetHashCode();                  return hashCode;              }
Magic Number,QuantConnect.Data,SubscriptionDataConfig,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionDataConfig.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = _sid.GetHashCode();                  hashCode = (hashCode*397) ^ Type.GetHashCode();                  hashCode = (hashCode*397) ^ (int) TickType;                  hashCode = (hashCode*397) ^ (int) Resolution;                  hashCode = (hashCode*397) ^ FillDataForward.GetHashCode();                  hashCode = (hashCode*397) ^ ExtendedMarketHours.GetHashCode();                  hashCode = (hashCode*397) ^ IsInternalFeed.GetHashCode();                  hashCode = (hashCode*397) ^ IsCustomData.GetHashCode();                  hashCode = (hashCode*397) ^ DataTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ ExchangeTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ IsFilteredSubscription.GetHashCode();                  return hashCode;              }
Magic Number,QuantConnect.Data,SubscriptionDataConfig,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionDataConfig.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = _sid.GetHashCode();                  hashCode = (hashCode*397) ^ Type.GetHashCode();                  hashCode = (hashCode*397) ^ (int) TickType;                  hashCode = (hashCode*397) ^ (int) Resolution;                  hashCode = (hashCode*397) ^ FillDataForward.GetHashCode();                  hashCode = (hashCode*397) ^ ExtendedMarketHours.GetHashCode();                  hashCode = (hashCode*397) ^ IsInternalFeed.GetHashCode();                  hashCode = (hashCode*397) ^ IsCustomData.GetHashCode();                  hashCode = (hashCode*397) ^ DataTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ ExchangeTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ IsFilteredSubscription.GetHashCode();                  return hashCode;              }
Magic Number,QuantConnect.Data,SubscriptionDataConfig,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionDataConfig.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = _sid.GetHashCode();                  hashCode = (hashCode*397) ^ Type.GetHashCode();                  hashCode = (hashCode*397) ^ (int) TickType;                  hashCode = (hashCode*397) ^ (int) Resolution;                  hashCode = (hashCode*397) ^ FillDataForward.GetHashCode();                  hashCode = (hashCode*397) ^ ExtendedMarketHours.GetHashCode();                  hashCode = (hashCode*397) ^ IsInternalFeed.GetHashCode();                  hashCode = (hashCode*397) ^ IsCustomData.GetHashCode();                  hashCode = (hashCode*397) ^ DataTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ ExchangeTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ IsFilteredSubscription.GetHashCode();                  return hashCode;              }
Magic Number,QuantConnect.Data,SubscriptionDataConfig,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionDataConfig.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = _sid.GetHashCode();                  hashCode = (hashCode*397) ^ Type.GetHashCode();                  hashCode = (hashCode*397) ^ (int) TickType;                  hashCode = (hashCode*397) ^ (int) Resolution;                  hashCode = (hashCode*397) ^ FillDataForward.GetHashCode();                  hashCode = (hashCode*397) ^ ExtendedMarketHours.GetHashCode();                  hashCode = (hashCode*397) ^ IsInternalFeed.GetHashCode();                  hashCode = (hashCode*397) ^ IsCustomData.GetHashCode();                  hashCode = (hashCode*397) ^ DataTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ ExchangeTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ IsFilteredSubscription.GetHashCode();                  return hashCode;              }
Magic Number,QuantConnect.Data,SubscriptionDataConfig,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionDataConfig.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = _sid.GetHashCode();                  hashCode = (hashCode*397) ^ Type.GetHashCode();                  hashCode = (hashCode*397) ^ (int) TickType;                  hashCode = (hashCode*397) ^ (int) Resolution;                  hashCode = (hashCode*397) ^ FillDataForward.GetHashCode();                  hashCode = (hashCode*397) ^ ExtendedMarketHours.GetHashCode();                  hashCode = (hashCode*397) ^ IsInternalFeed.GetHashCode();                  hashCode = (hashCode*397) ^ IsCustomData.GetHashCode();                  hashCode = (hashCode*397) ^ DataTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ ExchangeTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ IsFilteredSubscription.GetHashCode();                  return hashCode;              }
Magic Number,QuantConnect.Data,SubscriptionDataConfig,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionDataConfig.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = _sid.GetHashCode();                  hashCode = (hashCode*397) ^ Type.GetHashCode();                  hashCode = (hashCode*397) ^ (int) TickType;                  hashCode = (hashCode*397) ^ (int) Resolution;                  hashCode = (hashCode*397) ^ FillDataForward.GetHashCode();                  hashCode = (hashCode*397) ^ ExtendedMarketHours.GetHashCode();                  hashCode = (hashCode*397) ^ IsInternalFeed.GetHashCode();                  hashCode = (hashCode*397) ^ IsCustomData.GetHashCode();                  hashCode = (hashCode*397) ^ DataTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ ExchangeTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ IsFilteredSubscription.GetHashCode();                  return hashCode;              }
Magic Number,QuantConnect.Data,SubscriptionDataConfig,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionDataConfig.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = _sid.GetHashCode();                  hashCode = (hashCode*397) ^ Type.GetHashCode();                  hashCode = (hashCode*397) ^ (int) TickType;                  hashCode = (hashCode*397) ^ (int) Resolution;                  hashCode = (hashCode*397) ^ FillDataForward.GetHashCode();                  hashCode = (hashCode*397) ^ ExtendedMarketHours.GetHashCode();                  hashCode = (hashCode*397) ^ IsInternalFeed.GetHashCode();                  hashCode = (hashCode*397) ^ IsCustomData.GetHashCode();                  hashCode = (hashCode*397) ^ DataTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ ExchangeTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ IsFilteredSubscription.GetHashCode();                  return hashCode;              }
Magic Number,QuantConnect.Data,SubscriptionDataConfig,C:\repos\QuantConnect_Lean\Common\Data\SubscriptionDataConfig.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = _sid.GetHashCode();                  hashCode = (hashCode*397) ^ Type.GetHashCode();                  hashCode = (hashCode*397) ^ (int) TickType;                  hashCode = (hashCode*397) ^ (int) Resolution;                  hashCode = (hashCode*397) ^ FillDataForward.GetHashCode();                  hashCode = (hashCode*397) ^ ExtendedMarketHours.GetHashCode();                  hashCode = (hashCode*397) ^ IsInternalFeed.GetHashCode();                  hashCode = (hashCode*397) ^ IsCustomData.GetHashCode();                  hashCode = (hashCode*397) ^ DataTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ ExchangeTimeZone.GetHashCode();                  hashCode = (hashCode*397) ^ IsFilteredSubscription.GetHashCode();                  return hashCode;              }
Magic Number,QuantConnect.Data.UniverseSelection,CoarseFundamental,C:\repos\QuantConnect_Lean\Common\Data\UniverseSelection\CoarseFundamental.cs,Reader,The following statement contains a magic number: try              {                  var csv = line.Split(''');                  var coarse = new CoarseFundamental                  {                      Symbol = new Symbol(SecurityIdentifier.Parse(csv[0])' csv[1])'                      Time = date'                      Market = config.Market'                      Value = csv[2].ToDecimal()'                      Volume = csv[3].ToInt64()'                      DollarVolume = csv[4].ToDecimal()                  };                    if (csv.Length > 5)                  {                      coarse.HasFundamentalData = Convert.ToBoolean(csv[5]);                  }                    return coarse;              }              catch (Exception)              {                  return null;              }
Magic Number,QuantConnect.Data.UniverseSelection,CoarseFundamental,C:\repos\QuantConnect_Lean\Common\Data\UniverseSelection\CoarseFundamental.cs,Reader,The following statement contains a magic number: try              {                  var csv = line.Split(''');                  var coarse = new CoarseFundamental                  {                      Symbol = new Symbol(SecurityIdentifier.Parse(csv[0])' csv[1])'                      Time = date'                      Market = config.Market'                      Value = csv[2].ToDecimal()'                      Volume = csv[3].ToInt64()'                      DollarVolume = csv[4].ToDecimal()                  };                    if (csv.Length > 5)                  {                      coarse.HasFundamentalData = Convert.ToBoolean(csv[5]);                  }                    return coarse;              }              catch (Exception)              {                  return null;              }
Magic Number,QuantConnect.Data.UniverseSelection,CoarseFundamental,C:\repos\QuantConnect_Lean\Common\Data\UniverseSelection\CoarseFundamental.cs,Reader,The following statement contains a magic number: try              {                  var csv = line.Split(''');                  var coarse = new CoarseFundamental                  {                      Symbol = new Symbol(SecurityIdentifier.Parse(csv[0])' csv[1])'                      Time = date'                      Market = config.Market'                      Value = csv[2].ToDecimal()'                      Volume = csv[3].ToInt64()'                      DollarVolume = csv[4].ToDecimal()                  };                    if (csv.Length > 5)                  {                      coarse.HasFundamentalData = Convert.ToBoolean(csv[5]);                  }                    return coarse;              }              catch (Exception)              {                  return null;              }
Magic Number,QuantConnect.Data.UniverseSelection,CoarseFundamental,C:\repos\QuantConnect_Lean\Common\Data\UniverseSelection\CoarseFundamental.cs,Reader,The following statement contains a magic number: try              {                  var csv = line.Split(''');                  var coarse = new CoarseFundamental                  {                      Symbol = new Symbol(SecurityIdentifier.Parse(csv[0])' csv[1])'                      Time = date'                      Market = config.Market'                      Value = csv[2].ToDecimal()'                      Volume = csv[3].ToInt64()'                      DollarVolume = csv[4].ToDecimal()                  };                    if (csv.Length > 5)                  {                      coarse.HasFundamentalData = Convert.ToBoolean(csv[5]);                  }                    return coarse;              }              catch (Exception)              {                  return null;              }
Magic Number,QuantConnect.Data.UniverseSelection,CoarseFundamental,C:\repos\QuantConnect_Lean\Common\Data\UniverseSelection\CoarseFundamental.cs,Reader,The following statement contains a magic number: try              {                  var csv = line.Split(''');                  var coarse = new CoarseFundamental                  {                      Symbol = new Symbol(SecurityIdentifier.Parse(csv[0])' csv[1])'                      Time = date'                      Market = config.Market'                      Value = csv[2].ToDecimal()'                      Volume = csv[3].ToInt64()'                      DollarVolume = csv[4].ToDecimal()                  };                    if (csv.Length > 5)                  {                      coarse.HasFundamentalData = Convert.ToBoolean(csv[5]);                  }                    return coarse;              }              catch (Exception)              {                  return null;              }
Magic Number,QuantConnect.Data.Auxiliary,FactorFileRow,C:\repos\QuantConnect_Lean\Common\Data\Auxiliary\FactorFileRow.cs,Parse,The following statement contains a magic number: return new FactorFileRow(                  DateTime.ParseExact(csv[0]' DateFormat.EightCharacter' CultureInfo.InvariantCulture' DateTimeStyles.None)'                  decimal.Parse(csv[1]' CultureInfo.InvariantCulture)'                  decimal.Parse(csv[2]' CultureInfo.InvariantCulture)                  );
Magic Number,QuantConnect.Data.Auxiliary,MapFileRow,C:\repos\QuantConnect_Lean\Common\Data\Auxiliary\MapFileRow.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return (Date.GetHashCode() * 397) ^ (MappedSymbol != null ? MappedSymbol.GetHashCode() : 0);              }
Magic Number,QuantConnect.Indicators,IndicatorDataPoint,C:\repos\QuantConnect_Lean\Common\Indicators\IndicatorDataPoint.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return (Value.GetHashCode()*397) ^ Time.GetHashCode();              }
Magic Number,QuantConnect.Orders.Fees,InteractiveBrokersFeeModel,C:\repos\QuantConnect_Lean\Common\Orders\Fees\InteractiveBrokersFeeModel.cs,ProcessForexRateSchedule,The following statement contains a magic number: if (monthlyForexTradeAmountInUSDollars <= 1000000000)      // 1 billion              {                  commissionRate = 0.20m * bp;                  minimumOrderFee = 2.00m;              }              else if (monthlyForexTradeAmountInUSDollars <= 2000000000) // 2 billion              {                  commissionRate = 0.15m * bp;                  minimumOrderFee = 1.50m;              }              else if (monthlyForexTradeAmountInUSDollars <= 5000000000) // 5 billion              {                  commissionRate = 0.10m * bp;                  minimumOrderFee = 1.25m;              }              else              {                  commissionRate = 0.08m * bp;                  minimumOrderFee = 1.00m;              }
Magic Number,QuantConnect.Orders.Fees,InteractiveBrokersFeeModel,C:\repos\QuantConnect_Lean\Common\Orders\Fees\InteractiveBrokersFeeModel.cs,ProcessForexRateSchedule,The following statement contains a magic number: if (monthlyForexTradeAmountInUSDollars <= 1000000000)      // 1 billion              {                  commissionRate = 0.20m * bp;                  minimumOrderFee = 2.00m;              }              else if (monthlyForexTradeAmountInUSDollars <= 2000000000) // 2 billion              {                  commissionRate = 0.15m * bp;                  minimumOrderFee = 1.50m;              }              else if (monthlyForexTradeAmountInUSDollars <= 5000000000) // 5 billion              {                  commissionRate = 0.10m * bp;                  minimumOrderFee = 1.25m;              }              else              {                  commissionRate = 0.08m * bp;                  minimumOrderFee = 1.00m;              }
Magic Number,QuantConnect.Orders.Fees,InteractiveBrokersFeeModel,C:\repos\QuantConnect_Lean\Common\Orders\Fees\InteractiveBrokersFeeModel.cs,ProcessForexRateSchedule,The following statement contains a magic number: if (monthlyForexTradeAmountInUSDollars <= 1000000000)      // 1 billion              {                  commissionRate = 0.20m * bp;                  minimumOrderFee = 2.00m;              }              else if (monthlyForexTradeAmountInUSDollars <= 2000000000) // 2 billion              {                  commissionRate = 0.15m * bp;                  minimumOrderFee = 1.50m;              }              else if (monthlyForexTradeAmountInUSDollars <= 5000000000) // 5 billion              {                  commissionRate = 0.10m * bp;                  minimumOrderFee = 1.25m;              }              else              {                  commissionRate = 0.08m * bp;                  minimumOrderFee = 1.00m;              }
Magic Number,QuantConnect.Orders.Fees,InteractiveBrokersFeeModel,C:\repos\QuantConnect_Lean\Common\Orders\Fees\InteractiveBrokersFeeModel.cs,ProcessOptionsRateSchedule,The following statement contains a magic number: if (monthlyOptionsTradeAmountInContracts <= 10000)                    {                  optionsCommissionFunc = (orderSize' premium) =>                  {                      var commissionRate = premium >= 0.1m ?                                               0.7m :                                               (0.05m <= premium && premium < 0.1m ? 0.5m : 0.25m);                      return Math.Min(orderSize * commissionRate' 1.0m);                                                                          };              }              else if (monthlyOptionsTradeAmountInContracts <= 50000)               {                  optionsCommissionFunc = (orderSize' premium) =>                  {                      var commissionRate = premium >= 0.05m ? 0.5m : 0.25m;                      return Math.Min(orderSize * commissionRate' 1.0m);                  };              }              else if (monthlyOptionsTradeAmountInContracts <= 100000)              {                  optionsCommissionFunc = (orderSize' premium) =>                  {                      var commissionRate = 0.25m;                      return Math.Min(orderSize * commissionRate' 1.0m);                  };              }              else              {                  optionsCommissionFunc = (orderSize' premium) =>                  {                      var commissionRate = 0.15m;                      return Math.Min(orderSize * commissionRate' 1.0m);                  };              }
Magic Number,QuantConnect.Orders.Fees,InteractiveBrokersFeeModel,C:\repos\QuantConnect_Lean\Common\Orders\Fees\InteractiveBrokersFeeModel.cs,ProcessOptionsRateSchedule,The following statement contains a magic number: if (monthlyOptionsTradeAmountInContracts <= 10000)                    {                  optionsCommissionFunc = (orderSize' premium) =>                  {                      var commissionRate = premium >= 0.1m ?                                               0.7m :                                               (0.05m <= premium && premium < 0.1m ? 0.5m : 0.25m);                      return Math.Min(orderSize * commissionRate' 1.0m);                                                                          };              }              else if (monthlyOptionsTradeAmountInContracts <= 50000)               {                  optionsCommissionFunc = (orderSize' premium) =>                  {                      var commissionRate = premium >= 0.05m ? 0.5m : 0.25m;                      return Math.Min(orderSize * commissionRate' 1.0m);                  };              }              else if (monthlyOptionsTradeAmountInContracts <= 100000)              {                  optionsCommissionFunc = (orderSize' premium) =>                  {                      var commissionRate = 0.25m;                      return Math.Min(orderSize * commissionRate' 1.0m);                  };              }              else              {                  optionsCommissionFunc = (orderSize' premium) =>                  {                      var commissionRate = 0.15m;                      return Math.Min(orderSize * commissionRate' 1.0m);                  };              }
Magic Number,QuantConnect.Orders.Fees,InteractiveBrokersFeeModel,C:\repos\QuantConnect_Lean\Common\Orders\Fees\InteractiveBrokersFeeModel.cs,ProcessOptionsRateSchedule,The following statement contains a magic number: if (monthlyOptionsTradeAmountInContracts <= 10000)                    {                  optionsCommissionFunc = (orderSize' premium) =>                  {                      var commissionRate = premium >= 0.1m ?                                               0.7m :                                               (0.05m <= premium && premium < 0.1m ? 0.5m : 0.25m);                      return Math.Min(orderSize * commissionRate' 1.0m);                                                                          };              }              else if (monthlyOptionsTradeAmountInContracts <= 50000)               {                  optionsCommissionFunc = (orderSize' premium) =>                  {                      var commissionRate = premium >= 0.05m ? 0.5m : 0.25m;                      return Math.Min(orderSize * commissionRate' 1.0m);                  };              }              else if (monthlyOptionsTradeAmountInContracts <= 100000)              {                  optionsCommissionFunc = (orderSize' premium) =>                  {                      var commissionRate = 0.25m;                      return Math.Min(orderSize * commissionRate' 1.0m);                  };              }              else              {                  optionsCommissionFunc = (orderSize' premium) =>                  {                      var commissionRate = 0.15m;                      return Math.Min(orderSize * commissionRate' 1.0m);                  };              }
Magic Number,QuantConnect.Orders.Fees,FxcmFeeModel,C:\repos\QuantConnect_Lean\Common\Orders\Fees\FxcmFeeModel.cs,GetOrderFee,The following statement contains a magic number: return Math.Abs(commissionRate*order.AbsoluteQuantity/1000);
Magic Number,QuantConnect.Packets,Controls,C:\repos\QuantConnect_Lean\Common\Packets\Controls.cs,Controls,The following statement contains a magic number: MinuteLimit = 500;
Magic Number,QuantConnect.Packets,Controls,C:\repos\QuantConnect_Lean\Common\Packets\Controls.cs,Controls,The following statement contains a magic number: SecondLimit = 100;
Magic Number,QuantConnect.Packets,Controls,C:\repos\QuantConnect_Lean\Common\Packets\Controls.cs,Controls,The following statement contains a magic number: TickLimit = 30;
Magic Number,QuantConnect.Packets,Controls,C:\repos\QuantConnect_Lean\Common\Packets\Controls.cs,Controls,The following statement contains a magic number: RamAllocation = 1024;
Magic Number,QuantConnect.Packets,Controls,C:\repos\QuantConnect_Lean\Common\Packets\Controls.cs,Controls,The following statement contains a magic number: BacktestLogLimit = 10000;
Magic Number,QuantConnect.Packets,Controls,C:\repos\QuantConnect_Lean\Common\Packets\Controls.cs,Controls,The following statement contains a magic number: DailyLogLimit = 3000000;
Magic Number,QuantConnect.Packets,Controls,C:\repos\QuantConnect_Lean\Common\Packets\Controls.cs,Controls,The following statement contains a magic number: RemainingLogAllowance = 10000;
Magic Number,QuantConnect.Packets,BacktestNodePacket,C:\repos\QuantConnect_Lean\Common\Packets\BacktestNodePacket.cs,BacktestNodePacket,The following statement contains a magic number: Controls = new Controls              {                  MinuteLimit = 500'                  SecondLimit = 100'                  TickLimit = 30              };
Magic Number,QuantConnect.Packets,BacktestNodePacket,C:\repos\QuantConnect_Lean\Common\Packets\BacktestNodePacket.cs,BacktestNodePacket,The following statement contains a magic number: Controls = new Controls              {                  MinuteLimit = 500'                  SecondLimit = 100'                  TickLimit = 30              };
Magic Number,QuantConnect.Packets,BacktestNodePacket,C:\repos\QuantConnect_Lean\Common\Packets\BacktestNodePacket.cs,BacktestNodePacket,The following statement contains a magic number: Controls = new Controls              {                  MinuteLimit = 500'                  SecondLimit = 100'                  TickLimit = 30              };
Magic Number,QuantConnect.Packets,BacktestNodePacket,C:\repos\QuantConnect_Lean\Common\Packets\BacktestNodePacket.cs,BacktestNodePacket,The following statement contains a magic number: Controls = new Controls              {                  MinuteLimit = 500'                  SecondLimit = 100'                  TickLimit = 30              };
Magic Number,QuantConnect.Packets,BacktestNodePacket,C:\repos\QuantConnect_Lean\Common\Packets\BacktestNodePacket.cs,BacktestNodePacket,The following statement contains a magic number: Controls = new Controls              {                  MinuteLimit = 500'                  SecondLimit = 100'                  TickLimit = 30              };
Magic Number,QuantConnect.Packets,BacktestNodePacket,C:\repos\QuantConnect_Lean\Common\Packets\BacktestNodePacket.cs,BacktestNodePacket,The following statement contains a magic number: Controls = new Controls              {                  MinuteLimit = 500'                  SecondLimit = 100'                  TickLimit = 30              };
Magic Number,QuantConnect.Packets,BacktestResultPacket,C:\repos\QuantConnect_Lean\Common\Packets\BacktestResultPacket.cs,BacktestResultPacket,The following statement contains a magic number: try              {                  Progress = Math.Round(progress' 3);                  SessionId = job.SessionId;                  PeriodFinish = job.PeriodFinish;                  PeriodStart = job.PeriodStart;                  CompileId = job.CompileId;                  Channel = job.Channel;                  BacktestId = job.BacktestId;                  Results = results;                  Name = job.Name;                  UserId = job.UserId;                  ProjectId = job.ProjectId;                  SessionId = job.SessionId;                  TradeableDates = job.TradeableDates;              }              catch (Exception err) {                  Log.Error(err);              }
Magic Number,QuantConnect.Packets,LiveNodePacket,C:\repos\QuantConnect_Lean\Common\Packets\LiveNodePacket.cs,LiveNodePacket,The following statement contains a magic number: Controls = new Controls              {                  MinuteLimit = 100'                  SecondLimit = 50'                  TickLimit = 25'                  RamAllocation = 512              };
Magic Number,QuantConnect.Packets,LiveNodePacket,C:\repos\QuantConnect_Lean\Common\Packets\LiveNodePacket.cs,LiveNodePacket,The following statement contains a magic number: Controls = new Controls              {                  MinuteLimit = 100'                  SecondLimit = 50'                  TickLimit = 25'                  RamAllocation = 512              };
Magic Number,QuantConnect.Packets,LiveNodePacket,C:\repos\QuantConnect_Lean\Common\Packets\LiveNodePacket.cs,LiveNodePacket,The following statement contains a magic number: Controls = new Controls              {                  MinuteLimit = 100'                  SecondLimit = 50'                  TickLimit = 25'                  RamAllocation = 512              };
Magic Number,QuantConnect.Packets,LiveNodePacket,C:\repos\QuantConnect_Lean\Common\Packets\LiveNodePacket.cs,LiveNodePacket,The following statement contains a magic number: Controls = new Controls              {                  MinuteLimit = 100'                  SecondLimit = 50'                  TickLimit = 25'                  RamAllocation = 512              };
Magic Number,QuantConnect.Packets,MarketHours,C:\repos\QuantConnect_Lean\Common\Packets\MarketTodayPacket.cs,MarketHours,The following statement contains a magic number: if (defaultEnd == 24)              {                  // when we mark it as the end of the day other code that relies on .TimeOfDay has issues                  End = End.AddTicks(-1);              }
Magic Number,QuantConnect.Scheduling,ScheduleManager,C:\repos\QuantConnect_Lean\Common\Scheduling\ScheduleManager.cs,On,The following statement contains a magic number: var exampleTimes = eventTimes.Take(3)                      .Select(x => x.ToString())                      .ToArray();
Magic Number,QuantConnect.Securities.Forex,Forex,C:\repos\QuantConnect_Lean\Common\Securities\Forex\Forex.cs,DecomposeCurrencyPair,The following statement contains a magic number: if (currencyPair == null || currencyPair.Length != 6)              {                  throw new ArgumentException("Currency pairs must be exactly 6 characters: " + currencyPair);              }
Magic Number,QuantConnect.Securities.Forex,Forex,C:\repos\QuantConnect_Lean\Common\Securities\Forex\Forex.cs,DecomposeCurrencyPair,The following statement contains a magic number: baseCurrency = currencyPair.Substring(0' 3);
Magic Number,QuantConnect.Securities.Forex,Forex,C:\repos\QuantConnect_Lean\Common\Securities\Forex\Forex.cs,DecomposeCurrencyPair,The following statement contains a magic number: quoteCurrency = currencyPair.Substring(3);
Magic Number,QuantConnect.Statistics,PortfolioStatistics,C:\repos\QuantConnect_Lean\Common\Statistics\PortfolioStatistics.cs,PortfolioStatistics,The following statement contains a magic number: var fractionOfYears = (decimal) (equity.Keys.LastOrDefault() - equity.Keys.FirstOrDefault()).TotalDays / 365;
Magic Number,QuantConnect.Statistics,PortfolioStatistics,C:\repos\QuantConnect_Lean\Common\Statistics\PortfolioStatistics.cs,PortfolioStatistics,The following statement contains a magic number: Drawdown = DrawdownPercent(equity' 3);
Magic Number,QuantConnect.Statistics,PortfolioStatistics,C:\repos\QuantConnect_Lean\Common\Statistics\PortfolioStatistics.cs,PortfolioStatistics,The following statement contains a magic number: TrackingError = correlation.IsNaNOrZero() || benchmarkAnnualVariance.IsNaNOrZero() ? 0 :                  (decimal)Math.Sqrt((double)AnnualVariance - 2 * correlation * (double)AnnualStandardDeviation * Math.Sqrt(benchmarkAnnualVariance) + benchmarkAnnualVariance);
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetAlgorithmPerformance,The following statement contains a magic number: performance.Values.ToList().ForEach(i => listPerformance.Add((double)(i / 100)));
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetRollingPerformances,The following statement contains a magic number: var monthPeriods = new[] { 1' 3' 6' 12 };
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetRollingPerformances,The following statement contains a magic number: var monthPeriods = new[] { 1' 3' 6' 12 };
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetRollingPerformances,The following statement contains a magic number: var monthPeriods = new[] { 1' 3' 6' 12 };
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The following statement contains a magic number: return new Dictionary<string' string>               {                   { "Total Trades"' totalTransactions.ToString(CultureInfo.InvariantCulture) }'                  { "Average Win"' Math.Round(totalPerformance.PortfolioStatistics.AverageWinRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%"  }'                  { "Average Loss"' Math.Round(totalPerformance.PortfolioStatistics.AverageLossRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Compounding Annual Return"' Math.Round(totalPerformance.PortfolioStatistics.CompoundingAnnualReturn.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Drawdown"' Math.Round(totalPerformance.PortfolioStatistics.Drawdown.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Expectancy"' Math.Round(totalPerformance.PortfolioStatistics.Expectancy' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Net Profit"' Math.Round(totalPerformance.PortfolioStatistics.TotalNetProfit.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%"}'                  { "Sharpe Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.SharpeRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Loss Rate"' Math.Round(totalPerformance.PortfolioStatistics.LossRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Win Rate"' Math.Round(totalPerformance.PortfolioStatistics.WinRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                   { "Profit-Loss Ratio"' Math.Round(totalPerformance.PortfolioStatistics.ProfitLossRatio' 2).ToString(CultureInfo.InvariantCulture) }'                  { "Alpha"' Math.Round((double)totalPerformance.PortfolioStatistics.Alpha' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Beta"' Math.Round((double)totalPerformance.PortfolioStatistics.Beta' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Standard Deviation"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualStandardDeviation' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Variance"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualVariance' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Information Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.InformationRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Tracking Error"' Math.Round((double)totalPerformance.PortfolioStatistics.TrackingError' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Treynor Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.TreynorRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Total Fees"' "$" + totalFees.ToString("0.00"' CultureInfo.InvariantCulture) }              };
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The following statement contains a magic number: return new Dictionary<string' string>               {                   { "Total Trades"' totalTransactions.ToString(CultureInfo.InvariantCulture) }'                  { "Average Win"' Math.Round(totalPerformance.PortfolioStatistics.AverageWinRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%"  }'                  { "Average Loss"' Math.Round(totalPerformance.PortfolioStatistics.AverageLossRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Compounding Annual Return"' Math.Round(totalPerformance.PortfolioStatistics.CompoundingAnnualReturn.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Drawdown"' Math.Round(totalPerformance.PortfolioStatistics.Drawdown.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Expectancy"' Math.Round(totalPerformance.PortfolioStatistics.Expectancy' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Net Profit"' Math.Round(totalPerformance.PortfolioStatistics.TotalNetProfit.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%"}'                  { "Sharpe Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.SharpeRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Loss Rate"' Math.Round(totalPerformance.PortfolioStatistics.LossRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Win Rate"' Math.Round(totalPerformance.PortfolioStatistics.WinRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                   { "Profit-Loss Ratio"' Math.Round(totalPerformance.PortfolioStatistics.ProfitLossRatio' 2).ToString(CultureInfo.InvariantCulture) }'                  { "Alpha"' Math.Round((double)totalPerformance.PortfolioStatistics.Alpha' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Beta"' Math.Round((double)totalPerformance.PortfolioStatistics.Beta' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Standard Deviation"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualStandardDeviation' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Variance"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualVariance' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Information Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.InformationRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Tracking Error"' Math.Round((double)totalPerformance.PortfolioStatistics.TrackingError' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Treynor Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.TreynorRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Total Fees"' "$" + totalFees.ToString("0.00"' CultureInfo.InvariantCulture) }              };
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The following statement contains a magic number: return new Dictionary<string' string>               {                   { "Total Trades"' totalTransactions.ToString(CultureInfo.InvariantCulture) }'                  { "Average Win"' Math.Round(totalPerformance.PortfolioStatistics.AverageWinRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%"  }'                  { "Average Loss"' Math.Round(totalPerformance.PortfolioStatistics.AverageLossRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Compounding Annual Return"' Math.Round(totalPerformance.PortfolioStatistics.CompoundingAnnualReturn.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Drawdown"' Math.Round(totalPerformance.PortfolioStatistics.Drawdown.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Expectancy"' Math.Round(totalPerformance.PortfolioStatistics.Expectancy' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Net Profit"' Math.Round(totalPerformance.PortfolioStatistics.TotalNetProfit.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%"}'                  { "Sharpe Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.SharpeRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Loss Rate"' Math.Round(totalPerformance.PortfolioStatistics.LossRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Win Rate"' Math.Round(totalPerformance.PortfolioStatistics.WinRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                   { "Profit-Loss Ratio"' Math.Round(totalPerformance.PortfolioStatistics.ProfitLossRatio' 2).ToString(CultureInfo.InvariantCulture) }'                  { "Alpha"' Math.Round((double)totalPerformance.PortfolioStatistics.Alpha' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Beta"' Math.Round((double)totalPerformance.PortfolioStatistics.Beta' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Standard Deviation"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualStandardDeviation' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Variance"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualVariance' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Information Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.InformationRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Tracking Error"' Math.Round((double)totalPerformance.PortfolioStatistics.TrackingError' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Treynor Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.TreynorRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Total Fees"' "$" + totalFees.ToString("0.00"' CultureInfo.InvariantCulture) }              };
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The following statement contains a magic number: return new Dictionary<string' string>               {                   { "Total Trades"' totalTransactions.ToString(CultureInfo.InvariantCulture) }'                  { "Average Win"' Math.Round(totalPerformance.PortfolioStatistics.AverageWinRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%"  }'                  { "Average Loss"' Math.Round(totalPerformance.PortfolioStatistics.AverageLossRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Compounding Annual Return"' Math.Round(totalPerformance.PortfolioStatistics.CompoundingAnnualReturn.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Drawdown"' Math.Round(totalPerformance.PortfolioStatistics.Drawdown.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Expectancy"' Math.Round(totalPerformance.PortfolioStatistics.Expectancy' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Net Profit"' Math.Round(totalPerformance.PortfolioStatistics.TotalNetProfit.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%"}'                  { "Sharpe Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.SharpeRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Loss Rate"' Math.Round(totalPerformance.PortfolioStatistics.LossRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Win Rate"' Math.Round(totalPerformance.PortfolioStatistics.WinRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                   { "Profit-Loss Ratio"' Math.Round(totalPerformance.PortfolioStatistics.ProfitLossRatio' 2).ToString(CultureInfo.InvariantCulture) }'                  { "Alpha"' Math.Round((double)totalPerformance.PortfolioStatistics.Alpha' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Beta"' Math.Round((double)totalPerformance.PortfolioStatistics.Beta' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Standard Deviation"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualStandardDeviation' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Variance"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualVariance' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Information Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.InformationRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Tracking Error"' Math.Round((double)totalPerformance.PortfolioStatistics.TrackingError' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Treynor Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.TreynorRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Total Fees"' "$" + totalFees.ToString("0.00"' CultureInfo.InvariantCulture) }              };
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The following statement contains a magic number: return new Dictionary<string' string>               {                   { "Total Trades"' totalTransactions.ToString(CultureInfo.InvariantCulture) }'                  { "Average Win"' Math.Round(totalPerformance.PortfolioStatistics.AverageWinRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%"  }'                  { "Average Loss"' Math.Round(totalPerformance.PortfolioStatistics.AverageLossRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Compounding Annual Return"' Math.Round(totalPerformance.PortfolioStatistics.CompoundingAnnualReturn.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Drawdown"' Math.Round(totalPerformance.PortfolioStatistics.Drawdown.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Expectancy"' Math.Round(totalPerformance.PortfolioStatistics.Expectancy' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Net Profit"' Math.Round(totalPerformance.PortfolioStatistics.TotalNetProfit.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%"}'                  { "Sharpe Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.SharpeRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Loss Rate"' Math.Round(totalPerformance.PortfolioStatistics.LossRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Win Rate"' Math.Round(totalPerformance.PortfolioStatistics.WinRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                   { "Profit-Loss Ratio"' Math.Round(totalPerformance.PortfolioStatistics.ProfitLossRatio' 2).ToString(CultureInfo.InvariantCulture) }'                  { "Alpha"' Math.Round((double)totalPerformance.PortfolioStatistics.Alpha' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Beta"' Math.Round((double)totalPerformance.PortfolioStatistics.Beta' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Standard Deviation"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualStandardDeviation' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Variance"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualVariance' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Information Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.InformationRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Tracking Error"' Math.Round((double)totalPerformance.PortfolioStatistics.TrackingError' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Treynor Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.TreynorRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Total Fees"' "$" + totalFees.ToString("0.00"' CultureInfo.InvariantCulture) }              };
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The following statement contains a magic number: return new Dictionary<string' string>               {                   { "Total Trades"' totalTransactions.ToString(CultureInfo.InvariantCulture) }'                  { "Average Win"' Math.Round(totalPerformance.PortfolioStatistics.AverageWinRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%"  }'                  { "Average Loss"' Math.Round(totalPerformance.PortfolioStatistics.AverageLossRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Compounding Annual Return"' Math.Round(totalPerformance.PortfolioStatistics.CompoundingAnnualReturn.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Drawdown"' Math.Round(totalPerformance.PortfolioStatistics.Drawdown.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Expectancy"' Math.Round(totalPerformance.PortfolioStatistics.Expectancy' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Net Profit"' Math.Round(totalPerformance.PortfolioStatistics.TotalNetProfit.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%"}'                  { "Sharpe Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.SharpeRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Loss Rate"' Math.Round(totalPerformance.PortfolioStatistics.LossRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Win Rate"' Math.Round(totalPerformance.PortfolioStatistics.WinRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                   { "Profit-Loss Ratio"' Math.Round(totalPerformance.PortfolioStatistics.ProfitLossRatio' 2).ToString(CultureInfo.InvariantCulture) }'                  { "Alpha"' Math.Round((double)totalPerformance.PortfolioStatistics.Alpha' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Beta"' Math.Round((double)totalPerformance.PortfolioStatistics.Beta' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Standard Deviation"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualStandardDeviation' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Variance"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualVariance' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Information Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.InformationRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Tracking Error"' Math.Round((double)totalPerformance.PortfolioStatistics.TrackingError' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Treynor Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.TreynorRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Total Fees"' "$" + totalFees.ToString("0.00"' CultureInfo.InvariantCulture) }              };
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The following statement contains a magic number: return new Dictionary<string' string>               {                   { "Total Trades"' totalTransactions.ToString(CultureInfo.InvariantCulture) }'                  { "Average Win"' Math.Round(totalPerformance.PortfolioStatistics.AverageWinRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%"  }'                  { "Average Loss"' Math.Round(totalPerformance.PortfolioStatistics.AverageLossRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Compounding Annual Return"' Math.Round(totalPerformance.PortfolioStatistics.CompoundingAnnualReturn.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Drawdown"' Math.Round(totalPerformance.PortfolioStatistics.Drawdown.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Expectancy"' Math.Round(totalPerformance.PortfolioStatistics.Expectancy' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Net Profit"' Math.Round(totalPerformance.PortfolioStatistics.TotalNetProfit.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%"}'                  { "Sharpe Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.SharpeRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Loss Rate"' Math.Round(totalPerformance.PortfolioStatistics.LossRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Win Rate"' Math.Round(totalPerformance.PortfolioStatistics.WinRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                   { "Profit-Loss Ratio"' Math.Round(totalPerformance.PortfolioStatistics.ProfitLossRatio' 2).ToString(CultureInfo.InvariantCulture) }'                  { "Alpha"' Math.Round((double)totalPerformance.PortfolioStatistics.Alpha' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Beta"' Math.Round((double)totalPerformance.PortfolioStatistics.Beta' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Standard Deviation"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualStandardDeviation' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Variance"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualVariance' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Information Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.InformationRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Tracking Error"' Math.Round((double)totalPerformance.PortfolioStatistics.TrackingError' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Treynor Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.TreynorRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Total Fees"' "$" + totalFees.ToString("0.00"' CultureInfo.InvariantCulture) }              };
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The following statement contains a magic number: return new Dictionary<string' string>               {                   { "Total Trades"' totalTransactions.ToString(CultureInfo.InvariantCulture) }'                  { "Average Win"' Math.Round(totalPerformance.PortfolioStatistics.AverageWinRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%"  }'                  { "Average Loss"' Math.Round(totalPerformance.PortfolioStatistics.AverageLossRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Compounding Annual Return"' Math.Round(totalPerformance.PortfolioStatistics.CompoundingAnnualReturn.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Drawdown"' Math.Round(totalPerformance.PortfolioStatistics.Drawdown.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Expectancy"' Math.Round(totalPerformance.PortfolioStatistics.Expectancy' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Net Profit"' Math.Round(totalPerformance.PortfolioStatistics.TotalNetProfit.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%"}'                  { "Sharpe Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.SharpeRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Loss Rate"' Math.Round(totalPerformance.PortfolioStatistics.LossRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Win Rate"' Math.Round(totalPerformance.PortfolioStatistics.WinRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                   { "Profit-Loss Ratio"' Math.Round(totalPerformance.PortfolioStatistics.ProfitLossRatio' 2).ToString(CultureInfo.InvariantCulture) }'                  { "Alpha"' Math.Round((double)totalPerformance.PortfolioStatistics.Alpha' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Beta"' Math.Round((double)totalPerformance.PortfolioStatistics.Beta' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Standard Deviation"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualStandardDeviation' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Variance"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualVariance' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Information Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.InformationRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Tracking Error"' Math.Round((double)totalPerformance.PortfolioStatistics.TrackingError' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Treynor Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.TreynorRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Total Fees"' "$" + totalFees.ToString("0.00"' CultureInfo.InvariantCulture) }              };
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The following statement contains a magic number: return new Dictionary<string' string>               {                   { "Total Trades"' totalTransactions.ToString(CultureInfo.InvariantCulture) }'                  { "Average Win"' Math.Round(totalPerformance.PortfolioStatistics.AverageWinRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%"  }'                  { "Average Loss"' Math.Round(totalPerformance.PortfolioStatistics.AverageLossRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Compounding Annual Return"' Math.Round(totalPerformance.PortfolioStatistics.CompoundingAnnualReturn.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Drawdown"' Math.Round(totalPerformance.PortfolioStatistics.Drawdown.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Expectancy"' Math.Round(totalPerformance.PortfolioStatistics.Expectancy' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Net Profit"' Math.Round(totalPerformance.PortfolioStatistics.TotalNetProfit.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%"}'                  { "Sharpe Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.SharpeRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Loss Rate"' Math.Round(totalPerformance.PortfolioStatistics.LossRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Win Rate"' Math.Round(totalPerformance.PortfolioStatistics.WinRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                   { "Profit-Loss Ratio"' Math.Round(totalPerformance.PortfolioStatistics.ProfitLossRatio' 2).ToString(CultureInfo.InvariantCulture) }'                  { "Alpha"' Math.Round((double)totalPerformance.PortfolioStatistics.Alpha' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Beta"' Math.Round((double)totalPerformance.PortfolioStatistics.Beta' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Standard Deviation"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualStandardDeviation' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Variance"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualVariance' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Information Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.InformationRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Tracking Error"' Math.Round((double)totalPerformance.PortfolioStatistics.TrackingError' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Treynor Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.TreynorRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Total Fees"' "$" + totalFees.ToString("0.00"' CultureInfo.InvariantCulture) }              };
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The following statement contains a magic number: return new Dictionary<string' string>               {                   { "Total Trades"' totalTransactions.ToString(CultureInfo.InvariantCulture) }'                  { "Average Win"' Math.Round(totalPerformance.PortfolioStatistics.AverageWinRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%"  }'                  { "Average Loss"' Math.Round(totalPerformance.PortfolioStatistics.AverageLossRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Compounding Annual Return"' Math.Round(totalPerformance.PortfolioStatistics.CompoundingAnnualReturn.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Drawdown"' Math.Round(totalPerformance.PortfolioStatistics.Drawdown.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Expectancy"' Math.Round(totalPerformance.PortfolioStatistics.Expectancy' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Net Profit"' Math.Round(totalPerformance.PortfolioStatistics.TotalNetProfit.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%"}'                  { "Sharpe Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.SharpeRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Loss Rate"' Math.Round(totalPerformance.PortfolioStatistics.LossRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Win Rate"' Math.Round(totalPerformance.PortfolioStatistics.WinRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                   { "Profit-Loss Ratio"' Math.Round(totalPerformance.PortfolioStatistics.ProfitLossRatio' 2).ToString(CultureInfo.InvariantCulture) }'                  { "Alpha"' Math.Round((double)totalPerformance.PortfolioStatistics.Alpha' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Beta"' Math.Round((double)totalPerformance.PortfolioStatistics.Beta' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Standard Deviation"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualStandardDeviation' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Variance"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualVariance' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Information Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.InformationRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Tracking Error"' Math.Round((double)totalPerformance.PortfolioStatistics.TrackingError' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Treynor Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.TreynorRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Total Fees"' "$" + totalFees.ToString("0.00"' CultureInfo.InvariantCulture) }              };
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The following statement contains a magic number: return new Dictionary<string' string>               {                   { "Total Trades"' totalTransactions.ToString(CultureInfo.InvariantCulture) }'                  { "Average Win"' Math.Round(totalPerformance.PortfolioStatistics.AverageWinRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%"  }'                  { "Average Loss"' Math.Round(totalPerformance.PortfolioStatistics.AverageLossRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Compounding Annual Return"' Math.Round(totalPerformance.PortfolioStatistics.CompoundingAnnualReturn.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Drawdown"' Math.Round(totalPerformance.PortfolioStatistics.Drawdown.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Expectancy"' Math.Round(totalPerformance.PortfolioStatistics.Expectancy' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Net Profit"' Math.Round(totalPerformance.PortfolioStatistics.TotalNetProfit.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%"}'                  { "Sharpe Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.SharpeRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Loss Rate"' Math.Round(totalPerformance.PortfolioStatistics.LossRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Win Rate"' Math.Round(totalPerformance.PortfolioStatistics.WinRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                   { "Profit-Loss Ratio"' Math.Round(totalPerformance.PortfolioStatistics.ProfitLossRatio' 2).ToString(CultureInfo.InvariantCulture) }'                  { "Alpha"' Math.Round((double)totalPerformance.PortfolioStatistics.Alpha' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Beta"' Math.Round((double)totalPerformance.PortfolioStatistics.Beta' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Standard Deviation"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualStandardDeviation' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Variance"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualVariance' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Information Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.InformationRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Tracking Error"' Math.Round((double)totalPerformance.PortfolioStatistics.TrackingError' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Treynor Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.TreynorRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Total Fees"' "$" + totalFees.ToString("0.00"' CultureInfo.InvariantCulture) }              };
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The following statement contains a magic number: return new Dictionary<string' string>               {                   { "Total Trades"' totalTransactions.ToString(CultureInfo.InvariantCulture) }'                  { "Average Win"' Math.Round(totalPerformance.PortfolioStatistics.AverageWinRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%"  }'                  { "Average Loss"' Math.Round(totalPerformance.PortfolioStatistics.AverageLossRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Compounding Annual Return"' Math.Round(totalPerformance.PortfolioStatistics.CompoundingAnnualReturn.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Drawdown"' Math.Round(totalPerformance.PortfolioStatistics.Drawdown.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Expectancy"' Math.Round(totalPerformance.PortfolioStatistics.Expectancy' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Net Profit"' Math.Round(totalPerformance.PortfolioStatistics.TotalNetProfit.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%"}'                  { "Sharpe Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.SharpeRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Loss Rate"' Math.Round(totalPerformance.PortfolioStatistics.LossRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Win Rate"' Math.Round(totalPerformance.PortfolioStatistics.WinRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                   { "Profit-Loss Ratio"' Math.Round(totalPerformance.PortfolioStatistics.ProfitLossRatio' 2).ToString(CultureInfo.InvariantCulture) }'                  { "Alpha"' Math.Round((double)totalPerformance.PortfolioStatistics.Alpha' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Beta"' Math.Round((double)totalPerformance.PortfolioStatistics.Beta' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Standard Deviation"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualStandardDeviation' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Variance"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualVariance' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Information Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.InformationRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Tracking Error"' Math.Round((double)totalPerformance.PortfolioStatistics.TrackingError' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Treynor Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.TreynorRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Total Fees"' "$" + totalFees.ToString("0.00"' CultureInfo.InvariantCulture) }              };
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The following statement contains a magic number: return new Dictionary<string' string>               {                   { "Total Trades"' totalTransactions.ToString(CultureInfo.InvariantCulture) }'                  { "Average Win"' Math.Round(totalPerformance.PortfolioStatistics.AverageWinRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%"  }'                  { "Average Loss"' Math.Round(totalPerformance.PortfolioStatistics.AverageLossRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Compounding Annual Return"' Math.Round(totalPerformance.PortfolioStatistics.CompoundingAnnualReturn.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Drawdown"' Math.Round(totalPerformance.PortfolioStatistics.Drawdown.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Expectancy"' Math.Round(totalPerformance.PortfolioStatistics.Expectancy' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Net Profit"' Math.Round(totalPerformance.PortfolioStatistics.TotalNetProfit.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%"}'                  { "Sharpe Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.SharpeRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Loss Rate"' Math.Round(totalPerformance.PortfolioStatistics.LossRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Win Rate"' Math.Round(totalPerformance.PortfolioStatistics.WinRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                   { "Profit-Loss Ratio"' Math.Round(totalPerformance.PortfolioStatistics.ProfitLossRatio' 2).ToString(CultureInfo.InvariantCulture) }'                  { "Alpha"' Math.Round((double)totalPerformance.PortfolioStatistics.Alpha' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Beta"' Math.Round((double)totalPerformance.PortfolioStatistics.Beta' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Standard Deviation"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualStandardDeviation' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Variance"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualVariance' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Information Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.InformationRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Tracking Error"' Math.Round((double)totalPerformance.PortfolioStatistics.TrackingError' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Treynor Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.TreynorRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Total Fees"' "$" + totalFees.ToString("0.00"' CultureInfo.InvariantCulture) }              };
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The following statement contains a magic number: return new Dictionary<string' string>               {                   { "Total Trades"' totalTransactions.ToString(CultureInfo.InvariantCulture) }'                  { "Average Win"' Math.Round(totalPerformance.PortfolioStatistics.AverageWinRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%"  }'                  { "Average Loss"' Math.Round(totalPerformance.PortfolioStatistics.AverageLossRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Compounding Annual Return"' Math.Round(totalPerformance.PortfolioStatistics.CompoundingAnnualReturn.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Drawdown"' Math.Round(totalPerformance.PortfolioStatistics.Drawdown.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Expectancy"' Math.Round(totalPerformance.PortfolioStatistics.Expectancy' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Net Profit"' Math.Round(totalPerformance.PortfolioStatistics.TotalNetProfit.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%"}'                  { "Sharpe Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.SharpeRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Loss Rate"' Math.Round(totalPerformance.PortfolioStatistics.LossRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Win Rate"' Math.Round(totalPerformance.PortfolioStatistics.WinRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                   { "Profit-Loss Ratio"' Math.Round(totalPerformance.PortfolioStatistics.ProfitLossRatio' 2).ToString(CultureInfo.InvariantCulture) }'                  { "Alpha"' Math.Round((double)totalPerformance.PortfolioStatistics.Alpha' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Beta"' Math.Round((double)totalPerformance.PortfolioStatistics.Beta' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Standard Deviation"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualStandardDeviation' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Variance"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualVariance' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Information Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.InformationRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Tracking Error"' Math.Round((double)totalPerformance.PortfolioStatistics.TrackingError' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Treynor Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.TreynorRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Total Fees"' "$" + totalFees.ToString("0.00"' CultureInfo.InvariantCulture) }              };
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetSummary,The following statement contains a magic number: return new Dictionary<string' string>               {                   { "Total Trades"' totalTransactions.ToString(CultureInfo.InvariantCulture) }'                  { "Average Win"' Math.Round(totalPerformance.PortfolioStatistics.AverageWinRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%"  }'                  { "Average Loss"' Math.Round(totalPerformance.PortfolioStatistics.AverageLossRate.SafeMultiply100()' 2).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Compounding Annual Return"' Math.Round(totalPerformance.PortfolioStatistics.CompoundingAnnualReturn.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Drawdown"' Math.Round(totalPerformance.PortfolioStatistics.Drawdown.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Expectancy"' Math.Round(totalPerformance.PortfolioStatistics.Expectancy' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Net Profit"' Math.Round(totalPerformance.PortfolioStatistics.TotalNetProfit.SafeMultiply100()' 3).ToString(CultureInfo.InvariantCulture) + "%"}'                  { "Sharpe Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.SharpeRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Loss Rate"' Math.Round(totalPerformance.PortfolioStatistics.LossRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                  { "Win Rate"' Math.Round(totalPerformance.PortfolioStatistics.WinRate.SafeMultiply100()).ToString(CultureInfo.InvariantCulture) + "%" }'                   { "Profit-Loss Ratio"' Math.Round(totalPerformance.PortfolioStatistics.ProfitLossRatio' 2).ToString(CultureInfo.InvariantCulture) }'                  { "Alpha"' Math.Round((double)totalPerformance.PortfolioStatistics.Alpha' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Beta"' Math.Round((double)totalPerformance.PortfolioStatistics.Beta' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Standard Deviation"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualStandardDeviation' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Annual Variance"' Math.Round((double)totalPerformance.PortfolioStatistics.AnnualVariance' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Information Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.InformationRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Tracking Error"' Math.Round((double)totalPerformance.PortfolioStatistics.TrackingError' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Treynor Ratio"' Math.Round((double)totalPerformance.PortfolioStatistics.TreynorRatio' 3).ToString(CultureInfo.InvariantCulture) }'                  { "Total Fees"' "$" + totalFees.ToString("0.00"' CultureInfo.InvariantCulture) }              };
Magic Number,QuantConnect.Statistics,StatisticsBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\StatisticsBuilder.cs,GetPeriodRanges,The following statement contains a magic number: for (var i = endDates.Count - 2; i >= 0; i--)              {                  var startDate = ranges[ranges.Count - 1].EndDate.AddDays(1).AddMonths(1 - periodMonths);                  if (startDate < firstDate) startDate = firstDate;                    ranges.Add(new PeriodRange                  {                      StartDate = startDate'                      EndDate = endDates[i]                  });              }
Magic Number,QuantConnect.Statistics,TradeStatistics,C:\repos\QuantConnect_Lean\Common\Statistics\TradeStatistics.cs,TradeStatistics,The following statement contains a magic number: WinLossRatio = TotalNumberOfTrades == 0 ? 0 : (NumberOfLosingTrades > 0 ? (decimal)NumberOfWinningTrades / NumberOfLosingTrades : 10);
Magic Number,QuantConnect.Statistics,TradeStatistics,C:\repos\QuantConnect_Lean\Common\Statistics\TradeStatistics.cs,TradeStatistics,The following statement contains a magic number: ProfitFactor = TotalProfit == 0 ? 0 : (TotalLoss < 0 ? TotalProfit / Math.Abs(TotalLoss) : 10);
Magic Number,QuantConnect.Statistics,TradeStatistics,C:\repos\QuantConnect_Lean\Common\Statistics\TradeStatistics.cs,TradeStatistics,The following statement contains a magic number: ProfitToMaxDrawdownRatio = TotalProfitLoss == 0 ? 0 : (MaximumClosedTradeDrawdown < 0 ? TotalProfitLoss / Math.Abs(MaximumClosedTradeDrawdown) : 10);
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Get array versions of the performance:                  performance = ChartPointToDictionary(pointsPerformance);                  equity = ChartPointToDictionary(pointsEquity);                  performance.Values.ToList().ForEach(i => listPerformance.Add((double)(i / 100)));                  benchmark = new SortedDictionary<DateTime' decimal>(unsortedBenchmark);                    // to find the delta in benchmark for first day' we need to know the price at the opening                  // moment of the day' but since we cannot find this' we cannot find the first benchmark's delta'                  // so we pad it with Zero. If running a short backtest this will skew results' longer backtests                  // will not be affected much                  listBenchmark.Add(0);                    //Get benchmark performance array for same period:                  benchmark.Keys.ToList().ForEach(dt =>                  {                      if (dt >= equity.Keys.FirstOrDefault().AddDays(-1) && dt < equity.Keys.LastOrDefault())                      {                          decimal previous;                          if (benchmark.TryGetValue(dtPrevious' out previous) && previous != 0)                          {                              var deltaBenchmark = (benchmark[dt] - previous)/previous;                              listBenchmark.Add((double)(deltaBenchmark));                          }                          else                          {                              listBenchmark.Add(0);                          }                          dtPrevious = dt;                      }                  });                    // TODO : if these lists are required to be the same length then we should create structure to pair the values' this way' by contract it will be enforced.                    //THIS SHOULD NEVER HAPPEN --> But if it does' log it and fail silently.                  while (listPerformance.Count < listBenchmark.Count)                  {                      listPerformance.Add(0);                      Log.Error("Statistics.Generate(): Padded Performance");                  }                  while (listPerformance.Count > listBenchmark.Count)                  {                      listBenchmark.Add(0);                      Log.Error("Statistics.Generate(): Padded Benchmark");                  }              }              catch (Exception err)              {                  Log.Error(err' "Dic-Array Convert:");              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Number of years in this dataset:                  fractionOfYears = (equity.Keys.LastOrDefault() - equity.Keys.FirstOrDefault()).TotalDays / 365;              }              catch (Exception err)              {                  Log.Error(err' "Fraction of Years:");              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,Generate,The following statement contains a magic number: try              {                  //Run over each equity day:                  foreach (var closedTrade in profitLoss.Keys)                  {                      profitLossValue = profitLoss[closedTrade];                        //Check if this date is in the "years" array:                      var year = closedTrade.Year;                      if (!years.Contains(year))                      {                          //Initialise a new year holder:                          years.Add(year);                          annualTrades.Add(year' 0);                          annualWins.Add(year' 0);                          annualWinTotal.Add(year' 0);                          annualLosses.Add(year' 0);                          annualLossTotal.Add(year' 0);                      }                        //Add another trade:                      annualTrades[year]++;                        //Profit loss tracking:                      if (profitLossValue > 0)                      {                          annualWins[year]++;                          annualWinTotal[year] += profitLossValue / runningCash;                      }                      else                      {                          annualLosses[year]++;                          annualLossTotal[year] += profitLossValue / runningCash;                      }                        //Increment the cash:                      runningCash += profitLossValue;                  }                    //Get the annual percentage of profit and loss:                  foreach (var year in years)                  {                      annualNetProfit[year] = (annualWinTotal[year] + annualLossTotal[year]);                  }                    //Sum the totals:                  try                  {                      if (profitLoss.Keys.Count > 0)                      {                          totalClosedTrades = annualTrades.Values.Sum();                          totalWins = annualWins.Values.Sum();                          totalLosses = annualLosses.Values.Sum();                          totalNetProfit = (equity.Values.LastOrDefault() / startingCash) - 1;                            //-> Handle Div/0 Errors                          if (totalWins == 0)                          {                              averageWin = 0;                          }                          else                          {                              averageWin = annualWinTotal.Values.Sum() / totalWins;                          }                          if (totalLosses == 0)                          {                              averageLoss = 0;                              averageWinRatio = 0;                          }                          else                          {                              averageLoss = annualLossTotal.Values.Sum() / totalLosses;                              averageWinRatio = Math.Abs(averageWin / averageLoss);                          }                          if (totalTrades == 0)                          {                              winRate = 0;                              lossRate = 0;                          }                          else                          {                              winRate = Math.Round(totalWins / totalClosedTrades' 5);                              lossRate = Math.Round(totalLosses / totalClosedTrades' 5);                          }                      }                    }                  catch (Exception err)                  {                      Log.Error(err' "Second Half:");                  }                    var profitLossRatio = ProfitLossRatio(averageWin' averageLoss);                  var profitLossRatioHuman = profitLossRatio.ToString(CultureInfo.InvariantCulture);                  if (profitLossRatio == -1) profitLossRatioHuman = "0";                    //Add the over all results first' break down by year later:                  statistics = new Dictionary<string' string> {                       { "Total Trades"' Math.Round(totalTrades' 0).ToString(CultureInfo.InvariantCulture) }'                      { "Average Win"' Math.Round(averageWin * 100' 2) + "%"  }'                      { "Average Loss"' Math.Round(averageLoss * 100' 2) + "%" }'                      { "Compounding Annual Return"' Math.Round(algoCompoundingPerformance * 100' 3) + "%" }'                      { "Drawdown"' (DrawdownPercent(equity' 3) * 100) + "%" }'                      { "Expectancy"' Math.Round((winRate * averageWinRatio) - (lossRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Net Profit"' Math.Round(totalNetProfit * 100' 3) + "%"}'                      { "Sharpe Ratio"' Math.Round(SharpeRatio(listPerformance' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Loss Rate"' Math.Round(lossRate * 100) + "%" }'                      { "Win Rate"' Math.Round(winRate * 100) + "%" }'                       { "Profit-Loss Ratio"' profitLossRatioHuman }'                      { "Alpha"' Math.Round(Alpha(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Beta"' Math.Round(Beta(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Standard Deviation"' Math.Round(AnnualStandardDeviation(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Annual Variance"' Math.Round(AnnualVariance(listPerformance' tradingDaysPerYear)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Information Ratio"' Math.Round(InformationRatio(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Tracking Error"' Math.Round(TrackingError(listPerformance' listBenchmark)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Treynor Ratio"' Math.Round(TreynorRatio(listPerformance' listBenchmark' riskFreeRate)' 3).ToString(CultureInfo.InvariantCulture) }'                      { "Total Fees"' "$" + totalFees.ToString("0.00") }                  };              }              catch (Exception err)              {                  Log.Error(err);              }
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,ProfitLossRatio,The following statement contains a magic number: return Math.Round(averageWin / Math.Abs(averageLoss)' 2);
Magic Number,QuantConnect.Statistics,Statistics,C:\repos\QuantConnect_Lean\Common\Statistics\Statistics.cs,TrackingError,The following statement contains a magic number: return Math.Sqrt(AnnualVariance(algoPerformance) - 2 * Correlation.Pearson(algoPerformance' benchmarkPerformance) * AnnualStandardDeviation(algoPerformance) * AnnualStandardDeviation(benchmarkPerformance) + AnnualVariance(benchmarkPerformance));
Magic Number,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFillToFill,The following statement contains a magic number: if (Math.Sign(fill.FillQuantity) == (position.PendingTrades[index].Direction == TradeDirection.Long ? +1 : -1))              {                  // execution has same direction of trade                  position.PendingTrades.Add(new Trade                  {                      Symbol = fill.Symbol'                      EntryTime = fill.UtcTime'                      EntryPrice = fill.FillPrice'                      Direction = fill.FillQuantity > 0 ? TradeDirection.Long : TradeDirection.Short'                      Quantity = fill.AbsoluteFillQuantity'                      TotalFees = orderFee                  });              }              else              {                  // execution has opposite direction of trade                  var totalExecutedQuantity = 0m;                  var orderFeeAssigned = false;                  while (position.PendingTrades.Count > 0 && Math.Abs(totalExecutedQuantity) < fill.AbsoluteFillQuantity)                  {                      var trade = position.PendingTrades[index];                        if (fill.AbsoluteFillQuantity >= trade.Quantity)                      {                          totalExecutedQuantity -= trade.Quantity * (trade.Direction == TradeDirection.Long ? +1 : -1);                          position.PendingTrades.RemoveAt(index);                            if (index > 0 && _matchingMethod == FillMatchingMethod.LIFO) index--;                            trade.ExitTime = fill.UtcTime;                          trade.ExitPrice = fill.FillPrice;                          trade.ProfitLoss = Math.Round((trade.ExitPrice - trade.EntryPrice) * trade.Quantity * (trade.Direction == TradeDirection.Long ? +1 : -1) * conversionRate * multiplier' 2);                          // if closing multiple trades with the same order' assign order fee only once                          trade.TotalFees += orderFeeAssigned ? 0 : orderFee;                          trade.MAE = Math.Round((trade.Direction == TradeDirection.Long ? position.MinPrice - trade.EntryPrice : trade.EntryPrice - position.MaxPrice) * trade.Quantity * conversionRate * multiplier' 2);                          trade.MFE = Math.Round((trade.Direction == TradeDirection.Long ? position.MaxPrice - trade.EntryPrice : trade.EntryPrice - position.MinPrice) * trade.Quantity * conversionRate * multiplier' 2);                                                    AddNewTrade(trade);                      }                      else                      {                          totalExecutedQuantity += fill.FillQuantity;                          trade.Quantity -= fill.AbsoluteFillQuantity;                            AddNewTrade(new Trade                          {                              Symbol = trade.Symbol'                              EntryTime = trade.EntryTime'                              EntryPrice = trade.EntryPrice'                              Direction = trade.Direction'                              Quantity = fill.AbsoluteFillQuantity'                              ExitTime = fill.UtcTime'                              ExitPrice = fill.FillPrice'                              ProfitLoss = Math.Round((fill.FillPrice - trade.EntryPrice) * fill.AbsoluteFillQuantity * (trade.Direction == TradeDirection.Long ? +1 : -1) * conversionRate * multiplier' 2)'                              TotalFees = trade.TotalFees + (orderFeeAssigned ? 0 : orderFee)'                              MAE = Math.Round((trade.Direction == TradeDirection.Long ? position.MinPrice - trade.EntryPrice : trade.EntryPrice - position.MaxPrice) * fill.AbsoluteFillQuantity * conversionRate * multiplier' 2)'                              MFE = Math.Round((trade.Direction == TradeDirection.Long ? position.MaxPrice - trade.EntryPrice : trade.EntryPrice - position.MinPrice) * fill.AbsoluteFillQuantity * conversionRate * multiplier' 2)                          });                            trade.TotalFees = 0;                      }                        orderFeeAssigned = true;                  }                    if (Math.Abs(totalExecutedQuantity) == fill.AbsoluteFillQuantity && position.PendingTrades.Count == 0)                  {                      _positions.Remove(fill.Symbol);                  }                  else if (Math.Abs(totalExecutedQuantity) < fill.AbsoluteFillQuantity)                  {                      // direction reversal                      fill.FillQuantity -= totalExecutedQuantity;                      position.PendingTrades = new List<Trade>                      {                          new Trade                          {                              Symbol = fill.Symbol'                              EntryTime = fill.UtcTime'                              EntryPrice = fill.FillPrice'                              Direction = fill.FillQuantity > 0 ? TradeDirection.Long : TradeDirection.Short'                              Quantity = fill.AbsoluteFillQuantity'                              TotalFees = 0                          }                      };                      position.MinPrice = fill.FillPrice;                      position.MaxPrice = fill.FillPrice;                  }              }
Magic Number,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFillToFill,The following statement contains a magic number: if (Math.Sign(fill.FillQuantity) == (position.PendingTrades[index].Direction == TradeDirection.Long ? +1 : -1))              {                  // execution has same direction of trade                  position.PendingTrades.Add(new Trade                  {                      Symbol = fill.Symbol'                      EntryTime = fill.UtcTime'                      EntryPrice = fill.FillPrice'                      Direction = fill.FillQuantity > 0 ? TradeDirection.Long : TradeDirection.Short'                      Quantity = fill.AbsoluteFillQuantity'                      TotalFees = orderFee                  });              }              else              {                  // execution has opposite direction of trade                  var totalExecutedQuantity = 0m;                  var orderFeeAssigned = false;                  while (position.PendingTrades.Count > 0 && Math.Abs(totalExecutedQuantity) < fill.AbsoluteFillQuantity)                  {                      var trade = position.PendingTrades[index];                        if (fill.AbsoluteFillQuantity >= trade.Quantity)                      {                          totalExecutedQuantity -= trade.Quantity * (trade.Direction == TradeDirection.Long ? +1 : -1);                          position.PendingTrades.RemoveAt(index);                            if (index > 0 && _matchingMethod == FillMatchingMethod.LIFO) index--;                            trade.ExitTime = fill.UtcTime;                          trade.ExitPrice = fill.FillPrice;                          trade.ProfitLoss = Math.Round((trade.ExitPrice - trade.EntryPrice) * trade.Quantity * (trade.Direction == TradeDirection.Long ? +1 : -1) * conversionRate * multiplier' 2);                          // if closing multiple trades with the same order' assign order fee only once                          trade.TotalFees += orderFeeAssigned ? 0 : orderFee;                          trade.MAE = Math.Round((trade.Direction == TradeDirection.Long ? position.MinPrice - trade.EntryPrice : trade.EntryPrice - position.MaxPrice) * trade.Quantity * conversionRate * multiplier' 2);                          trade.MFE = Math.Round((trade.Direction == TradeDirection.Long ? position.MaxPrice - trade.EntryPrice : trade.EntryPrice - position.MinPrice) * trade.Quantity * conversionRate * multiplier' 2);                                                    AddNewTrade(trade);                      }                      else                      {                          totalExecutedQuantity += fill.FillQuantity;                          trade.Quantity -= fill.AbsoluteFillQuantity;                            AddNewTrade(new Trade                          {                              Symbol = trade.Symbol'                              EntryTime = trade.EntryTime'                              EntryPrice = trade.EntryPrice'                              Direction = trade.Direction'                              Quantity = fill.AbsoluteFillQuantity'                              ExitTime = fill.UtcTime'                              ExitPrice = fill.FillPrice'                              ProfitLoss = Math.Round((fill.FillPrice - trade.EntryPrice) * fill.AbsoluteFillQuantity * (trade.Direction == TradeDirection.Long ? +1 : -1) * conversionRate * multiplier' 2)'                              TotalFees = trade.TotalFees + (orderFeeAssigned ? 0 : orderFee)'                              MAE = Math.Round((trade.Direction == TradeDirection.Long ? position.MinPrice - trade.EntryPrice : trade.EntryPrice - position.MaxPrice) * fill.AbsoluteFillQuantity * conversionRate * multiplier' 2)'                              MFE = Math.Round((trade.Direction == TradeDirection.Long ? position.MaxPrice - trade.EntryPrice : trade.EntryPrice - position.MinPrice) * fill.AbsoluteFillQuantity * conversionRate * multiplier' 2)                          });                            trade.TotalFees = 0;                      }                        orderFeeAssigned = true;                  }                    if (Math.Abs(totalExecutedQuantity) == fill.AbsoluteFillQuantity && position.PendingTrades.Count == 0)                  {                      _positions.Remove(fill.Symbol);                  }                  else if (Math.Abs(totalExecutedQuantity) < fill.AbsoluteFillQuantity)                  {                      // direction reversal                      fill.FillQuantity -= totalExecutedQuantity;                      position.PendingTrades = new List<Trade>                      {                          new Trade                          {                              Symbol = fill.Symbol'                              EntryTime = fill.UtcTime'                              EntryPrice = fill.FillPrice'                              Direction = fill.FillQuantity > 0 ? TradeDirection.Long : TradeDirection.Short'                              Quantity = fill.AbsoluteFillQuantity'                              TotalFees = 0                          }                      };                      position.MinPrice = fill.FillPrice;                      position.MaxPrice = fill.FillPrice;                  }              }
Magic Number,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFillToFill,The following statement contains a magic number: if (Math.Sign(fill.FillQuantity) == (position.PendingTrades[index].Direction == TradeDirection.Long ? +1 : -1))              {                  // execution has same direction of trade                  position.PendingTrades.Add(new Trade                  {                      Symbol = fill.Symbol'                      EntryTime = fill.UtcTime'                      EntryPrice = fill.FillPrice'                      Direction = fill.FillQuantity > 0 ? TradeDirection.Long : TradeDirection.Short'                      Quantity = fill.AbsoluteFillQuantity'                      TotalFees = orderFee                  });              }              else              {                  // execution has opposite direction of trade                  var totalExecutedQuantity = 0m;                  var orderFeeAssigned = false;                  while (position.PendingTrades.Count > 0 && Math.Abs(totalExecutedQuantity) < fill.AbsoluteFillQuantity)                  {                      var trade = position.PendingTrades[index];                        if (fill.AbsoluteFillQuantity >= trade.Quantity)                      {                          totalExecutedQuantity -= trade.Quantity * (trade.Direction == TradeDirection.Long ? +1 : -1);                          position.PendingTrades.RemoveAt(index);                            if (index > 0 && _matchingMethod == FillMatchingMethod.LIFO) index--;                            trade.ExitTime = fill.UtcTime;                          trade.ExitPrice = fill.FillPrice;                          trade.ProfitLoss = Math.Round((trade.ExitPrice - trade.EntryPrice) * trade.Quantity * (trade.Direction == TradeDirection.Long ? +1 : -1) * conversionRate * multiplier' 2);                          // if closing multiple trades with the same order' assign order fee only once                          trade.TotalFees += orderFeeAssigned ? 0 : orderFee;                          trade.MAE = Math.Round((trade.Direction == TradeDirection.Long ? position.MinPrice - trade.EntryPrice : trade.EntryPrice - position.MaxPrice) * trade.Quantity * conversionRate * multiplier' 2);                          trade.MFE = Math.Round((trade.Direction == TradeDirection.Long ? position.MaxPrice - trade.EntryPrice : trade.EntryPrice - position.MinPrice) * trade.Quantity * conversionRate * multiplier' 2);                                                    AddNewTrade(trade);                      }                      else                      {                          totalExecutedQuantity += fill.FillQuantity;                          trade.Quantity -= fill.AbsoluteFillQuantity;                            AddNewTrade(new Trade                          {                              Symbol = trade.Symbol'                              EntryTime = trade.EntryTime'                              EntryPrice = trade.EntryPrice'                              Direction = trade.Direction'                              Quantity = fill.AbsoluteFillQuantity'                              ExitTime = fill.UtcTime'                              ExitPrice = fill.FillPrice'                              ProfitLoss = Math.Round((fill.FillPrice - trade.EntryPrice) * fill.AbsoluteFillQuantity * (trade.Direction == TradeDirection.Long ? +1 : -1) * conversionRate * multiplier' 2)'                              TotalFees = trade.TotalFees + (orderFeeAssigned ? 0 : orderFee)'                              MAE = Math.Round((trade.Direction == TradeDirection.Long ? position.MinPrice - trade.EntryPrice : trade.EntryPrice - position.MaxPrice) * fill.AbsoluteFillQuantity * conversionRate * multiplier' 2)'                              MFE = Math.Round((trade.Direction == TradeDirection.Long ? position.MaxPrice - trade.EntryPrice : trade.EntryPrice - position.MinPrice) * fill.AbsoluteFillQuantity * conversionRate * multiplier' 2)                          });                            trade.TotalFees = 0;                      }                        orderFeeAssigned = true;                  }                    if (Math.Abs(totalExecutedQuantity) == fill.AbsoluteFillQuantity && position.PendingTrades.Count == 0)                  {                      _positions.Remove(fill.Symbol);                  }                  else if (Math.Abs(totalExecutedQuantity) < fill.AbsoluteFillQuantity)                  {                      // direction reversal                      fill.FillQuantity -= totalExecutedQuantity;                      position.PendingTrades = new List<Trade>                      {                          new Trade                          {                              Symbol = fill.Symbol'                              EntryTime = fill.UtcTime'                              EntryPrice = fill.FillPrice'                              Direction = fill.FillQuantity > 0 ? TradeDirection.Long : TradeDirection.Short'                              Quantity = fill.AbsoluteFillQuantity'                              TotalFees = 0                          }                      };                      position.MinPrice = fill.FillPrice;                      position.MaxPrice = fill.FillPrice;                  }              }
Magic Number,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFillToFill,The following statement contains a magic number: if (Math.Sign(fill.FillQuantity) == (position.PendingTrades[index].Direction == TradeDirection.Long ? +1 : -1))              {                  // execution has same direction of trade                  position.PendingTrades.Add(new Trade                  {                      Symbol = fill.Symbol'                      EntryTime = fill.UtcTime'                      EntryPrice = fill.FillPrice'                      Direction = fill.FillQuantity > 0 ? TradeDirection.Long : TradeDirection.Short'                      Quantity = fill.AbsoluteFillQuantity'                      TotalFees = orderFee                  });              }              else              {                  // execution has opposite direction of trade                  var totalExecutedQuantity = 0m;                  var orderFeeAssigned = false;                  while (position.PendingTrades.Count > 0 && Math.Abs(totalExecutedQuantity) < fill.AbsoluteFillQuantity)                  {                      var trade = position.PendingTrades[index];                        if (fill.AbsoluteFillQuantity >= trade.Quantity)                      {                          totalExecutedQuantity -= trade.Quantity * (trade.Direction == TradeDirection.Long ? +1 : -1);                          position.PendingTrades.RemoveAt(index);                            if (index > 0 && _matchingMethod == FillMatchingMethod.LIFO) index--;                            trade.ExitTime = fill.UtcTime;                          trade.ExitPrice = fill.FillPrice;                          trade.ProfitLoss = Math.Round((trade.ExitPrice - trade.EntryPrice) * trade.Quantity * (trade.Direction == TradeDirection.Long ? +1 : -1) * conversionRate * multiplier' 2);                          // if closing multiple trades with the same order' assign order fee only once                          trade.TotalFees += orderFeeAssigned ? 0 : orderFee;                          trade.MAE = Math.Round((trade.Direction == TradeDirection.Long ? position.MinPrice - trade.EntryPrice : trade.EntryPrice - position.MaxPrice) * trade.Quantity * conversionRate * multiplier' 2);                          trade.MFE = Math.Round((trade.Direction == TradeDirection.Long ? position.MaxPrice - trade.EntryPrice : trade.EntryPrice - position.MinPrice) * trade.Quantity * conversionRate * multiplier' 2);                                                    AddNewTrade(trade);                      }                      else                      {                          totalExecutedQuantity += fill.FillQuantity;                          trade.Quantity -= fill.AbsoluteFillQuantity;                            AddNewTrade(new Trade                          {                              Symbol = trade.Symbol'                              EntryTime = trade.EntryTime'                              EntryPrice = trade.EntryPrice'                              Direction = trade.Direction'                              Quantity = fill.AbsoluteFillQuantity'                              ExitTime = fill.UtcTime'                              ExitPrice = fill.FillPrice'                              ProfitLoss = Math.Round((fill.FillPrice - trade.EntryPrice) * fill.AbsoluteFillQuantity * (trade.Direction == TradeDirection.Long ? +1 : -1) * conversionRate * multiplier' 2)'                              TotalFees = trade.TotalFees + (orderFeeAssigned ? 0 : orderFee)'                              MAE = Math.Round((trade.Direction == TradeDirection.Long ? position.MinPrice - trade.EntryPrice : trade.EntryPrice - position.MaxPrice) * fill.AbsoluteFillQuantity * conversionRate * multiplier' 2)'                              MFE = Math.Round((trade.Direction == TradeDirection.Long ? position.MaxPrice - trade.EntryPrice : trade.EntryPrice - position.MinPrice) * fill.AbsoluteFillQuantity * conversionRate * multiplier' 2)                          });                            trade.TotalFees = 0;                      }                        orderFeeAssigned = true;                  }                    if (Math.Abs(totalExecutedQuantity) == fill.AbsoluteFillQuantity && position.PendingTrades.Count == 0)                  {                      _positions.Remove(fill.Symbol);                  }                  else if (Math.Abs(totalExecutedQuantity) < fill.AbsoluteFillQuantity)                  {                      // direction reversal                      fill.FillQuantity -= totalExecutedQuantity;                      position.PendingTrades = new List<Trade>                      {                          new Trade                          {                              Symbol = fill.Symbol'                              EntryTime = fill.UtcTime'                              EntryPrice = fill.FillPrice'                              Direction = fill.FillQuantity > 0 ? TradeDirection.Long : TradeDirection.Short'                              Quantity = fill.AbsoluteFillQuantity'                              TotalFees = 0                          }                      };                      position.MinPrice = fill.FillPrice;                      position.MaxPrice = fill.FillPrice;                  }              }
Magic Number,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFillToFill,The following statement contains a magic number: if (Math.Sign(fill.FillQuantity) == (position.PendingTrades[index].Direction == TradeDirection.Long ? +1 : -1))              {                  // execution has same direction of trade                  position.PendingTrades.Add(new Trade                  {                      Symbol = fill.Symbol'                      EntryTime = fill.UtcTime'                      EntryPrice = fill.FillPrice'                      Direction = fill.FillQuantity > 0 ? TradeDirection.Long : TradeDirection.Short'                      Quantity = fill.AbsoluteFillQuantity'                      TotalFees = orderFee                  });              }              else              {                  // execution has opposite direction of trade                  var totalExecutedQuantity = 0m;                  var orderFeeAssigned = false;                  while (position.PendingTrades.Count > 0 && Math.Abs(totalExecutedQuantity) < fill.AbsoluteFillQuantity)                  {                      var trade = position.PendingTrades[index];                        if (fill.AbsoluteFillQuantity >= trade.Quantity)                      {                          totalExecutedQuantity -= trade.Quantity * (trade.Direction == TradeDirection.Long ? +1 : -1);                          position.PendingTrades.RemoveAt(index);                            if (index > 0 && _matchingMethod == FillMatchingMethod.LIFO) index--;                            trade.ExitTime = fill.UtcTime;                          trade.ExitPrice = fill.FillPrice;                          trade.ProfitLoss = Math.Round((trade.ExitPrice - trade.EntryPrice) * trade.Quantity * (trade.Direction == TradeDirection.Long ? +1 : -1) * conversionRate * multiplier' 2);                          // if closing multiple trades with the same order' assign order fee only once                          trade.TotalFees += orderFeeAssigned ? 0 : orderFee;                          trade.MAE = Math.Round((trade.Direction == TradeDirection.Long ? position.MinPrice - trade.EntryPrice : trade.EntryPrice - position.MaxPrice) * trade.Quantity * conversionRate * multiplier' 2);                          trade.MFE = Math.Round((trade.Direction == TradeDirection.Long ? position.MaxPrice - trade.EntryPrice : trade.EntryPrice - position.MinPrice) * trade.Quantity * conversionRate * multiplier' 2);                                                    AddNewTrade(trade);                      }                      else                      {                          totalExecutedQuantity += fill.FillQuantity;                          trade.Quantity -= fill.AbsoluteFillQuantity;                            AddNewTrade(new Trade                          {                              Symbol = trade.Symbol'                              EntryTime = trade.EntryTime'                              EntryPrice = trade.EntryPrice'                              Direction = trade.Direction'                              Quantity = fill.AbsoluteFillQuantity'                              ExitTime = fill.UtcTime'                              ExitPrice = fill.FillPrice'                              ProfitLoss = Math.Round((fill.FillPrice - trade.EntryPrice) * fill.AbsoluteFillQuantity * (trade.Direction == TradeDirection.Long ? +1 : -1) * conversionRate * multiplier' 2)'                              TotalFees = trade.TotalFees + (orderFeeAssigned ? 0 : orderFee)'                              MAE = Math.Round((trade.Direction == TradeDirection.Long ? position.MinPrice - trade.EntryPrice : trade.EntryPrice - position.MaxPrice) * fill.AbsoluteFillQuantity * conversionRate * multiplier' 2)'                              MFE = Math.Round((trade.Direction == TradeDirection.Long ? position.MaxPrice - trade.EntryPrice : trade.EntryPrice - position.MinPrice) * fill.AbsoluteFillQuantity * conversionRate * multiplier' 2)                          });                            trade.TotalFees = 0;                      }                        orderFeeAssigned = true;                  }                    if (Math.Abs(totalExecutedQuantity) == fill.AbsoluteFillQuantity && position.PendingTrades.Count == 0)                  {                      _positions.Remove(fill.Symbol);                  }                  else if (Math.Abs(totalExecutedQuantity) < fill.AbsoluteFillQuantity)                  {                      // direction reversal                      fill.FillQuantity -= totalExecutedQuantity;                      position.PendingTrades = new List<Trade>                      {                          new Trade                          {                              Symbol = fill.Symbol'                              EntryTime = fill.UtcTime'                              EntryPrice = fill.FillPrice'                              Direction = fill.FillQuantity > 0 ? TradeDirection.Long : TradeDirection.Short'                              Quantity = fill.AbsoluteFillQuantity'                              TotalFees = 0                          }                      };                      position.MinPrice = fill.FillPrice;                      position.MaxPrice = fill.FillPrice;                  }              }
Magic Number,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFillToFill,The following statement contains a magic number: if (Math.Sign(fill.FillQuantity) == (position.PendingTrades[index].Direction == TradeDirection.Long ? +1 : -1))              {                  // execution has same direction of trade                  position.PendingTrades.Add(new Trade                  {                      Symbol = fill.Symbol'                      EntryTime = fill.UtcTime'                      EntryPrice = fill.FillPrice'                      Direction = fill.FillQuantity > 0 ? TradeDirection.Long : TradeDirection.Short'                      Quantity = fill.AbsoluteFillQuantity'                      TotalFees = orderFee                  });              }              else              {                  // execution has opposite direction of trade                  var totalExecutedQuantity = 0m;                  var orderFeeAssigned = false;                  while (position.PendingTrades.Count > 0 && Math.Abs(totalExecutedQuantity) < fill.AbsoluteFillQuantity)                  {                      var trade = position.PendingTrades[index];                        if (fill.AbsoluteFillQuantity >= trade.Quantity)                      {                          totalExecutedQuantity -= trade.Quantity * (trade.Direction == TradeDirection.Long ? +1 : -1);                          position.PendingTrades.RemoveAt(index);                            if (index > 0 && _matchingMethod == FillMatchingMethod.LIFO) index--;                            trade.ExitTime = fill.UtcTime;                          trade.ExitPrice = fill.FillPrice;                          trade.ProfitLoss = Math.Round((trade.ExitPrice - trade.EntryPrice) * trade.Quantity * (trade.Direction == TradeDirection.Long ? +1 : -1) * conversionRate * multiplier' 2);                          // if closing multiple trades with the same order' assign order fee only once                          trade.TotalFees += orderFeeAssigned ? 0 : orderFee;                          trade.MAE = Math.Round((trade.Direction == TradeDirection.Long ? position.MinPrice - trade.EntryPrice : trade.EntryPrice - position.MaxPrice) * trade.Quantity * conversionRate * multiplier' 2);                          trade.MFE = Math.Round((trade.Direction == TradeDirection.Long ? position.MaxPrice - trade.EntryPrice : trade.EntryPrice - position.MinPrice) * trade.Quantity * conversionRate * multiplier' 2);                                                    AddNewTrade(trade);                      }                      else                      {                          totalExecutedQuantity += fill.FillQuantity;                          trade.Quantity -= fill.AbsoluteFillQuantity;                            AddNewTrade(new Trade                          {                              Symbol = trade.Symbol'                              EntryTime = trade.EntryTime'                              EntryPrice = trade.EntryPrice'                              Direction = trade.Direction'                              Quantity = fill.AbsoluteFillQuantity'                              ExitTime = fill.UtcTime'                              ExitPrice = fill.FillPrice'                              ProfitLoss = Math.Round((fill.FillPrice - trade.EntryPrice) * fill.AbsoluteFillQuantity * (trade.Direction == TradeDirection.Long ? +1 : -1) * conversionRate * multiplier' 2)'                              TotalFees = trade.TotalFees + (orderFeeAssigned ? 0 : orderFee)'                              MAE = Math.Round((trade.Direction == TradeDirection.Long ? position.MinPrice - trade.EntryPrice : trade.EntryPrice - position.MaxPrice) * fill.AbsoluteFillQuantity * conversionRate * multiplier' 2)'                              MFE = Math.Round((trade.Direction == TradeDirection.Long ? position.MaxPrice - trade.EntryPrice : trade.EntryPrice - position.MinPrice) * fill.AbsoluteFillQuantity * conversionRate * multiplier' 2)                          });                            trade.TotalFees = 0;                      }                        orderFeeAssigned = true;                  }                    if (Math.Abs(totalExecutedQuantity) == fill.AbsoluteFillQuantity && position.PendingTrades.Count == 0)                  {                      _positions.Remove(fill.Symbol);                  }                  else if (Math.Abs(totalExecutedQuantity) < fill.AbsoluteFillQuantity)                  {                      // direction reversal                      fill.FillQuantity -= totalExecutedQuantity;                      position.PendingTrades = new List<Trade>                      {                          new Trade                          {                              Symbol = fill.Symbol'                              EntryTime = fill.UtcTime'                              EntryPrice = fill.FillPrice'                              Direction = fill.FillQuantity > 0 ? TradeDirection.Long : TradeDirection.Short'                              Quantity = fill.AbsoluteFillQuantity'                              TotalFees = 0                          }                      };                      position.MinPrice = fill.FillPrice;                      position.MaxPrice = fill.FillPrice;                  }              }
Magic Number,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFlatToFlat,The following statement contains a magic number: if (Math.Sign(position.PendingFills[0].FillQuantity) == Math.Sign(fill.FillQuantity))              {                  // execution has same direction of trade                  position.PendingFills.Add(fill);                  position.TotalFees += orderFee;              }              else              {                  // execution has opposite direction of trade                  if (position.PendingFills.Sum(x => x.FillQuantity) + fill.FillQuantity == 0 || fill.AbsoluteFillQuantity > Math.Abs(position.PendingFills.Sum(x => x.FillQuantity)))                  {                      // trade closed                      position.PendingFills.Add(fill);                      position.TotalFees += orderFee;                        var reverseQuantity = position.PendingFills.Sum(x => x.FillQuantity);                        var index = _matchingMethod == FillMatchingMethod.FIFO ? 0 : position.PendingFills.Count - 1;                        var entryTime = position.PendingFills[0].UtcTime;                      var totalEntryQuantity = 0m;                      var totalExitQuantity = 0m;                      var entryAveragePrice = 0m;                      var exitAveragePrice = 0m;                        while (position.PendingFills.Count > 0)                      {                          if (Math.Sign(position.PendingFills[index].FillQuantity) != Math.Sign(fill.FillQuantity))                          {                              // entry                              totalEntryQuantity += position.PendingFills[index].FillQuantity;                              entryAveragePrice += (position.PendingFills[index].FillPrice - entryAveragePrice) * position.PendingFills[index].FillQuantity / totalEntryQuantity;                          }                          else                          {                              // exit                              totalExitQuantity += position.PendingFills[index].FillQuantity;                              exitAveragePrice += (position.PendingFills[index].FillPrice - exitAveragePrice) * position.PendingFills[index].FillQuantity / totalExitQuantity;                          }                          position.PendingFills.RemoveAt(index);                            if (_matchingMethod == FillMatchingMethod.LIFO && index > 0) index--;                      }                        var direction = Math.Sign(fill.FillQuantity) < 0 ? TradeDirection.Long : TradeDirection.Short;                        AddNewTrade(new Trade                      {                          Symbol = fill.Symbol'                          EntryTime = entryTime'                          EntryPrice = entryAveragePrice'                          Direction = direction'                          Quantity = Math.Abs(totalEntryQuantity)'                          ExitTime = fill.UtcTime'                          ExitPrice = exitAveragePrice'                          ProfitLoss = Math.Round((exitAveragePrice - entryAveragePrice) * Math.Abs(totalEntryQuantity) * Math.Sign(totalEntryQuantity) * conversionRate * multiplier' 2)'                          TotalFees = position.TotalFees'                          MAE = Math.Round((direction == TradeDirection.Long ? position.MinPrice - entryAveragePrice : entryAveragePrice - position.MaxPrice) * Math.Abs(totalEntryQuantity) * conversionRate * multiplier' 2)'                          MFE = Math.Round((direction == TradeDirection.Long ? position.MaxPrice - entryAveragePrice : entryAveragePrice - position.MinPrice) * Math.Abs(totalEntryQuantity) * conversionRate * multiplier' 2)                      });                        _positions.Remove(fill.Symbol);                        if (reverseQuantity != 0)                      {                          // direction reversal                          fill.FillQuantity = reverseQuantity;                          _positions[fill.Symbol] = new Position                          {                              PendingFills = new List<OrderEvent> { fill }'                              TotalFees = 0'                              MinPrice = fill.FillPrice'                              MaxPrice = fill.FillPrice                          };                      }                  }                  else                  {                      // trade open                      position.PendingFills.Add(fill);                      position.TotalFees += orderFee;                  }              }
Magic Number,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFlatToFlat,The following statement contains a magic number: if (Math.Sign(position.PendingFills[0].FillQuantity) == Math.Sign(fill.FillQuantity))              {                  // execution has same direction of trade                  position.PendingFills.Add(fill);                  position.TotalFees += orderFee;              }              else              {                  // execution has opposite direction of trade                  if (position.PendingFills.Sum(x => x.FillQuantity) + fill.FillQuantity == 0 || fill.AbsoluteFillQuantity > Math.Abs(position.PendingFills.Sum(x => x.FillQuantity)))                  {                      // trade closed                      position.PendingFills.Add(fill);                      position.TotalFees += orderFee;                        var reverseQuantity = position.PendingFills.Sum(x => x.FillQuantity);                        var index = _matchingMethod == FillMatchingMethod.FIFO ? 0 : position.PendingFills.Count - 1;                        var entryTime = position.PendingFills[0].UtcTime;                      var totalEntryQuantity = 0m;                      var totalExitQuantity = 0m;                      var entryAveragePrice = 0m;                      var exitAveragePrice = 0m;                        while (position.PendingFills.Count > 0)                      {                          if (Math.Sign(position.PendingFills[index].FillQuantity) != Math.Sign(fill.FillQuantity))                          {                              // entry                              totalEntryQuantity += position.PendingFills[index].FillQuantity;                              entryAveragePrice += (position.PendingFills[index].FillPrice - entryAveragePrice) * position.PendingFills[index].FillQuantity / totalEntryQuantity;                          }                          else                          {                              // exit                              totalExitQuantity += position.PendingFills[index].FillQuantity;                              exitAveragePrice += (position.PendingFills[index].FillPrice - exitAveragePrice) * position.PendingFills[index].FillQuantity / totalExitQuantity;                          }                          position.PendingFills.RemoveAt(index);                            if (_matchingMethod == FillMatchingMethod.LIFO && index > 0) index--;                      }                        var direction = Math.Sign(fill.FillQuantity) < 0 ? TradeDirection.Long : TradeDirection.Short;                        AddNewTrade(new Trade                      {                          Symbol = fill.Symbol'                          EntryTime = entryTime'                          EntryPrice = entryAveragePrice'                          Direction = direction'                          Quantity = Math.Abs(totalEntryQuantity)'                          ExitTime = fill.UtcTime'                          ExitPrice = exitAveragePrice'                          ProfitLoss = Math.Round((exitAveragePrice - entryAveragePrice) * Math.Abs(totalEntryQuantity) * Math.Sign(totalEntryQuantity) * conversionRate * multiplier' 2)'                          TotalFees = position.TotalFees'                          MAE = Math.Round((direction == TradeDirection.Long ? position.MinPrice - entryAveragePrice : entryAveragePrice - position.MaxPrice) * Math.Abs(totalEntryQuantity) * conversionRate * multiplier' 2)'                          MFE = Math.Round((direction == TradeDirection.Long ? position.MaxPrice - entryAveragePrice : entryAveragePrice - position.MinPrice) * Math.Abs(totalEntryQuantity) * conversionRate * multiplier' 2)                      });                        _positions.Remove(fill.Symbol);                        if (reverseQuantity != 0)                      {                          // direction reversal                          fill.FillQuantity = reverseQuantity;                          _positions[fill.Symbol] = new Position                          {                              PendingFills = new List<OrderEvent> { fill }'                              TotalFees = 0'                              MinPrice = fill.FillPrice'                              MaxPrice = fill.FillPrice                          };                      }                  }                  else                  {                      // trade open                      position.PendingFills.Add(fill);                      position.TotalFees += orderFee;                  }              }
Magic Number,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFlatToFlat,The following statement contains a magic number: if (Math.Sign(position.PendingFills[0].FillQuantity) == Math.Sign(fill.FillQuantity))              {                  // execution has same direction of trade                  position.PendingFills.Add(fill);                  position.TotalFees += orderFee;              }              else              {                  // execution has opposite direction of trade                  if (position.PendingFills.Sum(x => x.FillQuantity) + fill.FillQuantity == 0 || fill.AbsoluteFillQuantity > Math.Abs(position.PendingFills.Sum(x => x.FillQuantity)))                  {                      // trade closed                      position.PendingFills.Add(fill);                      position.TotalFees += orderFee;                        var reverseQuantity = position.PendingFills.Sum(x => x.FillQuantity);                        var index = _matchingMethod == FillMatchingMethod.FIFO ? 0 : position.PendingFills.Count - 1;                        var entryTime = position.PendingFills[0].UtcTime;                      var totalEntryQuantity = 0m;                      var totalExitQuantity = 0m;                      var entryAveragePrice = 0m;                      var exitAveragePrice = 0m;                        while (position.PendingFills.Count > 0)                      {                          if (Math.Sign(position.PendingFills[index].FillQuantity) != Math.Sign(fill.FillQuantity))                          {                              // entry                              totalEntryQuantity += position.PendingFills[index].FillQuantity;                              entryAveragePrice += (position.PendingFills[index].FillPrice - entryAveragePrice) * position.PendingFills[index].FillQuantity / totalEntryQuantity;                          }                          else                          {                              // exit                              totalExitQuantity += position.PendingFills[index].FillQuantity;                              exitAveragePrice += (position.PendingFills[index].FillPrice - exitAveragePrice) * position.PendingFills[index].FillQuantity / totalExitQuantity;                          }                          position.PendingFills.RemoveAt(index);                            if (_matchingMethod == FillMatchingMethod.LIFO && index > 0) index--;                      }                        var direction = Math.Sign(fill.FillQuantity) < 0 ? TradeDirection.Long : TradeDirection.Short;                        AddNewTrade(new Trade                      {                          Symbol = fill.Symbol'                          EntryTime = entryTime'                          EntryPrice = entryAveragePrice'                          Direction = direction'                          Quantity = Math.Abs(totalEntryQuantity)'                          ExitTime = fill.UtcTime'                          ExitPrice = exitAveragePrice'                          ProfitLoss = Math.Round((exitAveragePrice - entryAveragePrice) * Math.Abs(totalEntryQuantity) * Math.Sign(totalEntryQuantity) * conversionRate * multiplier' 2)'                          TotalFees = position.TotalFees'                          MAE = Math.Round((direction == TradeDirection.Long ? position.MinPrice - entryAveragePrice : entryAveragePrice - position.MaxPrice) * Math.Abs(totalEntryQuantity) * conversionRate * multiplier' 2)'                          MFE = Math.Round((direction == TradeDirection.Long ? position.MaxPrice - entryAveragePrice : entryAveragePrice - position.MinPrice) * Math.Abs(totalEntryQuantity) * conversionRate * multiplier' 2)                      });                        _positions.Remove(fill.Symbol);                        if (reverseQuantity != 0)                      {                          // direction reversal                          fill.FillQuantity = reverseQuantity;                          _positions[fill.Symbol] = new Position                          {                              PendingFills = new List<OrderEvent> { fill }'                              TotalFees = 0'                              MinPrice = fill.FillPrice'                              MaxPrice = fill.FillPrice                          };                      }                  }                  else                  {                      // trade open                      position.PendingFills.Add(fill);                      position.TotalFees += orderFee;                  }              }
Magic Number,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFlatToReduced,The following statement contains a magic number: if (Math.Sign(fill.FillQuantity) == Math.Sign(position.PendingFills[index].FillQuantity))              {                  // execution has same direction of trade                  position.PendingFills.Add(fill);                  position.TotalFees += orderFee;              }              else              {                  // execution has opposite direction of trade                  var entryTime = position.PendingFills[index].UtcTime;                  var totalExecutedQuantity = 0m;                  var entryPrice = 0m;                  position.TotalFees += orderFee;                    while (position.PendingFills.Count > 0 && Math.Abs(totalExecutedQuantity) < fill.AbsoluteFillQuantity)                  {                      if (fill.AbsoluteFillQuantity >= Math.Abs(position.PendingFills[index].FillQuantity))                      {                          if (_matchingMethod == FillMatchingMethod.LIFO)                              entryTime = position.PendingFills[index].UtcTime;                            totalExecutedQuantity -= position.PendingFills[index].FillQuantity;                          entryPrice -= (position.PendingFills[index].FillPrice - entryPrice) * position.PendingFills[index].FillQuantity / totalExecutedQuantity;                          position.PendingFills.RemoveAt(index);                            if (_matchingMethod == FillMatchingMethod.LIFO && index > 0) index--;                      }                      else                      {                          totalExecutedQuantity += fill.FillQuantity;                          entryPrice += (position.PendingFills[index].FillPrice - entryPrice) * fill.FillQuantity / totalExecutedQuantity;                          position.PendingFills[index].FillQuantity += fill.FillQuantity;                      }                  }                    var direction = totalExecutedQuantity < 0 ? TradeDirection.Long : TradeDirection.Short;                    AddNewTrade(new Trade                  {                      Symbol = fill.Symbol'                      EntryTime = entryTime'                      EntryPrice = entryPrice'                      Direction = direction'                      Quantity = Math.Abs(totalExecutedQuantity)'                      ExitTime = fill.UtcTime'                      ExitPrice = fill.FillPrice'                      ProfitLoss = Math.Round((fill.FillPrice - entryPrice) * Math.Abs(totalExecutedQuantity) * Math.Sign(-totalExecutedQuantity) * conversionRate * multiplier' 2)'                      TotalFees = position.TotalFees'                      MAE = Math.Round((direction == TradeDirection.Long ? position.MinPrice - entryPrice : entryPrice - position.MaxPrice) * Math.Abs(totalExecutedQuantity) * conversionRate * multiplier' 2)'                      MFE = Math.Round((direction == TradeDirection.Long ? position.MaxPrice - entryPrice : entryPrice - position.MinPrice) * Math.Abs(totalExecutedQuantity) * conversionRate * multiplier' 2)                  });                    if (Math.Abs(totalExecutedQuantity) < fill.AbsoluteFillQuantity)                  {                      // direction reversal                      fill.FillQuantity -= totalExecutedQuantity;                      position.PendingFills = new List<OrderEvent> { fill };                      position.TotalFees = 0;                      position.MinPrice = fill.FillPrice;                      position.MaxPrice = fill.FillPrice;                  }                  else if (Math.Abs(totalExecutedQuantity) == fill.AbsoluteFillQuantity)                  {                      if (position.PendingFills.Count == 0)                          _positions.Remove(fill.Symbol);                      else                          position.TotalFees = 0;                  }              }
Magic Number,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFlatToReduced,The following statement contains a magic number: if (Math.Sign(fill.FillQuantity) == Math.Sign(position.PendingFills[index].FillQuantity))              {                  // execution has same direction of trade                  position.PendingFills.Add(fill);                  position.TotalFees += orderFee;              }              else              {                  // execution has opposite direction of trade                  var entryTime = position.PendingFills[index].UtcTime;                  var totalExecutedQuantity = 0m;                  var entryPrice = 0m;                  position.TotalFees += orderFee;                    while (position.PendingFills.Count > 0 && Math.Abs(totalExecutedQuantity) < fill.AbsoluteFillQuantity)                  {                      if (fill.AbsoluteFillQuantity >= Math.Abs(position.PendingFills[index].FillQuantity))                      {                          if (_matchingMethod == FillMatchingMethod.LIFO)                              entryTime = position.PendingFills[index].UtcTime;                            totalExecutedQuantity -= position.PendingFills[index].FillQuantity;                          entryPrice -= (position.PendingFills[index].FillPrice - entryPrice) * position.PendingFills[index].FillQuantity / totalExecutedQuantity;                          position.PendingFills.RemoveAt(index);                            if (_matchingMethod == FillMatchingMethod.LIFO && index > 0) index--;                      }                      else                      {                          totalExecutedQuantity += fill.FillQuantity;                          entryPrice += (position.PendingFills[index].FillPrice - entryPrice) * fill.FillQuantity / totalExecutedQuantity;                          position.PendingFills[index].FillQuantity += fill.FillQuantity;                      }                  }                    var direction = totalExecutedQuantity < 0 ? TradeDirection.Long : TradeDirection.Short;                    AddNewTrade(new Trade                  {                      Symbol = fill.Symbol'                      EntryTime = entryTime'                      EntryPrice = entryPrice'                      Direction = direction'                      Quantity = Math.Abs(totalExecutedQuantity)'                      ExitTime = fill.UtcTime'                      ExitPrice = fill.FillPrice'                      ProfitLoss = Math.Round((fill.FillPrice - entryPrice) * Math.Abs(totalExecutedQuantity) * Math.Sign(-totalExecutedQuantity) * conversionRate * multiplier' 2)'                      TotalFees = position.TotalFees'                      MAE = Math.Round((direction == TradeDirection.Long ? position.MinPrice - entryPrice : entryPrice - position.MaxPrice) * Math.Abs(totalExecutedQuantity) * conversionRate * multiplier' 2)'                      MFE = Math.Round((direction == TradeDirection.Long ? position.MaxPrice - entryPrice : entryPrice - position.MinPrice) * Math.Abs(totalExecutedQuantity) * conversionRate * multiplier' 2)                  });                    if (Math.Abs(totalExecutedQuantity) < fill.AbsoluteFillQuantity)                  {                      // direction reversal                      fill.FillQuantity -= totalExecutedQuantity;                      position.PendingFills = new List<OrderEvent> { fill };                      position.TotalFees = 0;                      position.MinPrice = fill.FillPrice;                      position.MaxPrice = fill.FillPrice;                  }                  else if (Math.Abs(totalExecutedQuantity) == fill.AbsoluteFillQuantity)                  {                      if (position.PendingFills.Count == 0)                          _positions.Remove(fill.Symbol);                      else                          position.TotalFees = 0;                  }              }
Magic Number,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFillUsingFlatToReduced,The following statement contains a magic number: if (Math.Sign(fill.FillQuantity) == Math.Sign(position.PendingFills[index].FillQuantity))              {                  // execution has same direction of trade                  position.PendingFills.Add(fill);                  position.TotalFees += orderFee;              }              else              {                  // execution has opposite direction of trade                  var entryTime = position.PendingFills[index].UtcTime;                  var totalExecutedQuantity = 0m;                  var entryPrice = 0m;                  position.TotalFees += orderFee;                    while (position.PendingFills.Count > 0 && Math.Abs(totalExecutedQuantity) < fill.AbsoluteFillQuantity)                  {                      if (fill.AbsoluteFillQuantity >= Math.Abs(position.PendingFills[index].FillQuantity))                      {                          if (_matchingMethod == FillMatchingMethod.LIFO)                              entryTime = position.PendingFills[index].UtcTime;                            totalExecutedQuantity -= position.PendingFills[index].FillQuantity;                          entryPrice -= (position.PendingFills[index].FillPrice - entryPrice) * position.PendingFills[index].FillQuantity / totalExecutedQuantity;                          position.PendingFills.RemoveAt(index);                            if (_matchingMethod == FillMatchingMethod.LIFO && index > 0) index--;                      }                      else                      {                          totalExecutedQuantity += fill.FillQuantity;                          entryPrice += (position.PendingFills[index].FillPrice - entryPrice) * fill.FillQuantity / totalExecutedQuantity;                          position.PendingFills[index].FillQuantity += fill.FillQuantity;                      }                  }                    var direction = totalExecutedQuantity < 0 ? TradeDirection.Long : TradeDirection.Short;                    AddNewTrade(new Trade                  {                      Symbol = fill.Symbol'                      EntryTime = entryTime'                      EntryPrice = entryPrice'                      Direction = direction'                      Quantity = Math.Abs(totalExecutedQuantity)'                      ExitTime = fill.UtcTime'                      ExitPrice = fill.FillPrice'                      ProfitLoss = Math.Round((fill.FillPrice - entryPrice) * Math.Abs(totalExecutedQuantity) * Math.Sign(-totalExecutedQuantity) * conversionRate * multiplier' 2)'                      TotalFees = position.TotalFees'                      MAE = Math.Round((direction == TradeDirection.Long ? position.MinPrice - entryPrice : entryPrice - position.MaxPrice) * Math.Abs(totalExecutedQuantity) * conversionRate * multiplier' 2)'                      MFE = Math.Round((direction == TradeDirection.Long ? position.MaxPrice - entryPrice : entryPrice - position.MinPrice) * Math.Abs(totalExecutedQuantity) * conversionRate * multiplier' 2)                  });                    if (Math.Abs(totalExecutedQuantity) < fill.AbsoluteFillQuantity)                  {                      // direction reversal                      fill.FillQuantity -= totalExecutedQuantity;                      position.PendingFills = new List<OrderEvent> { fill };                      position.TotalFees = 0;                      position.MinPrice = fill.FillPrice;                      position.MaxPrice = fill.FillPrice;                  }                  else if (Math.Abs(totalExecutedQuantity) == fill.AbsoluteFillQuantity)                  {                      if (position.PendingFills.Count == 0)                          _positions.Remove(fill.Symbol);                      else                          position.TotalFees = 0;                  }              }
Magic Number,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,ReadSymbolFromZipEntry,The following statement contains a magic number: switch (symbol.ID.SecurityType)              {                  case SecurityType.Option:                      if (isHourlyOrDaily)                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[2]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[3]' true);                          var strike = decimal.Parse(parts[4]) / 10000m;                          var expiry = DateTime.ParseExact(parts[5]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      else                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[4]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[5]' true);                          var strike = decimal.Parse(parts[6]) / 10000m;                          var expiry = DateTime.ParseExact(parts[7]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      break;                    case SecurityType.Future:                      if (isHourlyOrDaily)                      {                          var expiryYearMonth = DateTime.ParseExact(parts[2]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[0]' Market.USA' futureExpiry);                      }                      else                      {                          var expiryYearMonth = DateTime.ParseExact(parts[4]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[1]' Market.USA' futureExpiry);                      }                    default:                      throw new NotImplementedException("ReadSymbolFromZipEntry is not implemented for " + symbol.ID.SecurityType + " " + resolution);              }
Magic Number,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,ReadSymbolFromZipEntry,The following statement contains a magic number: switch (symbol.ID.SecurityType)              {                  case SecurityType.Option:                      if (isHourlyOrDaily)                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[2]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[3]' true);                          var strike = decimal.Parse(parts[4]) / 10000m;                          var expiry = DateTime.ParseExact(parts[5]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      else                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[4]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[5]' true);                          var strike = decimal.Parse(parts[6]) / 10000m;                          var expiry = DateTime.ParseExact(parts[7]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      break;                    case SecurityType.Future:                      if (isHourlyOrDaily)                      {                          var expiryYearMonth = DateTime.ParseExact(parts[2]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[0]' Market.USA' futureExpiry);                      }                      else                      {                          var expiryYearMonth = DateTime.ParseExact(parts[4]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[1]' Market.USA' futureExpiry);                      }                    default:                      throw new NotImplementedException("ReadSymbolFromZipEntry is not implemented for " + symbol.ID.SecurityType + " " + resolution);              }
Magic Number,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,ReadSymbolFromZipEntry,The following statement contains a magic number: switch (symbol.ID.SecurityType)              {                  case SecurityType.Option:                      if (isHourlyOrDaily)                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[2]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[3]' true);                          var strike = decimal.Parse(parts[4]) / 10000m;                          var expiry = DateTime.ParseExact(parts[5]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      else                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[4]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[5]' true);                          var strike = decimal.Parse(parts[6]) / 10000m;                          var expiry = DateTime.ParseExact(parts[7]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      break;                    case SecurityType.Future:                      if (isHourlyOrDaily)                      {                          var expiryYearMonth = DateTime.ParseExact(parts[2]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[0]' Market.USA' futureExpiry);                      }                      else                      {                          var expiryYearMonth = DateTime.ParseExact(parts[4]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[1]' Market.USA' futureExpiry);                      }                    default:                      throw new NotImplementedException("ReadSymbolFromZipEntry is not implemented for " + symbol.ID.SecurityType + " " + resolution);              }
Magic Number,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,ReadSymbolFromZipEntry,The following statement contains a magic number: switch (symbol.ID.SecurityType)              {                  case SecurityType.Option:                      if (isHourlyOrDaily)                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[2]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[3]' true);                          var strike = decimal.Parse(parts[4]) / 10000m;                          var expiry = DateTime.ParseExact(parts[5]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      else                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[4]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[5]' true);                          var strike = decimal.Parse(parts[6]) / 10000m;                          var expiry = DateTime.ParseExact(parts[7]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      break;                    case SecurityType.Future:                      if (isHourlyOrDaily)                      {                          var expiryYearMonth = DateTime.ParseExact(parts[2]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[0]' Market.USA' futureExpiry);                      }                      else                      {                          var expiryYearMonth = DateTime.ParseExact(parts[4]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[1]' Market.USA' futureExpiry);                      }                    default:                      throw new NotImplementedException("ReadSymbolFromZipEntry is not implemented for " + symbol.ID.SecurityType + " " + resolution);              }
Magic Number,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,ReadSymbolFromZipEntry,The following statement contains a magic number: switch (symbol.ID.SecurityType)              {                  case SecurityType.Option:                      if (isHourlyOrDaily)                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[2]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[3]' true);                          var strike = decimal.Parse(parts[4]) / 10000m;                          var expiry = DateTime.ParseExact(parts[5]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      else                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[4]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[5]' true);                          var strike = decimal.Parse(parts[6]) / 10000m;                          var expiry = DateTime.ParseExact(parts[7]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      break;                    case SecurityType.Future:                      if (isHourlyOrDaily)                      {                          var expiryYearMonth = DateTime.ParseExact(parts[2]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[0]' Market.USA' futureExpiry);                      }                      else                      {                          var expiryYearMonth = DateTime.ParseExact(parts[4]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[1]' Market.USA' futureExpiry);                      }                    default:                      throw new NotImplementedException("ReadSymbolFromZipEntry is not implemented for " + symbol.ID.SecurityType + " " + resolution);              }
Magic Number,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,ReadSymbolFromZipEntry,The following statement contains a magic number: switch (symbol.ID.SecurityType)              {                  case SecurityType.Option:                      if (isHourlyOrDaily)                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[2]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[3]' true);                          var strike = decimal.Parse(parts[4]) / 10000m;                          var expiry = DateTime.ParseExact(parts[5]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      else                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[4]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[5]' true);                          var strike = decimal.Parse(parts[6]) / 10000m;                          var expiry = DateTime.ParseExact(parts[7]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      break;                    case SecurityType.Future:                      if (isHourlyOrDaily)                      {                          var expiryYearMonth = DateTime.ParseExact(parts[2]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[0]' Market.USA' futureExpiry);                      }                      else                      {                          var expiryYearMonth = DateTime.ParseExact(parts[4]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[1]' Market.USA' futureExpiry);                      }                    default:                      throw new NotImplementedException("ReadSymbolFromZipEntry is not implemented for " + symbol.ID.SecurityType + " " + resolution);              }
Magic Number,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,ReadSymbolFromZipEntry,The following statement contains a magic number: switch (symbol.ID.SecurityType)              {                  case SecurityType.Option:                      if (isHourlyOrDaily)                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[2]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[3]' true);                          var strike = decimal.Parse(parts[4]) / 10000m;                          var expiry = DateTime.ParseExact(parts[5]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      else                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[4]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[5]' true);                          var strike = decimal.Parse(parts[6]) / 10000m;                          var expiry = DateTime.ParseExact(parts[7]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      break;                    case SecurityType.Future:                      if (isHourlyOrDaily)                      {                          var expiryYearMonth = DateTime.ParseExact(parts[2]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[0]' Market.USA' futureExpiry);                      }                      else                      {                          var expiryYearMonth = DateTime.ParseExact(parts[4]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[1]' Market.USA' futureExpiry);                      }                    default:                      throw new NotImplementedException("ReadSymbolFromZipEntry is not implemented for " + symbol.ID.SecurityType + " " + resolution);              }
Magic Number,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,ReadSymbolFromZipEntry,The following statement contains a magic number: switch (symbol.ID.SecurityType)              {                  case SecurityType.Option:                      if (isHourlyOrDaily)                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[2]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[3]' true);                          var strike = decimal.Parse(parts[4]) / 10000m;                          var expiry = DateTime.ParseExact(parts[5]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      else                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[4]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[5]' true);                          var strike = decimal.Parse(parts[6]) / 10000m;                          var expiry = DateTime.ParseExact(parts[7]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      break;                    case SecurityType.Future:                      if (isHourlyOrDaily)                      {                          var expiryYearMonth = DateTime.ParseExact(parts[2]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[0]' Market.USA' futureExpiry);                      }                      else                      {                          var expiryYearMonth = DateTime.ParseExact(parts[4]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[1]' Market.USA' futureExpiry);                      }                    default:                      throw new NotImplementedException("ReadSymbolFromZipEntry is not implemented for " + symbol.ID.SecurityType + " " + resolution);              }
Magic Number,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,ReadSymbolFromZipEntry,The following statement contains a magic number: switch (symbol.ID.SecurityType)              {                  case SecurityType.Option:                      if (isHourlyOrDaily)                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[2]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[3]' true);                          var strike = decimal.Parse(parts[4]) / 10000m;                          var expiry = DateTime.ParseExact(parts[5]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      else                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[4]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[5]' true);                          var strike = decimal.Parse(parts[6]) / 10000m;                          var expiry = DateTime.ParseExact(parts[7]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      break;                    case SecurityType.Future:                      if (isHourlyOrDaily)                      {                          var expiryYearMonth = DateTime.ParseExact(parts[2]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[0]' Market.USA' futureExpiry);                      }                      else                      {                          var expiryYearMonth = DateTime.ParseExact(parts[4]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[1]' Market.USA' futureExpiry);                      }                    default:                      throw new NotImplementedException("ReadSymbolFromZipEntry is not implemented for " + symbol.ID.SecurityType + " " + resolution);              }
Magic Number,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,ReadSymbolFromZipEntry,The following statement contains a magic number: switch (symbol.ID.SecurityType)              {                  case SecurityType.Option:                      if (isHourlyOrDaily)                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[2]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[3]' true);                          var strike = decimal.Parse(parts[4]) / 10000m;                          var expiry = DateTime.ParseExact(parts[5]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      else                      {                          var style = (OptionStyle)Enum.Parse(typeof(OptionStyle)' parts[4]' true);                          var right = (OptionRight)Enum.Parse(typeof(OptionRight)' parts[5]' true);                          var strike = decimal.Parse(parts[6]) / 10000m;                          var expiry = DateTime.ParseExact(parts[7]' DateFormat.EightCharacter' null);                          return Symbol.CreateOption(symbol.Underlying' Market.USA' style' right' strike' expiry);                      }                      break;                    case SecurityType.Future:                      if (isHourlyOrDaily)                      {                          var expiryYearMonth = DateTime.ParseExact(parts[2]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[0]' Market.USA' futureExpiry);                      }                      else                      {                          var expiryYearMonth = DateTime.ParseExact(parts[4]' DateFormat.YearMonth' null);                          var futureExpiryFunc = FuturesExpiryFunctions.FuturesExpiryFunction(parts[1]);                          var futureExpiry = futureExpiryFunc(expiryYearMonth);                          return Symbol.CreateFuture(parts[1]' Market.USA' futureExpiry);                      }                    default:                      throw new NotImplementedException("ReadSymbolFromZipEntry is not implemented for " + symbol.ID.SecurityType + " " + resolution);              }
Magic Number,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,Scale,The following statement contains a magic number: return (long)(value*10000);
Magic Number,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,TryParsePath,The following statement contains a magic number: try              {                  // Removes file extension                  fileName = fileName.Replace(fileName.GetExtension()' "");                    // remove any relative file path                  while (fileName.First() == '.' || pathSeparators.Any(x => x == fileName.First()))                  {                      fileName = fileName.Remove(0' 1);                  }                    // split path into components                  var info = fileName.Split(pathSeparators' StringSplitOptions.RemoveEmptyEntries).ToList();                    // find where the useful part of the path starts - i.e. the securityType                  var startIndex = info.FindIndex(x => securityTypes.Contains(x.ToLower()));                    // Gather components useed to create the security                  var market = info[startIndex + 1];                  var ticker = info[startIndex + 3];                  resolution = (Resolution)Enum.Parse(typeof(Resolution)' info[startIndex + 2]' true);                  var securityType = (SecurityType)Enum.Parse(typeof(SecurityType)' info[startIndex]' true);                    if (securityType == SecurityType.Option || securityType == SecurityType.Future)                  {                      throw new ArgumentException("LeanData.TryParsePath(): Options and futures are not supported by this method.");                  }                    // If resolution is Daily or Hour' we do not need to set the date and tick type                  if (resolution < Resolution.Hour)                  {                      date = DateTime.ParseExact(info[startIndex + 4].Substring(0' 8)' DateFormat.EightCharacter' null);                  }                    symbol = Symbol.Create(ticker' securityType' market);              }              catch (Exception ex)              {                  Log.Error("LeanData.TryParsePath(): Error encountered while parsing the path {0}. Error: {1}"' fileName' ex.GetBaseException());                  return false;              }
Magic Number,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,TryParsePath,The following statement contains a magic number: try              {                  // Removes file extension                  fileName = fileName.Replace(fileName.GetExtension()' "");                    // remove any relative file path                  while (fileName.First() == '.' || pathSeparators.Any(x => x == fileName.First()))                  {                      fileName = fileName.Remove(0' 1);                  }                    // split path into components                  var info = fileName.Split(pathSeparators' StringSplitOptions.RemoveEmptyEntries).ToList();                    // find where the useful part of the path starts - i.e. the securityType                  var startIndex = info.FindIndex(x => securityTypes.Contains(x.ToLower()));                    // Gather components useed to create the security                  var market = info[startIndex + 1];                  var ticker = info[startIndex + 3];                  resolution = (Resolution)Enum.Parse(typeof(Resolution)' info[startIndex + 2]' true);                  var securityType = (SecurityType)Enum.Parse(typeof(SecurityType)' info[startIndex]' true);                    if (securityType == SecurityType.Option || securityType == SecurityType.Future)                  {                      throw new ArgumentException("LeanData.TryParsePath(): Options and futures are not supported by this method.");                  }                    // If resolution is Daily or Hour' we do not need to set the date and tick type                  if (resolution < Resolution.Hour)                  {                      date = DateTime.ParseExact(info[startIndex + 4].Substring(0' 8)' DateFormat.EightCharacter' null);                  }                    symbol = Symbol.Create(ticker' securityType' market);              }              catch (Exception ex)              {                  Log.Error("LeanData.TryParsePath(): Error encountered while parsing the path {0}. Error: {1}"' fileName' ex.GetBaseException());                  return false;              }
Magic Number,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,TryParsePath,The following statement contains a magic number: try              {                  // Removes file extension                  fileName = fileName.Replace(fileName.GetExtension()' "");                    // remove any relative file path                  while (fileName.First() == '.' || pathSeparators.Any(x => x == fileName.First()))                  {                      fileName = fileName.Remove(0' 1);                  }                    // split path into components                  var info = fileName.Split(pathSeparators' StringSplitOptions.RemoveEmptyEntries).ToList();                    // find where the useful part of the path starts - i.e. the securityType                  var startIndex = info.FindIndex(x => securityTypes.Contains(x.ToLower()));                    // Gather components useed to create the security                  var market = info[startIndex + 1];                  var ticker = info[startIndex + 3];                  resolution = (Resolution)Enum.Parse(typeof(Resolution)' info[startIndex + 2]' true);                  var securityType = (SecurityType)Enum.Parse(typeof(SecurityType)' info[startIndex]' true);                    if (securityType == SecurityType.Option || securityType == SecurityType.Future)                  {                      throw new ArgumentException("LeanData.TryParsePath(): Options and futures are not supported by this method.");                  }                    // If resolution is Daily or Hour' we do not need to set the date and tick type                  if (resolution < Resolution.Hour)                  {                      date = DateTime.ParseExact(info[startIndex + 4].Substring(0' 8)' DateFormat.EightCharacter' null);                  }                    symbol = Symbol.Create(ticker' securityType' market);              }              catch (Exception ex)              {                  Log.Error("LeanData.TryParsePath(): Error encountered while parsing the path {0}. Error: {1}"' fileName' ex.GetBaseException());                  return false;              }
Magic Number,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,TryParsePath,The following statement contains a magic number: try              {                  // Removes file extension                  fileName = fileName.Replace(fileName.GetExtension()' "");                    // remove any relative file path                  while (fileName.First() == '.' || pathSeparators.Any(x => x == fileName.First()))                  {                      fileName = fileName.Remove(0' 1);                  }                    // split path into components                  var info = fileName.Split(pathSeparators' StringSplitOptions.RemoveEmptyEntries).ToList();                    // find where the useful part of the path starts - i.e. the securityType                  var startIndex = info.FindIndex(x => securityTypes.Contains(x.ToLower()));                    // Gather components useed to create the security                  var market = info[startIndex + 1];                  var ticker = info[startIndex + 3];                  resolution = (Resolution)Enum.Parse(typeof(Resolution)' info[startIndex + 2]' true);                  var securityType = (SecurityType)Enum.Parse(typeof(SecurityType)' info[startIndex]' true);                    if (securityType == SecurityType.Option || securityType == SecurityType.Future)                  {                      throw new ArgumentException("LeanData.TryParsePath(): Options and futures are not supported by this method.");                  }                    // If resolution is Daily or Hour' we do not need to set the date and tick type                  if (resolution < Resolution.Hour)                  {                      date = DateTime.ParseExact(info[startIndex + 4].Substring(0' 8)' DateFormat.EightCharacter' null);                  }                    symbol = Symbol.Create(ticker' securityType' market);              }              catch (Exception ex)              {                  Log.Error("LeanData.TryParsePath(): Error encountered while parsing the path {0}. Error: {1}"' fileName' ex.GetBaseException());                  return false;              }
Magic Number,QuantConnect.Util,LeanDataPathComponents,C:\repos\QuantConnect_Lean\Common\Util\LeanDataPathComponents.cs,Parse,The following statement contains a magic number: const int LowResSecurityTypeOffset = 4;
Magic Number,QuantConnect.Util,LeanDataPathComponents,C:\repos\QuantConnect_Lean\Common\Util\LeanDataPathComponents.cs,Parse,The following statement contains a magic number: const int HighResSecurityTypeOffset = 5;
Magic Number,QuantConnect.Util,LeanDataPathComponents,C:\repos\QuantConnect_Lean\Common\Util\LeanDataPathComponents.cs,Parse,The following statement contains a magic number: const int ResolutionOffset = 2;
Magic Number,QuantConnect.Util,LeanDataPathComponents,C:\repos\QuantConnect_Lean\Common\Util\LeanDataPathComponents.cs,Parse,The following statement contains a magic number: const int TickerOffset = 3;
Magic Number,QuantConnect.Util,ParallelRunnerController,C:\repos\QuantConnect_Lean\Common\Util\ParallelRunner.cs,Dispose,The following statement contains a magic number: lock (_sync)              {                  if (_holdQueue != null) _holdQueue.Dispose();                  if (_processQueue != null) _processQueue.Dispose();                    // Wait for _holdQueue disposal be completed                  Thread.Sleep(10000);                    if (_processQueueThread != null && _processQueueThread.IsAlive) _processQueueThread.Abort();                    foreach (var worker in _workers)                  {                      worker.DisposeSafely();                  }                    if (_waitHandle != null)                  {                      _waitHandle.Set();                      _waitHandle.Dispose();                  }              }
Magic Number,QuantConnect.Util,ColorJsonConverter,C:\repos\QuantConnect_Lean\Common\Util\ColorJsonConverter.cs,Convert,The following statement contains a magic number: if (value.Length != 7)              {                  var message = string.Format("Unable to convert '{0}' to a Color. Requires string length of 7 including the leading hashtag."' value);                  throw new FormatException(message);              }
Magic Number,QuantConnect.Util,ColorJsonConverter,C:\repos\QuantConnect_Lean\Common\Util\ColorJsonConverter.cs,Convert,The following statement contains a magic number: var red = HexToInt(value.Substring(1' 2));
Magic Number,QuantConnect.Util,ColorJsonConverter,C:\repos\QuantConnect_Lean\Common\Util\ColorJsonConverter.cs,Convert,The following statement contains a magic number: var green = HexToInt(value.Substring(3' 2));
Magic Number,QuantConnect.Util,ColorJsonConverter,C:\repos\QuantConnect_Lean\Common\Util\ColorJsonConverter.cs,Convert,The following statement contains a magic number: var green = HexToInt(value.Substring(3' 2));
Magic Number,QuantConnect.Util,ColorJsonConverter,C:\repos\QuantConnect_Lean\Common\Util\ColorJsonConverter.cs,Convert,The following statement contains a magic number: var blue = HexToInt(value.Substring(5' 2));
Magic Number,QuantConnect.Util,ColorJsonConverter,C:\repos\QuantConnect_Lean\Common\Util\ColorJsonConverter.cs,Convert,The following statement contains a magic number: var blue = HexToInt(value.Substring(5' 2));
Magic Number,QuantConnect.Util,ColorJsonConverter,C:\repos\QuantConnect_Lean\Common\Util\ColorJsonConverter.cs,HexToInt,The following statement contains a magic number: if (hexValue.Length != 2)              {                  var message = string.Format("Unable to convert '{0}' to an Integer. Requires string length of 2."' hexValue);                  throw new FormatException(message);              }
Magic Number,QuantConnect.Util,PythonUtil,C:\repos\QuantConnect_Lean\Common\Util\PythonUtil.cs,ToAction,The following statement contains a magic number: using (Py.GIL())              {                  int count = 0;                  if (!TryGetArgLength(pyObject' out count) || count != 2)                  {                      return null;                  }                  dynamic method = GetModule().GetAttr("to_action2");                  return method(pyObject' typeof(T1)' typeof(T2)).AsManagedObject(typeof(Action<T1' T2>));              }
Magic Number,QuantConnect.Util,LinqExtensions,C:\repos\QuantConnect_Lean\Common\Util\LinqExtensions.cs,Median,The following statement contains a magic number: return collection.OrderBy(x => x).Skip(collection.Count/2).First();
Magic Number,QuantConnect.Util,LinqExtensions,C:\repos\QuantConnect_Lean\Common\Util\LinqExtensions.cs,BinarySearch,The following statement contains a magic number: while (lower <= upper)              {                  var middle = lower + (upper - lower) / 2;                  var comparisonResult = comparer(value' list[middle]);                  if (comparisonResult < 0)                  {                      upper = middle - 1;                  }                  else if (comparisonResult > 0)                  {                      lower = middle + 1;                  }                  else                  {                      return middle;                  }              }
Duplicate Code,QuantConnect,SymbolRepresentation,C:\repos\QuantConnect_Lean\Common\SymbolRepresentation.cs,ParseFutureTicker,The method contains a code clone-set at the following line numbers (starting from the method definition): ((9' 30)' (37' 58))
Missing Default,QuantConnect,TradingCalendar,C:\repos\QuantConnect_Lean\Common\TradingCalendar.cs,GetDaysByType,The following switch statement is missing a default case: switch (type)                      {                          case TradingDayType.BusinessDay:                              return day.BusinessDay;                          case TradingDayType.PublicHoliday:                              return day.PublicHoliday;                          case TradingDayType.Weekend:                              return day.Weekend;                          case TradingDayType.OptionExpiration:                              return day.OptionExpirations.Any();                          case TradingDayType.FutureExpiration:                              return day.FutureExpirations.Any();                          case TradingDayType.FutureRoll:                              return day.FutureRolls.Any();                          case TradingDayType.SymbolDelisting:                              return day.SymbolDelistings.Any();                          case TradingDayType.EquityDividends:                              return day.EquityDividends.Any();                      }
Missing Default,QuantConnect.Brokerages,DefaultBrokerageMessageHandler,C:\repos\QuantConnect_Lean\Common\Brokerages\DefaultBrokerageMessageHandler.cs,Handle,The following switch statement is missing a default case: switch (message.Type)              {                  case BrokerageMessageType.Information:                      _algorithm.Debug("Brokerage Info: " + message.Message);                      break;                                    case BrokerageMessageType.Warning:                      _algorithm.Error("Brokerage Warning: " + message.Message);                      break;                    case BrokerageMessageType.Error:                      _algorithm.Error("Brokerage Error: " + message.Message);                      _algorithm.RunTimeError = new Exception(message.Message);                      break;                    case BrokerageMessageType.Disconnect:                      _connected = false;                      Log.Trace("DefaultBrokerageMessageHandler.Handle(): Disconnected.");                        // check to see if any non-custom security exchanges are open within the next x minutes                      var open = (from kvp in _algorithm.Securities                                  let security = kvp.Value                                  where security.Type != SecurityType.Base                                  let exchange = security.Exchange                                  let localTime = _algorithm.UtcTime.ConvertFromUtc(exchange.TimeZone)                                  where exchange.IsOpenDuringBar(localTime' localTime + _openThreshold' security.IsExtendedMarketHours)                                  select security).Any();                        // if any are open then we need to kill the algorithm                      if (open)                      {                          Log.Trace("DefaultBrokerageMessageHandler.Handle(): Disconnect when exchanges are open' trying to reconnect for " + _initialDelay.TotalMinutes + " minutes.");                            // wait 15 minutes before killing algorithm                          StartCheckReconnected(_initialDelay' message);                      }                      else                      {                          Log.Trace("DefaultBrokerageMessageHandler.Handle(): Disconnect when exchanges are closed' checking back before exchange open.");                            // if they aren't open' we'll need to check again a little bit before markets open                          DateTime nextMarketOpenUtc;                          if (_algorithm.Securities.Count != 0)                          {                              nextMarketOpenUtc = (from kvp in _algorithm.Securities                                                   let security = kvp.Value                                                   where security.Type != SecurityType.Base                                                   let exchange = security.Exchange                                                   let localTime = _algorithm.UtcTime.ConvertFromUtc(exchange.TimeZone)                                                   let marketOpen = exchange.Hours.GetNextMarketOpen(localTime' security.IsExtendedMarketHours)                                                   let marketOpenUtc = marketOpen.ConvertToUtc(exchange.TimeZone)                                                   select marketOpenUtc).Min();                          }                          else                          {                              // if we have no securities just make next market open an hour from now                              nextMarketOpenUtc = DateTime.UtcNow.AddHours(1);                          }                            var timeUntilNextMarketOpen = nextMarketOpenUtc - DateTime.UtcNow - _openThreshold;                          Log.Trace("DefaultBrokerageMessageHandler.Handle(): TimeUntilNextMarketOpen: " + timeUntilNextMarketOpen);                            // wake up 5 minutes before market open and check if we've reconnected                          StartCheckReconnected(timeUntilNextMarketOpen' message);                      }                      break;                    case BrokerageMessageType.Reconnect:                      _connected = true;                      Log.Trace("DefaultBrokerageMessageHandler.Handle(): Reconnected.");                        if (_cancellationTokenSource != null && !_cancellationTokenSource.IsCancellationRequested)                      {                          _cancellationTokenSource.Cancel();                      }                      break;              }
Missing Default,QuantConnect.Brokerages,DefaultBrokerageModel,C:\repos\QuantConnect_Lean\Common\Brokerages\DefaultBrokerageModel.cs,GetSettlementModel,The following switch statement is missing a default case: switch (security.Type)                  {                      case SecurityType.Equity:                          return new DelayedSettlementModel(Equity.DefaultSettlementDays' Equity.DefaultSettlementTime);                        case SecurityType.Option:                          return new DelayedSettlementModel(Option.DefaultSettlementDays' Option.DefaultSettlementTime);                  }
Missing Default,QuantConnect.Orders.Fills,ImmediateFillModel,C:\repos\QuantConnect_Lean\Common\Orders\Fills\ImmediateFillModel.cs,MarketFill,The following switch statement is missing a default case: switch (order.Direction)              {                  case OrderDirection.Buy:                      fill.FillPrice += slip;                      break;                  case OrderDirection.Sell:                      fill.FillPrice -= slip;                      break;              }
Missing Default,QuantConnect.Orders.Fills,ImmediateFillModel,C:\repos\QuantConnect_Lean\Common\Orders\Fills\ImmediateFillModel.cs,StopMarketFill,The following switch statement is missing a default case: switch (order.Direction)              {                  case OrderDirection.Sell:                      //-> 1.1 Sell Stop: If Price below setpoint' Sell:                      if (prices.Low < order.StopPrice)                      {                          fill.Status = OrderStatus.Filled;                          // Assuming worse case scenario fill - fill at lowest of the stop & asset price.                          fill.FillPrice = Math.Min(order.StopPrice' prices.Current - slip);                      }                      break;                    case OrderDirection.Buy:                      //-> 1.2 Buy Stop: If Price Above Setpoint' Buy:                      if (prices.High > order.StopPrice)                      {                          fill.Status = OrderStatus.Filled;                          // Assuming worse case scenario fill - fill at highest of the stop & asset price.                          fill.FillPrice = Math.Max(order.StopPrice' prices.Current + slip);                      }                      break;              }
Missing Default,QuantConnect.Orders.Fills,ImmediateFillModel,C:\repos\QuantConnect_Lean\Common\Orders\Fills\ImmediateFillModel.cs,StopLimitFill,The following switch statement is missing a default case: switch (order.Direction)              {                  case OrderDirection.Buy:                      //-> 1.2 Buy Stop: If Price Above Setpoint' Buy:                      if (prices.High > order.StopPrice || order.StopTriggered)                      {                          order.StopTriggered = true;                            // Fill the limit order' using closing price of bar:                          // Note > Can't use minimum price' because no way to be sure minimum wasn't before the stop triggered.                          if (asset.Price < order.LimitPrice)                          {                              fill.Status = OrderStatus.Filled;                              fill.FillPrice = order.LimitPrice;                          }                      }                      break;                    case OrderDirection.Sell:                      //-> 1.1 Sell Stop: If Price below setpoint' Sell:                      if (prices.Low < order.StopPrice || order.StopTriggered)                      {                          order.StopTriggered = true;                            // Fill the limit order' using minimum price of the bar                          // Note > Can't use minimum price' because no way to be sure minimum wasn't before the stop triggered.                          if (asset.Price > order.LimitPrice)                          {                              fill.Status = OrderStatus.Filled;                              fill.FillPrice = order.LimitPrice; // Fill at limit price not asset price.                          }                      }                      break;              }
Missing Default,QuantConnect.Orders.Fills,ImmediateFillModel,C:\repos\QuantConnect_Lean\Common\Orders\Fills\ImmediateFillModel.cs,LimitFill,The following switch statement is missing a default case: switch (order.Direction)              {                  case OrderDirection.Buy:                      //Buy limit seeks lowest price                      if (prices.Low < order.LimitPrice)                      {                          //Set order fill:                          fill.Status = OrderStatus.Filled;                          // fill at the worse price this bar or the limit price' this allows far out of the money limits                          // to be executed properly                          fill.FillPrice = Math.Min(prices.High' order.LimitPrice);                      }                      break;                  case OrderDirection.Sell:                      //Sell limit seeks highest price possible                      if (prices.High > order.LimitPrice)                      {                          fill.Status = OrderStatus.Filled;                          // fill at the worse price this bar or the limit price' this allows far out of the money limits                          // to be executed properly                          fill.FillPrice = Math.Max(prices.Low' order.LimitPrice);                      }                      break;              }
Missing Default,QuantConnect.Orders.Fills,ImmediateFillModel,C:\repos\QuantConnect_Lean\Common\Orders\Fills\ImmediateFillModel.cs,MarketOnOpenFill,The following switch statement is missing a default case: switch (order.Direction)              {                  case OrderDirection.Buy:                      fill.FillPrice += slip;                      break;                  case OrderDirection.Sell:                      fill.FillPrice -= slip;                      break;              }
Missing Default,QuantConnect.Orders.Fills,ImmediateFillModel,C:\repos\QuantConnect_Lean\Common\Orders\Fills\ImmediateFillModel.cs,MarketOnCloseFill,The following switch statement is missing a default case: switch (order.Direction)              {                  case OrderDirection.Buy:                      fill.FillPrice += slip;                      break;                  case OrderDirection.Sell:                      fill.FillPrice -= slip;                      break;              }
Missing Default,QuantConnect.Securities,FutureMarginModel,C:\repos\QuantConnect_Lean\Common\Securities\Future\FutureMarginModel.cs,GetMarginRemaining,The following switch statement is missing a default case: switch (direction)                  {                      case OrderDirection.Buy:                          return portfolio.MarginRemaining;                        case OrderDirection.Sell:                          return                              // portion of margin to close the existing position                              GetMaintenanceMargin(security) +                              // portion of margin to open the new position                              security.Holdings.AbsoluteHoldingsValue * GetInitialMarginRequirement(security' security.Holdings.HoldingsValue) +                              portfolio.MarginRemaining;                  }
Missing Default,QuantConnect.Securities,FutureMarginModel,C:\repos\QuantConnect_Lean\Common\Securities\Future\FutureMarginModel.cs,GetMarginRemaining,The following switch statement is missing a default case: switch (direction)                  {                      case OrderDirection.Buy:                          return                              // portion of margin to close the existing position                              GetMaintenanceMargin(security) +                              // portion of margin to open the new position                              security.Holdings.AbsoluteHoldingsValue * GetInitialMarginRequirement(security' security.Holdings.HoldingsValue) +                              portfolio.MarginRemaining;                        case OrderDirection.Sell:                          return portfolio.MarginRemaining;                  }
Missing Default,QuantConnect.Securities,OptionMarginModel,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionMarginModel.cs,GetMarginRemaining,The following switch statement is missing a default case: switch (direction)                  {                      case OrderDirection.Buy:                          return portfolio.MarginRemaining;                        case OrderDirection.Sell:                          return                              // portion of margin to close the existing position                              GetMaintenanceMargin(security) +                              // portion of margin to open the new position                              security.Holdings.AbsoluteHoldingsValue * GetInitialMarginRequirement(security' security.Holdings.HoldingsValue) +                              portfolio.MarginRemaining;                  }
Missing Default,QuantConnect.Securities,OptionMarginModel,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionMarginModel.cs,GetMarginRemaining,The following switch statement is missing a default case: switch (direction)                  {                      case OrderDirection.Buy:                          return                              // portion of margin to close the existing position                              GetMaintenanceMargin(security) +                              // portion of margin to open the new position                              security.Holdings.AbsoluteHoldingsValue * GetInitialMarginRequirement(security' security.Holdings.HoldingsValue) +                              portfolio.MarginRemaining;                        case OrderDirection.Sell:                          return portfolio.MarginRemaining;                  }
Missing Default,QuantConnect.Securities,SecurityPortfolioModel,C:\repos\QuantConnect_Lean\Common\Securities\SecurityPortfolioModel.cs,ProcessFill,The following switch statement is missing a default case: switch (fill.Direction)                      {                          case OrderDirection.Buy:                              //Update the Holding Average Price: Total Value / Total Quantity:                              averageHoldingsPrice = ((averageHoldingsPrice*quantityHoldings) + (fill.FillQuantity*fill.FillPrice))/(quantityHoldings + fill.FillQuantity);                              //Add the new quantity:                              quantityHoldings += fill.FillQuantity;                              break;                            case OrderDirection.Sell:                              quantityHoldings += fill.FillQuantity; //+ a short = a subtraction                              if (quantityHoldings < 0)                              {                                  //If we've now passed through zero from selling stock: new avg price:                                  averageHoldingsPrice = fill.FillPrice;                              }                              else if (quantityHoldings == 0)                              {                                  averageHoldingsPrice = 0;                              }                              break;                      }
Missing Default,QuantConnect.Securities,SecurityPortfolioModel,C:\repos\QuantConnect_Lean\Common\Securities\SecurityPortfolioModel.cs,ProcessFill,The following switch statement is missing a default case: switch (fill.Direction)                      {                          case OrderDirection.Buy:                              //Buying when we're shorting moves to close position:                              quantityHoldings += fill.FillQuantity;                              if (quantityHoldings > 0)                              {                                  //If we were short but passed through zero' new average price is what we paid. The short position was closed.                                  averageHoldingsPrice = fill.FillPrice;                              }                              else if (quantityHoldings == 0)                              {                                  averageHoldingsPrice = 0;                              }                              break;                            case OrderDirection.Sell:                              //We are increasing a Short position:                              //E.g.  -100 @ $5' adding -100 @ $10: Avg: $7.5                              //      dAvg = (-500 + -1000) / -200 = 7.5                              averageHoldingsPrice = ((averageHoldingsPrice*quantityHoldings) + (fill.FillQuantity*fill.FillPrice))/(quantityHoldings + fill.FillQuantity);                              quantityHoldings += fill.FillQuantity;                              break;                      }
Missing Default,QuantConnect.Securities,SecurityMarginModel,C:\repos\QuantConnect_Lean\Common\Securities\SecurityMarginModel.cs,GetMarginRemaining,The following switch statement is missing a default case: switch (direction)                  {                      case OrderDirection.Buy:                          return portfolio.MarginRemaining;                        case OrderDirection.Sell:                          return                               // portion of margin to close the existing position                              GetMaintenanceMargin(security) +                              // portion of margin to open the new position                              security.Holdings.AbsoluteHoldingsValue * GetInitialMarginRequirement(security) +                              portfolio.MarginRemaining;                  }
Missing Default,QuantConnect.Securities,SecurityMarginModel,C:\repos\QuantConnect_Lean\Common\Securities\SecurityMarginModel.cs,GetMarginRemaining,The following switch statement is missing a default case: switch (direction)                  {                      case OrderDirection.Buy:                          return                              // portion of margin to close the existing position                              GetMaintenanceMargin(security) +                              // portion of margin to open the new position                              security.Holdings.AbsoluteHoldingsValue * GetInitialMarginRequirement(security) +                              portfolio.MarginRemaining;                        case OrderDirection.Sell:                          return portfolio.MarginRemaining;                  }
Missing Default,QuantConnect.Securities.Option,OptionPortfolioModel,C:\repos\QuantConnect_Lean\Common\Securities\Option\OptionPortfolioModel.cs,ProcessExerciseFill,The following switch statement is missing a default case: switch (option.ExerciseSettlement)              {                  case SettlementType.PhysicalDelivery:                        base.ProcessFill(portfolio' processSecurity' fill);                      break;                    case SettlementType.Cash:                        var cashQuantity = option.GetIntrinsicValue(underlying.Close) * option.ContractUnitOfTrade * option.QuoteCurrency.ConversionRate * optionQuantity;                        // we add cash equivalent to portfolio                      option.SettlementModel.ApplyFunds(portfolio' option' fill.UtcTime' cashQuote.Symbol' cashQuantity);                        base.ProcessFill(portfolio' processSecurity' fill);                      break;              }
Missing Default,QuantConnect.Data.Market,QuoteBar,C:\repos\QuantConnect_Lean\Common\Data\Market\QuoteBar.cs,Reader,The following switch statement is missing a default case: switch (config.SecurityType)                      {                          case SecurityType.Equity:                              return ParseEquity(config' line' date);                            case SecurityType.Forex:                          case SecurityType.Crypto:                              return ParseForex(config' line' date);                            case SecurityType.Cfd:                              return ParseCfd(config' line' date);                            case SecurityType.Option:                              return ParseOption(config' line' date);                            case SecurityType.Future:                              return ParseFuture(config' line' date);                                                }
Missing Default,QuantConnect.Data.Market,Tick,C:\repos\QuantConnect_Lean\Common\Data\Market\Tick.cs,Tick,The following switch statement is missing a default case: switch (config.SecurityType)                  {                      case SecurityType.Equity:                      {                          var csv = line.ToCsv(6);                          Symbol = config.Symbol;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Value = config.GetNormalizedPrice(csv[1].ToDecimal() / scaleFactor);                          TickType = TickType.Trade;                          Quantity = csv[2].ToDecimal();                          if (csv.Count > 3)                          {                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = (csv[5] == "1");                          }                          break;                      }                        case SecurityType.Forex:                      case SecurityType.Cfd:                      {                          var csv = line.ToCsv(3);                          Symbol = config.Symbol;                          TickType = TickType.Quote;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          BidPrice = csv[1].ToDecimal();                          AskPrice = csv[2].ToDecimal();                          Value = (BidPrice + AskPrice) / 2;                          break;                      }                        case SecurityType.Crypto:                      {                          TickType = config.TickType;                          Symbol = config.Symbol;                          Exchange = config.Market;                            if (TickType == TickType.Trade)                          {                              var csv = line.ToCsv(3);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              Value = csv[1].ToDecimal();                              Quantity = csv[2].ToDecimal();                          }                            if (TickType == TickType.Quote)                          {                              var csv = line.ToCsv(6);                              Time = date.Date.AddMilliseconds(csv[0].ToInt64())                                  .ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                              BidPrice = csv[1].ToDecimal();                              BidSize = csv[2].ToDecimal();                              AskPrice = csv[3].ToDecimal();                              AskSize = csv[4].ToDecimal();                              Value = (BidPrice + AskPrice) / 2;                          }                          break;                      }                      case SecurityType.Future:                      case SecurityType.Option:                      {                          var csv = line.ToCsv(7);                          TickType = config.TickType;                          Time = date.Date.AddMilliseconds(csv[0].ToInt64()).ConvertTo(config.DataTimeZone' config.ExchangeTimeZone);                          Symbol = config.Symbol;                            if (TickType == TickType.Trade)                          {                              Value = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                              Quantity = csv[2].ToDecimal();                              Exchange = csv[3];                              SaleCondition = csv[4];                              Suspicious = csv[5] == "1";                          }                          else if (TickType == TickType.OpenInterest)                          {                              Value = csv[1].ToDecimal();                          }                          else                          {                              if (csv[1].Length != 0)                              {                                  BidPrice = config.GetNormalizedPrice(csv[1].ToDecimal()/scaleFactor);                                  BidSize = csv[2].ToDecimal();                              }                              if (csv[3].Length != 0)                              {                                  AskPrice = config.GetNormalizedPrice(csv[3].ToDecimal()/scaleFactor);                                  AskSize = csv[4].ToDecimal();                              }                              Exchange = csv[5];                              Suspicious = csv[6] == "1";                                if (BidPrice != 0)                              {                                  if (AskPrice != 0)                                  {                                      Value = (BidPrice + AskPrice)/2m;                                  }                                  else                                  {                                      Value = BidPrice;                                  }                              }                              else                              {                                  Value = AskPrice;                              }                          }                            break;                      }                  }
Missing Default,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,Reader,The following switch statement is missing a default case: switch (config.SecurityType)                  {                      //Equity File Data Format:                      case SecurityType.Equity:                          return ParseEquity<TradeBar>(config' line' date);                        //FOREX has a different data file format:                      case SecurityType.Forex:                          return ParseForex<TradeBar>(config' line' date);                        case SecurityType.Crypto:                          return ParseCrypto<TradeBar>(config' line' date);                        case SecurityType.Cfd:                          return ParseCfd<TradeBar>(config' line' date);                        case SecurityType.Option:                          return ParseOption(config' line' date);                        case SecurityType.Future:                          return ParseFuture(config' line' date);                    }
Missing Default,QuantConnect.Data.Market,TradeBar,C:\repos\QuantConnect_Lean\Common\Data\Market\TradeBar.cs,Parse,The following switch statement is missing a default case: switch (config.SecurityType)              {                  case SecurityType.Equity:                      return ParseEquity(config' line' baseDate);                    case SecurityType.Forex:                  case SecurityType.Crypto:                      return ParseForex(config' line' baseDate);                    case SecurityType.Cfd:                      return ParseCfd(config' line' baseDate);              }
Missing Default,QuantConnect.Orders.Fees,InteractiveBrokersFeeModel,C:\repos\QuantConnect_Lean\Common\Orders\Fees\InteractiveBrokersFeeModel.cs,GetOrderFee,The following switch statement is missing a default case: switch (security.Type)              {                  case SecurityType.Forex:                      // get the total order value in the account currency                      var totalOrderValue = order.GetValue(security);                      var fee = Math.Abs(_forexCommissionRate*totalOrderValue);                      return Math.Max(_forexMinimumOrderFee' fee);                    case SecurityType.Option:                      // applying commission function to the order                      return _optionsCommissionFunc(order.AbsoluteQuantity' order.Price);                    case SecurityType.Future:                      // currently we treat all futures as USD denominated generic US futures                      return order.AbsoluteQuantity * (0.85m + 1.0m);                    case SecurityType.Equity:                      var tradeValue = Math.Abs(order.GetValue(security));                        //Per share fees                      var tradeFee = 0.005m * order.AbsoluteQuantity;                        //Maximum Per Order: 0.5%                      //Minimum per order. $1.0                      var maximumPerOrder = 0.005m * tradeValue;                      if (tradeFee < 1)                      {                          tradeFee = 1;                      }                      else if (tradeFee > maximumPerOrder)                      {                          tradeFee = maximumPerOrder;                      }                        //Always return a positive fee.                      return Math.Abs(tradeFee);              }
Missing Default,QuantConnect.Statistics,TradeBuilder,C:\repos\QuantConnect_Lean\Common\Statistics\TradeBuilder.cs,ProcessFill,The following switch statement is missing a default case: switch (_groupingMethod)              {                  case FillGroupingMethod.FillToFill:                      ProcessFillUsingFillToFill(fill.Clone()' orderFee' conversionRate' multiplier);                      break;                    case FillGroupingMethod.FlatToFlat:                      ProcessFillUsingFlatToFlat(fill.Clone()' orderFee' conversionRate' multiplier);                      break;                    case FillGroupingMethod.FlatToReduced:                      ProcessFillUsingFlatToReduced(fill.Clone()' orderFee' conversionRate' multiplier);                      break;              }
Missing Default,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,GenerateLine,The following switch statement is missing a default case: switch (resolution)                      {                          case Resolution.Tick:                              var tick = (Tick) data;                              return ToCsv(milliseconds' Scale(tick.LastPrice)' tick.Quantity' tick.Exchange' tick.SaleCondition' tick.Suspicious ? "1" : "0");                            case Resolution.Minute:                          case Resolution.Second:                              var bar = (TradeBar) data;                              return ToCsv(milliseconds' Scale(bar.Open)' Scale(bar.High)' Scale(bar.Low)' Scale(bar.Close)' bar.Volume);                            case Resolution.Hour:                          case Resolution.Daily:                              var bigBar = (TradeBar) data;                              return ToCsv(longTime' Scale(bigBar.Open)' Scale(bigBar.High)' Scale(bigBar.Low)' Scale(bigBar.Close)' bigBar.Volume);                      }
Missing Default,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,GenerateLine,The following switch statement is missing a default case: switch (resolution)                      {                          case Resolution.Tick:                              var tick = data as Tick;                              if (tick == null) throw new NullReferenceException("Cryto tick could not be created");                                if (tick.TickType == TickType.Trade)                              {                                  return ToCsv(milliseconds' tick.LastPrice' tick.Quantity);                              }                              if (tick.TickType == TickType.Quote)                              {                                  return ToCsv(milliseconds' tick.BidPrice' tick.BidSize' tick.AskPrice' tick.AskSize);                              }                              throw new ArgumentException("Cryto tick could not be created");                          case Resolution.Second:                          case Resolution.Minute:                              var quoteBar = data as QuoteBar;                              if (quoteBar != null)                              {                                  return ToCsv(milliseconds'                                      ToNonScaledCsv(quoteBar.Bid)' quoteBar.LastBidSize'                                      ToNonScaledCsv(quoteBar.Ask)' quoteBar.LastAskSize);                              }                              var tradeBar = data as TradeBar;                              if (tradeBar != null)                              {                                  return ToCsv(milliseconds' tradeBar.Open' tradeBar.High' tradeBar.Low' tradeBar.Close' tradeBar.Volume);                              }                              throw new NullReferenceException("Cryto minute/second bar could not be created");                            case Resolution.Hour:                          case Resolution.Daily:                              var bigQuoteBar = data as QuoteBar;                              if (bigQuoteBar != null)                              {                                  return ToCsv(longTime'                                      ToNonScaledCsv(bigQuoteBar.Bid)' bigQuoteBar.LastBidSize'                                      ToNonScaledCsv(bigQuoteBar.Ask)' bigQuoteBar.LastAskSize);                              }                              var bigTradeBar = data as TradeBar;                              if (bigTradeBar != null)                              {                                  return ToCsv(longTime'                                               bigTradeBar.Open'                                               bigTradeBar.High'                                               bigTradeBar.Low'                                               bigTradeBar.Close'                                               bigTradeBar.Volume);                              }                              throw new NullReferenceException("Cryto hour/daily bar could not be created");                      }
Missing Default,QuantConnect.Util,LeanData,C:\repos\QuantConnect_Lean\Common\Util\LeanData.cs,GenerateLine,The following switch statement is missing a default case: switch (resolution)                      {                          case Resolution.Tick:                              var tick = data as Tick;                              if (tick == null) throw new NullReferenceException("tick");                              return ToCsv(milliseconds' tick.BidPrice' tick.AskPrice);                            case Resolution.Second:                          case Resolution.Minute:                              var bar = data as QuoteBar;                              if (bar == null) throw new NullReferenceException("bar");                              return ToCsv(milliseconds'                                  ToNonScaledCsv(bar.Bid)' bar.LastBidSize'                                  ToNonScaledCsv(bar.Ask)' bar.LastAskSize);                            case Resolution.Hour:                          case Resolution.Daily:                              var bigBar = data as QuoteBar;                              if (bigBar == null) throw new NullReferenceException("big bar");                              return ToCsv(longTime'                                  ToNonScaledCsv(bigBar.Bid)' bigBar.LastBidSize'                                  ToNonScaledCsv(bigBar.Ask)' bigBar.LastAskSize);                      }
