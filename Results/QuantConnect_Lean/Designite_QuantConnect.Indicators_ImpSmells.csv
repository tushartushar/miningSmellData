Implementation smell,Namespace,Class,File,Method,Description
Long Method,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The method has 106 lines of code.
Complex Method,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,ComputeNextValue,Cyclomatic complexity of the method is 8
Complex Method,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,Cyclomatic complexity of the method is 11
Complex Method,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,ComputeNextValue,Cyclomatic complexity of the method is 8
Complex Method,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,Cyclomatic complexity of the method is 10
Long Parameter List,QuantConnect.Indicators,IchimokuKinkoHyo,C:\repos\QuantConnect_Lean\Indicators\IchimokuKinkoHyo.cs,IchimokuKinkoHyo,The method has 7 parameters. Parameters: name' tenkanPeriod' kijunPeriod' senkouAPeriod' senkouBPeriod' senkouADelayPeriod' senkouBDelayPeriod
Long Parameter List,QuantConnect.Indicators,MovingAverageConvergenceDivergence,C:\repos\QuantConnect_Lean\Indicators\MovingAverageConvergenceDivergence.cs,MovingAverageConvergenceDivergence,The method has 5 parameters. Parameters: name' fastPeriod' slowPeriod' signalPeriod' type
Long Statement,QuantConnect.Indicators,AccumulationDistribution,C:\repos\QuantConnect_Lean\Indicators\AccumulationDistribution.cs,ComputeNextValue,The length of the statement  "            return Current.Value + (range > 0 ? ((input.Close - input.Low) - (input.High - input.Close)) / range * input.Volume : 0m); " is 122.
Long Statement,QuantConnect.Indicators,AverageDirectionalIndex,C:\repos\QuantConnect_Lean\Indicators\AverageDirectionalIndex.cs,ComputeSmoothedDirectionalMovementPlus,The length of the statement  "                value = SmoothedDirectionalMovementPlus.Current - (SmoothedDirectionalMovementPlus.Current / period) + DirectionalMovementPlus.Current; " is 135.
Long Statement,QuantConnect.Indicators,AverageDirectionalIndex,C:\repos\QuantConnect_Lean\Indicators\AverageDirectionalIndex.cs,ComputeSmoothedDirectionalMovementMinus,The length of the statement  "                value = SmoothedDirectionalMovementMinus.Current - (SmoothedDirectionalMovementMinus.Current / 14) + DirectionalMovementMinus.Current; " is 134.
Long Statement,QuantConnect.Indicators,AverageDirectionalIndex,C:\repos\QuantConnect_Lean\Indicators\AverageDirectionalIndex.cs,ComputeTrueRange,The length of the statement  "            trueRange = (Math.Max(Math.Abs(input.Low - _previousInput.Close)' Math.Max(TrueRange.Current' Math.Abs(input.High - _previousInput.Close)))); " is 141.
Long Statement,QuantConnect.Indicators,AverageDirectionalIndex,C:\repos\QuantConnect_Lean\Indicators\AverageDirectionalIndex.cs,ComputeNegativeDirectionalIndex,The length of the statement  "            var negativeDirectionalIndex = (SmoothedDirectionalMovementMinus.Current.Value / SmoothedTrueRange.Current.Value) * 100; " is 120.
Long Statement,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,ComputeNextValue,The length of the statement  "            double signal = _a0 * _c0 * (_b0 * _price[0] + _b1 * _price[1] + _b2 * _price[2]) + _a0 * (_a1 * _filt[0] + _a2 * _filt[1]); " is 124.
Long Statement,QuantConnect.Indicators,IchimokuKinkoHyo,C:\repos\QuantConnect_Lean\Indicators\IchimokuKinkoHyo.cs,computeSenkouB,The length of the statement  "            var senkouB = DelayedMaximumSenkouB.Samples >= period ? (DelayedMaximumSenkouB + DelayedMinimumSenkouB) / 2 : new decimal(0.0); " is 127.
Long Statement,QuantConnect.Indicators,IchimokuKinkoHyo,C:\repos\QuantConnect_Lean\Indicators\IchimokuKinkoHyo.cs,computeSenkouA,The length of the statement  "            var senkouA = DelayedKijunSenkouA.Samples >= period ? (DelayedTenkanSenkouA + DelayedKijunSenkouA) / 2 : new decimal(0.0); " is 122.
Long Statement,QuantConnect.Indicators,IchimokuKinkoHyo,C:\repos\QuantConnect_Lean\Indicators\IchimokuKinkoHyo.cs,ComputeTenkan,The length of the statement  "            var tenkan = TenkanMaximum.Samples >= period ? (TenkanMaximum.Current.Value + TenkanMinimum.Current.Value) / 2 : new decimal(0.0); " is 130.
Long Statement,QuantConnect.Indicators,IndicatorBase<T>,C:\repos\QuantConnect_Lean\Indicators\IndicatorBase.cs,Update,The length of the statement  "                throw new ArgumentException(string.Format("This is a forward only indicator: {0} Input: {1} Previous: {2}"' Name' input.Time.ToString("u")' _previousInput.Time.ToString("u"))); " is 176.
Long Statement,QuantConnect.Indicators,IndicatorBase<T>,C:\repos\QuantConnect_Lean\Indicators\IndicatorBase.cs,Update,The length of the statement  "                throw new NotSupportedException(string.Format("{0} does not support Update(DateTime' decimal) method overload. Use Update({1}) instead."' GetType().Name' typeof(T).Name)); " is 171.
Long Statement,QuantConnect.Indicators,IndicatorExtensions,C:\repos\QuantConnect_Lean\Indicators\IndicatorExtensions.cs,Plus,The length of the statement  "            var constantIndicator = new ConstantIndicator<IndicatorDataPoint>(constant.ToString(CultureInfo.InvariantCulture)' constant); " is 125.
Long Statement,QuantConnect.Indicators,IndicatorExtensions,C:\repos\QuantConnect_Lean\Indicators\IndicatorExtensions.cs,Minus,The length of the statement  "            var constantIndicator = new ConstantIndicator<IndicatorDataPoint>(constant.ToString(CultureInfo.InvariantCulture)' constant); " is 125.
Long Statement,QuantConnect.Indicators,IndicatorExtensions,C:\repos\QuantConnect_Lean\Indicators\IndicatorExtensions.cs,Over,The length of the statement  "            var constantIndicator = new ConstantIndicator<IndicatorDataPoint>(constant.ToString(CultureInfo.InvariantCulture)' constant); " is 125.
Long Statement,QuantConnect.Indicators,IndicatorExtensions,C:\repos\QuantConnect_Lean\Indicators\IndicatorExtensions.cs,Over,The length of the statement  "            return new CompositeIndicator<IndicatorDataPoint>(left' right' (l' r) => r == 0m ? new IndicatorResult(0m' IndicatorStatus.MathError) : new IndicatorResult(l / r)); " is 164.
Long Statement,QuantConnect.Indicators,IndicatorExtensions,C:\repos\QuantConnect_Lean\Indicators\IndicatorExtensions.cs,Over,The length of the statement  "            return new CompositeIndicator<IndicatorDataPoint>(name' left' right' (l' r) => r == 0m ? new IndicatorResult(0m' IndicatorStatus.MathError) : new IndicatorResult(l / r)); " is 170.
Long Statement,QuantConnect.Indicators,IndicatorExtensions,C:\repos\QuantConnect_Lean\Indicators\IndicatorExtensions.cs,Times,The length of the statement  "            var constantIndicator = new ConstantIndicator<IndicatorDataPoint>(constant.ToString(CultureInfo.InvariantCulture)' constant); " is 125.
Long Statement,QuantConnect.Indicators,IndicatorExtensions,C:\repos\QuantConnect_Lean\Indicators\IndicatorExtensions.cs,EMA,The length of the statement  "            decimal k = smoothingFactor.HasValue ? k = smoothingFactor.Value : ExponentialMovingAverage.SmoothingFactorDefault(period); " is 123.
Long Statement,QuantConnect.Indicators,IndicatorExtensions,C:\repos\QuantConnect_Lean\Indicators\IndicatorExtensions.cs,EMA,The length of the statement  "            ExponentialMovingAverage emaOfLeft = new ExponentialMovingAverage(string.Format("EMA{0}_Of_{1}"' period' left.Name)' period' k).Of(left' waitForFirstToReady); " is 158.
Long Statement,QuantConnect.Indicators,IndicatorExtensions,C:\repos\QuantConnect_Lean\Indicators\IndicatorExtensions.cs,MAX,The length of the statement  "            Maximum maxOfLeft = new Maximum(string.Format("MAX{0}_Of_{1}"' period' left.Name)' period).Of(left' waitForFirstToReady); " is 121.
Long Statement,QuantConnect.Indicators,IndicatorExtensions,C:\repos\QuantConnect_Lean\Indicators\IndicatorExtensions.cs,MIN,The length of the statement  "            Minimum minOfLeft = new Minimum(string.Format("MIN{0}_Of_{1}"' period' left.Name)' period).Of(left' waitForFirstToReady); " is 121.
Long Statement,QuantConnect.Indicators,IndicatorExtensions,C:\repos\QuantConnect_Lean\Indicators\IndicatorExtensions.cs,SMA,The length of the statement  "            SimpleMovingAverage smaOfLeft = new SimpleMovingAverage(string.Format("SMA{0}_Of_{1}"' period' left.Name)' period).Of(left' waitForFirstToReady); " is 145.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,TasukiGap,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TasukiGap.cs,ComputeNextValue,The length of the statement  "                    Math.Abs(GetRealBody(window[1]) - GetRealBody(input)) < GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1]) " is 125.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,TasukiGap,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TasukiGap.cs,ComputeNextValue,The length of the statement  "                    Math.Abs(GetRealBody(window[1]) - GetRealBody(input)) < GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1]) " is 125.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,ComputeNextValue,The length of the statement  "                GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) && " is 122.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,ComputeNextValue,The length of the statement  "                input.Open >= window[1].Close - GetRealBody(input) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) " is 125.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The length of the statement  "                Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low && " is 122.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The length of the statement  "                Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low && " is 122.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The length of the statement  "                Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low && " is 122.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,LadderBottom,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\LadderBottom.cs,ComputeNextValue,The length of the statement  "                GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) && " is 122.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,KickingByLength,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\KickingByLength.cs,ComputeNextValue,The length of the statement  "                GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) && " is 125.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,KickingByLength,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\KickingByLength.cs,ComputeNextValue,The length of the statement  "                GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) && " is 125.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,Kicking,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Kicking.cs,ComputeNextValue,The length of the statement  "                GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) && " is 125.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,Kicking,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Kicking.cs,ComputeNextValue,The length of the statement  "                GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) && " is 125.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,HangingMan,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HangingMan.cs,ComputeNextValue,The length of the statement  "                Math.Min(input.Close' input.Open) >= window[1].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1]) " is 123.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,Hammer,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Hammer.cs,ComputeNextValue,The length of the statement  "                Math.Min(input.Close' input.Open) <= window[1].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1]) " is 122.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The length of the statement  "                        GetRealBody(window[1]) < GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) && " is 123.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,ThreeBlackCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeBlackCrows.cs,ComputeNextValue,The length of the statement  "                GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) && " is 125.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,ThreeBlackCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeBlackCrows.cs,ComputeNextValue,The length of the statement  "                GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) && " is 125.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,ThreeInside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeInside.cs,ComputeNextValue,The length of the statement  "                ((GetCandleColor(window[2]) == CandleColor.White && GetCandleColor(input) == CandleColor.Black && input.Close < window[2].Open) || " is 130.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,ThreeInside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeInside.cs,ComputeNextValue,The length of the statement  "                  (GetCandleColor(window[2]) == CandleColor.Black && GetCandleColor(input) == CandleColor.White && input.Close > window[2].Open) " is 126.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The length of the statement  "                GetLowerShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) && " is 125.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The length of the statement  "                GetUpperShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) && " is 125.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The length of the statement  "                GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) && " is 125.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The length of the statement  "                GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) && " is 125.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The length of the statement  "                GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) && " is 125.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The length of the statement  "                window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) && " is 137.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The length of the statement  "                window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) && " is 137.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The length of the statement  "                window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) && " is 137.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The length of the statement  "                window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) && " is 137.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,ComputeNextValue,The length of the statement  "                GetLowerShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) && " is 125.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The length of the statement  "                GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) && " is 125.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The length of the statement  "                GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) && " is 125.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The length of the statement  "                GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) && " is 125.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The length of the statement  "                GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) && " is 125.
Long Statement,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The length of the statement  "                GetRealBody(window[1]) > GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) && " is 123.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,UpDownGapThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpDownGapThreeMethods.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 3rd opposite color                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 3rd opens within 2nd rb                  input.Open < Math.Max(window[1].Close' window[1].Open) &&                  input.Open > Math.Min(window[1].Close' window[1].Open) &&                  // 3rd closes within 1st rb                  input.Close < Math.Max(window[2].Close' window[2].Open) &&                  input.Close > Math.Min(window[2].Close' window[2].Open) &&                  ((                      // when 1st is white                      GetCandleColor(window[2]) == CandleColor.White &&                      // upside gap                      GetRealBodyGapUp(window[1]' window[2])                    ) ||                    (                      // when 1st is black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // downside gap                      GetRealBodyGapDown(window[1]' window[2])                    )                  )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,UpsideGapTwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpsideGapTwoCrows.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[2]) == CandleColor.White &&                  //      long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: black                  GetCandleColor(input) == CandleColor.Black &&                  // 3rd: engulfing prior rb                  input.Open > window[1].Open && input.Close < window[1].Close &&                  //      closing above 1st                  input.Close > window[2].Close"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,UniqueThreeRiver,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UniqueThreeRiver.cs,ComputeNextValue,The conditional expression  "GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      harami                  window[1].Close > window[2].Close && window[1].Open <= window[2].Open &&                  //      lower low                  window[1].Low < window[2].Low &&                  // 3rd: short                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      white                  GetCandleColor(input) == CandleColor.White &&                  //      open not lower                  input.Open > window[1].Low"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,Thrusting,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Thrusting.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[1]) == CandleColor.Black &&                  //      long                  GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[1]) &&                  // 2nd: white                  GetCandleColor(input) == CandleColor.White &&                  //      open below prior low                  input.Open < window[1].Low &&                  //      close into prior body                  input.Close > window[1].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1]) &&                  //      under the midpoint                  input.Close <= window[1].Close + GetRealBody(window[1]) * 0.5m"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,TasukiGap,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TasukiGap.cs,ComputeNextValue,The conditional expression  "(                      // upside gap                          GetRealBodyGapUp(window[1]' window[2]) &&                      // 1st: white                      GetCandleColor(window[1]) == CandleColor.White &&                      // 2nd: black                      GetCandleColor(input) == CandleColor.Black &&                      //      that opens within the white rb                      input.Open < window[1].Close && input.Open > window[1].Open &&                      //      and closes under the white rb                      input.Close < window[1].Open &&                      //      inside the gap                      input.Close > Math.Max(window[2].Close' window[2].Open) &&                      // size of 2 rb near the same                      Math.Abs(GetRealBody(window[1]) - GetRealBody(input)) < GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1])                  ) ||                  (                      // downside gap                      GetRealBodyGapDown(window[1]' window[2]) &&                      // 1st: black                      GetCandleColor(window[1]) == CandleColor.Black &&                      // 2nd: white                      GetCandleColor(input) == CandleColor.White &&                      //      that opens within the black rb                      input.Open < window[1].Open && input.Open > window[1].Close &&                      //      and closes above the black rb                      input.Close > window[1].Open &&                      //      inside the gap                      input.Close < Math.Min(window[2].Close' window[2].Open) &&                      // size of 2 rb near the same                      Math.Abs(GetRealBody(window[1]) - GetRealBody(input)) < GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1])                  )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,StickSandwich,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StickSandwich.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[2]) == CandleColor.Black &&                  // second white                  GetCandleColor(window[1]) == CandleColor.White &&                  // third black                  GetCandleColor(input) == CandleColor.Black &&                  // 2nd low > prior close                  window[1].Low > window[2].Close &&                  // 1st and 3rd same close                  input.Close <= window[2].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[2]) &&                  input.Close >= window[2].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[2])"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[2]' window[2]) &&                  // 2nd: long real body                  GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[1]' window[1]) &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd: small real body                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  // rides on the shoulder of 2nd real body                  input.Open >= window[1].Close - GetRealBody(input) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,ShootingStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ShootingStar.cs,ComputeNextValue,The conditional expression  "GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  // long upper shadow                  GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' input) &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' input) &&                  // gap up                  GetRealBodyGapUp(input' window[1])"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,SeparatingLines,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\SeparatingLines.cs,ComputeNextValue,The conditional expression  "(int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // same open                  input.Open <= window[1].Open + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1]) &&                  input.Open >= window[1].Open - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1]) &&                  // belt hold: long body                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' input) &&                  (                    // with no lower shadow if bullish                    (GetCandleColor(input) == CandleColor.White &&                      GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' input)                    )                    ||                    // with no upper shadow if bearish                    (GetCandleColor(input) == CandleColor.Black &&                      GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' input)                    )                  )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The conditional expression  "GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,RickshawMan,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RickshawMan.cs,ComputeNextValue,The conditional expression  "GetRealBody(input) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' input) &&                  // long shadow                  GetLowerShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' input) &&                  // long shadow                  GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' input) &&                  // body near midpoint                  (                      Math.Min(input.Open' input.Close)                          <= input.Low + GetHighLowRange(input) / 2 + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' input)                      &&                      Math.Max(input.Open' input.Close)                          >= input.Low + GetHighLowRange(input) / 2 - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' input)                  )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,Piercing,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Piercing.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[1]) == CandleColor.Black &&                  //      long                  GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[1]' window[1]) &&                  // 2nd: white                  GetCandleColor(input) == CandleColor.White &&                  //      long                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[0]' input) &&                  //      open below prior low                  input.Open < window[1].Low &&                  //      close within prior body                  input.Close < window[1].Open &&                  //      above midpoint                  input.Close > window[1].Close + GetRealBody(window[1]) * 0.5m"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,OnNeck,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\OnNeck.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[1]) == CandleColor.Black &&                  //      long                  GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[1]) &&                  // 2nd: white                  GetCandleColor(input) == CandleColor.White &&                  //      open below prior low                  input.Open < window[1].Low &&                  //      close equal to prior low                  input.Close <= window[1].Low + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1]) &&                  input.Close >= window[1].Low - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1])"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,MorningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningStar.cs,ComputeNextValue,The conditional expression  "GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal2' input) &&                  //      white real body                  GetCandleColor(input) == CandleColor.White &&                  //      closing well within 1st rb                  input.Close > window[2].Close + GetRealBody(window[2]) * _penetration"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,MorningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningDojiStar.cs,ComputeNextValue,The conditional expression  "GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  //      gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      white real body                  GetCandleColor(input) == CandleColor.White &&                  //      closing well within 1st rb                  input.Close > window[2].Close + GetRealBody(window[2]) * _penetration"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The conditional expression  "GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,MatchingLow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatchingLow.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[1]) == CandleColor.Black &&                  // second black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st and 2nd same close                  input.Close <= window[1].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1]) &&                  input.Close >= window[1].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1])"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,LadderBottom,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\LadderBottom.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[4]) == CandleColor.Black &&                   GetCandleColor(window[3]) == CandleColor.Black &&                   GetCandleColor(window[2]) == CandleColor.Black &&                  // with consecutively lower opens                  window[4].Open > window[3].Open && window[3].Open > window[2].Open &&                  // and closes                  window[4].Close > window[3].Close && window[3].Close > window[2].Close &&                  // 4th: black with an upper shadow                  GetCandleColor(window[1]) == CandleColor.Black &&                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // 5th: white                  GetCandleColor(input) == CandleColor.White &&                  // that opens above prior candle's body                  input.Open > window[1].Open &&                  // and closes above prior candle's high                  input.Close > window[1].High"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,KickingByLength,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\KickingByLength.cs,ComputeNextValue,The conditional expression  "(int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 1st marubozu                  GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[1]' window[1]) &&                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 2nd marubozu                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[0]' input) &&                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // gap                  (                    (GetCandleColor(window[1]) == CandleColor.Black && GetCandleGapUp(input' window[1]))                    ||                    (GetCandleColor(window[1]) == CandleColor.White && GetCandleGapDown(input' window[1]))                  )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,Kicking,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Kicking.cs,ComputeNextValue,The conditional expression  "(int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 1st marubozu                  GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[1]' window[1]) &&                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 2nd marubozu                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[0]' input) &&                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // gap                  (                    (GetCandleColor(window[1]) == CandleColor.Black && GetCandleGapUp(input' window[1]))                    ||                    (GetCandleColor(window[1]) == CandleColor.White && GetCandleGapDown(input' window[1]))                  )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,InvertedHammer,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\InvertedHammer.cs,ComputeNextValue,The conditional expression  "GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  // long upper shadow                  GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' input) &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' input) &&                  // gap down                  GetRealBodyGapDown(input' window[1])"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,InNeck,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\InNeck.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[1]) == CandleColor.Black &&                  //      long                  GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[1]) &&                  // 2nd: white                  GetCandleColor(input) == CandleColor.White &&                  //      open below prior low                  input.Open < window[1].Low &&                  //      close slightly into prior body                  input.Close <= window[1].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1]) &&                  input.Close >= window[1].Close"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,HomingPigeon,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HomingPigeon.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[1]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st long                  GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[1]) &&                  // 2nd short                  GetRealBody(input) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  // 2nd engulfed by 1st                  input.Open < window[1].Open &&                  input.Close > window[1].Close"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,HaramiCross,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HaramiCross.cs,ComputeNextValue,The conditional expression  "GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[1]) &&                  // 2nd: doji                  GetRealBody(input) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' input) &&                  //      engulfed by 1st                  Math.Max(input.Close' input.Open) < Math.Max(window[1].Close' window[1].Open) &&                  Math.Min(input.Close' input.Open) > Math.Min(window[1].Close' window[1].Open)"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,Harami,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Harami.cs,ComputeNextValue,The conditional expression  "GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[1]) &&                  // 2nd: short                  GetRealBody(input) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      engulfed by 1st                  Math.Max(input.Close' input.Open) < Math.Max(window[1].Close' window[1].Open) &&                  Math.Min(input.Close' input.Open) > Math.Min(window[1].Close' window[1].Open)"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,HangingMan,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HangingMan.cs,ComputeNextValue,The conditional expression  "GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  // long lower shadow                  GetLowerShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' input) &&                  // very short upper shadow                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' input) &&                  // rb near the prior candle's highs                  Math.Min(input.Close' input.Open) >= window[1].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1])"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,Hammer,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Hammer.cs,ComputeNextValue,The conditional expression  "GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  // long lower shadow                  GetLowerShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' input) &&                  // very short upper shadow                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' input) &&                  // rb near the prior candle's lows                  Math.Min(input.Close' input.Open) <= window[1].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1])"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,EveningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningStar.cs,ComputeNextValue,The conditional expression  "GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal2' input) &&                  //      black real body                  GetCandleColor(input) == CandleColor.Black &&                  //      closing well within 1st rb                  input.Close < window[2].Close - GetRealBody(window[2]) * _penetration"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,EveningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningDojiStar.cs,ComputeNextValue,The conditional expression  "GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      black real body                  GetCandleColor(input) == CandleColor.Black &&                  //      closing well within 1st rb                  input.Close < window[2].Close - GetRealBody(window[2]) * _penetration"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,DojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\DojiStar.cs,ComputeNextValue,The conditional expression  "GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[1]) &&                  // 2nd: doji                  GetRealBody(input) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' input) &&                  //      that gaps up if 1st is white                  ((GetCandleColor(window[1]) == CandleColor.White && GetRealBodyGapUp(input' window[1]))                      ||                      //      or down if 1st is black                      (GetCandleColor(window[1]) == CandleColor.Black && GetRealBodyGapDown(input' window[1]))                  )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,DarkCloudCover,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\DarkCloudCover.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[1]) == CandleColor.White &&                  //      long                  GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[1]) &&                  // 2nd: black                  GetCandleColor(input) == CandleColor.Black &&                  //      open above prior high                  input.Open > window[1].High &&                  //      close within prior body                  input.Close > window[1].Open &&                  input.Close < window[1].Close - GetRealBody(window[1]) * _penetration"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,AbandonedBaby,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AbandonedBaby.cs,ComputeNextValue,The conditional expression  "GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  ((                      // 1st white                      GetCandleColor(window[2]) == CandleColor.White &&                      // 3rd black                      GetCandleColor(input) == CandleColor.Black &&                      // 3rd closes well within 1st rb                      input.Close < window[2].Close - GetRealBody(window[2]) * _penetration &&                      // upside gap between 1st and 2nd                      GetCandleGapUp(window[1]' window[2]) &&                      // downside gap between 2nd and 3rd                      GetCandleGapDown(input' window[1])                    )                    ||                    (                      // 1st black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // 3rd white                      GetCandleColor(input) == CandleColor.White &&                      // 3rd closes well within 1st rb                      input.Close > window[2].Close + GetRealBody(window[2]) * _penetration &&                      // downside gap between 1st and 2nd                      GetCandleGapDown(window[1]' window[2]) &&                      // upside gap between 2nd and 3rd                      GetCandleGapUp(input' window[1])                    )                  )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 1st: short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[2]' window[2]) &&                  (                      // ( 2 far smaller than 1 && 3 not longer than 2 )                      // advance blocked with the 2nd' 3rd must not carry on the advance                      (                          GetRealBody(window[1]) < GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                          GetRealBody(input) < GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                      ) ||                      // 3 far smaller than 2                      // advance blocked with the 3rd                      (                          GetRealBody(input) < GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1])                      ) ||                      // ( 3 smaller than 2 && 2 smaller than 1 && (3 or 2 not short upper shadow) )                      // advance blocked with progressively smaller real bodies and some upper shadows                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetRealBody(window[1]) < GetRealBody(window[2]) &&                          (                              GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[0]' input) ||                              GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[1]' window[1])                          )                      ) ||                      // ( 3 smaller than 2 && 3 long upper shadow )                      // advance blocked with 3rd candle's long upper shadow and smaller body                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal[0]' input)                      )                  )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,ClosingMarubozu,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ClosingMarubozu.cs,ComputeNextValue,The conditional expression  "GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' input) &&                               (                    (                       // white body and very short upper shadow                      GetCandleColor(input) == CandleColor.White &&                      GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' input)                    ) ||                    (                       // black body and very short lower shadow                      GetCandleColor(input) == CandleColor.Black &&                      GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' input)                    )                  )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,BeltHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\BeltHold.cs,ComputeNextValue,The conditional expression  "GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' input) &&                               (                    (                       // white body and very short lower shadow                      GetCandleColor(input) == CandleColor.White &&                      GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' input)                    ) ||                    (                       // black body and very short upper shadow                      GetCandleColor(input) == CandleColor.Black &&                      GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' input)                    )                  )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The conditional expression  "GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The conditional expression  "window[2].High < window[3].High && window[2].Low > window[3].Low &&                          // 3rd: lower high and higher low than 2nd                          window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 4th: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low &&                            // (bull) 2nd: close near the low                            window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                              )                           ||                           // (bear) 4th: higher high and higher low                           (input.High > window[1].High && input.Low > window[1].Low &&                            // (bull) 2nd: close near the top                            window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                               )                              )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The conditional expression  "Samples <= _patternIndex + 4 &&                              // close higher than the high of 3rd                              ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                               ||                               // close lower than the low of 3rd                               (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low))"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The conditional expression  "window[2].High < window[3].High && window[2].Low > window[3].Low &&                  // 3rd: lower high and higher low than 2nd                  window[1].High < window[2].High && window[1].Low > window[2].Low &&                  // (bull) 4th: lower high and lower low                  ((input.High < window[1].High && input.Low < window[1].Low &&                    // (bull) 2nd: close near the low                    window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                      )                   ||                   // (bear) 4th: higher high and higher low                   (input.High > window[1].High && input.Low > window[1].Low &&                    // (bull) 2nd: close near the top                    window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                       )                      )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The conditional expression  "Samples <= _patternIndex + 4 &&                      // close higher than the high of 3rd                      ((_patternResult > 0 && input.Close > window[(int)Samples - _patternIndex].High)                       ||                       // close lower than the low of 3rd                       (_patternResult < 0 && input.Close < window[(int)Samples - _patternIndex].Low))"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,ThreeBlackCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeBlackCrows.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[3]) == CandleColor.White &&                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // 2nd black opens within 1st black's rb                  window[1].Open < window[2].Open && window[1].Open > window[2].Close &&                  // 3rd black opens within 2nd black's rb                  input.Open < window[1].Open && input.Open > window[1].Close &&                  // 1st black closes under prior candle's high                  window[3].High > window[2].Close &&                  // three declining                  window[2].Close > window[1].Close &&                  // three declining                  window[1].Close > input.Close"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,GapSideBySideWhite,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\GapSideBySideWhite.cs,ComputeNextValue,The conditional expression  "( // upside or downside gap between the 1st candle and both the next 2 candles                    (GetRealBodyGapUp(window[1]' window[2]) && GetRealBodyGapUp(input' window[2]))                    ||                    (GetRealBodyGapDown(window[1]' window[2]) && GetRealBodyGapDown(input' window[2]))                  ) &&                  // 2nd: white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd: white                  GetCandleColor(input) == CandleColor.White &&                  // same size 2 and 3                  GetRealBody(input) >= GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1]) &&                  GetRealBody(input) <= GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1]) &&                  // same open 2 and 3                  input.Open >= window[1].Open - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1]) &&                  input.Open <= window[1].Open + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1])"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,ThreeInside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeInside.cs,ComputeNextValue,The conditional expression  "GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      engulfed by 1st                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  Math.Min(window[1].Close' window[1].Open) > Math.Min(window[2].Close' window[2].Open) &&                  // 3rd: opposite to 1st                  ((GetCandleColor(window[2]) == CandleColor.White && GetCandleColor(input) == CandleColor.Black && input.Close < window[2].Open) ||                    //      and closing out                    (GetCandleColor(window[2]) == CandleColor.Black && GetCandleColor(input) == CandleColor.White && input.Close > window[2].Open)                  )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[3]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 4th black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: marubozu                  GetLowerShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  GetUpperShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  // 2nd: marubozu                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 3rd: opens gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  //      and has an upper shadow                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  //      that extends into the prior body                  window[1].High > window[2].Close &&                  // 4th: engulfs the 3rd including the shadows                  input.High > window[1].High && input.Low < window[1].Low"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,Engulfing,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Engulfing.cs,ComputeNextValue,The conditional expression  "(GetCandleColor(input) == CandleColor.White && GetCandleColor(window[1]) == CandleColor.Black &&                    input.Close > window[1].Open && input.Open < window[1].Close                  )                  ||                  // black engulfs white                  (GetCandleColor(input) == CandleColor.Black && GetCandleColor(window[1]) == CandleColor.White &&                    input.Open > window[1].Close && input.Close < window[1].Open                  )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,Hikkake,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Hikkake.cs,ComputeNextValue,The conditional expression  "window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 3rd: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low)                            ||                            // (bear) 3rd: higher high and higher low                            (input.High > window[1].High && input.Low > window[1].Low)                          )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,Hikkake,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Hikkake.cs,ComputeNextValue,The conditional expression  "Samples <= _patternIndex + 4 &&                              // close higher than the high of 2nd                              ((_patternResult > 0 && input.Close > window[(int)Samples - _patternIndex].High)                                ||                                // close lower than the low of 2nd                                (_patternResult < 0 && input.Close < window[(int)Samples - _patternIndex].Low)                              )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,Hikkake,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Hikkake.cs,ComputeNextValue,The conditional expression  "window[1].High < window[2].High && window[1].Low > window[2].Low &&                  // (bull) 3rd: lower high and lower low                  ((input.High < window[1].High && input.Low < window[1].Low)                   ||                   // (bear) 3rd: higher high and higher low                   (input.High > window[1].High && input.Low > window[1].Low)                      )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,Hikkake,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Hikkake.cs,ComputeNextValue,The conditional expression  "Samples <= _patternIndex + 4 &&                      // close higher than the high of 2nd                      ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                       ||                       // close lower than the low of 2nd                       (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low)                          )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,ThreeOutside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeOutside.cs,ComputeNextValue,The conditional expression  "(                    // white engulfs black                    GetCandleColor(window[1]) == CandleColor.White && GetCandleColor(window[2]) == CandleColor.Black &&                    window[1].Close > window[2].Open && window[1].Open < window[2].Close &&                    // third candle higher                    input.Close > window[1].Close                  )                  ||                  (                    // black engulfs white                    GetCandleColor(window[1]) == CandleColor.Black && GetCandleColor(window[2]) == CandleColor.White &&                    window[1].Open > window[2].Close && window[1].Close < window[2].Open &&                    // third candle lower                    input.Close < window[1].Close                  )"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,Counterattack,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Counterattack.cs,ComputeNextValue,The conditional expression  "(int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 1st long                  GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[1]' window[1]) &&                  // 2nd long                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[0]' input) &&                  // equal closes                  input.Close <= window[1].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1]) &&                  input.Close >= window[1].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1])"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      with long lower shadow                  GetLowerShadow(window[2]) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' window[2]) &&                  // 2nd: smaller candle                  GetRealBody(window[1]) < GetRealBody(window[2]) &&                  //      that opens higher but within 1st range                  window[1].Open > window[2].Close && window[1].Open <= window[2].High &&                  //      and trades lower than 1st close                  window[1].Low < window[2].Close &&                  //      but not lower than 1st low                  window[1].Low >= window[2].Low &&                  //      and has a lower shadow                  GetLowerShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd: small marubozu                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  //      engulfed by prior candle's range                  input.Low > window[1].Low && input.High < window[1].High"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // three declining                  window[2].Close > window[1].Close &&                  window[1].Close > input.Close &&                  // 2nd black opens very close to 1st close                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  window[1].Open >= window[2].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  // 3rd black opens very close to 2nd close                   input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1]) &&                  input.Open >= window[1].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1])"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[2]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 2nd not far shorter than 1st                  GetRealBody(window[1]) > GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                  // 3rd not far shorter than 2nd                  GetRealBody(input) > GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1]) &&                  // not short real body                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input)"  is complex.
Complex Conditional,QuantConnect.Indicators.CandlestickPatterns,TwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TwoCrows.cs,ComputeNextValue,The conditional expression  "GetCandleColor(window[2]) == CandleColor.White &&                  //      long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: black                  GetCandleColor(input) == CandleColor.Black &&                  //      opening within 2nd rb                  input.Open < window[1].Open && input.Open > window[1].Close &&                  //      closing within 1st rb                  input.Close > window[2].Open && input.Close < window[2].Close"  is complex.
Magic Number,QuantConnect.Indicators,ArnaudLegouxMovingAverage,C:\repos\QuantConnect_Lean\Indicators\ArnaudLegouxMovingAverage.cs,ArnaudLegouxMovingAverage,The following statement contains a magic number: var tmpVector = Vector<double>.Build.Dense(period'                  i => Math.Exp((double) (-(i - m) * (i - m) / (2 * s * s))));
Magic Number,QuantConnect.Indicators,AverageDirectionalIndex,C:\repos\QuantConnect_Lean\Indicators\AverageDirectionalIndex.cs,ComputeSmoothedDirectionalMovementMinus,The following statement contains a magic number: if (Samples < period)              {                  value = SmoothedDirectionalMovementMinus.Current + DirectionalMovementMinus.Current;              }              else              {                  value = SmoothedDirectionalMovementMinus.Current - (SmoothedDirectionalMovementMinus.Current / 14) + DirectionalMovementMinus.Current;              }
Magic Number,QuantConnect.Indicators,AverageDirectionalIndex,C:\repos\QuantConnect_Lean\Indicators\AverageDirectionalIndex.cs,ComputeNextValue,The following statement contains a magic number: var value = sum == 0 ? 50 : ((_period - 1) * Current.Value + 100 * diff / sum ) / _period;
Magic Number,QuantConnect.Indicators,AverageDirectionalIndex,C:\repos\QuantConnect_Lean\Indicators\AverageDirectionalIndex.cs,ComputeNextValue,The following statement contains a magic number: var value = sum == 0 ? 50 : ((_period - 1) * Current.Value + 100 * diff / sum ) / _period;
Magic Number,QuantConnect.Indicators,AverageDirectionalIndex,C:\repos\QuantConnect_Lean\Indicators\AverageDirectionalIndex.cs,ComputePositiveDirectionalIndex,The following statement contains a magic number: var positiveDirectionalIndex = (SmoothedDirectionalMovementPlus.Current.Value / SmoothedTrueRange.Current.Value) * 100;
Magic Number,QuantConnect.Indicators,AverageDirectionalIndex,C:\repos\QuantConnect_Lean\Indicators\AverageDirectionalIndex.cs,ComputeNegativeDirectionalIndex,The following statement contains a magic number: var negativeDirectionalIndex = (SmoothedDirectionalMovementMinus.Current.Value / SmoothedTrueRange.Current.Value) * 100;
Magic Number,QuantConnect.Indicators,AverageDirectionalMovementIndexRating,C:\repos\QuantConnect_Lean\Indicators\AverageDirectionalMovementIndexRating.cs,ComputeNextValue,The following statement contains a magic number: return (_adx + _adxHistory[Math.Min(_adxHistory.Count - 1' _period - 1)]) / 2;
Magic Number,QuantConnect.Indicators,DetrendedPriceOscillator,C:\repos\QuantConnect_Lean\Indicators\DetrendedPriceOscillator.cs,DetrendedPriceOscillator,The following statement contains a magic number: var lagPeriod = period / 2 + 1;
Magic Number,QuantConnect.Indicators,DonchianChannel,C:\repos\QuantConnect_Lean\Indicators\DonchianChannel.cs,ComputeNextValue,The following statement contains a magic number: return (UpperBand.Current.Value + LowerBand.Current.Value) / 2;
Magic Number,QuantConnect.Indicators,FractalAdaptiveMovingAverage,C:\repos\QuantConnect_Lean\Indicators\FractalAdaptiveMovingAverage.cs,FractalAdaptiveMovingAverage,The following statement contains a magic number: if (n % 2 > 0)              {                  throw new ArgumentException("N must be even.");              }
Magic Number,QuantConnect.Indicators,FractalAdaptiveMovingAverage,C:\repos\QuantConnect_Lean\Indicators\FractalAdaptiveMovingAverage.cs,ComputeNextValue,The following statement contains a magic number: var price = (double)(input.High + input.Low) / 2;
Magic Number,QuantConnect.Indicators,FractalAdaptiveMovingAverage,C:\repos\QuantConnect_Lean\Indicators\FractalAdaptiveMovingAverage.cs,ComputeNextValue,The following statement contains a magic number: hh = _high.Take(_n / 2).Max();
Magic Number,QuantConnect.Indicators,FractalAdaptiveMovingAverage,C:\repos\QuantConnect_Lean\Indicators\FractalAdaptiveMovingAverage.cs,ComputeNextValue,The following statement contains a magic number: ll = _low.Take(_n / 2).Min();
Magic Number,QuantConnect.Indicators,FractalAdaptiveMovingAverage,C:\repos\QuantConnect_Lean\Indicators\FractalAdaptiveMovingAverage.cs,ComputeNextValue,The following statement contains a magic number: n1 = (hh - ll) / (_n / 2);
Magic Number,QuantConnect.Indicators,FractalAdaptiveMovingAverage,C:\repos\QuantConnect_Lean\Indicators\FractalAdaptiveMovingAverage.cs,ComputeNextValue,The following statement contains a magic number: if (_high.IsReady)              {                  hh = _high.Skip(_n / 2).Take(_n / 2).Max();                  ll = _low.Skip(_n / 2).Take(_n / 2).Min();              }
Magic Number,QuantConnect.Indicators,FractalAdaptiveMovingAverage,C:\repos\QuantConnect_Lean\Indicators\FractalAdaptiveMovingAverage.cs,ComputeNextValue,The following statement contains a magic number: if (_high.IsReady)              {                  hh = _high.Skip(_n / 2).Take(_n / 2).Max();                  ll = _low.Skip(_n / 2).Take(_n / 2).Min();              }
Magic Number,QuantConnect.Indicators,FractalAdaptiveMovingAverage,C:\repos\QuantConnect_Lean\Indicators\FractalAdaptiveMovingAverage.cs,ComputeNextValue,The following statement contains a magic number: if (_high.IsReady)              {                  hh = _high.Skip(_n / 2).Take(_n / 2).Max();                  ll = _low.Skip(_n / 2).Take(_n / 2).Min();              }
Magic Number,QuantConnect.Indicators,FractalAdaptiveMovingAverage,C:\repos\QuantConnect_Lean\Indicators\FractalAdaptiveMovingAverage.cs,ComputeNextValue,The following statement contains a magic number: if (_high.IsReady)              {                  hh = _high.Skip(_n / 2).Take(_n / 2).Max();                  ll = _low.Skip(_n / 2).Take(_n / 2).Min();              }
Magic Number,QuantConnect.Indicators,FractalAdaptiveMovingAverage,C:\repos\QuantConnect_Lean\Indicators\FractalAdaptiveMovingAverage.cs,ComputeNextValue,The following statement contains a magic number: n2 = (hh - ll) / (_n / 2);
Magic Number,QuantConnect.Indicators,FractalAdaptiveMovingAverage,C:\repos\QuantConnect_Lean\Indicators\FractalAdaptiveMovingAverage.cs,ComputeNextValue,The following statement contains a magic number: if (n1 > 0 && n2 > 0 && n3 > 0)              {                  dimen = (Math.Log(n1 + n2) - Math.Log(n3)) / Math.Log(2);              }
Magic Number,QuantConnect.Indicators,FractalAdaptiveMovingAverage,C:\repos\QuantConnect_Lean\Indicators\FractalAdaptiveMovingAverage.cs,ComputeNextValue,The following statement contains a magic number: if (alpha < .01) { alpha = .01; }
Magic Number,QuantConnect.Indicators,FractalAdaptiveMovingAverage,C:\repos\QuantConnect_Lean\Indicators\FractalAdaptiveMovingAverage.cs,ComputeNextValue,The following statement contains a magic number: if (alpha < .01) { alpha = .01; }
Magic Number,QuantConnect.Indicators,FractalAdaptiveMovingAverage,C:\repos\QuantConnect_Lean\Indicators\FractalAdaptiveMovingAverage.cs,Reset,The following statement contains a magic number: _n = 16;
Magic Number,QuantConnect.Indicators,FractalAdaptiveMovingAverage,C:\repos\QuantConnect_Lean\Indicators\FractalAdaptiveMovingAverage.cs,Reset,The following statement contains a magic number: _w = -4.6;
Magic Number,QuantConnect.Indicators,HullMovingAverage,C:\repos\QuantConnect_Lean\Indicators\HullMovingAverage.cs,HullMovingAverage,The following statement contains a magic number: if (period < 2) throw new ArgumentException("The Hull Moving Average period should be greater or equal to 2"' "period");
Magic Number,QuantConnect.Indicators,HullMovingAverage,C:\repos\QuantConnect_Lean\Indicators\HullMovingAverage.cs,HullMovingAverage,The following statement contains a magic number: _fastWma = new LinearWeightedMovingAverage((int) Math.Round(period * 1d / 2));
Magic Number,QuantConnect.Indicators,HullMovingAverage,C:\repos\QuantConnect_Lean\Indicators\HullMovingAverage.cs,ComputeNextValue,The following statement contains a magic number: _hullMa.Update(new IndicatorDataPoint(input.Time' 2 * _fastWma.Current.Value - _slowWma.Current.Value));
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: _filt = new RollingWindow<double>(2) { 0.0' 0.0 };
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: _price = new RollingWindow<double>(3);
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: if (_tool == SwissArmyKnifeTool.Gauss)              {                  beta = 2.415 * (1 - Math.Cos(2 * Math.PI / _period));                  alpha = -beta + Math.Sqrt(Math.Pow(beta' 2) + 2d * beta);                  _c0 = alpha * alpha;                  _a1 = 2d * (1 - alpha);                  _a2 = -(1 - alpha) * (1 - alpha);              }
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: if (_tool == SwissArmyKnifeTool.Gauss)              {                  beta = 2.415 * (1 - Math.Cos(2 * Math.PI / _period));                  alpha = -beta + Math.Sqrt(Math.Pow(beta' 2) + 2d * beta);                  _c0 = alpha * alpha;                  _a1 = 2d * (1 - alpha);                  _a2 = -(1 - alpha) * (1 - alpha);              }
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: if (_tool == SwissArmyKnifeTool.Gauss)              {                  beta = 2.415 * (1 - Math.Cos(2 * Math.PI / _period));                  alpha = -beta + Math.Sqrt(Math.Pow(beta' 2) + 2d * beta);                  _c0 = alpha * alpha;                  _a1 = 2d * (1 - alpha);                  _a2 = -(1 - alpha) * (1 - alpha);              }
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: if (_tool == SwissArmyKnifeTool.Butter)              {                  beta = 2.415 * (1 - Math.Cos(2 * Math.PI / _period));                  alpha = -beta + Math.Sqrt(Math.Pow(beta' 2) + 2d * beta);                  _c0 = alpha * alpha / 4d;                  _b1 = 2;                  _b2 = 1;                  _a1 = 2d * (1 - alpha);                  _a2 = -(1 - alpha) * (1 - alpha);              }
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: if (_tool == SwissArmyKnifeTool.Butter)              {                  beta = 2.415 * (1 - Math.Cos(2 * Math.PI / _period));                  alpha = -beta + Math.Sqrt(Math.Pow(beta' 2) + 2d * beta);                  _c0 = alpha * alpha / 4d;                  _b1 = 2;                  _b2 = 1;                  _a1 = 2d * (1 - alpha);                  _a2 = -(1 - alpha) * (1 - alpha);              }
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: if (_tool == SwissArmyKnifeTool.Butter)              {                  beta = 2.415 * (1 - Math.Cos(2 * Math.PI / _period));                  alpha = -beta + Math.Sqrt(Math.Pow(beta' 2) + 2d * beta);                  _c0 = alpha * alpha / 4d;                  _b1 = 2;                  _b2 = 1;                  _a1 = 2d * (1 - alpha);                  _a2 = -(1 - alpha) * (1 - alpha);              }
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: if (_tool == SwissArmyKnifeTool.Butter)              {                  beta = 2.415 * (1 - Math.Cos(2 * Math.PI / _period));                  alpha = -beta + Math.Sqrt(Math.Pow(beta' 2) + 2d * beta);                  _c0 = alpha * alpha / 4d;                  _b1 = 2;                  _b2 = 1;                  _a1 = 2d * (1 - alpha);                  _a2 = -(1 - alpha) * (1 - alpha);              }
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: if (_tool == SwissArmyKnifeTool.HighPass)              {                  alpha = (Math.Cos(2 * Math.PI / _period) + Math.Sin(2 * Math.PI / _period) - 1) / Math.Cos(2 * Math.PI / _period);                  _c0 = (1 + alpha) / 2;                  _b1 = -1;                  _a1 = 1 - alpha;              }
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: if (_tool == SwissArmyKnifeTool.HighPass)              {                  alpha = (Math.Cos(2 * Math.PI / _period) + Math.Sin(2 * Math.PI / _period) - 1) / Math.Cos(2 * Math.PI / _period);                  _c0 = (1 + alpha) / 2;                  _b1 = -1;                  _a1 = 1 - alpha;              }
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: if (_tool == SwissArmyKnifeTool.HighPass)              {                  alpha = (Math.Cos(2 * Math.PI / _period) + Math.Sin(2 * Math.PI / _period) - 1) / Math.Cos(2 * Math.PI / _period);                  _c0 = (1 + alpha) / 2;                  _b1 = -1;                  _a1 = 1 - alpha;              }
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: if (_tool == SwissArmyKnifeTool.HighPass)              {                  alpha = (Math.Cos(2 * Math.PI / _period) + Math.Sin(2 * Math.PI / _period) - 1) / Math.Cos(2 * Math.PI / _period);                  _c0 = (1 + alpha) / 2;                  _b1 = -1;                  _a1 = 1 - alpha;              }
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: if (_tool == SwissArmyKnifeTool.TwoPoleHighPass)              {                  beta = 2.415 * (1 - Math.Cos(2 * Math.PI / _period));                  alpha = -beta + Math.Sqrt(Math.Pow(beta' 2) + 2d * beta);                  _c0 = (1 + alpha) * (1 + alpha) / 4;                  _b1 = -2;                  _b2 = 1;                  _a1 = 2d * (1 - alpha);                  _a2 = -(1 - alpha) * (1 - alpha);              }
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: if (_tool == SwissArmyKnifeTool.TwoPoleHighPass)              {                  beta = 2.415 * (1 - Math.Cos(2 * Math.PI / _period));                  alpha = -beta + Math.Sqrt(Math.Pow(beta' 2) + 2d * beta);                  _c0 = (1 + alpha) * (1 + alpha) / 4;                  _b1 = -2;                  _b2 = 1;                  _a1 = 2d * (1 - alpha);                  _a2 = -(1 - alpha) * (1 - alpha);              }
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: if (_tool == SwissArmyKnifeTool.TwoPoleHighPass)              {                  beta = 2.415 * (1 - Math.Cos(2 * Math.PI / _period));                  alpha = -beta + Math.Sqrt(Math.Pow(beta' 2) + 2d * beta);                  _c0 = (1 + alpha) * (1 + alpha) / 4;                  _b1 = -2;                  _b2 = 1;                  _a1 = 2d * (1 - alpha);                  _a2 = -(1 - alpha) * (1 - alpha);              }
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: if (_tool == SwissArmyKnifeTool.TwoPoleHighPass)              {                  beta = 2.415 * (1 - Math.Cos(2 * Math.PI / _period));                  alpha = -beta + Math.Sqrt(Math.Pow(beta' 2) + 2d * beta);                  _c0 = (1 + alpha) * (1 + alpha) / 4;                  _b1 = -2;                  _b2 = 1;                  _a1 = 2d * (1 - alpha);                  _a2 = -(1 - alpha) * (1 - alpha);              }
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: if (_tool == SwissArmyKnifeTool.TwoPoleHighPass)              {                  beta = 2.415 * (1 - Math.Cos(2 * Math.PI / _period));                  alpha = -beta + Math.Sqrt(Math.Pow(beta' 2) + 2d * beta);                  _c0 = (1 + alpha) * (1 + alpha) / 4;                  _b1 = -2;                  _b2 = 1;                  _a1 = 2d * (1 - alpha);                  _a2 = -(1 - alpha) * (1 - alpha);              }
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: if (_tool == SwissArmyKnifeTool.BandPass)              {                  beta = Math.Cos(2 * Math.PI / _period);                  gamma = (1 / Math.Cos(4 * Math.PI * _delta / _period));                  alpha = gamma - Math.Sqrt(Math.Pow(gamma' 2) - 1);                  _c0 = (1 - alpha) / 2d;                  _b0 = 1;                  _b2 = -1;                  _a1 = -beta * (1 - alpha);                  _a2 = alpha;              }
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: if (_tool == SwissArmyKnifeTool.BandPass)              {                  beta = Math.Cos(2 * Math.PI / _period);                  gamma = (1 / Math.Cos(4 * Math.PI * _delta / _period));                  alpha = gamma - Math.Sqrt(Math.Pow(gamma' 2) - 1);                  _c0 = (1 - alpha) / 2d;                  _b0 = 1;                  _b2 = -1;                  _a1 = -beta * (1 - alpha);                  _a2 = alpha;              }
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,SwissArmyKnife,The following statement contains a magic number: if (_tool == SwissArmyKnifeTool.BandPass)              {                  beta = Math.Cos(2 * Math.PI / _period);                  gamma = (1 / Math.Cos(4 * Math.PI * _delta / _period));                  alpha = gamma - Math.Sqrt(Math.Pow(gamma' 2) - 1);                  _c0 = (1 - alpha) / 2d;                  _b0 = 1;                  _b2 = -1;                  _a1 = -beta * (1 - alpha);                  _a2 = alpha;              }
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,ComputeNextValue,The following statement contains a magic number: double signal = _a0 * _c0 * (_b0 * _price[0] + _b1 * _price[1] + _b2 * _price[2]) + _a0 * (_a1 * _filt[0] + _a2 * _filt[1]);
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,Reset,The following statement contains a magic number: _period = 20;
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,Reset,The following statement contains a magic number: _delta = 0.1;
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,Reset,The following statement contains a magic number: _filt = new RollingWindow<double>(2) { 0.0' 0.0 };
Magic Number,QuantConnect.Indicators,SwissArmyKnife,C:\repos\QuantConnect_Lean\Indicators\SwissArmyKnife.cs,Reset,The following statement contains a magic number: _price = new RollingWindow<double>(3);
Magic Number,QuantConnect.Indicators,VolumeWeightedAveragePriceIndicator,C:\repos\QuantConnect_Lean\Indicators\VolumeWeightedAveragePriceIndicator.cs,ComputeNextValue,The following statement contains a magic number: _price.Update(input.EndTime' (input.Open + input.High + input.Low + input.Value) / 4);
Magic Number,QuantConnect.Indicators,FisherTransform,C:\repos\QuantConnect_Lean\Indicators\FisherTransform.cs,FisherTransform,The following statement contains a magic number: _alpha = .33;
Magic Number,QuantConnect.Indicators,FisherTransform,C:\repos\QuantConnect_Lean\Indicators\FisherTransform.cs,ComputeNextValue,The following statement contains a magic number: if (minL != maxH)              {                  x = _alpha * 2 * ((double)((price - minL) / (maxH - minL)) - .5) + (1 - _alpha) * _previous;                  y = FisherTransformFunction(x);              }
Magic Number,QuantConnect.Indicators,FisherTransform,C:\repos\QuantConnect_Lean\Indicators\FisherTransform.cs,ComputeNextValue,The following statement contains a magic number: if (minL != maxH)              {                  x = _alpha * 2 * ((double)((price - minL) / (maxH - minL)) - .5) + (1 - _alpha) * _previous;                  y = FisherTransformFunction(x);              }
Magic Number,QuantConnect.Indicators,FisherTransform,C:\repos\QuantConnect_Lean\Indicators\FisherTransform.cs,FisherTransformFunction,The following statement contains a magic number: if (x > .99)              {                  x = .999;              }
Magic Number,QuantConnect.Indicators,FisherTransform,C:\repos\QuantConnect_Lean\Indicators\FisherTransform.cs,FisherTransformFunction,The following statement contains a magic number: if (x > .99)              {                  x = .999;              }
Magic Number,QuantConnect.Indicators,FisherTransform,C:\repos\QuantConnect_Lean\Indicators\FisherTransform.cs,FisherTransformFunction,The following statement contains a magic number: if (x < -.99)              {                  x = -.999;              }
Magic Number,QuantConnect.Indicators,FisherTransform,C:\repos\QuantConnect_Lean\Indicators\FisherTransform.cs,FisherTransformFunction,The following statement contains a magic number: if (x < -.99)              {                  x = -.999;              }
Magic Number,QuantConnect.Indicators,FisherTransform,C:\repos\QuantConnect_Lean\Indicators\FisherTransform.cs,FisherTransformFunction,The following statement contains a magic number: return .5 * Math.Log((1.0 + x) / (1.0 - x));
Magic Number,QuantConnect.Indicators,HeikinAshi,C:\repos\QuantConnect_Lean\Indicators\HeikinAshi.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  Open.Update(new IndicatorDataPoint(input.Time' (input.Open + input.Close) / 2));                  Close.Update(new IndicatorDataPoint(input.Time' (input.Open + input.High + input.Low + input.Close) / 4));                  High.Update(new IndicatorDataPoint(input.Time' input.High));                  Low.Update(new IndicatorDataPoint(input.Time' input.Low));              }              else              {                  Open.Update(new IndicatorDataPoint(input.Time' (Open + Close) / 2));                  Close.Update(new IndicatorDataPoint(input.Time' (input.Open + input.High + input.Low + input.Close) / 4));                  High.Update(new IndicatorDataPoint(input.Time' Math.Max(input.High' Math.Max(Open' Close))));                  Low.Update(new IndicatorDataPoint(input.Time' Math.Min(input.Low' Math.Min(Open' Close))));              }
Magic Number,QuantConnect.Indicators,HeikinAshi,C:\repos\QuantConnect_Lean\Indicators\HeikinAshi.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  Open.Update(new IndicatorDataPoint(input.Time' (input.Open + input.Close) / 2));                  Close.Update(new IndicatorDataPoint(input.Time' (input.Open + input.High + input.Low + input.Close) / 4));                  High.Update(new IndicatorDataPoint(input.Time' input.High));                  Low.Update(new IndicatorDataPoint(input.Time' input.Low));              }              else              {                  Open.Update(new IndicatorDataPoint(input.Time' (Open + Close) / 2));                  Close.Update(new IndicatorDataPoint(input.Time' (input.Open + input.High + input.Low + input.Close) / 4));                  High.Update(new IndicatorDataPoint(input.Time' Math.Max(input.High' Math.Max(Open' Close))));                  Low.Update(new IndicatorDataPoint(input.Time' Math.Min(input.Low' Math.Min(Open' Close))));              }
Magic Number,QuantConnect.Indicators,HeikinAshi,C:\repos\QuantConnect_Lean\Indicators\HeikinAshi.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  Open.Update(new IndicatorDataPoint(input.Time' (input.Open + input.Close) / 2));                  Close.Update(new IndicatorDataPoint(input.Time' (input.Open + input.High + input.Low + input.Close) / 4));                  High.Update(new IndicatorDataPoint(input.Time' input.High));                  Low.Update(new IndicatorDataPoint(input.Time' input.Low));              }              else              {                  Open.Update(new IndicatorDataPoint(input.Time' (Open + Close) / 2));                  Close.Update(new IndicatorDataPoint(input.Time' (input.Open + input.High + input.Low + input.Close) / 4));                  High.Update(new IndicatorDataPoint(input.Time' Math.Max(input.High' Math.Max(Open' Close))));                  Low.Update(new IndicatorDataPoint(input.Time' Math.Min(input.Low' Math.Min(Open' Close))));              }
Magic Number,QuantConnect.Indicators,HeikinAshi,C:\repos\QuantConnect_Lean\Indicators\HeikinAshi.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  Open.Update(new IndicatorDataPoint(input.Time' (input.Open + input.Close) / 2));                  Close.Update(new IndicatorDataPoint(input.Time' (input.Open + input.High + input.Low + input.Close) / 4));                  High.Update(new IndicatorDataPoint(input.Time' input.High));                  Low.Update(new IndicatorDataPoint(input.Time' input.Low));              }              else              {                  Open.Update(new IndicatorDataPoint(input.Time' (Open + Close) / 2));                  Close.Update(new IndicatorDataPoint(input.Time' (input.Open + input.High + input.Low + input.Close) / 4));                  High.Update(new IndicatorDataPoint(input.Time' Math.Max(input.High' Math.Max(Open' Close))));                  Low.Update(new IndicatorDataPoint(input.Time' Math.Min(input.Low' Math.Min(Open' Close))));              }
Magic Number,QuantConnect.Indicators,IchimokuKinkoHyo,C:\repos\QuantConnect_Lean\Indicators\IchimokuKinkoHyo.cs,computeSenkouB,The following statement contains a magic number: var senkouB = DelayedMaximumSenkouB.Samples >= period ? (DelayedMaximumSenkouB + DelayedMinimumSenkouB) / 2 : new decimal(0.0);
Magic Number,QuantConnect.Indicators,IchimokuKinkoHyo,C:\repos\QuantConnect_Lean\Indicators\IchimokuKinkoHyo.cs,computeSenkouA,The following statement contains a magic number: var senkouA = DelayedKijunSenkouA.Samples >= period ? (DelayedTenkanSenkouA + DelayedKijunSenkouA) / 2 : new decimal(0.0);
Magic Number,QuantConnect.Indicators,IchimokuKinkoHyo,C:\repos\QuantConnect_Lean\Indicators\IchimokuKinkoHyo.cs,ComputeTenkan,The following statement contains a magic number: var tenkan = TenkanMaximum.Samples >= period ? (TenkanMaximum.Current.Value + TenkanMinimum.Current.Value) / 2 : new decimal(0.0);
Magic Number,QuantConnect.Indicators,IchimokuKinkoHyo,C:\repos\QuantConnect_Lean\Indicators\IchimokuKinkoHyo.cs,ComputeKijun,The following statement contains a magic number: var kijun = KijunMaximum.Samples >= period ? (KijunMaximum + KijunMinimum) / 2 : new decimal(0.0);
Magic Number,QuantConnect.Indicators,MidPrice,C:\repos\QuantConnect_Lean\Indicators\MidPrice.cs,ComputeNextValue,The following statement contains a magic number: return (_maximum + _minimum) / 2;
Magic Number,QuantConnect.Indicators,MidPoint,C:\repos\QuantConnect_Lean\Indicators\MidPoint.cs,ComputeNextValue,The following statement contains a magic number: return (_maximum + _minimum) / 2;
Magic Number,QuantConnect.Indicators,MomersionIndicator,C:\repos\QuantConnect_Lean\Indicators\Momersion.cs,MomersionIndicator,The following statement contains a magic number: if (minPeriod < 4)              {                  throw new ArgumentException("The minimum period should be greater of 3."' "minPeriod");              }
Magic Number,QuantConnect.Indicators,MomersionIndicator,C:\repos\QuantConnect_Lean\Indicators\Momersion.cs,ComputeNextValue,The following statement contains a magic number: if (window.Count >= 3) _multipliedDiffWindow.Add((window[0] - window[1]) * (window[1] - window[2]));
Magic Number,QuantConnect.Indicators,MomersionIndicator,C:\repos\QuantConnect_Lean\Indicators\Momersion.cs,ComputeNextValue,The following statement contains a magic number: if (window.Count >= 3) _multipliedDiffWindow.Add((window[0] - window[1]) * (window[1] - window[2]));
Magic Number,QuantConnect.Indicators,MomersionIndicator,C:\repos\QuantConnect_Lean\Indicators\Momersion.cs,ComputeNextValue,The following statement contains a magic number: if (this.IsReady &&                  _multipliedDiffWindow.Count(obs => obs == 0) < 0.5 * _multipliedDiffWindow.Count)              {                  Mc = _multipliedDiffWindow.Count(obs => obs > 0);                  MRc = _multipliedDiffWindow.Count(obs => obs < 0);                  momersion = 100m * Mc / (Mc + MRc);              }
Magic Number,QuantConnect.Indicators,NormalizedAverageTrueRange,C:\repos\QuantConnect_Lean\Indicators\NormalizedAverageTrueRange.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  _atr.Update(input);                  return input.Close != 0 ? _atr / input.Close * 100 : 0m;              }
Magic Number,QuantConnect.Indicators,NormalizedAverageTrueRange,C:\repos\QuantConnect_Lean\Indicators\NormalizedAverageTrueRange.cs,ComputeNextValue,The following statement contains a magic number: return input.Close != 0 ? _lastAtrValue / input.Close * 100 : 0m;
Magic Number,QuantConnect.Indicators,ParabolicStopAndReverse,C:\repos\QuantConnect_Lean\Indicators\ParabolicStopAndReverse.cs,ComputeNextValue,The following statement contains a magic number: if (Samples == 2)              {                  Init(input);                  _previousBar = input;                  return _sar;              }
Magic Number,QuantConnect.Indicators,PercentagePriceOscillator,C:\repos\QuantConnect_Lean\Indicators\PercentagePriceOscillator.cs,ComputeNextValue,The following statement contains a magic number: return Slow != 0 ? 100 * value / Slow : 0m;
Magic Number,QuantConnect.Indicators,Trix,C:\repos\QuantConnect_Lean\Indicators\Trix.cs,ComputeNextValue,The following statement contains a magic number: if (Samples > 2 * (_period - 1))                  _ema3.Update(_ema2.Current);
Magic Number,QuantConnect.Indicators,Trix,C:\repos\QuantConnect_Lean\Indicators\Trix.cs,ComputeNextValue,The following statement contains a magic number: if (Samples > 3 * (_period - 1))                  _roc.Update(_ema3.Current);
Magic Number,QuantConnect.Indicators,TripleExponentialMovingAverage,C:\repos\QuantConnect_Lean\Indicators\TripleExponentialMovingAverage.cs,ComputeNextValue,The following statement contains a magic number: if (Samples > 2 * (_period - 1))                  _ema3.Update(_ema2.Current);
Magic Number,QuantConnect.Indicators,TriangularMovingAverage,C:\repos\QuantConnect_Lean\Indicators\TriangularMovingAverage.cs,TriangularMovingAverage,The following statement contains a magic number: var periodSma1 = period % 2 == 0 ? period / 2 : (period + 1) / 2;
Magic Number,QuantConnect.Indicators,TriangularMovingAverage,C:\repos\QuantConnect_Lean\Indicators\TriangularMovingAverage.cs,TriangularMovingAverage,The following statement contains a magic number: var periodSma1 = period % 2 == 0 ? period / 2 : (period + 1) / 2;
Magic Number,QuantConnect.Indicators,TriangularMovingAverage,C:\repos\QuantConnect_Lean\Indicators\TriangularMovingAverage.cs,TriangularMovingAverage,The following statement contains a magic number: var periodSma1 = period % 2 == 0 ? period / 2 : (period + 1) / 2;
Magic Number,QuantConnect.Indicators,TriangularMovingAverage,C:\repos\QuantConnect_Lean\Indicators\TriangularMovingAverage.cs,TriangularMovingAverage,The following statement contains a magic number: var periodSma2 = period % 2 == 0 ? period / 2 + 1 : (period + 1) / 2;
Magic Number,QuantConnect.Indicators,TriangularMovingAverage,C:\repos\QuantConnect_Lean\Indicators\TriangularMovingAverage.cs,TriangularMovingAverage,The following statement contains a magic number: var periodSma2 = period % 2 == 0 ? period / 2 + 1 : (period + 1) / 2;
Magic Number,QuantConnect.Indicators,TriangularMovingAverage,C:\repos\QuantConnect_Lean\Indicators\TriangularMovingAverage.cs,TriangularMovingAverage,The following statement contains a magic number: var periodSma2 = period % 2 == 0 ? period / 2 + 1 : (period + 1) / 2;
Magic Number,QuantConnect.Indicators,UltimateOscillator,C:\repos\QuantConnect_Lean\Indicators\UltimateOscillator.cs,ComputeNextValue,The following statement contains a magic number: return 100m * (4 * average1 + 2 * average2 + average3) / 7;
Magic Number,QuantConnect.Indicators,UltimateOscillator,C:\repos\QuantConnect_Lean\Indicators\UltimateOscillator.cs,ComputeNextValue,The following statement contains a magic number: return 100m * (4 * average1 + 2 * average2 + average3) / 7;
Magic Number,QuantConnect.Indicators,UltimateOscillator,C:\repos\QuantConnect_Lean\Indicators\UltimateOscillator.cs,ComputeNextValue,The following statement contains a magic number: return 100m * (4 * average1 + 2 * average2 + average3) / 7;
Magic Number,QuantConnect.Indicators,Variance,C:\repos\QuantConnect_Lean\Indicators\Variance.cs,ComputeNextValue,The following statement contains a magic number: if (Samples < 2)                  return 0m;
Magic Number,QuantConnect.Indicators,MeanAbsoluteDeviation,C:\repos\QuantConnect_Lean\Indicators\MeanAbsoluteDeviation.cs,ComputeNextValue,The following statement contains a magic number: if (Samples < 2)              {                  return 0m;              }
Magic Number,QuantConnect.Indicators,RateOfChangePercent,C:\repos\QuantConnect_Lean\Indicators\RateOfChangePercent.cs,ComputeNextValue,The following statement contains a magic number: return 100 * (input - denominator) / denominator;
Magic Number,QuantConnect.Indicators,Stochastic,C:\repos\QuantConnect_Lean\Indicators\Stochastics.cs,ComputeFastStoch,The following statement contains a magic number: return fastStoch * 100;
Magic Number,QuantConnect.Indicators,Stochastic,C:\repos\QuantConnect_Lean\Indicators\Stochastics.cs,ComputeStochK,The following statement contains a magic number: return stochK * 100;
Magic Number,QuantConnect.Indicators,Stochastic,C:\repos\QuantConnect_Lean\Indicators\Stochastics.cs,ComputeStochD,The following statement contains a magic number: var stochD = _maximum.Samples >= (period + constantK + constantD - 2) ? _sumSlowK / constantD : new decimal(0.0);
Magic Number,QuantConnect.Indicators,Stochastic,C:\repos\QuantConnect_Lean\Indicators\Stochastics.cs,ComputeStochD,The following statement contains a magic number: return stochD * 100;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UpDownGapThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpDownGapThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st and 2nd of same color                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 3rd opposite color                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 3rd opens within 2nd rb                  input.Open < Math.Max(window[1].Close' window[1].Open) &&                  input.Open > Math.Min(window[1].Close' window[1].Open) &&                  // 3rd closes within 1st rb                  input.Close < Math.Max(window[2].Close' window[2].Open) &&                  input.Close > Math.Min(window[2].Close' window[2].Open) &&                  ((                      // when 1st is white                      GetCandleColor(window[2]) == CandleColor.White &&                      // upside gap                      GetRealBodyGapUp(window[1]' window[2])                    ) ||                    (                      // when 1st is black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // downside gap                      GetRealBodyGapDown(window[1]' window[2])                    )                  )              )                  value = (int)GetCandleColor(window[2]);              else                  value = 0;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UpDownGapThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpDownGapThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st and 2nd of same color                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 3rd opposite color                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 3rd opens within 2nd rb                  input.Open < Math.Max(window[1].Close' window[1].Open) &&                  input.Open > Math.Min(window[1].Close' window[1].Open) &&                  // 3rd closes within 1st rb                  input.Close < Math.Max(window[2].Close' window[2].Open) &&                  input.Close > Math.Min(window[2].Close' window[2].Open) &&                  ((                      // when 1st is white                      GetCandleColor(window[2]) == CandleColor.White &&                      // upside gap                      GetRealBodyGapUp(window[1]' window[2])                    ) ||                    (                      // when 1st is black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // downside gap                      GetRealBodyGapDown(window[1]' window[2])                    )                  )              )                  value = (int)GetCandleColor(window[2]);              else                  value = 0;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UpDownGapThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpDownGapThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st and 2nd of same color                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 3rd opposite color                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 3rd opens within 2nd rb                  input.Open < Math.Max(window[1].Close' window[1].Open) &&                  input.Open > Math.Min(window[1].Close' window[1].Open) &&                  // 3rd closes within 1st rb                  input.Close < Math.Max(window[2].Close' window[2].Open) &&                  input.Close > Math.Min(window[2].Close' window[2].Open) &&                  ((                      // when 1st is white                      GetCandleColor(window[2]) == CandleColor.White &&                      // upside gap                      GetRealBodyGapUp(window[1]' window[2])                    ) ||                    (                      // when 1st is black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // downside gap                      GetRealBodyGapDown(window[1]' window[2])                    )                  )              )                  value = (int)GetCandleColor(window[2]);              else                  value = 0;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UpDownGapThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpDownGapThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st and 2nd of same color                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 3rd opposite color                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 3rd opens within 2nd rb                  input.Open < Math.Max(window[1].Close' window[1].Open) &&                  input.Open > Math.Min(window[1].Close' window[1].Open) &&                  // 3rd closes within 1st rb                  input.Close < Math.Max(window[2].Close' window[2].Open) &&                  input.Close > Math.Min(window[2].Close' window[2].Open) &&                  ((                      // when 1st is white                      GetCandleColor(window[2]) == CandleColor.White &&                      // upside gap                      GetRealBodyGapUp(window[1]' window[2])                    ) ||                    (                      // when 1st is black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // downside gap                      GetRealBodyGapDown(window[1]' window[2])                    )                  )              )                  value = (int)GetCandleColor(window[2]);              else                  value = 0;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UpDownGapThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpDownGapThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st and 2nd of same color                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 3rd opposite color                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 3rd opens within 2nd rb                  input.Open < Math.Max(window[1].Close' window[1].Open) &&                  input.Open > Math.Min(window[1].Close' window[1].Open) &&                  // 3rd closes within 1st rb                  input.Close < Math.Max(window[2].Close' window[2].Open) &&                  input.Close > Math.Min(window[2].Close' window[2].Open) &&                  ((                      // when 1st is white                      GetCandleColor(window[2]) == CandleColor.White &&                      // upside gap                      GetRealBodyGapUp(window[1]' window[2])                    ) ||                    (                      // when 1st is black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // downside gap                      GetRealBodyGapDown(window[1]' window[2])                    )                  )              )                  value = (int)GetCandleColor(window[2]);              else                  value = 0;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UpDownGapThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpDownGapThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st and 2nd of same color                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 3rd opposite color                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 3rd opens within 2nd rb                  input.Open < Math.Max(window[1].Close' window[1].Open) &&                  input.Open > Math.Min(window[1].Close' window[1].Open) &&                  // 3rd closes within 1st rb                  input.Close < Math.Max(window[2].Close' window[2].Open) &&                  input.Close > Math.Min(window[2].Close' window[2].Open) &&                  ((                      // when 1st is white                      GetCandleColor(window[2]) == CandleColor.White &&                      // upside gap                      GetRealBodyGapUp(window[1]' window[2])                    ) ||                    (                      // when 1st is black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // downside gap                      GetRealBodyGapDown(window[1]' window[2])                    )                  )              )                  value = (int)GetCandleColor(window[2]);              else                  value = 0;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UpDownGapThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpDownGapThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st and 2nd of same color                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 3rd opposite color                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 3rd opens within 2nd rb                  input.Open < Math.Max(window[1].Close' window[1].Open) &&                  input.Open > Math.Min(window[1].Close' window[1].Open) &&                  // 3rd closes within 1st rb                  input.Close < Math.Max(window[2].Close' window[2].Open) &&                  input.Close > Math.Min(window[2].Close' window[2].Open) &&                  ((                      // when 1st is white                      GetCandleColor(window[2]) == CandleColor.White &&                      // upside gap                      GetRealBodyGapUp(window[1]' window[2])                    ) ||                    (                      // when 1st is black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // downside gap                      GetRealBodyGapDown(window[1]' window[2])                    )                  )              )                  value = (int)GetCandleColor(window[2]);              else                  value = 0;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UpDownGapThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpDownGapThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st and 2nd of same color                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 3rd opposite color                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 3rd opens within 2nd rb                  input.Open < Math.Max(window[1].Close' window[1].Open) &&                  input.Open > Math.Min(window[1].Close' window[1].Open) &&                  // 3rd closes within 1st rb                  input.Close < Math.Max(window[2].Close' window[2].Open) &&                  input.Close > Math.Min(window[2].Close' window[2].Open) &&                  ((                      // when 1st is white                      GetCandleColor(window[2]) == CandleColor.White &&                      // upside gap                      GetRealBodyGapUp(window[1]' window[2])                    ) ||                    (                      // when 1st is black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // downside gap                      GetRealBodyGapDown(window[1]' window[2])                    )                  )              )                  value = (int)GetCandleColor(window[2]);              else                  value = 0;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UpDownGapThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpDownGapThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st and 2nd of same color                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 3rd opposite color                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 3rd opens within 2nd rb                  input.Open < Math.Max(window[1].Close' window[1].Open) &&                  input.Open > Math.Min(window[1].Close' window[1].Open) &&                  // 3rd closes within 1st rb                  input.Close < Math.Max(window[2].Close' window[2].Open) &&                  input.Close > Math.Min(window[2].Close' window[2].Open) &&                  ((                      // when 1st is white                      GetCandleColor(window[2]) == CandleColor.White &&                      // upside gap                      GetRealBodyGapUp(window[1]' window[2])                    ) ||                    (                      // when 1st is black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // downside gap                      GetRealBodyGapDown(window[1]' window[2])                    )                  )              )                  value = (int)GetCandleColor(window[2]);              else                  value = 0;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UpDownGapThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpDownGapThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st and 2nd of same color                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 3rd opposite color                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 3rd opens within 2nd rb                  input.Open < Math.Max(window[1].Close' window[1].Open) &&                  input.Open > Math.Min(window[1].Close' window[1].Open) &&                  // 3rd closes within 1st rb                  input.Close < Math.Max(window[2].Close' window[2].Open) &&                  input.Close > Math.Min(window[2].Close' window[2].Open) &&                  ((                      // when 1st is white                      GetCandleColor(window[2]) == CandleColor.White &&                      // upside gap                      GetRealBodyGapUp(window[1]' window[2])                    ) ||                    (                      // when 1st is black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // downside gap                      GetRealBodyGapDown(window[1]' window[2])                    )                  )              )                  value = (int)GetCandleColor(window[2]);              else                  value = 0;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UpsideGapTwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpsideGapTwoCrows.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod - 2 && Samples < Period - 2)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    if (Samples >= Period - _bodyShortAveragePeriod - 1 && Samples < Period - 1)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UpsideGapTwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpsideGapTwoCrows.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod - 2 && Samples < Period - 2)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    if (Samples >= Period - _bodyShortAveragePeriod - 1 && Samples < Period - 1)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UpsideGapTwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpsideGapTwoCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: white                  GetCandleColor(window[2]) == CandleColor.White &&                  //      long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: black                  GetCandleColor(input) == CandleColor.Black &&                  // 3rd: engulfing prior rb                  input.Open > window[1].Open && input.Close < window[1].Close &&                  //      closing above 1st                  input.Close > window[2].Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UpsideGapTwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpsideGapTwoCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: white                  GetCandleColor(window[2]) == CandleColor.White &&                  //      long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: black                  GetCandleColor(input) == CandleColor.Black &&                  // 3rd: engulfing prior rb                  input.Open > window[1].Open && input.Close < window[1].Close &&                  //      closing above 1st                  input.Close > window[2].Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UpsideGapTwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpsideGapTwoCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: white                  GetCandleColor(window[2]) == CandleColor.White &&                  //      long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: black                  GetCandleColor(input) == CandleColor.Black &&                  // 3rd: engulfing prior rb                  input.Open > window[1].Open && input.Close < window[1].Close &&                  //      closing above 1st                  input.Close > window[2].Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UpsideGapTwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpsideGapTwoCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: white                  GetCandleColor(window[2]) == CandleColor.White &&                  //      long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: black                  GetCandleColor(input) == CandleColor.Black &&                  // 3rd: engulfing prior rb                  input.Open > window[1].Open && input.Close < window[1].Close &&                  //      closing above 1st                  input.Close > window[2].Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UpsideGapTwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpsideGapTwoCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: white                  GetCandleColor(window[2]) == CandleColor.White &&                  //      long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: black                  GetCandleColor(input) == CandleColor.Black &&                  // 3rd: engulfing prior rb                  input.Open > window[1].Open && input.Close < window[1].Close &&                  //      closing above 1st                  input.Close > window[2].Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UpsideGapTwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpsideGapTwoCrows.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[_bodyLongAveragePeriod + 2]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UpsideGapTwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UpsideGapTwoCrows.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[_bodyLongAveragePeriod + 2]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UniqueThreeRiver,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UniqueThreeRiver.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod - 2 && Samples < Period - 2)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    if (Samples >= Period - _bodyShortAveragePeriod)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UniqueThreeRiver,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UniqueThreeRiver.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod - 2 && Samples < Period - 2)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    if (Samples >= Period - _bodyShortAveragePeriod)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UniqueThreeRiver,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UniqueThreeRiver.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      harami                  window[1].Close > window[2].Close && window[1].Open <= window[2].Open &&                  //      lower low                  window[1].Low < window[2].Low &&                  // 3rd: short                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      white                  GetCandleColor(input) == CandleColor.White &&                  //      open not lower                  input.Open > window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UniqueThreeRiver,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UniqueThreeRiver.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      harami                  window[1].Close > window[2].Close && window[1].Open <= window[2].Open &&                  //      lower low                  window[1].Low < window[2].Low &&                  // 3rd: short                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      white                  GetCandleColor(input) == CandleColor.White &&                  //      open not lower                  input.Open > window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UniqueThreeRiver,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UniqueThreeRiver.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      harami                  window[1].Close > window[2].Close && window[1].Open <= window[2].Open &&                  //      lower low                  window[1].Low < window[2].Low &&                  // 3rd: short                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      white                  GetCandleColor(input) == CandleColor.White &&                  //      open not lower                  input.Open > window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UniqueThreeRiver,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UniqueThreeRiver.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      harami                  window[1].Close > window[2].Close && window[1].Open <= window[2].Open &&                  //      lower low                  window[1].Low < window[2].Low &&                  // 3rd: short                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      white                  GetCandleColor(input) == CandleColor.White &&                  //      open not lower                  input.Open > window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UniqueThreeRiver,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UniqueThreeRiver.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      harami                  window[1].Close > window[2].Close && window[1].Open <= window[2].Open &&                  //      lower low                  window[1].Low < window[2].Low &&                  // 3rd: short                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      white                  GetCandleColor(input) == CandleColor.White &&                  //      open not lower                  input.Open > window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UniqueThreeRiver,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UniqueThreeRiver.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      harami                  window[1].Close > window[2].Close && window[1].Open <= window[2].Open &&                  //      lower low                  window[1].Low < window[2].Low &&                  // 3rd: short                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      white                  GetCandleColor(input) == CandleColor.White &&                  //      open not lower                  input.Open > window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UniqueThreeRiver,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UniqueThreeRiver.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[_bodyLongAveragePeriod + 2]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,UniqueThreeRiver,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\UniqueThreeRiver.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[_bodyLongAveragePeriod + 2]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Tristar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Tristar.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyDojiAveragePeriod - 2 && Samples < Period - 2)                  {                      _bodyDojiPeriodTotal += GetCandleRange(CandleSettingType.BodyDoji' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Tristar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Tristar.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyDojiAveragePeriod - 2 && Samples < Period - 2)                  {                      _bodyDojiPeriodTotal += GetCandleRange(CandleSettingType.BodyDoji' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Tristar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Tristar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: doji                  GetRealBody(window[2]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[2]) &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[2]) &&                  // 3rd: doji                  GetRealBody(input) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[2]))              {                       value = 0;                  if (                      // 2nd gaps up                      GetRealBodyGapUp(window[1]' window[2]) &&                      // 3rd is not higher than 2nd                      Math.Max(input.Open' input.Close) < Math.Max(window[1].Open' window[1].Close)                     )                      value = -1m;                  if (                      // 2nd gaps down                      GetRealBodyGapDown(window[1]' window[2]) &&                      // 3rd is not lower than 2nd                       Math.Min(input.Open' input.Close) > Math.Min(window[1].Open' window[1].Close)                     )                      value = 1m;              }              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Tristar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Tristar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: doji                  GetRealBody(window[2]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[2]) &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[2]) &&                  // 3rd: doji                  GetRealBody(input) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[2]))              {                       value = 0;                  if (                      // 2nd gaps up                      GetRealBodyGapUp(window[1]' window[2]) &&                      // 3rd is not higher than 2nd                      Math.Max(input.Open' input.Close) < Math.Max(window[1].Open' window[1].Close)                     )                      value = -1m;                  if (                      // 2nd gaps down                      GetRealBodyGapDown(window[1]' window[2]) &&                      // 3rd is not lower than 2nd                       Math.Min(input.Open' input.Close) > Math.Min(window[1].Open' window[1].Close)                     )                      value = 1m;              }              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Tristar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Tristar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: doji                  GetRealBody(window[2]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[2]) &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[2]) &&                  // 3rd: doji                  GetRealBody(input) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[2]))              {                       value = 0;                  if (                      // 2nd gaps up                      GetRealBodyGapUp(window[1]' window[2]) &&                      // 3rd is not higher than 2nd                      Math.Max(input.Open' input.Close) < Math.Max(window[1].Open' window[1].Close)                     )                      value = -1m;                  if (                      // 2nd gaps down                      GetRealBodyGapDown(window[1]' window[2]) &&                      // 3rd is not lower than 2nd                       Math.Min(input.Open' input.Close) > Math.Min(window[1].Open' window[1].Close)                     )                      value = 1m;              }              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Tristar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Tristar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: doji                  GetRealBody(window[2]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[2]) &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[2]) &&                  // 3rd: doji                  GetRealBody(input) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[2]))              {                       value = 0;                  if (                      // 2nd gaps up                      GetRealBodyGapUp(window[1]' window[2]) &&                      // 3rd is not higher than 2nd                      Math.Max(input.Open' input.Close) < Math.Max(window[1].Open' window[1].Close)                     )                      value = -1m;                  if (                      // 2nd gaps down                      GetRealBodyGapDown(window[1]' window[2]) &&                      // 3rd is not lower than 2nd                       Math.Min(input.Open' input.Close) > Math.Min(window[1].Open' window[1].Close)                     )                      value = 1m;              }              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Tristar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Tristar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: doji                  GetRealBody(window[2]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[2]) &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[2]) &&                  // 3rd: doji                  GetRealBody(input) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[2]))              {                       value = 0;                  if (                      // 2nd gaps up                      GetRealBodyGapUp(window[1]' window[2]) &&                      // 3rd is not higher than 2nd                      Math.Max(input.Open' input.Close) < Math.Max(window[1].Open' window[1].Close)                     )                      value = -1m;                  if (                      // 2nd gaps down                      GetRealBodyGapDown(window[1]' window[2]) &&                      // 3rd is not lower than 2nd                       Math.Min(input.Open' input.Close) > Math.Min(window[1].Open' window[1].Close)                     )                      value = 1m;              }              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Tristar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Tristar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: doji                  GetRealBody(window[2]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[2]) &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[2]) &&                  // 3rd: doji                  GetRealBody(input) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[2]))              {                       value = 0;                  if (                      // 2nd gaps up                      GetRealBodyGapUp(window[1]' window[2]) &&                      // 3rd is not higher than 2nd                      Math.Max(input.Open' input.Close) < Math.Max(window[1].Open' window[1].Close)                     )                      value = -1m;                  if (                      // 2nd gaps down                      GetRealBodyGapDown(window[1]' window[2]) &&                      // 3rd is not lower than 2nd                       Math.Min(input.Open' input.Close) > Math.Min(window[1].Open' window[1].Close)                     )                      value = 1m;              }              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Tristar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Tristar.cs,ComputeNextValue,The following statement contains a magic number: _bodyDojiPeriodTotal += GetCandleRange(CandleSettingType.BodyDoji' window[2]) -                                      GetCandleRange(CandleSettingType.BodyDoji' window[_bodyDojiAveragePeriod + 2]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Tristar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Tristar.cs,ComputeNextValue,The following statement contains a magic number: _bodyDojiPeriodTotal += GetCandleRange(CandleSettingType.BodyDoji' window[2]) -                                      GetCandleRange(CandleSettingType.BodyDoji' window[_bodyDojiAveragePeriod + 2]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,TasukiGap,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TasukiGap.cs,ComputeNextValue,The following statement contains a magic number: if (                  (                      // upside gap                          GetRealBodyGapUp(window[1]' window[2]) &&                      // 1st: white                      GetCandleColor(window[1]) == CandleColor.White &&                      // 2nd: black                      GetCandleColor(input) == CandleColor.Black &&                      //      that opens within the white rb                      input.Open < window[1].Close && input.Open > window[1].Open &&                      //      and closes under the white rb                      input.Close < window[1].Open &&                      //      inside the gap                      input.Close > Math.Max(window[2].Close' window[2].Open) &&                      // size of 2 rb near the same                      Math.Abs(GetRealBody(window[1]) - GetRealBody(input)) < GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1])                  ) ||                  (                      // downside gap                      GetRealBodyGapDown(window[1]' window[2]) &&                      // 1st: black                      GetCandleColor(window[1]) == CandleColor.Black &&                      // 2nd: white                      GetCandleColor(input) == CandleColor.White &&                      //      that opens within the black rb                      input.Open < window[1].Open && input.Open > window[1].Close &&                      //      and closes above the black rb                      input.Close > window[1].Open &&                      //      inside the gap                      input.Close < Math.Min(window[2].Close' window[2].Open) &&                      // size of 2 rb near the same                      Math.Abs(GetRealBody(window[1]) - GetRealBody(input)) < GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1])                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,TasukiGap,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TasukiGap.cs,ComputeNextValue,The following statement contains a magic number: if (                  (                      // upside gap                          GetRealBodyGapUp(window[1]' window[2]) &&                      // 1st: white                      GetCandleColor(window[1]) == CandleColor.White &&                      // 2nd: black                      GetCandleColor(input) == CandleColor.Black &&                      //      that opens within the white rb                      input.Open < window[1].Close && input.Open > window[1].Open &&                      //      and closes under the white rb                      input.Close < window[1].Open &&                      //      inside the gap                      input.Close > Math.Max(window[2].Close' window[2].Open) &&                      // size of 2 rb near the same                      Math.Abs(GetRealBody(window[1]) - GetRealBody(input)) < GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1])                  ) ||                  (                      // downside gap                      GetRealBodyGapDown(window[1]' window[2]) &&                      // 1st: black                      GetCandleColor(window[1]) == CandleColor.Black &&                      // 2nd: white                      GetCandleColor(input) == CandleColor.White &&                      //      that opens within the black rb                      input.Open < window[1].Open && input.Open > window[1].Close &&                      //      and closes above the black rb                      input.Close > window[1].Open &&                      //      inside the gap                      input.Close < Math.Min(window[2].Close' window[2].Open) &&                      // size of 2 rb near the same                      Math.Abs(GetRealBody(window[1]) - GetRealBody(input)) < GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1])                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,TasukiGap,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TasukiGap.cs,ComputeNextValue,The following statement contains a magic number: if (                  (                      // upside gap                          GetRealBodyGapUp(window[1]' window[2]) &&                      // 1st: white                      GetCandleColor(window[1]) == CandleColor.White &&                      // 2nd: black                      GetCandleColor(input) == CandleColor.Black &&                      //      that opens within the white rb                      input.Open < window[1].Close && input.Open > window[1].Open &&                      //      and closes under the white rb                      input.Close < window[1].Open &&                      //      inside the gap                      input.Close > Math.Max(window[2].Close' window[2].Open) &&                      // size of 2 rb near the same                      Math.Abs(GetRealBody(window[1]) - GetRealBody(input)) < GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1])                  ) ||                  (                      // downside gap                      GetRealBodyGapDown(window[1]' window[2]) &&                      // 1st: black                      GetCandleColor(window[1]) == CandleColor.Black &&                      // 2nd: white                      GetCandleColor(input) == CandleColor.White &&                      //      that opens within the black rb                      input.Open < window[1].Open && input.Open > window[1].Close &&                      //      and closes above the black rb                      input.Close > window[1].Open &&                      //      inside the gap                      input.Close < Math.Min(window[2].Close' window[2].Open) &&                      // size of 2 rb near the same                      Math.Abs(GetRealBody(window[1]) - GetRealBody(input)) < GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1])                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,TasukiGap,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TasukiGap.cs,ComputeNextValue,The following statement contains a magic number: if (                  (                      // upside gap                          GetRealBodyGapUp(window[1]' window[2]) &&                      // 1st: white                      GetCandleColor(window[1]) == CandleColor.White &&                      // 2nd: black                      GetCandleColor(input) == CandleColor.Black &&                      //      that opens within the white rb                      input.Open < window[1].Close && input.Open > window[1].Open &&                      //      and closes under the white rb                      input.Close < window[1].Open &&                      //      inside the gap                      input.Close > Math.Max(window[2].Close' window[2].Open) &&                      // size of 2 rb near the same                      Math.Abs(GetRealBody(window[1]) - GetRealBody(input)) < GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1])                  ) ||                  (                      // downside gap                      GetRealBodyGapDown(window[1]' window[2]) &&                      // 1st: black                      GetCandleColor(window[1]) == CandleColor.Black &&                      // 2nd: white                      GetCandleColor(input) == CandleColor.White &&                      //      that opens within the black rb                      input.Open < window[1].Open && input.Open > window[1].Close &&                      //      and closes above the black rb                      input.Close > window[1].Open &&                      //      inside the gap                      input.Close < Math.Min(window[2].Close' window[2].Open) &&                      // size of 2 rb near the same                      Math.Abs(GetRealBody(window[1]) - GetRealBody(input)) < GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1])                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,TasukiGap,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TasukiGap.cs,ComputeNextValue,The following statement contains a magic number: if (                  (                      // upside gap                          GetRealBodyGapUp(window[1]' window[2]) &&                      // 1st: white                      GetCandleColor(window[1]) == CandleColor.White &&                      // 2nd: black                      GetCandleColor(input) == CandleColor.Black &&                      //      that opens within the white rb                      input.Open < window[1].Close && input.Open > window[1].Open &&                      //      and closes under the white rb                      input.Close < window[1].Open &&                      //      inside the gap                      input.Close > Math.Max(window[2].Close' window[2].Open) &&                      // size of 2 rb near the same                      Math.Abs(GetRealBody(window[1]) - GetRealBody(input)) < GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1])                  ) ||                  (                      // downside gap                      GetRealBodyGapDown(window[1]' window[2]) &&                      // 1st: black                      GetCandleColor(window[1]) == CandleColor.Black &&                      // 2nd: white                      GetCandleColor(input) == CandleColor.White &&                      //      that opens within the black rb                      input.Open < window[1].Open && input.Open > window[1].Close &&                      //      and closes above the black rb                      input.Close > window[1].Open &&                      //      inside the gap                      input.Close < Math.Min(window[2].Close' window[2].Open) &&                      // size of 2 rb near the same                      Math.Abs(GetRealBody(window[1]) - GetRealBody(input)) < GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1])                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,TasukiGap,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TasukiGap.cs,ComputeNextValue,The following statement contains a magic number: if (                  (                      // upside gap                          GetRealBodyGapUp(window[1]' window[2]) &&                      // 1st: white                      GetCandleColor(window[1]) == CandleColor.White &&                      // 2nd: black                      GetCandleColor(input) == CandleColor.Black &&                      //      that opens within the white rb                      input.Open < window[1].Close && input.Open > window[1].Open &&                      //      and closes under the white rb                      input.Close < window[1].Open &&                      //      inside the gap                      input.Close > Math.Max(window[2].Close' window[2].Open) &&                      // size of 2 rb near the same                      Math.Abs(GetRealBody(window[1]) - GetRealBody(input)) < GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1])                  ) ||                  (                      // downside gap                      GetRealBodyGapDown(window[1]' window[2]) &&                      // 1st: black                      GetCandleColor(window[1]) == CandleColor.Black &&                      // 2nd: white                      GetCandleColor(input) == CandleColor.White &&                      //      that opens within the black rb                      input.Open < window[1].Open && input.Open > window[1].Close &&                      //      and closes above the black rb                      input.Close > window[1].Open &&                      //      inside the gap                      input.Close < Math.Min(window[2].Close' window[2].Open) &&                      // size of 2 rb near the same                      Math.Abs(GetRealBody(window[1]) - GetRealBody(input)) < GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1])                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StickSandwich,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StickSandwich.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _equalAveragePeriod)                  {                      _equalPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StickSandwich,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StickSandwich.cs,ComputeNextValue,The following statement contains a magic number: if (                  // first black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // second white                  GetCandleColor(window[1]) == CandleColor.White &&                  // third black                  GetCandleColor(input) == CandleColor.Black &&                  // 2nd low > prior close                  window[1].Low > window[2].Close &&                  // 1st and 3rd same close                  input.Close <= window[2].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[2]) &&                  input.Close >= window[2].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[2])                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StickSandwich,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StickSandwich.cs,ComputeNextValue,The following statement contains a magic number: if (                  // first black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // second white                  GetCandleColor(window[1]) == CandleColor.White &&                  // third black                  GetCandleColor(input) == CandleColor.Black &&                  // 2nd low > prior close                  window[1].Low > window[2].Close &&                  // 1st and 3rd same close                  input.Close <= window[2].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[2]) &&                  input.Close >= window[2].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[2])                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StickSandwich,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StickSandwich.cs,ComputeNextValue,The following statement contains a magic number: if (                  // first black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // second white                  GetCandleColor(window[1]) == CandleColor.White &&                  // third black                  GetCandleColor(input) == CandleColor.Black &&                  // 2nd low > prior close                  window[1].Low > window[2].Close &&                  // 1st and 3rd same close                  input.Close <= window[2].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[2]) &&                  input.Close >= window[2].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[2])                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StickSandwich,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StickSandwich.cs,ComputeNextValue,The following statement contains a magic number: if (                  // first black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // second white                  GetCandleColor(window[1]) == CandleColor.White &&                  // third black                  GetCandleColor(input) == CandleColor.Black &&                  // 2nd low > prior close                  window[1].Low > window[2].Close &&                  // 1st and 3rd same close                  input.Close <= window[2].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[2]) &&                  input.Close >= window[2].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[2])                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StickSandwich,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StickSandwich.cs,ComputeNextValue,The following statement contains a magic number: if (                  // first black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // second white                  GetCandleColor(window[1]) == CandleColor.White &&                  // third black                  GetCandleColor(input) == CandleColor.Black &&                  // 2nd low > prior close                  window[1].Low > window[2].Close &&                  // 1st and 3rd same close                  input.Close <= window[2].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[2]) &&                  input.Close >= window[2].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[2])                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StickSandwich,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StickSandwich.cs,ComputeNextValue,The following statement contains a magic number: if (                  // first black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // second white                  GetCandleColor(window[1]) == CandleColor.White &&                  // third black                  GetCandleColor(input) == CandleColor.Black &&                  // 2nd low > prior close                  window[1].Low > window[2].Close &&                  // 1st and 3rd same close                  input.Close <= window[2].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[2]) &&                  input.Close >= window[2].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[2])                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StickSandwich,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StickSandwich.cs,ComputeNextValue,The following statement contains a magic number: _equalPeriodTotal += GetCandleRange(CandleSettingType.Equal' window[2]) -                                   GetCandleRange(CandleSettingType.Equal' window[_equalAveragePeriod + 2]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StickSandwich,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StickSandwich.cs,ComputeNextValue,The following statement contains a magic number: _equalPeriodTotal += GetCandleRange(CandleSettingType.Equal' window[2]) -                                   GetCandleRange(CandleSettingType.Equal' window[_equalAveragePeriod + 2]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod)                  {                      _bodyLongPeriodTotal[2] += GetCandleRange(CandleSettingType.BodyLong' window[2]);                      _bodyLongPeriodTotal[1] += GetCandleRange(CandleSettingType.BodyLong' window[1]);                  }                    if (Samples >= Period - _bodyShortAveragePeriod)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                  }                    if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _nearPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod)                  {                      _bodyLongPeriodTotal[2] += GetCandleRange(CandleSettingType.BodyLong' window[2]);                      _bodyLongPeriodTotal[1] += GetCandleRange(CandleSettingType.BodyLong' window[1]);                  }                    if (Samples >= Period - _bodyShortAveragePeriod)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                  }                    if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _nearPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod)                  {                      _bodyLongPeriodTotal[2] += GetCandleRange(CandleSettingType.BodyLong' window[2]);                      _bodyLongPeriodTotal[1] += GetCandleRange(CandleSettingType.BodyLong' window[1]);                  }                    if (Samples >= Period - _bodyShortAveragePeriod)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                  }                    if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _nearPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod)                  {                      _bodyLongPeriodTotal[2] += GetCandleRange(CandleSettingType.BodyLong' window[2]);                      _bodyLongPeriodTotal[1] += GetCandleRange(CandleSettingType.BodyLong' window[1]);                  }                    if (Samples >= Period - _bodyShortAveragePeriod)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                  }                    if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _nearPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[2]' window[2]) &&                  // 2nd: long real body                  GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[1]' window[1]) &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd: small real body                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  // rides on the shoulder of 2nd real body                  input.Open >= window[1].Close - GetRealBody(input) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[2]' window[2]) &&                  // 2nd: long real body                  GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[1]' window[1]) &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd: small real body                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  // rides on the shoulder of 2nd real body                  input.Open >= window[1].Close - GetRealBody(input) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[2]' window[2]) &&                  // 2nd: long real body                  GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[1]' window[1]) &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd: small real body                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  // rides on the shoulder of 2nd real body                  input.Open >= window[1].Close - GetRealBody(input) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[2]' window[2]) &&                  // 2nd: long real body                  GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[1]' window[1]) &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd: small real body                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  // rides on the shoulder of 2nd real body                  input.Open >= window[1].Close - GetRealBody(input) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[2]' window[2]) &&                  // 2nd: long real body                  GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[1]' window[1]) &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd: small real body                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  // rides on the shoulder of 2nd real body                  input.Open >= window[1].Close - GetRealBody(input) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[2]' window[2]) &&                  // 2nd: long real body                  GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[1]' window[1]) &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd: small real body                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  // rides on the shoulder of 2nd real body                  input.Open >= window[1].Close - GetRealBody(input) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[2]' window[2]) &&                  // 2nd: long real body                  GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[1]' window[1]) &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd: small real body                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  // rides on the shoulder of 2nd real body                  input.Open >= window[1].Close - GetRealBody(input) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[2]' window[2]) &&                  // 2nd: long real body                  GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[1]' window[1]) &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd: small real body                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  // rides on the shoulder of 2nd real body                  input.Open >= window[1].Close - GetRealBody(input) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[2]' window[2]) &&                  // 2nd: long real body                  GetRealBody(window[1]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal[1]' window[1]) &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd: small real body                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  // rides on the shoulder of 2nd real body                  input.Open >= window[1].Close - GetRealBody(input) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,ComputeNextValue,The following statement contains a magic number: for (var i = 2; i >= 1; i--)              {                  _bodyLongPeriodTotal[i] += GetCandleRange(CandleSettingType.BodyLong' window[i]) -                                             GetCandleRange(CandleSettingType.BodyLong' window[i + _bodyLongAveragePeriod]);                  _nearPeriodTotal[i] += GetCandleRange(CandleSettingType.Near' window[i]) -                                         GetCandleRange(CandleSettingType.Near' window[i + _nearAveragePeriod]);              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,Reset,The following statement contains a magic number: _bodyLongPeriodTotal = new decimal[3];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,StalledPattern,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\StalledPattern.cs,Reset,The following statement contains a magic number: _nearPeriodTotal = new decimal[3];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples > Period - _bodyShortAveragePeriod)                  {                      _bodyPeriodTotal[3] += GetCandleRange(CandleSettingType.BodyShort' window[3]);                      _bodyPeriodTotal[2] += GetCandleRange(CandleSettingType.BodyShort' window[2]);                      _bodyPeriodTotal[1] += GetCandleRange(CandleSettingType.BodyShort' window[1]);                  }                    if (Samples > Period - _bodyLongAveragePeriod)                  {                      _bodyPeriodTotal[4] += GetCandleRange(CandleSettingType.BodyLong' window[4]);                      _bodyPeriodTotal[0] += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples > Period - _bodyShortAveragePeriod)                  {                      _bodyPeriodTotal[3] += GetCandleRange(CandleSettingType.BodyShort' window[3]);                      _bodyPeriodTotal[2] += GetCandleRange(CandleSettingType.BodyShort' window[2]);                      _bodyPeriodTotal[1] += GetCandleRange(CandleSettingType.BodyShort' window[1]);                  }                    if (Samples > Period - _bodyLongAveragePeriod)                  {                      _bodyPeriodTotal[4] += GetCandleRange(CandleSettingType.BodyLong' window[4]);                      _bodyPeriodTotal[0] += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples > Period - _bodyShortAveragePeriod)                  {                      _bodyPeriodTotal[3] += GetCandleRange(CandleSettingType.BodyShort' window[3]);                      _bodyPeriodTotal[2] += GetCandleRange(CandleSettingType.BodyShort' window[2]);                      _bodyPeriodTotal[1] += GetCandleRange(CandleSettingType.BodyShort' window[1]);                  }                    if (Samples > Period - _bodyLongAveragePeriod)                  {                      _bodyPeriodTotal[4] += GetCandleRange(CandleSettingType.BodyLong' window[4]);                      _bodyPeriodTotal[0] += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples > Period - _bodyShortAveragePeriod)                  {                      _bodyPeriodTotal[3] += GetCandleRange(CandleSettingType.BodyShort' window[3]);                      _bodyPeriodTotal[2] += GetCandleRange(CandleSettingType.BodyShort' window[2]);                      _bodyPeriodTotal[1] += GetCandleRange(CandleSettingType.BodyShort' window[1]);                  }                    if (Samples > Period - _bodyLongAveragePeriod)                  {                      _bodyPeriodTotal[4] += GetCandleRange(CandleSettingType.BodyLong' window[4]);                      _bodyPeriodTotal[0] += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples > Period - _bodyShortAveragePeriod)                  {                      _bodyPeriodTotal[3] += GetCandleRange(CandleSettingType.BodyShort' window[3]);                      _bodyPeriodTotal[2] += GetCandleRange(CandleSettingType.BodyShort' window[2]);                      _bodyPeriodTotal[1] += GetCandleRange(CandleSettingType.BodyShort' window[1]);                  }                    if (Samples > Period - _bodyLongAveragePeriod)                  {                      _bodyPeriodTotal[4] += GetCandleRange(CandleSettingType.BodyLong' window[4]);                      _bodyPeriodTotal[0] += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples > Period - _bodyShortAveragePeriod)                  {                      _bodyPeriodTotal[3] += GetCandleRange(CandleSettingType.BodyShort' window[3]);                      _bodyPeriodTotal[2] += GetCandleRange(CandleSettingType.BodyShort' window[2]);                      _bodyPeriodTotal[1] += GetCandleRange(CandleSettingType.BodyShort' window[1]);                  }                    if (Samples > Period - _bodyLongAveragePeriod)                  {                      _bodyPeriodTotal[4] += GetCandleRange(CandleSettingType.BodyLong' window[4]);                      _bodyPeriodTotal[0] += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small' 5th long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[0]' input) &&                  // white' 3 black' white  ||  black' 3 white' black                  (int)GetCandleColor(window[4]) == -(int)GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  // 2nd to 4th hold within 1st: a part of the real body must be within 1st range                  Math.Min(window[3].Open' window[3].Close) < window[4].High && Math.Max(window[3].Open' window[3].Close) > window[4].Low &&                  Math.Min(window[2].Open' window[2].Close) < window[4].High && Math.Max(window[2].Open' window[2].Close) > window[4].Low &&                  Math.Min(window[1].Open' window[1].Close) < window[4].High && Math.Max(window[1].Open' window[1].Close) > window[4].Low &&                  // 2nd to 4th are falling (rising)                  window[2].Close * (int)GetCandleColor(window[4]) < window[3].Close * (int)GetCandleColor(window[4]) &&                  window[1].Close * (int)GetCandleColor(window[4]) < window[2].Close * (int)GetCandleColor(window[4]) &&                  // 5th opens above (below) the prior close                  input.Open * (int)GetCandleColor(window[4]) > window[1].Close * (int)GetCandleColor(window[4]) &&                  // 5th closes above (below) the 1st close                  input.Close * (int)GetCandleColor(window[4]) > window[4].Close * (int)GetCandleColor(window[4])                )                  value = (int)GetCandleColor(window[4]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: _bodyPeriodTotal[4] += GetCandleRange(CandleSettingType.BodyLong' window[4]) -                                     GetCandleRange(CandleSettingType.BodyLong' window[_bodyLongAveragePeriod + 4]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: _bodyPeriodTotal[4] += GetCandleRange(CandleSettingType.BodyLong' window[4]) -                                     GetCandleRange(CandleSettingType.BodyLong' window[_bodyLongAveragePeriod + 4]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: _bodyPeriodTotal[4] += GetCandleRange(CandleSettingType.BodyLong' window[4]) -                                     GetCandleRange(CandleSettingType.BodyLong' window[_bodyLongAveragePeriod + 4]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,ComputeNextValue,The following statement contains a magic number: for (var i = 3; i >= 1; i--)              {                  _bodyPeriodTotal[i] += GetCandleRange(CandleSettingType.BodyShort' window[i]) -                                         GetCandleRange(CandleSettingType.BodyShort' window[i + _bodyShortAveragePeriod]);              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RiseFallThreeMethods,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RiseFallThreeMethods.cs,Reset,The following statement contains a magic number: _bodyPeriodTotal = new decimal[5];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RickshawMan,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RickshawMan.cs,ComputeNextValue,The following statement contains a magic number: if (                  // doji                  GetRealBody(input) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' input) &&                  // long shadow                  GetLowerShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' input) &&                  // long shadow                  GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' input) &&                  // body near midpoint                  (                      Math.Min(input.Open' input.Close)                          <= input.Low + GetHighLowRange(input) / 2 + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' input)                      &&                      Math.Max(input.Open' input.Close)                          >= input.Low + GetHighLowRange(input) / 2 - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' input)                  )                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,RickshawMan,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\RickshawMan.cs,ComputeNextValue,The following statement contains a magic number: if (                  // doji                  GetRealBody(input) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' input) &&                  // long shadow                  GetLowerShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' input) &&                  // long shadow                  GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' input) &&                  // body near midpoint                  (                      Math.Min(input.Open' input.Close)                          <= input.Low + GetHighLowRange(input) / 2 + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' input)                      &&                      Math.Max(input.Open' input.Close)                          >= input.Low + GetHighLowRange(input) / 2 - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' input)                  )                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Piercing,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Piercing.cs,Reset,The following statement contains a magic number: _bodyLongPeriodTotal = new decimal[2];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningStar.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod - 2 && Samples < Period - 2)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    if (Samples >= Period - _bodyShortAveragePeriod - 1 && Samples < Period - 1)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                      _bodyShortPeriodTotal2 += GetCandleRange(CandleSettingType.BodyShort' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningStar.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod - 2 && Samples < Period - 2)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    if (Samples >= Period - _bodyShortAveragePeriod - 1 && Samples < Period - 1)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                      _bodyShortPeriodTotal2 += GetCandleRange(CandleSettingType.BodyShort' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal2' input) &&                  //      white real body                  GetCandleColor(input) == CandleColor.White &&                  //      closing well within 1st rb                  input.Close > window[2].Close + GetRealBody(window[2]) * _penetration                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal2' input) &&                  //      white real body                  GetCandleColor(input) == CandleColor.White &&                  //      closing well within 1st rb                  input.Close > window[2].Close + GetRealBody(window[2]) * _penetration                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal2' input) &&                  //      white real body                  GetCandleColor(input) == CandleColor.White &&                  //      closing well within 1st rb                  input.Close > window[2].Close + GetRealBody(window[2]) * _penetration                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal2' input) &&                  //      white real body                  GetCandleColor(input) == CandleColor.White &&                  //      closing well within 1st rb                  input.Close > window[2].Close + GetRealBody(window[2]) * _penetration                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal2' input) &&                  //      white real body                  GetCandleColor(input) == CandleColor.White &&                  //      closing well within 1st rb                  input.Close > window[2].Close + GetRealBody(window[2]) * _penetration                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal2' input) &&                  //      white real body                  GetCandleColor(input) == CandleColor.White &&                  //      closing well within 1st rb                  input.Close > window[2].Close + GetRealBody(window[2]) * _penetration                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningStar.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[_bodyLongAveragePeriod + 2]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningStar.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[_bodyLongAveragePeriod + 2]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod - 2 && Samples < Period - 2)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    if (Samples >= Period - _bodyDojiAveragePeriod - 1 && Samples < Period - 1)                  {                      _bodyDojiPeriodTotal += GetCandleRange(CandleSettingType.BodyDoji' input);                  }                    if (Samples >= Period - _bodyShortAveragePeriod)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod - 2 && Samples < Period - 2)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    if (Samples >= Period - _bodyDojiAveragePeriod - 1 && Samples < Period - 1)                  {                      _bodyDojiPeriodTotal += GetCandleRange(CandleSettingType.BodyDoji' input);                  }                    if (Samples >= Period - _bodyShortAveragePeriod)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  //      gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      white real body                  GetCandleColor(input) == CandleColor.White &&                  //      closing well within 1st rb                  input.Close > window[2].Close + GetRealBody(window[2]) * _penetration                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  //      gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      white real body                  GetCandleColor(input) == CandleColor.White &&                  //      closing well within 1st rb                  input.Close > window[2].Close + GetRealBody(window[2]) * _penetration                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  //      gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      white real body                  GetCandleColor(input) == CandleColor.White &&                  //      closing well within 1st rb                  input.Close > window[2].Close + GetRealBody(window[2]) * _penetration                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  //      gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      white real body                  GetCandleColor(input) == CandleColor.White &&                  //      closing well within 1st rb                  input.Close > window[2].Close + GetRealBody(window[2]) * _penetration                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  //      gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      white real body                  GetCandleColor(input) == CandleColor.White &&                  //      closing well within 1st rb                  input.Close > window[2].Close + GetRealBody(window[2]) * _penetration                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  //      gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      white real body                  GetCandleColor(input) == CandleColor.White &&                  //      closing well within 1st rb                  input.Close > window[2].Close + GetRealBody(window[2]) * _penetration                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[_bodyLongAveragePeriod + 2]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MorningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MorningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[_bodyLongAveragePeriod + 2]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples > Period - _bodyShortAveragePeriod)                  {                      _bodyPeriodTotal[3] += GetCandleRange(CandleSettingType.BodyShort' window[3]);                      _bodyPeriodTotal[2] += GetCandleRange(CandleSettingType.BodyShort' window[2]);                      _bodyPeriodTotal[1] += GetCandleRange(CandleSettingType.BodyShort' window[1]);                  }                    if (Samples > Period - _bodyLongAveragePeriod)                  {                      _bodyPeriodTotal[4] += GetCandleRange(CandleSettingType.BodyLong' window[4]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples > Period - _bodyShortAveragePeriod)                  {                      _bodyPeriodTotal[3] += GetCandleRange(CandleSettingType.BodyShort' window[3]);                      _bodyPeriodTotal[2] += GetCandleRange(CandleSettingType.BodyShort' window[2]);                      _bodyPeriodTotal[1] += GetCandleRange(CandleSettingType.BodyShort' window[1]);                  }                    if (Samples > Period - _bodyLongAveragePeriod)                  {                      _bodyPeriodTotal[4] += GetCandleRange(CandleSettingType.BodyLong' window[4]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples > Period - _bodyShortAveragePeriod)                  {                      _bodyPeriodTotal[3] += GetCandleRange(CandleSettingType.BodyShort' window[3]);                      _bodyPeriodTotal[2] += GetCandleRange(CandleSettingType.BodyShort' window[2]);                      _bodyPeriodTotal[1] += GetCandleRange(CandleSettingType.BodyShort' window[1]);                  }                    if (Samples > Period - _bodyLongAveragePeriod)                  {                      _bodyPeriodTotal[4] += GetCandleRange(CandleSettingType.BodyLong' window[4]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples > Period - _bodyShortAveragePeriod)                  {                      _bodyPeriodTotal[3] += GetCandleRange(CandleSettingType.BodyShort' window[3]);                      _bodyPeriodTotal[2] += GetCandleRange(CandleSettingType.BodyShort' window[2]);                      _bodyPeriodTotal[1] += GetCandleRange(CandleSettingType.BodyShort' window[1]);                  }                    if (Samples > Period - _bodyLongAveragePeriod)                  {                      _bodyPeriodTotal[4] += GetCandleRange(CandleSettingType.BodyLong' window[4]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples > Period - _bodyShortAveragePeriod)                  {                      _bodyPeriodTotal[3] += GetCandleRange(CandleSettingType.BodyShort' window[3]);                      _bodyPeriodTotal[2] += GetCandleRange(CandleSettingType.BodyShort' window[2]);                      _bodyPeriodTotal[1] += GetCandleRange(CandleSettingType.BodyShort' window[1]);                  }                    if (Samples > Period - _bodyLongAveragePeriod)                  {                      _bodyPeriodTotal[4] += GetCandleRange(CandleSettingType.BodyLong' window[4]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples > Period - _bodyShortAveragePeriod)                  {                      _bodyPeriodTotal[3] += GetCandleRange(CandleSettingType.BodyShort' window[3]);                      _bodyPeriodTotal[2] += GetCandleRange(CandleSettingType.BodyShort' window[2]);                      _bodyPeriodTotal[1] += GetCandleRange(CandleSettingType.BodyShort' window[1]);                  }                    if (Samples > Period - _bodyLongAveragePeriod)                  {                      _bodyPeriodTotal[4] += GetCandleRange(CandleSettingType.BodyLong' window[4]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: if (                   // 1st long' then 3 small                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyPeriodTotal[4]' window[4]) &&                  GetRealBody(window[3]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[3]' window[3]) &&                  GetRealBody(window[2]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[2]' window[2]) &&                  GetRealBody(window[1]) < GetCandleAverage(CandleSettingType.BodyShort' _bodyPeriodTotal[1]' window[1]) &&                  // white' black' 2 black or white' white                  GetCandleColor(window[4]) == CandleColor.White &&                  GetCandleColor(window[3]) == CandleColor.Black &&                  GetCandleColor(input) == CandleColor.White &&                  // upside gap 1st to 2nd                  GetRealBodyGapUp(window[3]' window[4]) &&                  // 3rd to 4th hold within 1st: a part of the real body must be within 1st real body                  Math.Min(window[2].Open' window[2].Close) < window[4].Close &&                  Math.Min(window[1].Open' window[1].Close) < window[4].Close &&                  // reaction days penetrate first body less than optInPenetration percent                  Math.Min(window[2].Open' window[2].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  Math.Min(window[1].Open' window[1].Close) > window[4].Close - GetRealBody(window[4]) * _penetration &&                  // 2nd to 4th are falling                  Math.Max(window[2].Close' window[2].Open) < window[3].Open &&                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  // 5th opens above the prior close                  input.Open > window[1].Close &&                  // 5th closes above the highest high of the reaction days                  input.Close > Math.Max(Math.Max(window[3].High' window[2].High)' window[1].High)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: _bodyPeriodTotal[4] += GetCandleRange(CandleSettingType.BodyLong' window[4]) -                                     GetCandleRange(CandleSettingType.BodyLong' window[_bodyLongAveragePeriod + 4]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: _bodyPeriodTotal[4] += GetCandleRange(CandleSettingType.BodyLong' window[4]) -                                     GetCandleRange(CandleSettingType.BodyLong' window[_bodyLongAveragePeriod + 4]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: _bodyPeriodTotal[4] += GetCandleRange(CandleSettingType.BodyLong' window[4]) -                                     GetCandleRange(CandleSettingType.BodyLong' window[_bodyLongAveragePeriod + 4]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,ComputeNextValue,The following statement contains a magic number: for (var i = 3; i >= 1; i--)              {                  _bodyPeriodTotal[i] += GetCandleRange(CandleSettingType.BodyShort' window[i]) -                                         GetCandleRange(CandleSettingType.BodyShort' window[i + _bodyShortAveragePeriod]);              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,MatHold,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\MatHold.cs,Reset,The following statement contains a magic number: _bodyPeriodTotal = new decimal[5];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,LadderBottom,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\LadderBottom.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 3 black candlesticks                  GetCandleColor(window[4]) == CandleColor.Black &&                   GetCandleColor(window[3]) == CandleColor.Black &&                   GetCandleColor(window[2]) == CandleColor.Black &&                  // with consecutively lower opens                  window[4].Open > window[3].Open && window[3].Open > window[2].Open &&                  // and closes                  window[4].Close > window[3].Close && window[3].Close > window[2].Close &&                  // 4th: black with an upper shadow                  GetCandleColor(window[1]) == CandleColor.Black &&                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // 5th: white                  GetCandleColor(input) == CandleColor.White &&                  // that opens above prior candle's body                  input.Open > window[1].Open &&                  // and closes above prior candle's high                  input.Close > window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,LadderBottom,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\LadderBottom.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 3 black candlesticks                  GetCandleColor(window[4]) == CandleColor.Black &&                   GetCandleColor(window[3]) == CandleColor.Black &&                   GetCandleColor(window[2]) == CandleColor.Black &&                  // with consecutively lower opens                  window[4].Open > window[3].Open && window[3].Open > window[2].Open &&                  // and closes                  window[4].Close > window[3].Close && window[3].Close > window[2].Close &&                  // 4th: black with an upper shadow                  GetCandleColor(window[1]) == CandleColor.Black &&                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // 5th: white                  GetCandleColor(input) == CandleColor.White &&                  // that opens above prior candle's body                  input.Open > window[1].Open &&                  // and closes above prior candle's high                  input.Close > window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,LadderBottom,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\LadderBottom.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 3 black candlesticks                  GetCandleColor(window[4]) == CandleColor.Black &&                   GetCandleColor(window[3]) == CandleColor.Black &&                   GetCandleColor(window[2]) == CandleColor.Black &&                  // with consecutively lower opens                  window[4].Open > window[3].Open && window[3].Open > window[2].Open &&                  // and closes                  window[4].Close > window[3].Close && window[3].Close > window[2].Close &&                  // 4th: black with an upper shadow                  GetCandleColor(window[1]) == CandleColor.Black &&                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // 5th: white                  GetCandleColor(input) == CandleColor.White &&                  // that opens above prior candle's body                  input.Open > window[1].Open &&                  // and closes above prior candle's high                  input.Close > window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,LadderBottom,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\LadderBottom.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 3 black candlesticks                  GetCandleColor(window[4]) == CandleColor.Black &&                   GetCandleColor(window[3]) == CandleColor.Black &&                   GetCandleColor(window[2]) == CandleColor.Black &&                  // with consecutively lower opens                  window[4].Open > window[3].Open && window[3].Open > window[2].Open &&                  // and closes                  window[4].Close > window[3].Close && window[3].Close > window[2].Close &&                  // 4th: black with an upper shadow                  GetCandleColor(window[1]) == CandleColor.Black &&                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // 5th: white                  GetCandleColor(input) == CandleColor.White &&                  // that opens above prior candle's body                  input.Open > window[1].Open &&                  // and closes above prior candle's high                  input.Close > window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,LadderBottom,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\LadderBottom.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 3 black candlesticks                  GetCandleColor(window[4]) == CandleColor.Black &&                   GetCandleColor(window[3]) == CandleColor.Black &&                   GetCandleColor(window[2]) == CandleColor.Black &&                  // with consecutively lower opens                  window[4].Open > window[3].Open && window[3].Open > window[2].Open &&                  // and closes                  window[4].Close > window[3].Close && window[3].Close > window[2].Close &&                  // 4th: black with an upper shadow                  GetCandleColor(window[1]) == CandleColor.Black &&                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // 5th: white                  GetCandleColor(input) == CandleColor.White &&                  // that opens above prior candle's body                  input.Open > window[1].Open &&                  // and closes above prior candle's high                  input.Close > window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,LadderBottom,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\LadderBottom.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 3 black candlesticks                  GetCandleColor(window[4]) == CandleColor.Black &&                   GetCandleColor(window[3]) == CandleColor.Black &&                   GetCandleColor(window[2]) == CandleColor.Black &&                  // with consecutively lower opens                  window[4].Open > window[3].Open && window[3].Open > window[2].Open &&                  // and closes                  window[4].Close > window[3].Close && window[3].Close > window[2].Close &&                  // 4th: black with an upper shadow                  GetCandleColor(window[1]) == CandleColor.Black &&                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // 5th: white                  GetCandleColor(input) == CandleColor.White &&                  // that opens above prior candle's body                  input.Open > window[1].Open &&                  // and closes above prior candle's high                  input.Close > window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,LadderBottom,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\LadderBottom.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 3 black candlesticks                  GetCandleColor(window[4]) == CandleColor.Black &&                   GetCandleColor(window[3]) == CandleColor.Black &&                   GetCandleColor(window[2]) == CandleColor.Black &&                  // with consecutively lower opens                  window[4].Open > window[3].Open && window[3].Open > window[2].Open &&                  // and closes                  window[4].Close > window[3].Close && window[3].Close > window[2].Close &&                  // 4th: black with an upper shadow                  GetCandleColor(window[1]) == CandleColor.Black &&                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // 5th: white                  GetCandleColor(input) == CandleColor.White &&                  // that opens above prior candle's body                  input.Open > window[1].Open &&                  // and closes above prior candle's high                  input.Close > window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,LadderBottom,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\LadderBottom.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 3 black candlesticks                  GetCandleColor(window[4]) == CandleColor.Black &&                   GetCandleColor(window[3]) == CandleColor.Black &&                   GetCandleColor(window[2]) == CandleColor.Black &&                  // with consecutively lower opens                  window[4].Open > window[3].Open && window[3].Open > window[2].Open &&                  // and closes                  window[4].Close > window[3].Close && window[3].Close > window[2].Close &&                  // 4th: black with an upper shadow                  GetCandleColor(window[1]) == CandleColor.Black &&                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // 5th: white                  GetCandleColor(input) == CandleColor.White &&                  // that opens above prior candle's body                  input.Open > window[1].Open &&                  // and closes above prior candle's high                  input.Close > window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,LadderBottom,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\LadderBottom.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 3 black candlesticks                  GetCandleColor(window[4]) == CandleColor.Black &&                   GetCandleColor(window[3]) == CandleColor.Black &&                   GetCandleColor(window[2]) == CandleColor.Black &&                  // with consecutively lower opens                  window[4].Open > window[3].Open && window[3].Open > window[2].Open &&                  // and closes                  window[4].Close > window[3].Close && window[3].Close > window[2].Close &&                  // 4th: black with an upper shadow                  GetCandleColor(window[1]) == CandleColor.Black &&                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // 5th: white                  GetCandleColor(input) == CandleColor.White &&                  // that opens above prior candle's body                  input.Open > window[1].Open &&                  // and closes above prior candle's high                  input.Close > window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,LadderBottom,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\LadderBottom.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 3 black candlesticks                  GetCandleColor(window[4]) == CandleColor.Black &&                   GetCandleColor(window[3]) == CandleColor.Black &&                   GetCandleColor(window[2]) == CandleColor.Black &&                  // with consecutively lower opens                  window[4].Open > window[3].Open && window[3].Open > window[2].Open &&                  // and closes                  window[4].Close > window[3].Close && window[3].Close > window[2].Close &&                  // 4th: black with an upper shadow                  GetCandleColor(window[1]) == CandleColor.Black &&                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // 5th: white                  GetCandleColor(input) == CandleColor.White &&                  // that opens above prior candle's body                  input.Open > window[1].Open &&                  // and closes above prior candle's high                  input.Close > window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,LadderBottom,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\LadderBottom.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 3 black candlesticks                  GetCandleColor(window[4]) == CandleColor.Black &&                   GetCandleColor(window[3]) == CandleColor.Black &&                   GetCandleColor(window[2]) == CandleColor.Black &&                  // with consecutively lower opens                  window[4].Open > window[3].Open && window[3].Open > window[2].Open &&                  // and closes                  window[4].Close > window[3].Close && window[3].Close > window[2].Close &&                  // 4th: black with an upper shadow                  GetCandleColor(window[1]) == CandleColor.Black &&                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal' window[1]) &&                  // 5th: white                  GetCandleColor(input) == CandleColor.White &&                  // that opens above prior candle's body                  input.Open > window[1].Open &&                  // and closes above prior candle's high                  input.Close > window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,KickingByLength,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\KickingByLength.cs,Reset,The following statement contains a magic number: _shadowVeryShortPeriodTotal = new decimal[2];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,KickingByLength,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\KickingByLength.cs,Reset,The following statement contains a magic number: _bodyLongPeriodTotal = new decimal[2];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Kicking,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Kicking.cs,Reset,The following statement contains a magic number: _shadowVeryShortPeriodTotal = new decimal[2];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Kicking,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Kicking.cs,Reset,The following statement contains a magic number: _bodyLongPeriodTotal = new decimal[2];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningStar.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod - 2 && Samples < Period - 2)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    if (Samples >= Period - _bodyShortAveragePeriod && Samples < Period)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' window[1]);                      _bodyShortPeriodTotal2 += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningStar.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod - 2 && Samples < Period - 2)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    if (Samples >= Period - _bodyShortAveragePeriod && Samples < Period)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' window[1]);                      _bodyShortPeriodTotal2 += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal2' input) &&                  //      black real body                  GetCandleColor(input) == CandleColor.Black &&                  //      closing well within 1st rb                  input.Close < window[2].Close - GetRealBody(window[2]) * _penetration                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal2' input) &&                  //      black real body                  GetCandleColor(input) == CandleColor.Black &&                  //      closing well within 1st rb                  input.Close < window[2].Close - GetRealBody(window[2]) * _penetration                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal2' input) &&                  //      black real body                  GetCandleColor(input) == CandleColor.Black &&                  //      closing well within 1st rb                  input.Close < window[2].Close - GetRealBody(window[2]) * _penetration                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal2' input) &&                  //      black real body                  GetCandleColor(input) == CandleColor.Black &&                  //      closing well within 1st rb                  input.Close < window[2].Close - GetRealBody(window[2]) * _penetration                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal2' input) &&                  //      black real body                  GetCandleColor(input) == CandleColor.Black &&                  //      closing well within 1st rb                  input.Close < window[2].Close - GetRealBody(window[2]) * _penetration                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal2' input) &&                  //      black real body                  GetCandleColor(input) == CandleColor.Black &&                  //      closing well within 1st rb                  input.Close < window[2].Close - GetRealBody(window[2]) * _penetration                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningStar.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[_bodyLongAveragePeriod + 2]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningStar.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[_bodyLongAveragePeriod + 2]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod - 2 && Samples < Period - 2)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    if (Samples >= Period - _bodyDojiAveragePeriod - 1 && Samples < Period - 1)                  {                      _bodyDojiPeriodTotal += GetCandleRange(CandleSettingType.BodyDoji' input);                  }                    if (Samples >= Period - _bodyShortAveragePeriod)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod - 2 && Samples < Period - 2)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    if (Samples >= Period - _bodyDojiAveragePeriod - 1 && Samples < Period - 1)                  {                      _bodyDojiPeriodTotal += GetCandleRange(CandleSettingType.BodyDoji' input);                  }                    if (Samples >= Period - _bodyShortAveragePeriod)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      black real body                  GetCandleColor(input) == CandleColor.Black &&                  //      closing well within 1st rb                  input.Close < window[2].Close - GetRealBody(window[2]) * _penetration                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      black real body                  GetCandleColor(input) == CandleColor.Black &&                  //      closing well within 1st rb                  input.Close < window[2].Close - GetRealBody(window[2]) * _penetration                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      black real body                  GetCandleColor(input) == CandleColor.Black &&                  //      closing well within 1st rb                  input.Close < window[2].Close - GetRealBody(window[2]) * _penetration                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      black real body                  GetCandleColor(input) == CandleColor.Black &&                  //      closing well within 1st rb                  input.Close < window[2].Close - GetRealBody(window[2]) * _penetration                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      black real body                  GetCandleColor(input) == CandleColor.Black &&                  //      closing well within 1st rb                  input.Close < window[2].Close - GetRealBody(window[2]) * _penetration                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  //      black real body                  GetCandleColor(input) == CandleColor.Black &&                  //      closing well within 1st rb                  input.Close < window[2].Close - GetRealBody(window[2]) * _penetration                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[_bodyLongAveragePeriod + 2]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,EveningDojiStar,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\EveningDojiStar.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[_bodyLongAveragePeriod + 2]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AbandonedBaby,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AbandonedBaby.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples > Period - _bodyLongAveragePeriod)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]);                  }                  if (Samples > Period - _bodyDojiAveragePeriod)                  {                      _bodyDojiPeriodTotal += GetCandleRange(CandleSettingType.BodyDoji' window[1]);                  }                  if (Samples > Period - _bodyShortAveragePeriod)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AbandonedBaby,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AbandonedBaby.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  ((                      // 1st white                      GetCandleColor(window[2]) == CandleColor.White &&                      // 3rd black                      GetCandleColor(input) == CandleColor.Black &&                      // 3rd closes well within 1st rb                      input.Close < window[2].Close - GetRealBody(window[2]) * _penetration &&                      // upside gap between 1st and 2nd                      GetCandleGapUp(window[1]' window[2]) &&                      // downside gap between 2nd and 3rd                      GetCandleGapDown(input' window[1])                    )                    ||                    (                      // 1st black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // 3rd white                      GetCandleColor(input) == CandleColor.White &&                      // 3rd closes well within 1st rb                      input.Close > window[2].Close + GetRealBody(window[2]) * _penetration &&                      // downside gap between 1st and 2nd                      GetCandleGapDown(window[1]' window[2]) &&                      // upside gap between 2nd and 3rd                      GetCandleGapUp(input' window[1])                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AbandonedBaby,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AbandonedBaby.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  ((                      // 1st white                      GetCandleColor(window[2]) == CandleColor.White &&                      // 3rd black                      GetCandleColor(input) == CandleColor.Black &&                      // 3rd closes well within 1st rb                      input.Close < window[2].Close - GetRealBody(window[2]) * _penetration &&                      // upside gap between 1st and 2nd                      GetCandleGapUp(window[1]' window[2]) &&                      // downside gap between 2nd and 3rd                      GetCandleGapDown(input' window[1])                    )                    ||                    (                      // 1st black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // 3rd white                      GetCandleColor(input) == CandleColor.White &&                      // 3rd closes well within 1st rb                      input.Close > window[2].Close + GetRealBody(window[2]) * _penetration &&                      // downside gap between 1st and 2nd                      GetCandleGapDown(window[1]' window[2]) &&                      // upside gap between 2nd and 3rd                      GetCandleGapUp(input' window[1])                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AbandonedBaby,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AbandonedBaby.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  ((                      // 1st white                      GetCandleColor(window[2]) == CandleColor.White &&                      // 3rd black                      GetCandleColor(input) == CandleColor.Black &&                      // 3rd closes well within 1st rb                      input.Close < window[2].Close - GetRealBody(window[2]) * _penetration &&                      // upside gap between 1st and 2nd                      GetCandleGapUp(window[1]' window[2]) &&                      // downside gap between 2nd and 3rd                      GetCandleGapDown(input' window[1])                    )                    ||                    (                      // 1st black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // 3rd white                      GetCandleColor(input) == CandleColor.White &&                      // 3rd closes well within 1st rb                      input.Close > window[2].Close + GetRealBody(window[2]) * _penetration &&                      // downside gap between 1st and 2nd                      GetCandleGapDown(window[1]' window[2]) &&                      // upside gap between 2nd and 3rd                      GetCandleGapUp(input' window[1])                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AbandonedBaby,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AbandonedBaby.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  ((                      // 1st white                      GetCandleColor(window[2]) == CandleColor.White &&                      // 3rd black                      GetCandleColor(input) == CandleColor.Black &&                      // 3rd closes well within 1st rb                      input.Close < window[2].Close - GetRealBody(window[2]) * _penetration &&                      // upside gap between 1st and 2nd                      GetCandleGapUp(window[1]' window[2]) &&                      // downside gap between 2nd and 3rd                      GetCandleGapDown(input' window[1])                    )                    ||                    (                      // 1st black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // 3rd white                      GetCandleColor(input) == CandleColor.White &&                      // 3rd closes well within 1st rb                      input.Close > window[2].Close + GetRealBody(window[2]) * _penetration &&                      // downside gap between 1st and 2nd                      GetCandleGapDown(window[1]' window[2]) &&                      // upside gap between 2nd and 3rd                      GetCandleGapUp(input' window[1])                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AbandonedBaby,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AbandonedBaby.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  ((                      // 1st white                      GetCandleColor(window[2]) == CandleColor.White &&                      // 3rd black                      GetCandleColor(input) == CandleColor.Black &&                      // 3rd closes well within 1st rb                      input.Close < window[2].Close - GetRealBody(window[2]) * _penetration &&                      // upside gap between 1st and 2nd                      GetCandleGapUp(window[1]' window[2]) &&                      // downside gap between 2nd and 3rd                      GetCandleGapDown(input' window[1])                    )                    ||                    (                      // 1st black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // 3rd white                      GetCandleColor(input) == CandleColor.White &&                      // 3rd closes well within 1st rb                      input.Close > window[2].Close + GetRealBody(window[2]) * _penetration &&                      // downside gap between 1st and 2nd                      GetCandleGapDown(window[1]' window[2]) &&                      // upside gap between 2nd and 3rd                      GetCandleGapUp(input' window[1])                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AbandonedBaby,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AbandonedBaby.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  ((                      // 1st white                      GetCandleColor(window[2]) == CandleColor.White &&                      // 3rd black                      GetCandleColor(input) == CandleColor.Black &&                      // 3rd closes well within 1st rb                      input.Close < window[2].Close - GetRealBody(window[2]) * _penetration &&                      // upside gap between 1st and 2nd                      GetCandleGapUp(window[1]' window[2]) &&                      // downside gap between 2nd and 3rd                      GetCandleGapDown(input' window[1])                    )                    ||                    (                      // 1st black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // 3rd white                      GetCandleColor(input) == CandleColor.White &&                      // 3rd closes well within 1st rb                      input.Close > window[2].Close + GetRealBody(window[2]) * _penetration &&                      // downside gap between 1st and 2nd                      GetCandleGapDown(window[1]' window[2]) &&                      // upside gap between 2nd and 3rd                      GetCandleGapUp(input' window[1])                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AbandonedBaby,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AbandonedBaby.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  ((                      // 1st white                      GetCandleColor(window[2]) == CandleColor.White &&                      // 3rd black                      GetCandleColor(input) == CandleColor.Black &&                      // 3rd closes well within 1st rb                      input.Close < window[2].Close - GetRealBody(window[2]) * _penetration &&                      // upside gap between 1st and 2nd                      GetCandleGapUp(window[1]' window[2]) &&                      // downside gap between 2nd and 3rd                      GetCandleGapDown(input' window[1])                    )                    ||                    (                      // 1st black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // 3rd white                      GetCandleColor(input) == CandleColor.White &&                      // 3rd closes well within 1st rb                      input.Close > window[2].Close + GetRealBody(window[2]) * _penetration &&                      // downside gap between 1st and 2nd                      GetCandleGapDown(window[1]' window[2]) &&                      // upside gap between 2nd and 3rd                      GetCandleGapUp(input' window[1])                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AbandonedBaby,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AbandonedBaby.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  ((                      // 1st white                      GetCandleColor(window[2]) == CandleColor.White &&                      // 3rd black                      GetCandleColor(input) == CandleColor.Black &&                      // 3rd closes well within 1st rb                      input.Close < window[2].Close - GetRealBody(window[2]) * _penetration &&                      // upside gap between 1st and 2nd                      GetCandleGapUp(window[1]' window[2]) &&                      // downside gap between 2nd and 3rd                      GetCandleGapDown(input' window[1])                    )                    ||                    (                      // 1st black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // 3rd white                      GetCandleColor(input) == CandleColor.White &&                      // 3rd closes well within 1st rb                      input.Close > window[2].Close + GetRealBody(window[2]) * _penetration &&                      // downside gap between 1st and 2nd                      GetCandleGapDown(window[1]' window[2]) &&                      // upside gap between 2nd and 3rd                      GetCandleGapUp(input' window[1])                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AbandonedBaby,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AbandonedBaby.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  ((                      // 1st white                      GetCandleColor(window[2]) == CandleColor.White &&                      // 3rd black                      GetCandleColor(input) == CandleColor.Black &&                      // 3rd closes well within 1st rb                      input.Close < window[2].Close - GetRealBody(window[2]) * _penetration &&                      // upside gap between 1st and 2nd                      GetCandleGapUp(window[1]' window[2]) &&                      // downside gap between 2nd and 3rd                      GetCandleGapDown(input' window[1])                    )                    ||                    (                      // 1st black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // 3rd white                      GetCandleColor(input) == CandleColor.White &&                      // 3rd closes well within 1st rb                      input.Close > window[2].Close + GetRealBody(window[2]) * _penetration &&                      // downside gap between 1st and 2nd                      GetCandleGapDown(window[1]' window[2]) &&                      // upside gap between 2nd and 3rd                      GetCandleGapUp(input' window[1])                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AbandonedBaby,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AbandonedBaby.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: doji                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyDoji' _bodyDojiPeriodTotal' window[1]) &&                  // 3rd: longer than short                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  ((                      // 1st white                      GetCandleColor(window[2]) == CandleColor.White &&                      // 3rd black                      GetCandleColor(input) == CandleColor.Black &&                      // 3rd closes well within 1st rb                      input.Close < window[2].Close - GetRealBody(window[2]) * _penetration &&                      // upside gap between 1st and 2nd                      GetCandleGapUp(window[1]' window[2]) &&                      // downside gap between 2nd and 3rd                      GetCandleGapDown(input' window[1])                    )                    ||                    (                      // 1st black                      GetCandleColor(window[2]) == CandleColor.Black &&                      // 3rd white                      GetCandleColor(input) == CandleColor.White &&                      // 3rd closes well within 1st rb                      input.Close > window[2].Close + GetRealBody(window[2]) * _penetration &&                      // downside gap between 1st and 2nd                      GetCandleGapDown(window[1]' window[2]) &&                      // upside gap between 2nd and 3rd                      GetCandleGapUp(input' window[1])                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AbandonedBaby,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AbandonedBaby.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[_bodyLongAveragePeriod - 1]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowShortAveragePeriod)                  {                      _shadowShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowShort' window[2]);                      _shadowShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowShort' window[1]);                      _shadowShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowShort' input);                  }                    if (Samples >= Period - _shadowLongAveragePeriod)                  {                      _shadowLongPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowLong' window[1]);                      _shadowLongPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowLong' input);                  }                    if (Samples >= Period - _bodyLongAveragePeriod)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]);                  }                    if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _nearPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    if (Samples >= Period - _farAveragePeriod)                  {                      _farPeriodTotal[2] += GetCandleRange(CandleSettingType.Far' window[2]);                      _farPeriodTotal[1] += GetCandleRange(CandleSettingType.Far' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowShortAveragePeriod)                  {                      _shadowShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowShort' window[2]);                      _shadowShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowShort' window[1]);                      _shadowShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowShort' input);                  }                    if (Samples >= Period - _shadowLongAveragePeriod)                  {                      _shadowLongPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowLong' window[1]);                      _shadowLongPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowLong' input);                  }                    if (Samples >= Period - _bodyLongAveragePeriod)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]);                  }                    if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _nearPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    if (Samples >= Period - _farAveragePeriod)                  {                      _farPeriodTotal[2] += GetCandleRange(CandleSettingType.Far' window[2]);                      _farPeriodTotal[1] += GetCandleRange(CandleSettingType.Far' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowShortAveragePeriod)                  {                      _shadowShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowShort' window[2]);                      _shadowShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowShort' window[1]);                      _shadowShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowShort' input);                  }                    if (Samples >= Period - _shadowLongAveragePeriod)                  {                      _shadowLongPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowLong' window[1]);                      _shadowLongPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowLong' input);                  }                    if (Samples >= Period - _bodyLongAveragePeriod)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]);                  }                    if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _nearPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    if (Samples >= Period - _farAveragePeriod)                  {                      _farPeriodTotal[2] += GetCandleRange(CandleSettingType.Far' window[2]);                      _farPeriodTotal[1] += GetCandleRange(CandleSettingType.Far' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowShortAveragePeriod)                  {                      _shadowShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowShort' window[2]);                      _shadowShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowShort' window[1]);                      _shadowShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowShort' input);                  }                    if (Samples >= Period - _shadowLongAveragePeriod)                  {                      _shadowLongPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowLong' window[1]);                      _shadowLongPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowLong' input);                  }                    if (Samples >= Period - _bodyLongAveragePeriod)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]);                  }                    if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _nearPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    if (Samples >= Period - _farAveragePeriod)                  {                      _farPeriodTotal[2] += GetCandleRange(CandleSettingType.Far' window[2]);                      _farPeriodTotal[1] += GetCandleRange(CandleSettingType.Far' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowShortAveragePeriod)                  {                      _shadowShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowShort' window[2]);                      _shadowShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowShort' window[1]);                      _shadowShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowShort' input);                  }                    if (Samples >= Period - _shadowLongAveragePeriod)                  {                      _shadowLongPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowLong' window[1]);                      _shadowLongPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowLong' input);                  }                    if (Samples >= Period - _bodyLongAveragePeriod)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]);                  }                    if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _nearPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    if (Samples >= Period - _farAveragePeriod)                  {                      _farPeriodTotal[2] += GetCandleRange(CandleSettingType.Far' window[2]);                      _farPeriodTotal[1] += GetCandleRange(CandleSettingType.Far' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowShortAveragePeriod)                  {                      _shadowShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowShort' window[2]);                      _shadowShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowShort' window[1]);                      _shadowShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowShort' input);                  }                    if (Samples >= Period - _shadowLongAveragePeriod)                  {                      _shadowLongPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowLong' window[1]);                      _shadowLongPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowLong' input);                  }                    if (Samples >= Period - _bodyLongAveragePeriod)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]);                  }                    if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _nearPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    if (Samples >= Period - _farAveragePeriod)                  {                      _farPeriodTotal[2] += GetCandleRange(CandleSettingType.Far' window[2]);                      _farPeriodTotal[1] += GetCandleRange(CandleSettingType.Far' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowShortAveragePeriod)                  {                      _shadowShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowShort' window[2]);                      _shadowShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowShort' window[1]);                      _shadowShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowShort' input);                  }                    if (Samples >= Period - _shadowLongAveragePeriod)                  {                      _shadowLongPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowLong' window[1]);                      _shadowLongPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowLong' input);                  }                    if (Samples >= Period - _bodyLongAveragePeriod)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]);                  }                    if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _nearPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    if (Samples >= Period - _farAveragePeriod)                  {                      _farPeriodTotal[2] += GetCandleRange(CandleSettingType.Far' window[2]);                      _farPeriodTotal[1] += GetCandleRange(CandleSettingType.Far' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 1st: short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[2]' window[2]) &&                  (                      // ( 2 far smaller than 1 && 3 not longer than 2 )                      // advance blocked with the 2nd' 3rd must not carry on the advance                      (                          GetRealBody(window[1]) < GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                          GetRealBody(input) < GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                      ) ||                      // 3 far smaller than 2                      // advance blocked with the 3rd                      (                          GetRealBody(input) < GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1])                      ) ||                      // ( 3 smaller than 2 && 2 smaller than 1 && (3 or 2 not short upper shadow) )                      // advance blocked with progressively smaller real bodies and some upper shadows                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetRealBody(window[1]) < GetRealBody(window[2]) &&                          (                              GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[0]' input) ||                              GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[1]' window[1])                          )                      ) ||                      // ( 3 smaller than 2 && 3 long upper shadow )                      // advance blocked with 3rd candle's long upper shadow and smaller body                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal[0]' input)                      )                  )                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 1st: short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[2]' window[2]) &&                  (                      // ( 2 far smaller than 1 && 3 not longer than 2 )                      // advance blocked with the 2nd' 3rd must not carry on the advance                      (                          GetRealBody(window[1]) < GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                          GetRealBody(input) < GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                      ) ||                      // 3 far smaller than 2                      // advance blocked with the 3rd                      (                          GetRealBody(input) < GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1])                      ) ||                      // ( 3 smaller than 2 && 2 smaller than 1 && (3 or 2 not short upper shadow) )                      // advance blocked with progressively smaller real bodies and some upper shadows                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetRealBody(window[1]) < GetRealBody(window[2]) &&                          (                              GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[0]' input) ||                              GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[1]' window[1])                          )                      ) ||                      // ( 3 smaller than 2 && 3 long upper shadow )                      // advance blocked with 3rd candle's long upper shadow and smaller body                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal[0]' input)                      )                  )                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 1st: short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[2]' window[2]) &&                  (                      // ( 2 far smaller than 1 && 3 not longer than 2 )                      // advance blocked with the 2nd' 3rd must not carry on the advance                      (                          GetRealBody(window[1]) < GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                          GetRealBody(input) < GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                      ) ||                      // 3 far smaller than 2                      // advance blocked with the 3rd                      (                          GetRealBody(input) < GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1])                      ) ||                      // ( 3 smaller than 2 && 2 smaller than 1 && (3 or 2 not short upper shadow) )                      // advance blocked with progressively smaller real bodies and some upper shadows                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetRealBody(window[1]) < GetRealBody(window[2]) &&                          (                              GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[0]' input) ||                              GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[1]' window[1])                          )                      ) ||                      // ( 3 smaller than 2 && 3 long upper shadow )                      // advance blocked with 3rd candle's long upper shadow and smaller body                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal[0]' input)                      )                  )                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 1st: short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[2]' window[2]) &&                  (                      // ( 2 far smaller than 1 && 3 not longer than 2 )                      // advance blocked with the 2nd' 3rd must not carry on the advance                      (                          GetRealBody(window[1]) < GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                          GetRealBody(input) < GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                      ) ||                      // 3 far smaller than 2                      // advance blocked with the 3rd                      (                          GetRealBody(input) < GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1])                      ) ||                      // ( 3 smaller than 2 && 2 smaller than 1 && (3 or 2 not short upper shadow) )                      // advance blocked with progressively smaller real bodies and some upper shadows                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetRealBody(window[1]) < GetRealBody(window[2]) &&                          (                              GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[0]' input) ||                              GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[1]' window[1])                          )                      ) ||                      // ( 3 smaller than 2 && 3 long upper shadow )                      // advance blocked with 3rd candle's long upper shadow and smaller body                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal[0]' input)                      )                  )                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 1st: short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[2]' window[2]) &&                  (                      // ( 2 far smaller than 1 && 3 not longer than 2 )                      // advance blocked with the 2nd' 3rd must not carry on the advance                      (                          GetRealBody(window[1]) < GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                          GetRealBody(input) < GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                      ) ||                      // 3 far smaller than 2                      // advance blocked with the 3rd                      (                          GetRealBody(input) < GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1])                      ) ||                      // ( 3 smaller than 2 && 2 smaller than 1 && (3 or 2 not short upper shadow) )                      // advance blocked with progressively smaller real bodies and some upper shadows                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetRealBody(window[1]) < GetRealBody(window[2]) &&                          (                              GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[0]' input) ||                              GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[1]' window[1])                          )                      ) ||                      // ( 3 smaller than 2 && 3 long upper shadow )                      // advance blocked with 3rd candle's long upper shadow and smaller body                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal[0]' input)                      )                  )                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 1st: short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[2]' window[2]) &&                  (                      // ( 2 far smaller than 1 && 3 not longer than 2 )                      // advance blocked with the 2nd' 3rd must not carry on the advance                      (                          GetRealBody(window[1]) < GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                          GetRealBody(input) < GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                      ) ||                      // 3 far smaller than 2                      // advance blocked with the 3rd                      (                          GetRealBody(input) < GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1])                      ) ||                      // ( 3 smaller than 2 && 2 smaller than 1 && (3 or 2 not short upper shadow) )                      // advance blocked with progressively smaller real bodies and some upper shadows                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetRealBody(window[1]) < GetRealBody(window[2]) &&                          (                              GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[0]' input) ||                              GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[1]' window[1])                          )                      ) ||                      // ( 3 smaller than 2 && 3 long upper shadow )                      // advance blocked with 3rd candle's long upper shadow and smaller body                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal[0]' input)                      )                  )                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 1st: short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[2]' window[2]) &&                  (                      // ( 2 far smaller than 1 && 3 not longer than 2 )                      // advance blocked with the 2nd' 3rd must not carry on the advance                      (                          GetRealBody(window[1]) < GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                          GetRealBody(input) < GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                      ) ||                      // 3 far smaller than 2                      // advance blocked with the 3rd                      (                          GetRealBody(input) < GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1])                      ) ||                      // ( 3 smaller than 2 && 2 smaller than 1 && (3 or 2 not short upper shadow) )                      // advance blocked with progressively smaller real bodies and some upper shadows                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetRealBody(window[1]) < GetRealBody(window[2]) &&                          (                              GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[0]' input) ||                              GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[1]' window[1])                          )                      ) ||                      // ( 3 smaller than 2 && 3 long upper shadow )                      // advance blocked with 3rd candle's long upper shadow and smaller body                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal[0]' input)                      )                  )                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 1st: short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[2]' window[2]) &&                  (                      // ( 2 far smaller than 1 && 3 not longer than 2 )                      // advance blocked with the 2nd' 3rd must not carry on the advance                      (                          GetRealBody(window[1]) < GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                          GetRealBody(input) < GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                      ) ||                      // 3 far smaller than 2                      // advance blocked with the 3rd                      (                          GetRealBody(input) < GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1])                      ) ||                      // ( 3 smaller than 2 && 2 smaller than 1 && (3 or 2 not short upper shadow) )                      // advance blocked with progressively smaller real bodies and some upper shadows                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetRealBody(window[1]) < GetRealBody(window[2]) &&                          (                              GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[0]' input) ||                              GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[1]' window[1])                          )                      ) ||                      // ( 3 smaller than 2 && 3 long upper shadow )                      // advance blocked with 3rd candle's long upper shadow and smaller body                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal[0]' input)                      )                  )                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 1st: short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[2]' window[2]) &&                  (                      // ( 2 far smaller than 1 && 3 not longer than 2 )                      // advance blocked with the 2nd' 3rd must not carry on the advance                      (                          GetRealBody(window[1]) < GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                          GetRealBody(input) < GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                      ) ||                      // 3 far smaller than 2                      // advance blocked with the 3rd                      (                          GetRealBody(input) < GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1])                      ) ||                      // ( 3 smaller than 2 && 2 smaller than 1 && (3 or 2 not short upper shadow) )                      // advance blocked with progressively smaller real bodies and some upper shadows                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetRealBody(window[1]) < GetRealBody(window[2]) &&                          (                              GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[0]' input) ||                              GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[1]' window[1])                          )                      ) ||                      // ( 3 smaller than 2 && 3 long upper shadow )                      // advance blocked with 3rd candle's long upper shadow and smaller body                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal[0]' input)                      )                  )                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 1st: short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[2]' window[2]) &&                  (                      // ( 2 far smaller than 1 && 3 not longer than 2 )                      // advance blocked with the 2nd' 3rd must not carry on the advance                      (                          GetRealBody(window[1]) < GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                          GetRealBody(input) < GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                      ) ||                      // 3 far smaller than 2                      // advance blocked with the 3rd                      (                          GetRealBody(input) < GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1])                      ) ||                      // ( 3 smaller than 2 && 2 smaller than 1 && (3 or 2 not short upper shadow) )                      // advance blocked with progressively smaller real bodies and some upper shadows                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetRealBody(window[1]) < GetRealBody(window[2]) &&                          (                              GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[0]' input) ||                              GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[1]' window[1])                          )                      ) ||                      // ( 3 smaller than 2 && 3 long upper shadow )                      // advance blocked with 3rd candle's long upper shadow and smaller body                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal[0]' input)                      )                  )                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 1st: short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[2]' window[2]) &&                  (                      // ( 2 far smaller than 1 && 3 not longer than 2 )                      // advance blocked with the 2nd' 3rd must not carry on the advance                      (                          GetRealBody(window[1]) < GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                          GetRealBody(input) < GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                      ) ||                      // 3 far smaller than 2                      // advance blocked with the 3rd                      (                          GetRealBody(input) < GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1])                      ) ||                      // ( 3 smaller than 2 && 2 smaller than 1 && (3 or 2 not short upper shadow) )                      // advance blocked with progressively smaller real bodies and some upper shadows                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetRealBody(window[1]) < GetRealBody(window[2]) &&                          (                              GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[0]' input) ||                              GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[1]' window[1])                          )                      ) ||                      // ( 3 smaller than 2 && 3 long upper shadow )                      // advance blocked with 3rd candle's long upper shadow and smaller body                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal[0]' input)                      )                  )                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 1st: short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[2]' window[2]) &&                  (                      // ( 2 far smaller than 1 && 3 not longer than 2 )                      // advance blocked with the 2nd' 3rd must not carry on the advance                      (                          GetRealBody(window[1]) < GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                          GetRealBody(input) < GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                      ) ||                      // 3 far smaller than 2                      // advance blocked with the 3rd                      (                          GetRealBody(input) < GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1])                      ) ||                      // ( 3 smaller than 2 && 2 smaller than 1 && (3 or 2 not short upper shadow) )                      // advance blocked with progressively smaller real bodies and some upper shadows                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetRealBody(window[1]) < GetRealBody(window[2]) &&                          (                              GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[0]' input) ||                              GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[1]' window[1])                          )                      ) ||                      // ( 3 smaller than 2 && 3 long upper shadow )                      // advance blocked with 3rd candle's long upper shadow and smaller body                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal[0]' input)                      )                  )                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 1st: short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[2]' window[2]) &&                  (                      // ( 2 far smaller than 1 && 3 not longer than 2 )                      // advance blocked with the 2nd' 3rd must not carry on the advance                      (                          GetRealBody(window[1]) < GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                          GetRealBody(input) < GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                      ) ||                      // 3 far smaller than 2                      // advance blocked with the 3rd                      (                          GetRealBody(input) < GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1])                      ) ||                      // ( 3 smaller than 2 && 2 smaller than 1 && (3 or 2 not short upper shadow) )                      // advance blocked with progressively smaller real bodies and some upper shadows                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetRealBody(window[1]) < GetRealBody(window[2]) &&                          (                              GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[0]' input) ||                              GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[1]' window[1])                          )                      ) ||                      // ( 3 smaller than 2 && 3 long upper shadow )                      // advance blocked with 3rd candle's long upper shadow and smaller body                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal[0]' input)                      )                  )                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 1st: short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[2]' window[2]) &&                  (                      // ( 2 far smaller than 1 && 3 not longer than 2 )                      // advance blocked with the 2nd' 3rd must not carry on the advance                      (                          GetRealBody(window[1]) < GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                          GetRealBody(input) < GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                      ) ||                      // 3 far smaller than 2                      // advance blocked with the 3rd                      (                          GetRealBody(input) < GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1])                      ) ||                      // ( 3 smaller than 2 && 2 smaller than 1 && (3 or 2 not short upper shadow) )                      // advance blocked with progressively smaller real bodies and some upper shadows                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetRealBody(window[1]) < GetRealBody(window[2]) &&                          (                              GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[0]' input) ||                              GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[1]' window[1])                          )                      ) ||                      // ( 3 smaller than 2 && 3 long upper shadow )                      // advance blocked with 3rd candle's long upper shadow and smaller body                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal[0]' input)                      )                  )                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 1st: long real body                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 1st: short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[2]' window[2]) &&                  (                      // ( 2 far smaller than 1 && 3 not longer than 2 )                      // advance blocked with the 2nd' 3rd must not carry on the advance                      (                          GetRealBody(window[1]) < GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                          GetRealBody(input) < GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1])                      ) ||                      // 3 far smaller than 2                      // advance blocked with the 3rd                      (                          GetRealBody(input) < GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1])                      ) ||                      // ( 3 smaller than 2 && 2 smaller than 1 && (3 or 2 not short upper shadow) )                      // advance blocked with progressively smaller real bodies and some upper shadows                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetRealBody(window[1]) < GetRealBody(window[2]) &&                          (                              GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[0]' input) ||                              GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowShort' _shadowShortPeriodTotal[1]' window[1])                          )                      ) ||                      // ( 3 smaller than 2 && 3 long upper shadow )                      // advance blocked with 3rd candle's long upper shadow and smaller body                      (                          GetRealBody(input) < GetRealBody(window[1]) &&                          GetUpperShadow(input) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal[0]' input)                      )                  )                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: for (var i = 2; i >= 0; i--)              {                  _shadowShortPeriodTotal[i] += GetCandleRange(CandleSettingType.ShadowShort' window[i]) -                                                GetCandleRange(CandleSettingType.ShadowShort' window[i + _shadowShortAveragePeriod]);              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: for (var i = 2; i >= 1; i--)              {                  _farPeriodTotal[i] += GetCandleRange(CandleSettingType.Far' window[i]) -                                        GetCandleRange(CandleSettingType.Far' window[i + _farAveragePeriod]);                  _nearPeriodTotal[i] += GetCandleRange(CandleSettingType.Near' window[i]) -                                         GetCandleRange(CandleSettingType.Near' window[i + _nearAveragePeriod]);              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                       GetCandleRange(CandleSettingType.BodyLong' window[2 + _bodyLongAveragePeriod]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                       GetCandleRange(CandleSettingType.BodyLong' window[2 + _bodyLongAveragePeriod]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,Reset,The following statement contains a magic number: _shadowShortPeriodTotal = new decimal[3];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,Reset,The following statement contains a magic number: _shadowLongPeriodTotal = new decimal[2];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,Reset,The following statement contains a magic number: _nearPeriodTotal = new decimal[3];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,AdvanceBlock,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\AdvanceBlock.cs,Reset,The following statement contains a magic number: _farPeriodTotal = new decimal[3];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[4]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st long                  GetRealBody(window[4]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[4]) &&                  // 1st' 2nd' 4th same color' 5th opposite                  GetCandleColor(window[4]) == GetCandleColor(window[3]) &&                  GetCandleColor(window[3]) == GetCandleColor(window[1]) &&                  (int)GetCandleColor(window[1]) == -(int)GetCandleColor(input) &&                  (                    (                      // when 1st is black:                      GetCandleColor(window[4]) == CandleColor.Black &&                      // 2nd gaps down                      GetRealBodyGapDown(window[3]' window[4]) &&                      // 3rd has lower high and low than 2nd                      window[2].High < window[3].High && window[2].Low < window[3].Low &&                      // 4th has lower high and low than 3rd                      window[1].High < window[2].High && window[1].Low < window[2].Low &&                      // 5th closes inside the gap                      input.Close > window[3].Open && input.Close < window[4].Close                    )                    ||                    (                      // when 1st is white:                      GetCandleColor(window[4]) == CandleColor.White &&                      // 2nd gaps up                      GetRealBodyGapUp(window[3]' window[4]) &&                      // 3rd has higher high and low than 2nd                      window[2].High > window[3].High && window[2].Low > window[3].Low &&                      // 4th has higher high and low than 3rd                      window[1].High > window[2].High && window[1].Low > window[2].Low &&                      // 5th closes inside the gap                      input.Close < window[3].Open && input.Close > window[4].Close                    )                  )                )                  value = (int)GetCandleColor(input);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[4]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[4 + _bodyLongAveragePeriod]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Breakaway,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Breakaway.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[4]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[4 + _bodyLongAveragePeriod]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod - 3 && Samples < Period - 3)                  {                      _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    else if (Samples >= Period - 3)                  {                          // copy here the pattern recognition code below                          // 2nd: lower high and higher low than 1st                          if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                          // 3rd: lower high and higher low than 2nd                          window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 4th: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low &&                            // (bull) 2nd: close near the low                            window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                              )                           ||                           // (bear) 4th: higher high and higher low                           (input.High > window[1].High && input.Low > window[1].Low &&                            // (bull) 2nd: close near the top                            window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                               )                              )                          )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int) Samples - 1;                      }                      else                      {                          // search for confirmation if modified hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 3rd                              ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                               ||                               // close lower than the low of 3rd                               (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low))                                  )                              _patternIndex = 0;                      }                        // add the current range and subtract the first range: this is done after the pattern recognition                       // when avgPeriod is not 0' that means "compare with the previous candles" (it excludes the current candle)                        _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                          GetCandleRange(CandleSettingType.Near' window[(int)Samples - 1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod - 3 && Samples < Period - 3)                  {                      _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    else if (Samples >= Period - 3)                  {                          // copy here the pattern recognition code below                          // 2nd: lower high and higher low than 1st                          if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                          // 3rd: lower high and higher low than 2nd                          window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 4th: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low &&                            // (bull) 2nd: close near the low                            window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                              )                           ||                           // (bear) 4th: higher high and higher low                           (input.High > window[1].High && input.Low > window[1].Low &&                            // (bull) 2nd: close near the top                            window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                               )                              )                          )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int) Samples - 1;                      }                      else                      {                          // search for confirmation if modified hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 3rd                              ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                               ||                               // close lower than the low of 3rd                               (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low))                                  )                              _patternIndex = 0;                      }                        // add the current range and subtract the first range: this is done after the pattern recognition                       // when avgPeriod is not 0' that means "compare with the previous candles" (it excludes the current candle)                        _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                          GetCandleRange(CandleSettingType.Near' window[(int)Samples - 1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod - 3 && Samples < Period - 3)                  {                      _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    else if (Samples >= Period - 3)                  {                          // copy here the pattern recognition code below                          // 2nd: lower high and higher low than 1st                          if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                          // 3rd: lower high and higher low than 2nd                          window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 4th: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low &&                            // (bull) 2nd: close near the low                            window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                              )                           ||                           // (bear) 4th: higher high and higher low                           (input.High > window[1].High && input.Low > window[1].Low &&                            // (bull) 2nd: close near the top                            window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                               )                              )                          )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int) Samples - 1;                      }                      else                      {                          // search for confirmation if modified hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 3rd                              ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                               ||                               // close lower than the low of 3rd                               (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low))                                  )                              _patternIndex = 0;                      }                        // add the current range and subtract the first range: this is done after the pattern recognition                       // when avgPeriod is not 0' that means "compare with the previous candles" (it excludes the current candle)                        _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                          GetCandleRange(CandleSettingType.Near' window[(int)Samples - 1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod - 3 && Samples < Period - 3)                  {                      _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    else if (Samples >= Period - 3)                  {                          // copy here the pattern recognition code below                          // 2nd: lower high and higher low than 1st                          if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                          // 3rd: lower high and higher low than 2nd                          window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 4th: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low &&                            // (bull) 2nd: close near the low                            window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                              )                           ||                           // (bear) 4th: higher high and higher low                           (input.High > window[1].High && input.Low > window[1].Low &&                            // (bull) 2nd: close near the top                            window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                               )                              )                          )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int) Samples - 1;                      }                      else                      {                          // search for confirmation if modified hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 3rd                              ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                               ||                               // close lower than the low of 3rd                               (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low))                                  )                              _patternIndex = 0;                      }                        // add the current range and subtract the first range: this is done after the pattern recognition                       // when avgPeriod is not 0' that means "compare with the previous candles" (it excludes the current candle)                        _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                          GetCandleRange(CandleSettingType.Near' window[(int)Samples - 1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod - 3 && Samples < Period - 3)                  {                      _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    else if (Samples >= Period - 3)                  {                          // copy here the pattern recognition code below                          // 2nd: lower high and higher low than 1st                          if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                          // 3rd: lower high and higher low than 2nd                          window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 4th: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low &&                            // (bull) 2nd: close near the low                            window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                              )                           ||                           // (bear) 4th: higher high and higher low                           (input.High > window[1].High && input.Low > window[1].Low &&                            // (bull) 2nd: close near the top                            window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                               )                              )                          )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int) Samples - 1;                      }                      else                      {                          // search for confirmation if modified hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 3rd                              ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                               ||                               // close lower than the low of 3rd                               (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low))                                  )                              _patternIndex = 0;                      }                        // add the current range and subtract the first range: this is done after the pattern recognition                       // when avgPeriod is not 0' that means "compare with the previous candles" (it excludes the current candle)                        _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                          GetCandleRange(CandleSettingType.Near' window[(int)Samples - 1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod - 3 && Samples < Period - 3)                  {                      _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    else if (Samples >= Period - 3)                  {                          // copy here the pattern recognition code below                          // 2nd: lower high and higher low than 1st                          if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                          // 3rd: lower high and higher low than 2nd                          window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 4th: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low &&                            // (bull) 2nd: close near the low                            window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                              )                           ||                           // (bear) 4th: higher high and higher low                           (input.High > window[1].High && input.Low > window[1].Low &&                            // (bull) 2nd: close near the top                            window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                               )                              )                          )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int) Samples - 1;                      }                      else                      {                          // search for confirmation if modified hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 3rd                              ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                               ||                               // close lower than the low of 3rd                               (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low))                                  )                              _patternIndex = 0;                      }                        // add the current range and subtract the first range: this is done after the pattern recognition                       // when avgPeriod is not 0' that means "compare with the previous candles" (it excludes the current candle)                        _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                          GetCandleRange(CandleSettingType.Near' window[(int)Samples - 1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod - 3 && Samples < Period - 3)                  {                      _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    else if (Samples >= Period - 3)                  {                          // copy here the pattern recognition code below                          // 2nd: lower high and higher low than 1st                          if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                          // 3rd: lower high and higher low than 2nd                          window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 4th: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low &&                            // (bull) 2nd: close near the low                            window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                              )                           ||                           // (bear) 4th: higher high and higher low                           (input.High > window[1].High && input.Low > window[1].Low &&                            // (bull) 2nd: close near the top                            window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                               )                              )                          )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int) Samples - 1;                      }                      else                      {                          // search for confirmation if modified hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 3rd                              ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                               ||                               // close lower than the low of 3rd                               (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low))                                  )                              _patternIndex = 0;                      }                        // add the current range and subtract the first range: this is done after the pattern recognition                       // when avgPeriod is not 0' that means "compare with the previous candles" (it excludes the current candle)                        _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                          GetCandleRange(CandleSettingType.Near' window[(int)Samples - 1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod - 3 && Samples < Period - 3)                  {                      _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    else if (Samples >= Period - 3)                  {                          // copy here the pattern recognition code below                          // 2nd: lower high and higher low than 1st                          if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                          // 3rd: lower high and higher low than 2nd                          window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 4th: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low &&                            // (bull) 2nd: close near the low                            window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                              )                           ||                           // (bear) 4th: higher high and higher low                           (input.High > window[1].High && input.Low > window[1].Low &&                            // (bull) 2nd: close near the top                            window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                               )                              )                          )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int) Samples - 1;                      }                      else                      {                          // search for confirmation if modified hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 3rd                              ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                               ||                               // close lower than the low of 3rd                               (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low))                                  )                              _patternIndex = 0;                      }                        // add the current range and subtract the first range: this is done after the pattern recognition                       // when avgPeriod is not 0' that means "compare with the previous candles" (it excludes the current candle)                        _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                          GetCandleRange(CandleSettingType.Near' window[(int)Samples - 1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod - 3 && Samples < Period - 3)                  {                      _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    else if (Samples >= Period - 3)                  {                          // copy here the pattern recognition code below                          // 2nd: lower high and higher low than 1st                          if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                          // 3rd: lower high and higher low than 2nd                          window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 4th: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low &&                            // (bull) 2nd: close near the low                            window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                              )                           ||                           // (bear) 4th: higher high and higher low                           (input.High > window[1].High && input.Low > window[1].Low &&                            // (bull) 2nd: close near the top                            window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                               )                              )                          )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int) Samples - 1;                      }                      else                      {                          // search for confirmation if modified hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 3rd                              ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                               ||                               // close lower than the low of 3rd                               (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low))                                  )                              _patternIndex = 0;                      }                        // add the current range and subtract the first range: this is done after the pattern recognition                       // when avgPeriod is not 0' that means "compare with the previous candles" (it excludes the current candle)                        _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                          GetCandleRange(CandleSettingType.Near' window[(int)Samples - 1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod - 3 && Samples < Period - 3)                  {                      _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    else if (Samples >= Period - 3)                  {                          // copy here the pattern recognition code below                          // 2nd: lower high and higher low than 1st                          if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                          // 3rd: lower high and higher low than 2nd                          window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 4th: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low &&                            // (bull) 2nd: close near the low                            window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                              )                           ||                           // (bear) 4th: higher high and higher low                           (input.High > window[1].High && input.Low > window[1].Low &&                            // (bull) 2nd: close near the top                            window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                               )                              )                          )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int) Samples - 1;                      }                      else                      {                          // search for confirmation if modified hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 3rd                              ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                               ||                               // close lower than the low of 3rd                               (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low))                                  )                              _patternIndex = 0;                      }                        // add the current range and subtract the first range: this is done after the pattern recognition                       // when avgPeriod is not 0' that means "compare with the previous candles" (it excludes the current candle)                        _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                          GetCandleRange(CandleSettingType.Near' window[(int)Samples - 1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod - 3 && Samples < Period - 3)                  {                      _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    else if (Samples >= Period - 3)                  {                          // copy here the pattern recognition code below                          // 2nd: lower high and higher low than 1st                          if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                          // 3rd: lower high and higher low than 2nd                          window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 4th: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low &&                            // (bull) 2nd: close near the low                            window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                              )                           ||                           // (bear) 4th: higher high and higher low                           (input.High > window[1].High && input.Low > window[1].Low &&                            // (bull) 2nd: close near the top                            window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                               )                              )                          )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int) Samples - 1;                      }                      else                      {                          // search for confirmation if modified hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 3rd                              ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                               ||                               // close lower than the low of 3rd                               (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low))                                  )                              _patternIndex = 0;                      }                        // add the current range and subtract the first range: this is done after the pattern recognition                       // when avgPeriod is not 0' that means "compare with the previous candles" (it excludes the current candle)                        _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                          GetCandleRange(CandleSettingType.Near' window[(int)Samples - 1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod - 3 && Samples < Period - 3)                  {                      _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    else if (Samples >= Period - 3)                  {                          // copy here the pattern recognition code below                          // 2nd: lower high and higher low than 1st                          if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                          // 3rd: lower high and higher low than 2nd                          window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 4th: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low &&                            // (bull) 2nd: close near the low                            window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                              )                           ||                           // (bear) 4th: higher high and higher low                           (input.High > window[1].High && input.Low > window[1].Low &&                            // (bull) 2nd: close near the top                            window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                               )                              )                          )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int) Samples - 1;                      }                      else                      {                          // search for confirmation if modified hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 3rd                              ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                               ||                               // close lower than the low of 3rd                               (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low))                                  )                              _patternIndex = 0;                      }                        // add the current range and subtract the first range: this is done after the pattern recognition                       // when avgPeriod is not 0' that means "compare with the previous candles" (it excludes the current candle)                        _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                          GetCandleRange(CandleSettingType.Near' window[(int)Samples - 1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod - 3 && Samples < Period - 3)                  {                      _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    else if (Samples >= Period - 3)                  {                          // copy here the pattern recognition code below                          // 2nd: lower high and higher low than 1st                          if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                          // 3rd: lower high and higher low than 2nd                          window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 4th: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low &&                            // (bull) 2nd: close near the low                            window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                              )                           ||                           // (bear) 4th: higher high and higher low                           (input.High > window[1].High && input.Low > window[1].Low &&                            // (bull) 2nd: close near the top                            window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                               )                              )                          )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int) Samples - 1;                      }                      else                      {                          // search for confirmation if modified hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 3rd                              ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                               ||                               // close lower than the low of 3rd                               (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low))                                  )                              _patternIndex = 0;                      }                        // add the current range and subtract the first range: this is done after the pattern recognition                       // when avgPeriod is not 0' that means "compare with the previous candles" (it excludes the current candle)                        _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                          GetCandleRange(CandleSettingType.Near' window[(int)Samples - 1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod - 3 && Samples < Period - 3)                  {                      _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    else if (Samples >= Period - 3)                  {                          // copy here the pattern recognition code below                          // 2nd: lower high and higher low than 1st                          if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                          // 3rd: lower high and higher low than 2nd                          window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 4th: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low &&                            // (bull) 2nd: close near the low                            window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                              )                           ||                           // (bear) 4th: higher high and higher low                           (input.High > window[1].High && input.Low > window[1].Low &&                            // (bull) 2nd: close near the top                            window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                               )                              )                          )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int) Samples - 1;                      }                      else                      {                          // search for confirmation if modified hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 3rd                              ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                               ||                               // close lower than the low of 3rd                               (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low))                                  )                              _patternIndex = 0;                      }                        // add the current range and subtract the first range: this is done after the pattern recognition                       // when avgPeriod is not 0' that means "compare with the previous candles" (it excludes the current candle)                        _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                          GetCandleRange(CandleSettingType.Near' window[(int)Samples - 1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod - 3 && Samples < Period - 3)                  {                      _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    else if (Samples >= Period - 3)                  {                          // copy here the pattern recognition code below                          // 2nd: lower high and higher low than 1st                          if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                          // 3rd: lower high and higher low than 2nd                          window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 4th: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low &&                            // (bull) 2nd: close near the low                            window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                              )                           ||                           // (bear) 4th: higher high and higher low                           (input.High > window[1].High && input.Low > window[1].Low &&                            // (bull) 2nd: close near the top                            window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                               )                              )                          )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int) Samples - 1;                      }                      else                      {                          // search for confirmation if modified hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 3rd                              ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                               ||                               // close lower than the low of 3rd                               (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low))                                  )                              _patternIndex = 0;                      }                        // add the current range and subtract the first range: this is done after the pattern recognition                       // when avgPeriod is not 0' that means "compare with the previous candles" (it excludes the current candle)                        _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                          GetCandleRange(CandleSettingType.Near' window[(int)Samples - 1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod - 3 && Samples < Period - 3)                  {                      _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    else if (Samples >= Period - 3)                  {                          // copy here the pattern recognition code below                          // 2nd: lower high and higher low than 1st                          if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                          // 3rd: lower high and higher low than 2nd                          window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 4th: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low &&                            // (bull) 2nd: close near the low                            window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                              )                           ||                           // (bear) 4th: higher high and higher low                           (input.High > window[1].High && input.Low > window[1].Low &&                            // (bull) 2nd: close near the top                            window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                               )                              )                          )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int) Samples - 1;                      }                      else                      {                          // search for confirmation if modified hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 3rd                              ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                               ||                               // close lower than the low of 3rd                               (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low))                                  )                              _patternIndex = 0;                      }                        // add the current range and subtract the first range: this is done after the pattern recognition                       // when avgPeriod is not 0' that means "compare with the previous candles" (it excludes the current candle)                        _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                          GetCandleRange(CandleSettingType.Near' window[(int)Samples - 1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod - 3 && Samples < Period - 3)                  {                      _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    else if (Samples >= Period - 3)                  {                          // copy here the pattern recognition code below                          // 2nd: lower high and higher low than 1st                          if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                          // 3rd: lower high and higher low than 2nd                          window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 4th: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low &&                            // (bull) 2nd: close near the low                            window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                              )                           ||                           // (bear) 4th: higher high and higher low                           (input.High > window[1].High && input.Low > window[1].Low &&                            // (bull) 2nd: close near the top                            window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                               )                              )                          )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int) Samples - 1;                      }                      else                      {                          // search for confirmation if modified hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 3rd                              ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                               ||                               // close lower than the low of 3rd                               (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low))                                  )                              _patternIndex = 0;                      }                        // add the current range and subtract the first range: this is done after the pattern recognition                       // when avgPeriod is not 0' that means "compare with the previous candles" (it excludes the current candle)                        _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                          GetCandleRange(CandleSettingType.Near' window[(int)Samples - 1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod - 3 && Samples < Period - 3)                  {                      _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    else if (Samples >= Period - 3)                  {                          // copy here the pattern recognition code below                          // 2nd: lower high and higher low than 1st                          if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                          // 3rd: lower high and higher low than 2nd                          window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 4th: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low &&                            // (bull) 2nd: close near the low                            window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                              )                           ||                           // (bear) 4th: higher high and higher low                           (input.High > window[1].High && input.Low > window[1].Low &&                            // (bull) 2nd: close near the top                            window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                               )                              )                          )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int) Samples - 1;                      }                      else                      {                          // search for confirmation if modified hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 3rd                              ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                               ||                               // close lower than the low of 3rd                               (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low))                                  )                              _patternIndex = 0;                      }                        // add the current range and subtract the first range: this is done after the pattern recognition                       // when avgPeriod is not 0' that means "compare with the previous candles" (it excludes the current candle)                        _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                          GetCandleRange(CandleSettingType.Near' window[(int)Samples - 1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                  // 3rd: lower high and higher low than 2nd                  window[1].High < window[2].High && window[1].Low > window[2].Low &&                  // (bull) 4th: lower high and lower low                  ((input.High < window[1].High && input.Low < window[1].Low &&                    // (bull) 2nd: close near the low                    window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                      )                   ||                   // (bear) 4th: higher high and higher low                   (input.High > window[1].High && input.Low > window[1].Low &&                    // (bull) 2nd: close near the top                    window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                       )                      )                  )              {                  _patternResult = (input.High < window[1].High ? 1 : -1);                  _patternIndex = (int) Samples - 1;                  value = _patternResult;              }              else              {                  // search for confirmation if modified hikkake was no more than 3 bars ago                  if (Samples <= _patternIndex + 4 &&                      // close higher than the high of 3rd                      ((_patternResult > 0 && input.Close > window[(int)Samples - _patternIndex].High)                       ||                       // close lower than the low of 3rd                       (_patternResult < 0 && input.Close < window[(int)Samples - _patternIndex].Low))                          )                  {                      value = _patternResult + (_patternResult > 0 ? 1 : -1);                      _patternIndex = 0;                  }                  else                      value = 0;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                  // 3rd: lower high and higher low than 2nd                  window[1].High < window[2].High && window[1].Low > window[2].Low &&                  // (bull) 4th: lower high and lower low                  ((input.High < window[1].High && input.Low < window[1].Low &&                    // (bull) 2nd: close near the low                    window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                      )                   ||                   // (bear) 4th: higher high and higher low                   (input.High > window[1].High && input.Low > window[1].Low &&                    // (bull) 2nd: close near the top                    window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                       )                      )                  )              {                  _patternResult = (input.High < window[1].High ? 1 : -1);                  _patternIndex = (int) Samples - 1;                  value = _patternResult;              }              else              {                  // search for confirmation if modified hikkake was no more than 3 bars ago                  if (Samples <= _patternIndex + 4 &&                      // close higher than the high of 3rd                      ((_patternResult > 0 && input.Close > window[(int)Samples - _patternIndex].High)                       ||                       // close lower than the low of 3rd                       (_patternResult < 0 && input.Close < window[(int)Samples - _patternIndex].Low))                          )                  {                      value = _patternResult + (_patternResult > 0 ? 1 : -1);                      _patternIndex = 0;                  }                  else                      value = 0;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                  // 3rd: lower high and higher low than 2nd                  window[1].High < window[2].High && window[1].Low > window[2].Low &&                  // (bull) 4th: lower high and lower low                  ((input.High < window[1].High && input.Low < window[1].Low &&                    // (bull) 2nd: close near the low                    window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                      )                   ||                   // (bear) 4th: higher high and higher low                   (input.High > window[1].High && input.Low > window[1].Low &&                    // (bull) 2nd: close near the top                    window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                       )                      )                  )              {                  _patternResult = (input.High < window[1].High ? 1 : -1);                  _patternIndex = (int) Samples - 1;                  value = _patternResult;              }              else              {                  // search for confirmation if modified hikkake was no more than 3 bars ago                  if (Samples <= _patternIndex + 4 &&                      // close higher than the high of 3rd                      ((_patternResult > 0 && input.Close > window[(int)Samples - _patternIndex].High)                       ||                       // close lower than the low of 3rd                       (_patternResult < 0 && input.Close < window[(int)Samples - _patternIndex].Low))                          )                  {                      value = _patternResult + (_patternResult > 0 ? 1 : -1);                      _patternIndex = 0;                  }                  else                      value = 0;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                  // 3rd: lower high and higher low than 2nd                  window[1].High < window[2].High && window[1].Low > window[2].Low &&                  // (bull) 4th: lower high and lower low                  ((input.High < window[1].High && input.Low < window[1].Low &&                    // (bull) 2nd: close near the low                    window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                      )                   ||                   // (bear) 4th: higher high and higher low                   (input.High > window[1].High && input.Low > window[1].Low &&                    // (bull) 2nd: close near the top                    window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                       )                      )                  )              {                  _patternResult = (input.High < window[1].High ? 1 : -1);                  _patternIndex = (int) Samples - 1;                  value = _patternResult;              }              else              {                  // search for confirmation if modified hikkake was no more than 3 bars ago                  if (Samples <= _patternIndex + 4 &&                      // close higher than the high of 3rd                      ((_patternResult > 0 && input.Close > window[(int)Samples - _patternIndex].High)                       ||                       // close lower than the low of 3rd                       (_patternResult < 0 && input.Close < window[(int)Samples - _patternIndex].Low))                          )                  {                      value = _patternResult + (_patternResult > 0 ? 1 : -1);                      _patternIndex = 0;                  }                  else                      value = 0;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                  // 3rd: lower high and higher low than 2nd                  window[1].High < window[2].High && window[1].Low > window[2].Low &&                  // (bull) 4th: lower high and lower low                  ((input.High < window[1].High && input.Low < window[1].Low &&                    // (bull) 2nd: close near the low                    window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                      )                   ||                   // (bear) 4th: higher high and higher low                   (input.High > window[1].High && input.Low > window[1].Low &&                    // (bull) 2nd: close near the top                    window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                       )                      )                  )              {                  _patternResult = (input.High < window[1].High ? 1 : -1);                  _patternIndex = (int) Samples - 1;                  value = _patternResult;              }              else              {                  // search for confirmation if modified hikkake was no more than 3 bars ago                  if (Samples <= _patternIndex + 4 &&                      // close higher than the high of 3rd                      ((_patternResult > 0 && input.Close > window[(int)Samples - _patternIndex].High)                       ||                       // close lower than the low of 3rd                       (_patternResult < 0 && input.Close < window[(int)Samples - _patternIndex].Low))                          )                  {                      value = _patternResult + (_patternResult > 0 ? 1 : -1);                      _patternIndex = 0;                  }                  else                      value = 0;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                  // 3rd: lower high and higher low than 2nd                  window[1].High < window[2].High && window[1].Low > window[2].Low &&                  // (bull) 4th: lower high and lower low                  ((input.High < window[1].High && input.Low < window[1].Low &&                    // (bull) 2nd: close near the low                    window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                      )                   ||                   // (bear) 4th: higher high and higher low                   (input.High > window[1].High && input.Low > window[1].Low &&                    // (bull) 2nd: close near the top                    window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                       )                      )                  )              {                  _patternResult = (input.High < window[1].High ? 1 : -1);                  _patternIndex = (int) Samples - 1;                  value = _patternResult;              }              else              {                  // search for confirmation if modified hikkake was no more than 3 bars ago                  if (Samples <= _patternIndex + 4 &&                      // close higher than the high of 3rd                      ((_patternResult > 0 && input.Close > window[(int)Samples - _patternIndex].High)                       ||                       // close lower than the low of 3rd                       (_patternResult < 0 && input.Close < window[(int)Samples - _patternIndex].Low))                          )                  {                      value = _patternResult + (_patternResult > 0 ? 1 : -1);                      _patternIndex = 0;                  }                  else                      value = 0;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                  // 3rd: lower high and higher low than 2nd                  window[1].High < window[2].High && window[1].Low > window[2].Low &&                  // (bull) 4th: lower high and lower low                  ((input.High < window[1].High && input.Low < window[1].Low &&                    // (bull) 2nd: close near the low                    window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                      )                   ||                   // (bear) 4th: higher high and higher low                   (input.High > window[1].High && input.Low > window[1].Low &&                    // (bull) 2nd: close near the top                    window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                       )                      )                  )              {                  _patternResult = (input.High < window[1].High ? 1 : -1);                  _patternIndex = (int) Samples - 1;                  value = _patternResult;              }              else              {                  // search for confirmation if modified hikkake was no more than 3 bars ago                  if (Samples <= _patternIndex + 4 &&                      // close higher than the high of 3rd                      ((_patternResult > 0 && input.Close > window[(int)Samples - _patternIndex].High)                       ||                       // close lower than the low of 3rd                       (_patternResult < 0 && input.Close < window[(int)Samples - _patternIndex].Low))                          )                  {                      value = _patternResult + (_patternResult > 0 ? 1 : -1);                      _patternIndex = 0;                  }                  else                      value = 0;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                  // 3rd: lower high and higher low than 2nd                  window[1].High < window[2].High && window[1].Low > window[2].Low &&                  // (bull) 4th: lower high and lower low                  ((input.High < window[1].High && input.Low < window[1].Low &&                    // (bull) 2nd: close near the low                    window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                      )                   ||                   // (bear) 4th: higher high and higher low                   (input.High > window[1].High && input.Low > window[1].Low &&                    // (bull) 2nd: close near the top                    window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                       )                      )                  )              {                  _patternResult = (input.High < window[1].High ? 1 : -1);                  _patternIndex = (int) Samples - 1;                  value = _patternResult;              }              else              {                  // search for confirmation if modified hikkake was no more than 3 bars ago                  if (Samples <= _patternIndex + 4 &&                      // close higher than the high of 3rd                      ((_patternResult > 0 && input.Close > window[(int)Samples - _patternIndex].High)                       ||                       // close lower than the low of 3rd                       (_patternResult < 0 && input.Close < window[(int)Samples - _patternIndex].Low))                          )                  {                      value = _patternResult + (_patternResult > 0 ? 1 : -1);                      _patternIndex = 0;                  }                  else                      value = 0;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                  // 3rd: lower high and higher low than 2nd                  window[1].High < window[2].High && window[1].Low > window[2].Low &&                  // (bull) 4th: lower high and lower low                  ((input.High < window[1].High && input.Low < window[1].Low &&                    // (bull) 2nd: close near the low                    window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                      )                   ||                   // (bear) 4th: higher high and higher low                   (input.High > window[1].High && input.Low > window[1].Low &&                    // (bull) 2nd: close near the top                    window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                       )                      )                  )              {                  _patternResult = (input.High < window[1].High ? 1 : -1);                  _patternIndex = (int) Samples - 1;                  value = _patternResult;              }              else              {                  // search for confirmation if modified hikkake was no more than 3 bars ago                  if (Samples <= _patternIndex + 4 &&                      // close higher than the high of 3rd                      ((_patternResult > 0 && input.Close > window[(int)Samples - _patternIndex].High)                       ||                       // close lower than the low of 3rd                       (_patternResult < 0 && input.Close < window[(int)Samples - _patternIndex].Low))                          )                  {                      value = _patternResult + (_patternResult > 0 ? 1 : -1);                      _patternIndex = 0;                  }                  else                      value = 0;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                  // 3rd: lower high and higher low than 2nd                  window[1].High < window[2].High && window[1].Low > window[2].Low &&                  // (bull) 4th: lower high and lower low                  ((input.High < window[1].High && input.Low < window[1].Low &&                    // (bull) 2nd: close near the low                    window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                      )                   ||                   // (bear) 4th: higher high and higher low                   (input.High > window[1].High && input.Low > window[1].Low &&                    // (bull) 2nd: close near the top                    window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                       )                      )                  )              {                  _patternResult = (input.High < window[1].High ? 1 : -1);                  _patternIndex = (int) Samples - 1;                  value = _patternResult;              }              else              {                  // search for confirmation if modified hikkake was no more than 3 bars ago                  if (Samples <= _patternIndex + 4 &&                      // close higher than the high of 3rd                      ((_patternResult > 0 && input.Close > window[(int)Samples - _patternIndex].High)                       ||                       // close lower than the low of 3rd                       (_patternResult < 0 && input.Close < window[(int)Samples - _patternIndex].Low))                          )                  {                      value = _patternResult + (_patternResult > 0 ? 1 : -1);                      _patternIndex = 0;                  }                  else                      value = 0;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                  // 3rd: lower high and higher low than 2nd                  window[1].High < window[2].High && window[1].Low > window[2].Low &&                  // (bull) 4th: lower high and lower low                  ((input.High < window[1].High && input.Low < window[1].Low &&                    // (bull) 2nd: close near the low                    window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                      )                   ||                   // (bear) 4th: higher high and higher low                   (input.High > window[1].High && input.Low > window[1].Low &&                    // (bull) 2nd: close near the top                    window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                       )                      )                  )              {                  _patternResult = (input.High < window[1].High ? 1 : -1);                  _patternIndex = (int) Samples - 1;                  value = _patternResult;              }              else              {                  // search for confirmation if modified hikkake was no more than 3 bars ago                  if (Samples <= _patternIndex + 4 &&                      // close higher than the high of 3rd                      ((_patternResult > 0 && input.Close > window[(int)Samples - _patternIndex].High)                       ||                       // close lower than the low of 3rd                       (_patternResult < 0 && input.Close < window[(int)Samples - _patternIndex].Low))                          )                  {                      value = _patternResult + (_patternResult > 0 ? 1 : -1);                      _patternIndex = 0;                  }                  else                      value = 0;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                  // 3rd: lower high and higher low than 2nd                  window[1].High < window[2].High && window[1].Low > window[2].Low &&                  // (bull) 4th: lower high and lower low                  ((input.High < window[1].High && input.Low < window[1].Low &&                    // (bull) 2nd: close near the low                    window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                      )                   ||                   // (bear) 4th: higher high and higher low                   (input.High > window[1].High && input.Low > window[1].Low &&                    // (bull) 2nd: close near the top                    window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                       )                      )                  )              {                  _patternResult = (input.High < window[1].High ? 1 : -1);                  _patternIndex = (int) Samples - 1;                  value = _patternResult;              }              else              {                  // search for confirmation if modified hikkake was no more than 3 bars ago                  if (Samples <= _patternIndex + 4 &&                      // close higher than the high of 3rd                      ((_patternResult > 0 && input.Close > window[(int)Samples - _patternIndex].High)                       ||                       // close lower than the low of 3rd                       (_patternResult < 0 && input.Close < window[(int)Samples - _patternIndex].Low))                          )                  {                      value = _patternResult + (_patternResult > 0 ? 1 : -1);                      _patternIndex = 0;                  }                  else                      value = 0;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: if (window[2].High < window[3].High && window[2].Low > window[3].Low &&                  // 3rd: lower high and higher low than 2nd                  window[1].High < window[2].High && window[1].Low > window[2].Low &&                  // (bull) 4th: lower high and lower low                  ((input.High < window[1].High && input.Low < window[1].Low &&                    // (bull) 2nd: close near the low                    window[2].Close <= window[2].Low + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                      )                   ||                   // (bear) 4th: higher high and higher low                   (input.High > window[1].High && input.Low > window[1].Low &&                    // (bull) 2nd: close near the top                    window[2].Close >= window[2].High - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[2])                       )                      )                  )              {                  _patternResult = (input.High < window[1].High ? 1 : -1);                  _patternIndex = (int) Samples - 1;                  value = _patternResult;              }              else              {                  // search for confirmation if modified hikkake was no more than 3 bars ago                  if (Samples <= _patternIndex + 4 &&                      // close higher than the high of 3rd                      ((_patternResult > 0 && input.Close > window[(int)Samples - _patternIndex].High)                       ||                       // close lower than the low of 3rd                       (_patternResult < 0 && input.Close < window[(int)Samples - _patternIndex].Low))                          )                  {                      value = _patternResult + (_patternResult > 0 ? 1 : -1);                      _patternIndex = 0;                  }                  else                      value = 0;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                  GetCandleRange(CandleSettingType.Near' window[_nearAveragePeriod + 5]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The following statement contains a magic number: _nearPeriodTotal += GetCandleRange(CandleSettingType.Near' window[2]) -                                  GetCandleRange(CandleSettingType.Near' window[_nearAveragePeriod + 5]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeBlackCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeBlackCrows.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[2]);                      _shadowVeryShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                      _shadowVeryShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowVeryShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeBlackCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeBlackCrows.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[2]);                      _shadowVeryShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                      _shadowVeryShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowVeryShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeBlackCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeBlackCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // white                  GetCandleColor(window[3]) == CandleColor.White &&                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // 2nd black opens within 1st black's rb                  window[1].Open < window[2].Open && window[1].Open > window[2].Close &&                  // 3rd black opens within 2nd black's rb                  input.Open < window[1].Open && input.Open > window[1].Close &&                  // 1st black closes under prior candle's high                  window[3].High > window[2].Close &&                  // three declining                  window[2].Close > window[1].Close &&                  // three declining                  window[1].Close > input.Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeBlackCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeBlackCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // white                  GetCandleColor(window[3]) == CandleColor.White &&                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // 2nd black opens within 1st black's rb                  window[1].Open < window[2].Open && window[1].Open > window[2].Close &&                  // 3rd black opens within 2nd black's rb                  input.Open < window[1].Open && input.Open > window[1].Close &&                  // 1st black closes under prior candle's high                  window[3].High > window[2].Close &&                  // three declining                  window[2].Close > window[1].Close &&                  // three declining                  window[1].Close > input.Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeBlackCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeBlackCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // white                  GetCandleColor(window[3]) == CandleColor.White &&                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // 2nd black opens within 1st black's rb                  window[1].Open < window[2].Open && window[1].Open > window[2].Close &&                  // 3rd black opens within 2nd black's rb                  input.Open < window[1].Open && input.Open > window[1].Close &&                  // 1st black closes under prior candle's high                  window[3].High > window[2].Close &&                  // three declining                  window[2].Close > window[1].Close &&                  // three declining                  window[1].Close > input.Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeBlackCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeBlackCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // white                  GetCandleColor(window[3]) == CandleColor.White &&                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // 2nd black opens within 1st black's rb                  window[1].Open < window[2].Open && window[1].Open > window[2].Close &&                  // 3rd black opens within 2nd black's rb                  input.Open < window[1].Open && input.Open > window[1].Close &&                  // 1st black closes under prior candle's high                  window[3].High > window[2].Close &&                  // three declining                  window[2].Close > window[1].Close &&                  // three declining                  window[1].Close > input.Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeBlackCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeBlackCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // white                  GetCandleColor(window[3]) == CandleColor.White &&                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // 2nd black opens within 1st black's rb                  window[1].Open < window[2].Open && window[1].Open > window[2].Close &&                  // 3rd black opens within 2nd black's rb                  input.Open < window[1].Open && input.Open > window[1].Close &&                  // 1st black closes under prior candle's high                  window[3].High > window[2].Close &&                  // three declining                  window[2].Close > window[1].Close &&                  // three declining                  window[1].Close > input.Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeBlackCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeBlackCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // white                  GetCandleColor(window[3]) == CandleColor.White &&                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // 2nd black opens within 1st black's rb                  window[1].Open < window[2].Open && window[1].Open > window[2].Close &&                  // 3rd black opens within 2nd black's rb                  input.Open < window[1].Open && input.Open > window[1].Close &&                  // 1st black closes under prior candle's high                  window[3].High > window[2].Close &&                  // three declining                  window[2].Close > window[1].Close &&                  // three declining                  window[1].Close > input.Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeBlackCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeBlackCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // white                  GetCandleColor(window[3]) == CandleColor.White &&                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // 2nd black opens within 1st black's rb                  window[1].Open < window[2].Open && window[1].Open > window[2].Close &&                  // 3rd black opens within 2nd black's rb                  input.Open < window[1].Open && input.Open > window[1].Close &&                  // 1st black closes under prior candle's high                  window[3].High > window[2].Close &&                  // three declining                  window[2].Close > window[1].Close &&                  // three declining                  window[1].Close > input.Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeBlackCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeBlackCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // white                  GetCandleColor(window[3]) == CandleColor.White &&                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // 2nd black opens within 1st black's rb                  window[1].Open < window[2].Open && window[1].Open > window[2].Close &&                  // 3rd black opens within 2nd black's rb                  input.Open < window[1].Open && input.Open > window[1].Close &&                  // 1st black closes under prior candle's high                  window[3].High > window[2].Close &&                  // three declining                  window[2].Close > window[1].Close &&                  // three declining                  window[1].Close > input.Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeBlackCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeBlackCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // white                  GetCandleColor(window[3]) == CandleColor.White &&                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // 2nd black opens within 1st black's rb                  window[1].Open < window[2].Open && window[1].Open > window[2].Close &&                  // 3rd black opens within 2nd black's rb                  input.Open < window[1].Open && input.Open > window[1].Close &&                  // 1st black closes under prior candle's high                  window[3].High > window[2].Close &&                  // three declining                  window[2].Close > window[1].Close &&                  // three declining                  window[1].Close > input.Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeBlackCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeBlackCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // white                  GetCandleColor(window[3]) == CandleColor.White &&                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // 2nd black opens within 1st black's rb                  window[1].Open < window[2].Open && window[1].Open > window[2].Close &&                  // 3rd black opens within 2nd black's rb                  input.Open < window[1].Open && input.Open > window[1].Close &&                  // 1st black closes under prior candle's high                  window[3].High > window[2].Close &&                  // three declining                  window[2].Close > window[1].Close &&                  // three declining                  window[1].Close > input.Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeBlackCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeBlackCrows.cs,ComputeNextValue,The following statement contains a magic number: for (var i = 2; i >= 0; i--)              {                  _shadowVeryShortPeriodTotal[i] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[i]) -                                                    GetCandleRange(CandleSettingType.ShadowVeryShort' window[i + _shadowVeryShortAveragePeriod]);              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeBlackCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeBlackCrows.cs,Reset,The following statement contains a magic number: _shadowVeryShortPeriodTotal = new decimal[3];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,GapSideBySideWhite,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\GapSideBySideWhite.cs,ComputeNextValue,The following statement contains a magic number: if (                  ( // upside or downside gap between the 1st candle and both the next 2 candles                    (GetRealBodyGapUp(window[1]' window[2]) && GetRealBodyGapUp(input' window[2]))                    ||                    (GetRealBodyGapDown(window[1]' window[2]) && GetRealBodyGapDown(input' window[2]))                  ) &&                  // 2nd: white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd: white                  GetCandleColor(input) == CandleColor.White &&                  // same size 2 and 3                  GetRealBody(input) >= GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1]) &&                  GetRealBody(input) <= GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1]) &&                  // same open 2 and 3                  input.Open >= window[1].Open - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1]) &&                  input.Open <= window[1].Open + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1])                )                  value = GetRealBodyGapUp(window[1]' window[2]) ? 1m : -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,GapSideBySideWhite,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\GapSideBySideWhite.cs,ComputeNextValue,The following statement contains a magic number: if (                  ( // upside or downside gap between the 1st candle and both the next 2 candles                    (GetRealBodyGapUp(window[1]' window[2]) && GetRealBodyGapUp(input' window[2]))                    ||                    (GetRealBodyGapDown(window[1]' window[2]) && GetRealBodyGapDown(input' window[2]))                  ) &&                  // 2nd: white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd: white                  GetCandleColor(input) == CandleColor.White &&                  // same size 2 and 3                  GetRealBody(input) >= GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1]) &&                  GetRealBody(input) <= GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1]) &&                  // same open 2 and 3                  input.Open >= window[1].Open - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1]) &&                  input.Open <= window[1].Open + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1])                )                  value = GetRealBodyGapUp(window[1]' window[2]) ? 1m : -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,GapSideBySideWhite,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\GapSideBySideWhite.cs,ComputeNextValue,The following statement contains a magic number: if (                  ( // upside or downside gap between the 1st candle and both the next 2 candles                    (GetRealBodyGapUp(window[1]' window[2]) && GetRealBodyGapUp(input' window[2]))                    ||                    (GetRealBodyGapDown(window[1]' window[2]) && GetRealBodyGapDown(input' window[2]))                  ) &&                  // 2nd: white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd: white                  GetCandleColor(input) == CandleColor.White &&                  // same size 2 and 3                  GetRealBody(input) >= GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1]) &&                  GetRealBody(input) <= GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1]) &&                  // same open 2 and 3                  input.Open >= window[1].Open - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1]) &&                  input.Open <= window[1].Open + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1])                )                  value = GetRealBodyGapUp(window[1]' window[2]) ? 1m : -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,GapSideBySideWhite,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\GapSideBySideWhite.cs,ComputeNextValue,The following statement contains a magic number: if (                  ( // upside or downside gap between the 1st candle and both the next 2 candles                    (GetRealBodyGapUp(window[1]' window[2]) && GetRealBodyGapUp(input' window[2]))                    ||                    (GetRealBodyGapDown(window[1]' window[2]) && GetRealBodyGapDown(input' window[2]))                  ) &&                  // 2nd: white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd: white                  GetCandleColor(input) == CandleColor.White &&                  // same size 2 and 3                  GetRealBody(input) >= GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1]) &&                  GetRealBody(input) <= GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1]) &&                  // same open 2 and 3                  input.Open >= window[1].Open - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1]) &&                  input.Open <= window[1].Open + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1])                )                  value = GetRealBodyGapUp(window[1]' window[2]) ? 1m : -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,GapSideBySideWhite,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\GapSideBySideWhite.cs,ComputeNextValue,The following statement contains a magic number: if (                  ( // upside or downside gap between the 1st candle and both the next 2 candles                    (GetRealBodyGapUp(window[1]' window[2]) && GetRealBodyGapUp(input' window[2]))                    ||                    (GetRealBodyGapDown(window[1]' window[2]) && GetRealBodyGapDown(input' window[2]))                  ) &&                  // 2nd: white                  GetCandleColor(window[1]) == CandleColor.White &&                  // 3rd: white                  GetCandleColor(input) == CandleColor.White &&                  // same size 2 and 3                  GetRealBody(input) >= GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1]) &&                  GetRealBody(input) <= GetRealBody(window[1]) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal' window[1]) &&                  // same open 2 and 3                  input.Open >= window[1].Open - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1]) &&                  input.Open <= window[1].Open + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal' window[1])                )                  value = GetRealBodyGapUp(window[1]' window[2]) ? 1m : -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeInside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeInside.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod - 2 && Samples < Period - 2)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    if (Samples >= Period - _bodyShortAveragePeriod - 1 && Samples < Period - 1)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeInside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeInside.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod - 2 && Samples < Period - 2)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' input);                  }                    if (Samples >= Period - _bodyShortAveragePeriod - 1 && Samples < Period - 1)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeInside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeInside.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      engulfed by 1st                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  Math.Min(window[1].Close' window[1].Open) > Math.Min(window[2].Close' window[2].Open) &&                  // 3rd: opposite to 1st                  ((GetCandleColor(window[2]) == CandleColor.White && GetCandleColor(input) == CandleColor.Black && input.Close < window[2].Open) ||                    //      and closing out                    (GetCandleColor(window[2]) == CandleColor.Black && GetCandleColor(input) == CandleColor.White && input.Close > window[2].Open)                  )                )                  value = -(int)GetCandleColor(window[2]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeInside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeInside.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      engulfed by 1st                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  Math.Min(window[1].Close' window[1].Open) > Math.Min(window[2].Close' window[2].Open) &&                  // 3rd: opposite to 1st                  ((GetCandleColor(window[2]) == CandleColor.White && GetCandleColor(input) == CandleColor.Black && input.Close < window[2].Open) ||                    //      and closing out                    (GetCandleColor(window[2]) == CandleColor.Black && GetCandleColor(input) == CandleColor.White && input.Close > window[2].Open)                  )                )                  value = -(int)GetCandleColor(window[2]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeInside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeInside.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      engulfed by 1st                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  Math.Min(window[1].Close' window[1].Open) > Math.Min(window[2].Close' window[2].Open) &&                  // 3rd: opposite to 1st                  ((GetCandleColor(window[2]) == CandleColor.White && GetCandleColor(input) == CandleColor.Black && input.Close < window[2].Open) ||                    //      and closing out                    (GetCandleColor(window[2]) == CandleColor.Black && GetCandleColor(input) == CandleColor.White && input.Close > window[2].Open)                  )                )                  value = -(int)GetCandleColor(window[2]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeInside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeInside.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      engulfed by 1st                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  Math.Min(window[1].Close' window[1].Open) > Math.Min(window[2].Close' window[2].Open) &&                  // 3rd: opposite to 1st                  ((GetCandleColor(window[2]) == CandleColor.White && GetCandleColor(input) == CandleColor.Black && input.Close < window[2].Open) ||                    //      and closing out                    (GetCandleColor(window[2]) == CandleColor.Black && GetCandleColor(input) == CandleColor.White && input.Close > window[2].Open)                  )                )                  value = -(int)GetCandleColor(window[2]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeInside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeInside.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      engulfed by 1st                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  Math.Min(window[1].Close' window[1].Open) > Math.Min(window[2].Close' window[2].Open) &&                  // 3rd: opposite to 1st                  ((GetCandleColor(window[2]) == CandleColor.White && GetCandleColor(input) == CandleColor.Black && input.Close < window[2].Open) ||                    //      and closing out                    (GetCandleColor(window[2]) == CandleColor.Black && GetCandleColor(input) == CandleColor.White && input.Close > window[2].Open)                  )                )                  value = -(int)GetCandleColor(window[2]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeInside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeInside.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      engulfed by 1st                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  Math.Min(window[1].Close' window[1].Open) > Math.Min(window[2].Close' window[2].Open) &&                  // 3rd: opposite to 1st                  ((GetCandleColor(window[2]) == CandleColor.White && GetCandleColor(input) == CandleColor.Black && input.Close < window[2].Open) ||                    //      and closing out                    (GetCandleColor(window[2]) == CandleColor.Black && GetCandleColor(input) == CandleColor.White && input.Close > window[2].Open)                  )                )                  value = -(int)GetCandleColor(window[2]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeInside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeInside.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      engulfed by 1st                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  Math.Min(window[1].Close' window[1].Open) > Math.Min(window[2].Close' window[2].Open) &&                  // 3rd: opposite to 1st                  ((GetCandleColor(window[2]) == CandleColor.White && GetCandleColor(input) == CandleColor.Black && input.Close < window[2].Open) ||                    //      and closing out                    (GetCandleColor(window[2]) == CandleColor.Black && GetCandleColor(input) == CandleColor.White && input.Close > window[2].Open)                  )                )                  value = -(int)GetCandleColor(window[2]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeInside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeInside.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      engulfed by 1st                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  Math.Min(window[1].Close' window[1].Open) > Math.Min(window[2].Close' window[2].Open) &&                  // 3rd: opposite to 1st                  ((GetCandleColor(window[2]) == CandleColor.White && GetCandleColor(input) == CandleColor.Black && input.Close < window[2].Open) ||                    //      and closing out                    (GetCandleColor(window[2]) == CandleColor.Black && GetCandleColor(input) == CandleColor.White && input.Close > window[2].Open)                  )                )                  value = -(int)GetCandleColor(window[2]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeInside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeInside.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      engulfed by 1st                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  Math.Min(window[1].Close' window[1].Open) > Math.Min(window[2].Close' window[2].Open) &&                  // 3rd: opposite to 1st                  ((GetCandleColor(window[2]) == CandleColor.White && GetCandleColor(input) == CandleColor.Black && input.Close < window[2].Open) ||                    //      and closing out                    (GetCandleColor(window[2]) == CandleColor.Black && GetCandleColor(input) == CandleColor.White && input.Close > window[2].Open)                  )                )                  value = -(int)GetCandleColor(window[2]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeInside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeInside.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      engulfed by 1st                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  Math.Min(window[1].Close' window[1].Open) > Math.Min(window[2].Close' window[2].Open) &&                  // 3rd: opposite to 1st                  ((GetCandleColor(window[2]) == CandleColor.White && GetCandleColor(input) == CandleColor.Black && input.Close < window[2].Open) ||                    //      and closing out                    (GetCandleColor(window[2]) == CandleColor.Black && GetCandleColor(input) == CandleColor.White && input.Close > window[2].Open)                  )                )                  value = -(int)GetCandleColor(window[2]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeInside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeInside.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: short                  GetRealBody(window[1]) <= GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' window[1]) &&                  //      engulfed by 1st                  Math.Max(window[1].Close' window[1].Open) < Math.Max(window[2].Close' window[2].Open) &&                  Math.Min(window[1].Close' window[1].Open) > Math.Min(window[2].Close' window[2].Open) &&                  // 3rd: opposite to 1st                  ((GetCandleColor(window[2]) == CandleColor.White && GetCandleColor(input) == CandleColor.Black && input.Close < window[2].Open) ||                    //      and closing out                    (GetCandleColor(window[2]) == CandleColor.Black && GetCandleColor(input) == CandleColor.White && input.Close > window[2].Open)                  )                )                  value = -(int)GetCandleColor(window[2]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeInside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeInside.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[2 + _bodyLongAveragePeriod]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeInside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeInside.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[2 + _bodyLongAveragePeriod]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal[3] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[3]);                      _shadowVeryShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[2]);                      _shadowVeryShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal[3] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[3]);                      _shadowVeryShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[2]);                      _shadowVeryShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal[3] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[3]);                      _shadowVeryShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[2]);                      _shadowVeryShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal[3] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[3]);                      _shadowVeryShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[2]);                      _shadowVeryShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[3]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 4th black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: marubozu                  GetLowerShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  GetUpperShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  // 2nd: marubozu                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 3rd: opens gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  //      and has an upper shadow                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  //      that extends into the prior body                  window[1].High > window[2].Close &&                  // 4th: engulfs the 3rd including the shadows                  input.High > window[1].High && input.Low < window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[3]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 4th black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: marubozu                  GetLowerShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  GetUpperShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  // 2nd: marubozu                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 3rd: opens gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  //      and has an upper shadow                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  //      that extends into the prior body                  window[1].High > window[2].Close &&                  // 4th: engulfs the 3rd including the shadows                  input.High > window[1].High && input.Low < window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[3]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 4th black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: marubozu                  GetLowerShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  GetUpperShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  // 2nd: marubozu                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 3rd: opens gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  //      and has an upper shadow                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  //      that extends into the prior body                  window[1].High > window[2].Close &&                  // 4th: engulfs the 3rd including the shadows                  input.High > window[1].High && input.Low < window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[3]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 4th black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: marubozu                  GetLowerShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  GetUpperShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  // 2nd: marubozu                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 3rd: opens gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  //      and has an upper shadow                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  //      that extends into the prior body                  window[1].High > window[2].Close &&                  // 4th: engulfs the 3rd including the shadows                  input.High > window[1].High && input.Low < window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[3]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 4th black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: marubozu                  GetLowerShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  GetUpperShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  // 2nd: marubozu                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 3rd: opens gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  //      and has an upper shadow                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  //      that extends into the prior body                  window[1].High > window[2].Close &&                  // 4th: engulfs the 3rd including the shadows                  input.High > window[1].High && input.Low < window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[3]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 4th black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: marubozu                  GetLowerShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  GetUpperShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  // 2nd: marubozu                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 3rd: opens gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  //      and has an upper shadow                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  //      that extends into the prior body                  window[1].High > window[2].Close &&                  // 4th: engulfs the 3rd including the shadows                  input.High > window[1].High && input.Low < window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[3]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 4th black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: marubozu                  GetLowerShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  GetUpperShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  // 2nd: marubozu                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 3rd: opens gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  //      and has an upper shadow                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  //      that extends into the prior body                  window[1].High > window[2].Close &&                  // 4th: engulfs the 3rd including the shadows                  input.High > window[1].High && input.Low < window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[3]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 4th black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: marubozu                  GetLowerShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  GetUpperShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  // 2nd: marubozu                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 3rd: opens gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  //      and has an upper shadow                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  //      that extends into the prior body                  window[1].High > window[2].Close &&                  // 4th: engulfs the 3rd including the shadows                  input.High > window[1].High && input.Low < window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[3]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 4th black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: marubozu                  GetLowerShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  GetUpperShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  // 2nd: marubozu                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 3rd: opens gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  //      and has an upper shadow                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  //      that extends into the prior body                  window[1].High > window[2].Close &&                  // 4th: engulfs the 3rd including the shadows                  input.High > window[1].High && input.Low < window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[3]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 4th black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: marubozu                  GetLowerShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  GetUpperShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  // 2nd: marubozu                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 3rd: opens gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  //      and has an upper shadow                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  //      that extends into the prior body                  window[1].High > window[2].Close &&                  // 4th: engulfs the 3rd including the shadows                  input.High > window[1].High && input.Low < window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[3]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 4th black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: marubozu                  GetLowerShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  GetUpperShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  // 2nd: marubozu                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 3rd: opens gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  //      and has an upper shadow                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  //      that extends into the prior body                  window[1].High > window[2].Close &&                  // 4th: engulfs the 3rd including the shadows                  input.High > window[1].High && input.Low < window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[3]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 4th black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: marubozu                  GetLowerShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  GetUpperShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  // 2nd: marubozu                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 3rd: opens gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  //      and has an upper shadow                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  //      that extends into the prior body                  window[1].High > window[2].Close &&                  // 4th: engulfs the 3rd including the shadows                  input.High > window[1].High && input.Low < window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[3]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 4th black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: marubozu                  GetLowerShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  GetUpperShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  // 2nd: marubozu                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 3rd: opens gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  //      and has an upper shadow                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  //      that extends into the prior body                  window[1].High > window[2].Close &&                  // 4th: engulfs the 3rd including the shadows                  input.High > window[1].High && input.Low < window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[3]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 4th black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: marubozu                  GetLowerShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  GetUpperShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  // 2nd: marubozu                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 3rd: opens gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  //      and has an upper shadow                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  //      that extends into the prior body                  window[1].High > window[2].Close &&                  // 4th: engulfs the 3rd including the shadows                  input.High > window[1].High && input.Low < window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[3]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 4th black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: marubozu                  GetLowerShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  GetUpperShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  // 2nd: marubozu                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 3rd: opens gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  //      and has an upper shadow                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  //      that extends into the prior body                  window[1].High > window[2].Close &&                  // 4th: engulfs the 3rd including the shadows                  input.High > window[1].High && input.Low < window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[3]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 4th black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: marubozu                  GetLowerShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  GetUpperShadow(window[3]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[3]' window[3]) &&                  // 2nd: marubozu                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 3rd: opens gapping down                  GetRealBodyGapDown(window[1]' window[2]) &&                  //      and has an upper shadow                  GetUpperShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  //      that extends into the prior body                  window[1].High > window[2].Close &&                  // 4th: engulfs the 3rd including the shadows                  input.High > window[1].High && input.Low < window[1].Low                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,ComputeNextValue,The following statement contains a magic number: for (var i = 3; i >= 1; i--)              {                  _shadowVeryShortPeriodTotal[i] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[i]) -                                                    GetCandleRange(CandleSettingType.ShadowVeryShort' window[i + _shadowVeryShortAveragePeriod]);              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ConcealedBabySwallow,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ConcealedBabySwallow.cs,Reset,The following statement contains a magic number: _shadowVeryShortPeriodTotal = new decimal[4];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[3] += GetCandleRange(CandleSettingType.Near' window[3]);                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[3] += GetCandleRange(CandleSettingType.Near' window[3]);                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[3] += GetCandleRange(CandleSettingType.Near' window[3]);                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[3] += GetCandleRange(CandleSettingType.Near' window[3]);                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: if (                  // three with same color                  GetCandleColor(window[3]) == GetCandleColor(window[2]) &&                  GetCandleColor(window[2]) == GetCandleColor(window[1]) &&                  // 4th opposite color                  (int)GetCandleColor(input) == -(int)GetCandleColor(window[1]) &&                  // 2nd opens within/near 1st rb                  window[2].Open >= Math.Min(window[3].Open' window[3].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  window[2].Open <= Math.Max(window[3].Open' window[3].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[3]' window[3]) &&                  // 3rd opens within/near 2nd rb                  window[1].Open >= Math.Min(window[2].Open' window[2].Close) - GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  window[1].Open <= Math.Max(window[2].Open' window[2].Close) + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  (                      (                          // if three white                          GetCandleColor(window[1]) == CandleColor.White &&                          // consecutive higher closes                          window[1].Close > window[2].Close && window[2].Close > window[3].Close &&                          // 4th opens above prior close                          input.Open > window[1].Close &&                          // 4th closes below 1st open                          input.Close < window[3].Open                      ) ||                      (                          // if three black                          GetCandleColor(window[1]) == CandleColor.Black &&                          // consecutive lower closes                          window[1].Close < window[2].Close && window[2].Close < window[3].Close &&                          // 4th opens below prior close                          input.Open < window[1].Close &&                          // 4th closes above 1st open                          input.Close > window[3].Open                      )                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: for (var i = 3; i >= 2; i--)              {                  _nearPeriodTotal[i] += GetCandleRange(CandleSettingType.Near' window[i]) -                                         GetCandleRange(CandleSettingType.Near' window[i + _nearAveragePeriod]);              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,ComputeNextValue,The following statement contains a magic number: for (var i = 3; i >= 2; i--)              {                  _nearPeriodTotal[i] += GetCandleRange(CandleSettingType.Near' window[i]) -                                         GetCandleRange(CandleSettingType.Near' window[i + _nearAveragePeriod]);              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeLineStrike,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeLineStrike.cs,Reset,The following statement contains a magic number: _nearPeriodTotal = new decimal[4];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Hikkake,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Hikkake.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= 3)                  {                      // copy here the pattern recognition code below                      // 1st + 2nd: lower high and higher low                      if (window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 3rd: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low)                            ||                            // (bear) 3rd: higher high and higher low                            (input.High > window[1].High && input.Low > window[1].Low)                          )                      )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int)Samples - 1;                      }                      else                          // search for confirmation if hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 2nd                              ((_patternResult > 0 && input.Close > window[(int)Samples - _patternIndex].High)                                ||                                // close lower than the low of 2nd                                (_patternResult < 0 && input.Close < window[(int)Samples - _patternIndex].Low)                              )                          )                          _patternIndex = 0;                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Hikkake,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Hikkake.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= 3)                  {                      // copy here the pattern recognition code below                      // 1st + 2nd: lower high and higher low                      if (window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 3rd: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low)                            ||                            // (bear) 3rd: higher high and higher low                            (input.High > window[1].High && input.Low > window[1].Low)                          )                      )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int)Samples - 1;                      }                      else                          // search for confirmation if hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 2nd                              ((_patternResult > 0 && input.Close > window[(int)Samples - _patternIndex].High)                                ||                                // close lower than the low of 2nd                                (_patternResult < 0 && input.Close < window[(int)Samples - _patternIndex].Low)                              )                          )                          _patternIndex = 0;                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Hikkake,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Hikkake.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= 3)                  {                      // copy here the pattern recognition code below                      // 1st + 2nd: lower high and higher low                      if (window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 3rd: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low)                            ||                            // (bear) 3rd: higher high and higher low                            (input.High > window[1].High && input.Low > window[1].Low)                          )                      )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int)Samples - 1;                      }                      else                          // search for confirmation if hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 2nd                              ((_patternResult > 0 && input.Close > window[(int)Samples - _patternIndex].High)                                ||                                // close lower than the low of 2nd                                (_patternResult < 0 && input.Close < window[(int)Samples - _patternIndex].Low)                              )                          )                          _patternIndex = 0;                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Hikkake,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Hikkake.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= 3)                  {                      // copy here the pattern recognition code below                      // 1st + 2nd: lower high and higher low                      if (window[1].High < window[2].High && window[1].Low > window[2].Low &&                          // (bull) 3rd: lower high and lower low                          ((input.High < window[1].High && input.Low < window[1].Low)                            ||                            // (bear) 3rd: higher high and higher low                            (input.High > window[1].High && input.Low > window[1].Low)                          )                      )                      {                          _patternResult = (input.High < window[1].High ? 1 : -1);                          _patternIndex = (int)Samples - 1;                      }                      else                          // search for confirmation if hikkake was no more than 3 bars ago                          if (Samples <= _patternIndex + 4 &&                              // close higher than the high of 2nd                              ((_patternResult > 0 && input.Close > window[(int)Samples - _patternIndex].High)                                ||                                // close lower than the low of 2nd                                (_patternResult < 0 && input.Close < window[(int)Samples - _patternIndex].Low)                              )                          )                          _patternIndex = 0;                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Hikkake,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Hikkake.cs,ComputeNextValue,The following statement contains a magic number: if (window[1].High < window[2].High && window[1].Low > window[2].Low &&                  // (bull) 3rd: lower high and lower low                  ((input.High < window[1].High && input.Low < window[1].Low)                   ||                   // (bear) 3rd: higher high and higher low                   (input.High > window[1].High && input.Low > window[1].Low)                      )                  )              {                  _patternResult = (input.High < window[1].High ? 1 : -1);                  _patternIndex = (int) Samples - 1;                  value = _patternResult;              }              else              {                  // search for confirmation if hikkake was no more than 3 bars ago                  if (Samples <= _patternIndex + 4 &&                      // close higher than the high of 2nd                      ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                       ||                       // close lower than the low of 2nd                       (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low)                          )                      )                  {                      value = _patternResult + (_patternResult > 0 ? 1 : -1);                      _patternIndex = 0;                  }                  else                      value = 0;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Hikkake,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Hikkake.cs,ComputeNextValue,The following statement contains a magic number: if (window[1].High < window[2].High && window[1].Low > window[2].Low &&                  // (bull) 3rd: lower high and lower low                  ((input.High < window[1].High && input.Low < window[1].Low)                   ||                   // (bear) 3rd: higher high and higher low                   (input.High > window[1].High && input.Low > window[1].Low)                      )                  )              {                  _patternResult = (input.High < window[1].High ? 1 : -1);                  _patternIndex = (int) Samples - 1;                  value = _patternResult;              }              else              {                  // search for confirmation if hikkake was no more than 3 bars ago                  if (Samples <= _patternIndex + 4 &&                      // close higher than the high of 2nd                      ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                       ||                       // close lower than the low of 2nd                       (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low)                          )                      )                  {                      value = _patternResult + (_patternResult > 0 ? 1 : -1);                      _patternIndex = 0;                  }                  else                      value = 0;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Hikkake,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Hikkake.cs,ComputeNextValue,The following statement contains a magic number: if (window[1].High < window[2].High && window[1].Low > window[2].Low &&                  // (bull) 3rd: lower high and lower low                  ((input.High < window[1].High && input.Low < window[1].Low)                   ||                   // (bear) 3rd: higher high and higher low                   (input.High > window[1].High && input.Low > window[1].Low)                      )                  )              {                  _patternResult = (input.High < window[1].High ? 1 : -1);                  _patternIndex = (int) Samples - 1;                  value = _patternResult;              }              else              {                  // search for confirmation if hikkake was no more than 3 bars ago                  if (Samples <= _patternIndex + 4 &&                      // close higher than the high of 2nd                      ((_patternResult > 0 && input.Close > window[(int) Samples - _patternIndex].High)                       ||                       // close lower than the low of 2nd                       (_patternResult < 0 && input.Close < window[(int) Samples - _patternIndex].Low)                          )                      )                  {                      value = _patternResult + (_patternResult > 0 ? 1 : -1);                      _patternIndex = 0;                  }                  else                      value = 0;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeOutside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeOutside.cs,ComputeNextValue,The following statement contains a magic number: if (                 (                    // white engulfs black                    GetCandleColor(window[1]) == CandleColor.White && GetCandleColor(window[2]) == CandleColor.Black &&                    window[1].Close > window[2].Open && window[1].Open < window[2].Close &&                    // third candle higher                    input.Close > window[1].Close                  )                  ||                  (                    // black engulfs white                    GetCandleColor(window[1]) == CandleColor.Black && GetCandleColor(window[2]) == CandleColor.White &&                    window[1].Open > window[2].Close && window[1].Close < window[2].Open &&                    // third candle lower                    input.Close < window[1].Close                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeOutside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeOutside.cs,ComputeNextValue,The following statement contains a magic number: if (                 (                    // white engulfs black                    GetCandleColor(window[1]) == CandleColor.White && GetCandleColor(window[2]) == CandleColor.Black &&                    window[1].Close > window[2].Open && window[1].Open < window[2].Close &&                    // third candle higher                    input.Close > window[1].Close                  )                  ||                  (                    // black engulfs white                    GetCandleColor(window[1]) == CandleColor.Black && GetCandleColor(window[2]) == CandleColor.White &&                    window[1].Open > window[2].Close && window[1].Close < window[2].Open &&                    // third candle lower                    input.Close < window[1].Close                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeOutside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeOutside.cs,ComputeNextValue,The following statement contains a magic number: if (                 (                    // white engulfs black                    GetCandleColor(window[1]) == CandleColor.White && GetCandleColor(window[2]) == CandleColor.Black &&                    window[1].Close > window[2].Open && window[1].Open < window[2].Close &&                    // third candle higher                    input.Close > window[1].Close                  )                  ||                  (                    // black engulfs white                    GetCandleColor(window[1]) == CandleColor.Black && GetCandleColor(window[2]) == CandleColor.White &&                    window[1].Open > window[2].Close && window[1].Close < window[2].Open &&                    // third candle lower                    input.Close < window[1].Close                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeOutside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeOutside.cs,ComputeNextValue,The following statement contains a magic number: if (                 (                    // white engulfs black                    GetCandleColor(window[1]) == CandleColor.White && GetCandleColor(window[2]) == CandleColor.Black &&                    window[1].Close > window[2].Open && window[1].Open < window[2].Close &&                    // third candle higher                    input.Close > window[1].Close                  )                  ||                  (                    // black engulfs white                    GetCandleColor(window[1]) == CandleColor.Black && GetCandleColor(window[2]) == CandleColor.White &&                    window[1].Open > window[2].Close && window[1].Close < window[2].Open &&                    // third candle lower                    input.Close < window[1].Close                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeOutside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeOutside.cs,ComputeNextValue,The following statement contains a magic number: if (                 (                    // white engulfs black                    GetCandleColor(window[1]) == CandleColor.White && GetCandleColor(window[2]) == CandleColor.Black &&                    window[1].Close > window[2].Open && window[1].Open < window[2].Close &&                    // third candle higher                    input.Close > window[1].Close                  )                  ||                  (                    // black engulfs white                    GetCandleColor(window[1]) == CandleColor.Black && GetCandleColor(window[2]) == CandleColor.White &&                    window[1].Open > window[2].Close && window[1].Close < window[2].Open &&                    // third candle lower                    input.Close < window[1].Close                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeOutside,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeOutside.cs,ComputeNextValue,The following statement contains a magic number: if (                 (                    // white engulfs black                    GetCandleColor(window[1]) == CandleColor.White && GetCandleColor(window[2]) == CandleColor.Black &&                    window[1].Close > window[2].Open && window[1].Open < window[2].Close &&                    // third candle higher                    input.Close > window[1].Close                  )                  ||                  (                    // black engulfs white                    GetCandleColor(window[1]) == CandleColor.Black && GetCandleColor(window[2]) == CandleColor.White &&                    window[1].Open > window[2].Close && window[1].Close < window[2].Open &&                    // third candle lower                    input.Close < window[1].Close                  )                )                  value = (int)GetCandleColor(window[1]);              else                  value = 0;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,Counterattack,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\Counterattack.cs,Reset,The following statement contains a magic number: _bodyLongPeriodTotal = new decimal[2];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]);                  }                    if (Samples >= Period - _shadowLongAveragePeriod)                  {                      _shadowLongPeriodTotal += GetCandleRange(CandleSettingType.ShadowLong' window[2]);                  }                    if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                      _shadowVeryShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowVeryShort' input);                  }                    if (Samples >= Period - _bodyShortAveragePeriod)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]);                  }                    if (Samples >= Period - _shadowLongAveragePeriod)                  {                      _shadowLongPeriodTotal += GetCandleRange(CandleSettingType.ShadowLong' window[2]);                  }                    if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                      _shadowVeryShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowVeryShort' input);                  }                    if (Samples >= Period - _bodyShortAveragePeriod)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      with long lower shadow                  GetLowerShadow(window[2]) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' window[2]) &&                  // 2nd: smaller candle                  GetRealBody(window[1]) < GetRealBody(window[2]) &&                  //      that opens higher but within 1st range                  window[1].Open > window[2].Close && window[1].Open <= window[2].High &&                  //      and trades lower than 1st close                  window[1].Low < window[2].Close &&                  //      but not lower than 1st low                  window[1].Low >= window[2].Low &&                  //      and has a lower shadow                  GetLowerShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd: small marubozu                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  //      engulfed by prior candle's range                  input.Low > window[1].Low && input.High < window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      with long lower shadow                  GetLowerShadow(window[2]) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' window[2]) &&                  // 2nd: smaller candle                  GetRealBody(window[1]) < GetRealBody(window[2]) &&                  //      that opens higher but within 1st range                  window[1].Open > window[2].Close && window[1].Open <= window[2].High &&                  //      and trades lower than 1st close                  window[1].Low < window[2].Close &&                  //      but not lower than 1st low                  window[1].Low >= window[2].Low &&                  //      and has a lower shadow                  GetLowerShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd: small marubozu                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  //      engulfed by prior candle's range                  input.Low > window[1].Low && input.High < window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      with long lower shadow                  GetLowerShadow(window[2]) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' window[2]) &&                  // 2nd: smaller candle                  GetRealBody(window[1]) < GetRealBody(window[2]) &&                  //      that opens higher but within 1st range                  window[1].Open > window[2].Close && window[1].Open <= window[2].High &&                  //      and trades lower than 1st close                  window[1].Low < window[2].Close &&                  //      but not lower than 1st low                  window[1].Low >= window[2].Low &&                  //      and has a lower shadow                  GetLowerShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd: small marubozu                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  //      engulfed by prior candle's range                  input.Low > window[1].Low && input.High < window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      with long lower shadow                  GetLowerShadow(window[2]) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' window[2]) &&                  // 2nd: smaller candle                  GetRealBody(window[1]) < GetRealBody(window[2]) &&                  //      that opens higher but within 1st range                  window[1].Open > window[2].Close && window[1].Open <= window[2].High &&                  //      and trades lower than 1st close                  window[1].Low < window[2].Close &&                  //      but not lower than 1st low                  window[1].Low >= window[2].Low &&                  //      and has a lower shadow                  GetLowerShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd: small marubozu                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  //      engulfed by prior candle's range                  input.Low > window[1].Low && input.High < window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      with long lower shadow                  GetLowerShadow(window[2]) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' window[2]) &&                  // 2nd: smaller candle                  GetRealBody(window[1]) < GetRealBody(window[2]) &&                  //      that opens higher but within 1st range                  window[1].Open > window[2].Close && window[1].Open <= window[2].High &&                  //      and trades lower than 1st close                  window[1].Low < window[2].Close &&                  //      but not lower than 1st low                  window[1].Low >= window[2].Low &&                  //      and has a lower shadow                  GetLowerShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd: small marubozu                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  //      engulfed by prior candle's range                  input.Low > window[1].Low && input.High < window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      with long lower shadow                  GetLowerShadow(window[2]) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' window[2]) &&                  // 2nd: smaller candle                  GetRealBody(window[1]) < GetRealBody(window[2]) &&                  //      that opens higher but within 1st range                  window[1].Open > window[2].Close && window[1].Open <= window[2].High &&                  //      and trades lower than 1st close                  window[1].Low < window[2].Close &&                  //      but not lower than 1st low                  window[1].Low >= window[2].Low &&                  //      and has a lower shadow                  GetLowerShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd: small marubozu                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  //      engulfed by prior candle's range                  input.Low > window[1].Low && input.High < window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      with long lower shadow                  GetLowerShadow(window[2]) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' window[2]) &&                  // 2nd: smaller candle                  GetRealBody(window[1]) < GetRealBody(window[2]) &&                  //      that opens higher but within 1st range                  window[1].Open > window[2].Close && window[1].Open <= window[2].High &&                  //      and trades lower than 1st close                  window[1].Low < window[2].Close &&                  //      but not lower than 1st low                  window[1].Low >= window[2].Low &&                  //      and has a lower shadow                  GetLowerShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd: small marubozu                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  //      engulfed by prior candle's range                  input.Low > window[1].Low && input.High < window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      with long lower shadow                  GetLowerShadow(window[2]) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' window[2]) &&                  // 2nd: smaller candle                  GetRealBody(window[1]) < GetRealBody(window[2]) &&                  //      that opens higher but within 1st range                  window[1].Open > window[2].Close && window[1].Open <= window[2].High &&                  //      and trades lower than 1st close                  window[1].Low < window[2].Close &&                  //      but not lower than 1st low                  window[1].Low >= window[2].Low &&                  //      and has a lower shadow                  GetLowerShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd: small marubozu                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  //      engulfed by prior candle's range                  input.Low > window[1].Low && input.High < window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      with long lower shadow                  GetLowerShadow(window[2]) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' window[2]) &&                  // 2nd: smaller candle                  GetRealBody(window[1]) < GetRealBody(window[2]) &&                  //      that opens higher but within 1st range                  window[1].Open > window[2].Close && window[1].Open <= window[2].High &&                  //      and trades lower than 1st close                  window[1].Low < window[2].Close &&                  //      but not lower than 1st low                  window[1].Low >= window[2].Low &&                  //      and has a lower shadow                  GetLowerShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd: small marubozu                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  //      engulfed by prior candle's range                  input.Low > window[1].Low && input.High < window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // 1st: long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  //      with long lower shadow                  GetLowerShadow(window[2]) > GetCandleAverage(CandleSettingType.ShadowLong' _shadowLongPeriodTotal' window[2]) &&                  // 2nd: smaller candle                  GetRealBody(window[1]) < GetRealBody(window[2]) &&                  //      that opens higher but within 1st range                  window[1].Open > window[2].Close && window[1].Open <= window[2].High &&                  //      and trades lower than 1st close                  window[1].Low < window[2].Close &&                  //      but not lower than 1st low                  window[1].Low >= window[2].Low &&                  //      and has a lower shadow                  GetLowerShadow(window[1]) > GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd: small marubozu                  GetRealBody(input) < GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input) &&                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  //      engulfed by prior candle's range                  input.Low > window[1].Low && input.High < window[1].High                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[2 + _bodyLongAveragePeriod]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[2 + _bodyLongAveragePeriod]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,ComputeNextValue,The following statement contains a magic number: _shadowLongPeriodTotal += GetCandleRange(CandleSettingType.ShadowLong' window[2]) -                                        GetCandleRange(CandleSettingType.ShadowLong' window[2 + _shadowLongAveragePeriod]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,ComputeNextValue,The following statement contains a magic number: _shadowLongPeriodTotal += GetCandleRange(CandleSettingType.ShadowLong' window[2]) -                                        GetCandleRange(CandleSettingType.ShadowLong' window[2 + _shadowLongAveragePeriod]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeStarsInSouth,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeStarsInSouth.cs,Reset,The following statement contains a magic number: _shadowVeryShortPeriodTotal = new decimal[2];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[2]);                      _shadowVeryShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                      _shadowVeryShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowVeryShort' input);                  }                    if (Samples >= Period - _equalAveragePeriod)                  {                      _equalPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _equalPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[2]);                      _shadowVeryShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                      _shadowVeryShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowVeryShort' input);                  }                    if (Samples >= Period - _equalAveragePeriod)                  {                      _equalPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _equalPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[2]);                      _shadowVeryShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                      _shadowVeryShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowVeryShort' input);                  }                    if (Samples >= Period - _equalAveragePeriod)                  {                      _equalPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _equalPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[2]);                      _shadowVeryShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                      _shadowVeryShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowVeryShort' input);                  }                    if (Samples >= Period - _equalAveragePeriod)                  {                      _equalPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _equalPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // three declining                  window[2].Close > window[1].Close &&                  window[1].Close > input.Close &&                  // 2nd black opens very close to 1st close                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  window[1].Open >= window[2].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  // 3rd black opens very close to 2nd close                   input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1]) &&                  input.Open >= window[1].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // three declining                  window[2].Close > window[1].Close &&                  window[1].Close > input.Close &&                  // 2nd black opens very close to 1st close                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  window[1].Open >= window[2].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  // 3rd black opens very close to 2nd close                   input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1]) &&                  input.Open >= window[1].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // three declining                  window[2].Close > window[1].Close &&                  window[1].Close > input.Close &&                  // 2nd black opens very close to 1st close                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  window[1].Open >= window[2].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  // 3rd black opens very close to 2nd close                   input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1]) &&                  input.Open >= window[1].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // three declining                  window[2].Close > window[1].Close &&                  window[1].Close > input.Close &&                  // 2nd black opens very close to 1st close                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  window[1].Open >= window[2].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  // 3rd black opens very close to 2nd close                   input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1]) &&                  input.Open >= window[1].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // three declining                  window[2].Close > window[1].Close &&                  window[1].Close > input.Close &&                  // 2nd black opens very close to 1st close                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  window[1].Open >= window[2].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  // 3rd black opens very close to 2nd close                   input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1]) &&                  input.Open >= window[1].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // three declining                  window[2].Close > window[1].Close &&                  window[1].Close > input.Close &&                  // 2nd black opens very close to 1st close                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  window[1].Open >= window[2].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  // 3rd black opens very close to 2nd close                   input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1]) &&                  input.Open >= window[1].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // three declining                  window[2].Close > window[1].Close &&                  window[1].Close > input.Close &&                  // 2nd black opens very close to 1st close                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  window[1].Open >= window[2].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  // 3rd black opens very close to 2nd close                   input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1]) &&                  input.Open >= window[1].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // three declining                  window[2].Close > window[1].Close &&                  window[1].Close > input.Close &&                  // 2nd black opens very close to 1st close                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  window[1].Open >= window[2].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  // 3rd black opens very close to 2nd close                   input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1]) &&                  input.Open >= window[1].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // three declining                  window[2].Close > window[1].Close &&                  window[1].Close > input.Close &&                  // 2nd black opens very close to 1st close                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  window[1].Open >= window[2].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  // 3rd black opens very close to 2nd close                   input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1]) &&                  input.Open >= window[1].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // three declining                  window[2].Close > window[1].Close &&                  window[1].Close > input.Close &&                  // 2nd black opens very close to 1st close                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  window[1].Open >= window[2].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  // 3rd black opens very close to 2nd close                   input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1]) &&                  input.Open >= window[1].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st black                  GetCandleColor(window[2]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd black                  GetCandleColor(window[1]) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd black                  GetCandleColor(input) == CandleColor.Black &&                  // very short lower shadow                  GetLowerShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // three declining                  window[2].Close > window[1].Close &&                  window[1].Close > input.Close &&                  // 2nd black opens very close to 1st close                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  window[1].Open >= window[2].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[2]' window[2]) &&                  // 3rd black opens very close to 2nd close                   input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1]) &&                  input.Open >= window[1].Close - GetCandleAverage(CandleSettingType.Equal' _equalPeriodTotal[1]' window[1])                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The following statement contains a magic number: for (var i = 2; i >= 0; i--)              {                  _shadowVeryShortPeriodTotal[i] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[i]) -                                                    GetCandleRange(CandleSettingType.ShadowVeryShort' window[i + _shadowVeryShortAveragePeriod]);              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,ComputeNextValue,The following statement contains a magic number: for (var i = 2; i >= 1; i--)              {                  _equalPeriodTotal[i] += GetCandleRange(CandleSettingType.Equal' window[i]) -                                         GetCandleRange(CandleSettingType.Equal' window[i + _equalAveragePeriod]);              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,Reset,The following statement contains a magic number: _shadowVeryShortPeriodTotal = new decimal[3];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,IdenticalThreeCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\IdenticalThreeCrows.cs,Reset,The following statement contains a magic number: _equalPeriodTotal = new decimal[3];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[2]);                      _shadowVeryShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                      _shadowVeryShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowVeryShort' input);                  }                    if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _nearPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    if (Samples >= Period - _farAveragePeriod)                  {                      _farPeriodTotal[2] += GetCandleRange(CandleSettingType.Far' window[2]);                      _farPeriodTotal[1] += GetCandleRange(CandleSettingType.Far' window[1]);                  }                    if (Samples >= Period - _bodyShortAveragePeriod)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[2]);                      _shadowVeryShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                      _shadowVeryShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowVeryShort' input);                  }                    if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _nearPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    if (Samples >= Period - _farAveragePeriod)                  {                      _farPeriodTotal[2] += GetCandleRange(CandleSettingType.Far' window[2]);                      _farPeriodTotal[1] += GetCandleRange(CandleSettingType.Far' window[1]);                  }                    if (Samples >= Period - _bodyShortAveragePeriod)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[2]);                      _shadowVeryShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                      _shadowVeryShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowVeryShort' input);                  }                    if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _nearPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    if (Samples >= Period - _farAveragePeriod)                  {                      _farPeriodTotal[2] += GetCandleRange(CandleSettingType.Far' window[2]);                      _farPeriodTotal[1] += GetCandleRange(CandleSettingType.Far' window[1]);                  }                    if (Samples >= Period - _bodyShortAveragePeriod)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[2]);                      _shadowVeryShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                      _shadowVeryShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowVeryShort' input);                  }                    if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _nearPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    if (Samples >= Period - _farAveragePeriod)                  {                      _farPeriodTotal[2] += GetCandleRange(CandleSettingType.Far' window[2]);                      _farPeriodTotal[1] += GetCandleRange(CandleSettingType.Far' window[1]);                  }                    if (Samples >= Period - _bodyShortAveragePeriod)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[2]);                      _shadowVeryShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                      _shadowVeryShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowVeryShort' input);                  }                    if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _nearPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    if (Samples >= Period - _farAveragePeriod)                  {                      _farPeriodTotal[2] += GetCandleRange(CandleSettingType.Far' window[2]);                      _farPeriodTotal[1] += GetCandleRange(CandleSettingType.Far' window[1]);                  }                    if (Samples >= Period - _bodyShortAveragePeriod)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _shadowVeryShortAveragePeriod)                  {                      _shadowVeryShortPeriodTotal[2] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[2]);                      _shadowVeryShortPeriodTotal[1] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[1]);                      _shadowVeryShortPeriodTotal[0] += GetCandleRange(CandleSettingType.ShadowVeryShort' input);                  }                    if (Samples >= Period - _nearAveragePeriod)                  {                      _nearPeriodTotal[2] += GetCandleRange(CandleSettingType.Near' window[2]);                      _nearPeriodTotal[1] += GetCandleRange(CandleSettingType.Near' window[1]);                  }                    if (Samples >= Period - _farAveragePeriod)                  {                      _farPeriodTotal[2] += GetCandleRange(CandleSettingType.Far' window[2]);                      _farPeriodTotal[1] += GetCandleRange(CandleSettingType.Far' window[1]);                  }                    if (Samples >= Period - _bodyShortAveragePeriod)                  {                      _bodyShortPeriodTotal += GetCandleRange(CandleSettingType.BodyShort' input);                  }                    return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 2nd not far shorter than 1st                  GetRealBody(window[1]) > GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                  // 3rd not far shorter than 2nd                  GetRealBody(input) > GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1]) &&                  // not short real body                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 2nd not far shorter than 1st                  GetRealBody(window[1]) > GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                  // 3rd not far shorter than 2nd                  GetRealBody(input) > GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1]) &&                  // not short real body                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 2nd not far shorter than 1st                  GetRealBody(window[1]) > GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                  // 3rd not far shorter than 2nd                  GetRealBody(input) > GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1]) &&                  // not short real body                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 2nd not far shorter than 1st                  GetRealBody(window[1]) > GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                  // 3rd not far shorter than 2nd                  GetRealBody(input) > GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1]) &&                  // not short real body                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 2nd not far shorter than 1st                  GetRealBody(window[1]) > GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                  // 3rd not far shorter than 2nd                  GetRealBody(input) > GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1]) &&                  // not short real body                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 2nd not far shorter than 1st                  GetRealBody(window[1]) > GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                  // 3rd not far shorter than 2nd                  GetRealBody(input) > GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1]) &&                  // not short real body                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 2nd not far shorter than 1st                  GetRealBody(window[1]) > GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                  // 3rd not far shorter than 2nd                  GetRealBody(input) > GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1]) &&                  // not short real body                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 2nd not far shorter than 1st                  GetRealBody(window[1]) > GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                  // 3rd not far shorter than 2nd                  GetRealBody(input) > GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1]) &&                  // not short real body                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 2nd not far shorter than 1st                  GetRealBody(window[1]) > GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                  // 3rd not far shorter than 2nd                  GetRealBody(input) > GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1]) &&                  // not short real body                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 2nd not far shorter than 1st                  GetRealBody(window[1]) > GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                  // 3rd not far shorter than 2nd                  GetRealBody(input) > GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1]) &&                  // not short real body                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 2nd not far shorter than 1st                  GetRealBody(window[1]) > GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                  // 3rd not far shorter than 2nd                  GetRealBody(input) > GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1]) &&                  // not short real body                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st white                  GetCandleColor(window[2]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[2]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[2]' window[2]) &&                  // 2nd white                  GetCandleColor(window[1]) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(window[1]) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[1]' window[1]) &&                  // 3rd white                  GetCandleColor(input) == CandleColor.White &&                  // very short upper shadow                  GetUpperShadow(input) < GetCandleAverage(CandleSettingType.ShadowVeryShort' _shadowVeryShortPeriodTotal[0]' input) &&                  // consecutive higher closes                  input.Close > window[1].Close && window[1].Close > window[2].Close &&                  // 2nd opens within/near 1st real body                  window[1].Open > window[2].Open &&                  window[1].Open <= window[2].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[2]' window[2]) &&                  // 3rd opens within/near 2nd real body                  input.Open > window[1].Open &&                  input.Open <= window[1].Close + GetCandleAverage(CandleSettingType.Near' _nearPeriodTotal[1]' window[1]) &&                  // 2nd not far shorter than 1st                  GetRealBody(window[1]) > GetRealBody(window[2]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[2]' window[2]) &&                  // 3rd not far shorter than 2nd                  GetRealBody(input) > GetRealBody(window[1]) - GetCandleAverage(CandleSettingType.Far' _farPeriodTotal[1]' window[1]) &&                  // not short real body                  GetRealBody(input) > GetCandleAverage(CandleSettingType.BodyShort' _bodyShortPeriodTotal' input)                )                  value = 1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: for (var i = 2; i >= 0; i--)              {                  _shadowVeryShortPeriodTotal[i] += GetCandleRange(CandleSettingType.ShadowVeryShort' window[i]) -                                                    GetCandleRange(CandleSettingType.ShadowVeryShort' window[i + _shadowVeryShortAveragePeriod]);              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: for (var i = 2; i >= 1; i--)              {                  _farPeriodTotal[i] += GetCandleRange(CandleSettingType.Far' window[i]) -                                        GetCandleRange(CandleSettingType.Far' window[i + _farAveragePeriod]);              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,ComputeNextValue,The following statement contains a magic number: for (var i = 2; i >= 1; i--)              {                  _nearPeriodTotal[i] += GetCandleRange(CandleSettingType.Near' window[i]) -                                         GetCandleRange(CandleSettingType.Near' window[i + _nearAveragePeriod]);              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,Reset,The following statement contains a magic number: _shadowVeryShortPeriodTotal = new decimal[3];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,Reset,The following statement contains a magic number: _nearPeriodTotal = new decimal[3];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,ThreeWhiteSoldiers,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\ThreeWhiteSoldiers.cs,Reset,The following statement contains a magic number: _farPeriodTotal = new decimal[3];
Magic Number,QuantConnect.Indicators.CandlestickPatterns,TwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TwoCrows.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod - 2 && Samples < Period - 2)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' input);                  }                  return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,TwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TwoCrows.cs,ComputeNextValue,The following statement contains a magic number: if (!IsReady)              {                  if (Samples >= Period - _bodyLongAveragePeriod - 2 && Samples < Period - 2)                  {                      _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' input);                  }                  return 0m;              }
Magic Number,QuantConnect.Indicators.CandlestickPatterns,TwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TwoCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: white                  GetCandleColor(window[2]) == CandleColor.White &&                  //      long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: black                  GetCandleColor(input) == CandleColor.Black &&                  //      opening within 2nd rb                  input.Open < window[1].Open && input.Open > window[1].Close &&                  //      closing within 1st rb                  input.Close > window[2].Open && input.Close < window[2].Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,TwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TwoCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: white                  GetCandleColor(window[2]) == CandleColor.White &&                  //      long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: black                  GetCandleColor(input) == CandleColor.Black &&                  //      opening within 2nd rb                  input.Open < window[1].Open && input.Open > window[1].Close &&                  //      closing within 1st rb                  input.Close > window[2].Open && input.Close < window[2].Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,TwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TwoCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: white                  GetCandleColor(window[2]) == CandleColor.White &&                  //      long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: black                  GetCandleColor(input) == CandleColor.Black &&                  //      opening within 2nd rb                  input.Open < window[1].Open && input.Open > window[1].Close &&                  //      closing within 1st rb                  input.Close > window[2].Open && input.Close < window[2].Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,TwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TwoCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: white                  GetCandleColor(window[2]) == CandleColor.White &&                  //      long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: black                  GetCandleColor(input) == CandleColor.Black &&                  //      opening within 2nd rb                  input.Open < window[1].Open && input.Open > window[1].Close &&                  //      closing within 1st rb                  input.Close > window[2].Open && input.Close < window[2].Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,TwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TwoCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: white                  GetCandleColor(window[2]) == CandleColor.White &&                  //      long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: black                  GetCandleColor(input) == CandleColor.Black &&                  //      opening within 2nd rb                  input.Open < window[1].Open && input.Open > window[1].Close &&                  //      closing within 1st rb                  input.Close > window[2].Open && input.Close < window[2].Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,TwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TwoCrows.cs,ComputeNextValue,The following statement contains a magic number: if (                  // 1st: white                  GetCandleColor(window[2]) == CandleColor.White &&                  //      long                  GetRealBody(window[2]) > GetCandleAverage(CandleSettingType.BodyLong' _bodyLongPeriodTotal' window[2]) &&                  // 2nd: black                  GetCandleColor(window[1]) == CandleColor.Black &&                  //      gapping up                  GetRealBodyGapUp(window[1]' window[2]) &&                  // 3rd: black                  GetCandleColor(input) == CandleColor.Black &&                  //      opening within 2nd rb                  input.Open < window[1].Open && input.Open > window[1].Close &&                  //      closing within 1st rb                  input.Close > window[2].Open && input.Close < window[2].Close                )                  value = -1m;              else                  value = 0m;
Magic Number,QuantConnect.Indicators.CandlestickPatterns,TwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TwoCrows.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[2 + _bodyLongAveragePeriod]);
Magic Number,QuantConnect.Indicators.CandlestickPatterns,TwoCrows,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\TwoCrows.cs,ComputeNextValue,The following statement contains a magic number: _bodyLongPeriodTotal += GetCandleRange(CandleSettingType.BodyLong' window[2]) -                                      GetCandleRange(CandleSettingType.BodyLong' window[2 + _bodyLongAveragePeriod]);
Duplicate Code,QuantConnect.Indicators.CandlestickPatterns,HikkakeModified,C:\repos\QuantConnect_Lean\Indicators\CandlestickPatterns\HikkakeModified.cs,ComputeNextValue,The method contains a code clone-set at the following line numbers (starting from the method definition): ((12' 31)' (57' 76))
