Implementation smell,Namespace,Class,File,Method,Description
Complex Method,QuantConnect.AlgorithmFactory,Loader,C:\repos\QuantConnect_Lean\AlgorithmFactory\Loader.cs,TryCreateILAlgorithm,Cyclomatic complexity of the method is 10
Long Parameter List,QuantConnect.AlgorithmFactory.Python.Wrappers,AlgorithmPythonWrapper,C:\repos\QuantConnect_Lean\AlgorithmFactory\Python\Wrappers\AlgorithmPythonWrapper.cs,AddSecurity,The method has 7 parameters. Parameters: securityType' symbol' resolution' market' fillDataForward' leverage' extendedMarketHours
Long Identifier,QuantConnect.AlgorithmFactory,Loader,C:\repos\QuantConnect_Lean\AlgorithmFactory\Loader.cs,Loader,The length of the parameter multipleTypeNameResolverFunction is 32.
Long Identifier,QuantConnect.AlgorithmFactory,Loader,C:\repos\QuantConnect_Lean\AlgorithmFactory\Loader.cs,,The length of the parameter _multipleTypeNameResolverFunction is 33.
Long Statement,QuantConnect.AlgorithmFactory,Loader,C:\repos\QuantConnect_Lean\AlgorithmFactory\Loader.cs,TryCreatePythonAlgorithm,The length of the statement  "                        errorMessage = "Loader.TryCreatePythonAlgorithm(): Unable to import python module " + assemblyPath + ". Check for errors in the python scripts."; " is 145.
Long Statement,QuantConnect.AlgorithmFactory,Loader,C:\repos\QuantConnect_Lean\AlgorithmFactory\Loader.cs,TryCreateILAlgorithm,The length of the statement  "                if (directoryName != null && directoryName.TrimEnd(Path.DirectorySeparatorChar) != AppDomain.CurrentDomain.BaseDirectory.TrimEnd(Path.DirectorySeparatorChar)) " is 158.
Long Statement,QuantConnect.AlgorithmFactory,Loader,C:\repos\QuantConnect_Lean\AlgorithmFactory\Loader.cs,TryCreateILAlgorithm,The length of the statement  "                        errorMessage = "Please verify algorithm type name matches the algorithm name in the configuration file. Unable to resolve multiple algorithm types to a single type."; " is 166.
Long Statement,QuantConnect.AlgorithmFactory.Python.Wrappers,AlgorithmPythonWrapper,C:\repos\QuantConnect_Lean\AlgorithmFactory\Python\Wrappers\AlgorithmPythonWrapper.cs,AddSecurity,The length of the statement  "            return _baseAlgorithm.AddSecurity(securityType' symbol' resolution' market' fillDataForward' leverage' extendedMarketHours); " is 124.
Magic Number,QuantConnect.AlgorithmFactory,Loader,C:\repos\QuantConnect_Lean\AlgorithmFactory\Loader.cs,TryCreateILAlgorithm,The following statement contains a magic number: try              {                  byte[] debugInformationBytes = null;                                    // if the assembly is located in the base directory then don't bother loading the pdbs                  // manually' they'll be loaded automatically by the .NET runtime.                  var directoryName = new FileInfo(assemblyPath).DirectoryName;                  if (directoryName != null && directoryName.TrimEnd(Path.DirectorySeparatorChar) != AppDomain.CurrentDomain.BaseDirectory.TrimEnd(Path.DirectorySeparatorChar))                  {                      // see if the pdb exists                      var mdbFilename = assemblyPath + ".mdb";                      var pdbFilename = assemblyPath.Substring(0' assemblyPath.Length - 4) + ".pdb";                      if (File.Exists(pdbFilename))                      {                          debugInformationBytes = File.ReadAllBytes(pdbFilename);                      }                      // see if the mdb exists                      if (File.Exists(mdbFilename))                      {                          debugInformationBytes = File.ReadAllBytes(mdbFilename);                      }                  }                    //Load the assembly:                  Assembly assembly;                  if (debugInformationBytes == null)                  {                      Log.Trace("Loader.TryCreateILAlgorithm(): Loading only the algorithm assembly");                      assembly = Assembly.LoadFrom(assemblyPath);                  }                  else                  {                      Log.Trace("Loader.TryCreateILAlgorithm(): Loading debug information with algorithm");                      var assemblyBytes = File.ReadAllBytes(assemblyPath);                      assembly = Assembly.Load(assemblyBytes' debugInformationBytes);                  }                  if (assembly == null)                  {                      errorMessage = "Assembly is null.";                      Log.Error("Loader.TryCreateILAlgorithm(): Assembly is null");                      return false;                  }                    //Get the list of extention classes in the library:                   var types = GetExtendedTypeNames(assembly);                  Log.Debug("Loader.TryCreateILAlgorithm(): Assembly types: " + string.Join("'"' types));                    //No extensions' nothing to load.                  if (types.Count == 0)                  {                      errorMessage = "Algorithm type was not found.";                      Log.Error("Loader.TryCreateILAlgorithm(): Types array empty' no algorithm type found.");                      return false;                  }                    if (types.Count > 1)                  {                      // reshuffle type[0] to the resolved typename                      types[0] = _multipleTypeNameResolverFunction.Invoke(types);                        if (string.IsNullOrEmpty(types[0]))                      {                          errorMessage = "Please verify algorithm type name matches the algorithm name in the configuration file. Unable to resolve multiple algorithm types to a single type.";                          Log.Error("Loader.TryCreateILAlgorithm(): Failed resolving multiple algorithm types to a single type.");                          return false;                      }                  }                  //Load the assembly into this AppDomain:                  algorithmInstance = (IAlgorithm)assembly.CreateInstance(types[0]' true);                    if (algorithmInstance != null)                  {                      Log.Trace("Loader.TryCreateILAlgorithm(): Loaded " + algorithmInstance.GetType().Name);                  }                }              catch (ReflectionTypeLoadException err)              {                  Log.Error(err);                  Log.Error("Loader.TryCreateILAlgorithm(1): " + err.LoaderExceptions[0]);                  if (err.InnerException != null) errorMessage = err.InnerException.Message;              }              catch (Exception err)              {                  Log.Error(err);                  if (err.InnerException != null) errorMessage = err.InnerException.Message;              }
