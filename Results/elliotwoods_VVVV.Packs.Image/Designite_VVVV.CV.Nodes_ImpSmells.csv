Implementation smell,Namespace,Class,File,Method,Description
Complex Method,VVVV.CV.Nodes,FindBoardInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\FindBoardInstance.cs,Process,Cyclomatic complexity of the method is 17
Complex Method,VVVV.CV.Nodes,AsImageRawNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Sources\AsImageRaw.cs,Update,Cyclomatic complexity of the method is 10
Complex Method,VVVV.CV.Nodes,SolvePnPNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\SolvePnP.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,VVVV.CV.Nodes.Calibration,CalibrateCameraNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\CalibrateCamera.cs,Evaluate,Cyclomatic complexity of the method is 9
Complex Method,VVVV.CV.Nodes.Features,FeatureSetSplit,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Features\FeatureSetSplit.cs,Evaluate,Cyclomatic complexity of the method is 10
Complex Method,VVVV.CV.Nodes.StructuredLight,SpaceNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\DataViewNode.cs,Update,Cyclomatic complexity of the method is 11
Complex Method,VVVV.CV.Nodes.StructuredLight,DecodeInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\DecodeNode.cs,Process,Cyclomatic complexity of the method is 9
Complex Method,VVVV.CV.Nodes.StructuredLight,DecodeNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\DecodeNode.cs,Update,Cyclomatic complexity of the method is 14
Long Statement,VVVV.CV.Nodes,StereoCalibrateNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\StereoCalibrate.cs,Evaluate,The length of the statement  "					CameraCalibration.StereoCalibrate(objectPoints' imagePoints1' imagePoints2' intrinsics1' intrinsics2' imageSize' flags' termCrit' out interCameraExtrinsics' out foundamentalMatrix' out essentialMatrix); " is 202.
Long Statement,VVVV.CV.Nodes,FindBoardInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\FindBoardInstance.cs,Process,The length of the statement  "				var lowResPoints = CameraCalibration.FindChessboardCorners(FLowResolution.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH); " is 147.
Long Statement,VVVV.CV.Nodes,FindBoardInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\FindBoardInstance.cs,Process,The length of the statement  "					points = CameraCalibration.FindChessboardCorners(FCropped.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH); " is 131.
Long Statement,VVVV.CV.Nodes,FindBoardInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\FindBoardInstance.cs,Process,The length of the statement  "				points = CameraCalibration.FindChessboardCorners(FGrayscale.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH); " is 133.
Long Statement,VVVV.CV.Nodes,IntrinsicsSplitNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\IntrinsicsSplitNode.cs,Evaluate,The length of the statement  "					FPinOutSensorSize[i] = new Vector2D((double)FPinInIntrinsics[i].SensorSize.Width' (double)FPinInIntrinsics[i].SensorSize.Height); " is 129.
Long Statement,VVVV.CV.Nodes,TransformInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\Transform.cs,Process,The length of the statement  "                    CvInvoke.cvWarpAffine(FInput.CvMat' FOutput.CvMat' matrix.Ptr' (int)Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS' new MCvScalar(0' 0' 0)); " is 135.
Long Statement,VVVV.CV.Nodes,SolvePnPNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\SolvePnP.cs,Evaluate,The length of the statement  "						ExtrinsicCameraParameters extrinsics = CameraCalibration.FindExtrinsicCameraParams2(MatrixUtils.ObjectPoints(FPinInObject[i]' useVVVVCoords)' MatrixUtils.ImagePoints(FPinInImage[i])' FPinInIntrinsics[i].intrinsics); " is 215.
Long Statement,VVVV.CV.Nodes,AsTextureInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Destinations\AsTextureInstance.cs,UpdateTexture,The length of the statement  "                				    Memory.Copy(rect.Data.DataPointer.Move(rect.Pitch * i)' FBufferConverted.FrontImage.Data.Move(FBufferConverted.ImageAttributes.Stride * i)' (uint)FBufferConverted.ImageAttributes.Stride);" is 187.
Long Statement,VVVV.CV.Nodes,AdaptiveThresholdInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\AdaptiveThreshold.cs,Process,The length of the statement  "				CvInvoke.cvAdaptiveThreshold(FOutput.Image.CvMat' FOutput.Image.CvMat' FMaximum' FMethod' FType' (int)FBlockSize' FConstant); " is 125.
Long Statement,VVVV.CV.Nodes,FrameDifferenceInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\FrameDifference.cs,Process,The length of the statement  "					Status = "Cannot perform threshold on image type " + FInput.ImageAttributes.ColorFormat.ToString() + ". Can only perform threshold on L8";" is 138.
Long Statement,VVVV.CV.Nodes.Calibration,CalibrateCameraNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\CalibrateCamera.cs,Evaluate,The length of the statement  "					FPinOutError[0] = CameraCalibration.CalibrateCamera(objectPoints' imagePoints' imageSize' intrinsicParam' flags' out extrinsicsPerView); " is 136.
Long Statement,VVVV.CV.Nodes.Features.Criteria,ImageRegion,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Features\Criteria\Position.cs,Accept,The length of the statement  "            return (x > Position.x - Scale.x * 0.5 && x < Position.x + Scale.x * 0.5 && y > Position.y - Scale.y * 0.5 && y < Position.y + Scale.y * 0.5); " is 142.
Long Statement,VVVV.CV.Nodes.Tracking,TrackingInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Tracking\DetectObject.cs,Process,The length of the statement  "				trackingObject.Scale = VMath.Map(new Vector2D(rectangle.Width' rectangle.Height)' FMinimumSourceXY.x' maximumSourceXY.x' 0' " is 123.
Complex Conditional,VVVV.CV.Nodes.StructuredLight.Payload,PayloadNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\Payload\PayloadNode.cs,Evaluate,The conditional expression  "FWidth.IsChanged || FHeight.IsChanged || FMode.IsChanged || FBalanced.IsChanged"  is complex.
Virtual Method Call from Constructor,VVVV.CV.Nodes.Features,FeatureSet,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Features\FeatureSet.cs,FeatureSet,The constructor "FeatureSet" calls a virtual method "Accept".
Virtual Method Call from Constructor,VVVV.CV.Nodes.StructuredLight,IPayload,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\Payload\IPayload.cs,IPayload,The constructor "IPayload" calls a virtual method "GetMaxIndex".
Virtual Method Call from Constructor,VVVV.CV.Nodes.StructuredLight,IPayload,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\Payload\IPayload.cs,IPayload,The constructor "IPayload" calls a virtual method "GetMaxIndex".
Virtual Method Call from Constructor,VVVV.CV.Nodes.StructuredLight,IPayload,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\Payload\IPayload.cs,IPayload,The constructor "IPayload" calls a virtual method "Render".
Empty Catch Block,VVVV.CV.Nodes,FrameDifferenceInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\FrameDifference.cs,Process,The method has an empty catch block.
Magic Number,VVVV.CV.Nodes,ManageDependencies,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\ManageDependencies.cs,Start,The following statement contains a magic number: bool isx64 = IntPtr.Size == 8;
Magic Number,VVVV.CV.Nodes,Homography,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\Homography.cs,Evaluate,The following statement contains a magic number: if (FSource.IsChanged || FTarget.IsChanged)              {                  SpreadMax = Math.Max(FSource.SliceCount' FTarget.SliceCount);                  FTransformOut.SliceCount = SpreadMax;                  FStatus.SliceCount = SpreadMax;                    for (int slice = 0; slice < SpreadMax; slice++)                  {                      try                      {                          var source = FSource[slice];                          var target = FTarget[slice];                            if (source.SliceCount < 4 || target.SliceCount < 4)                          {                              throw(new Exception("You need at least 4 source and 4 target points"));                          }                            int sliceSpreadMax = Math.Max(source.SliceCount' target.SliceCount);                          PointF[] sourcePoints = new PointF[sliceSpreadMax];                          PointF[] targetPoints = new PointF[sliceSpreadMax];                            for (int i = 0; i < sliceSpreadMax; i++)                          {                              sourcePoints[i].X = (float)source[i].x;                              sourcePoints[i].Y = (float)source[i].y;                                targetPoints[i].X = (float)target[i].x;                              targetPoints[i].Y = (float)target[i].y;                          }                            var matrix = CameraCalibration.FindHomography(sourcePoints' targetPoints' Emgu.CV.CvEnum.HOMOGRAPHY_METHOD.LMEDS' 0.0);                            FTransformOut[slice] = new Matrix4x4(matrix[0' 0]' matrix[1' 0]' 0.0' matrix[2' 0]'                                                               matrix[0' 1]' matrix[1' 1]' 0.0' matrix[2' 1]'                                                               0.0' 0.0' 1.0' 0.0'                                                               matrix[0' 2]' matrix[1' 2]' 0.0' matrix[2' 2]);                            FStatus[slice] = "OK";                      }                      catch (Exception e)                      {                          FTransformOut[slice] = VMath.IdentityMatrix;                          FStatus[slice] = e.Message;                      }                  }              }
Magic Number,VVVV.CV.Nodes,Homography,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\Homography.cs,Evaluate,The following statement contains a magic number: if (FSource.IsChanged || FTarget.IsChanged)              {                  SpreadMax = Math.Max(FSource.SliceCount' FTarget.SliceCount);                  FTransformOut.SliceCount = SpreadMax;                  FStatus.SliceCount = SpreadMax;                    for (int slice = 0; slice < SpreadMax; slice++)                  {                      try                      {                          var source = FSource[slice];                          var target = FTarget[slice];                            if (source.SliceCount < 4 || target.SliceCount < 4)                          {                              throw(new Exception("You need at least 4 source and 4 target points"));                          }                            int sliceSpreadMax = Math.Max(source.SliceCount' target.SliceCount);                          PointF[] sourcePoints = new PointF[sliceSpreadMax];                          PointF[] targetPoints = new PointF[sliceSpreadMax];                            for (int i = 0; i < sliceSpreadMax; i++)                          {                              sourcePoints[i].X = (float)source[i].x;                              sourcePoints[i].Y = (float)source[i].y;                                targetPoints[i].X = (float)target[i].x;                              targetPoints[i].Y = (float)target[i].y;                          }                            var matrix = CameraCalibration.FindHomography(sourcePoints' targetPoints' Emgu.CV.CvEnum.HOMOGRAPHY_METHOD.LMEDS' 0.0);                            FTransformOut[slice] = new Matrix4x4(matrix[0' 0]' matrix[1' 0]' 0.0' matrix[2' 0]'                                                               matrix[0' 1]' matrix[1' 1]' 0.0' matrix[2' 1]'                                                               0.0' 0.0' 1.0' 0.0'                                                               matrix[0' 2]' matrix[1' 2]' 0.0' matrix[2' 2]);                            FStatus[slice] = "OK";                      }                      catch (Exception e)                      {                          FTransformOut[slice] = VMath.IdentityMatrix;                          FStatus[slice] = e.Message;                      }                  }              }
Magic Number,VVVV.CV.Nodes,Homography,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\Homography.cs,Evaluate,The following statement contains a magic number: if (FSource.IsChanged || FTarget.IsChanged)              {                  SpreadMax = Math.Max(FSource.SliceCount' FTarget.SliceCount);                  FTransformOut.SliceCount = SpreadMax;                  FStatus.SliceCount = SpreadMax;                    for (int slice = 0; slice < SpreadMax; slice++)                  {                      try                      {                          var source = FSource[slice];                          var target = FTarget[slice];                            if (source.SliceCount < 4 || target.SliceCount < 4)                          {                              throw(new Exception("You need at least 4 source and 4 target points"));                          }                            int sliceSpreadMax = Math.Max(source.SliceCount' target.SliceCount);                          PointF[] sourcePoints = new PointF[sliceSpreadMax];                          PointF[] targetPoints = new PointF[sliceSpreadMax];                            for (int i = 0; i < sliceSpreadMax; i++)                          {                              sourcePoints[i].X = (float)source[i].x;                              sourcePoints[i].Y = (float)source[i].y;                                targetPoints[i].X = (float)target[i].x;                              targetPoints[i].Y = (float)target[i].y;                          }                            var matrix = CameraCalibration.FindHomography(sourcePoints' targetPoints' Emgu.CV.CvEnum.HOMOGRAPHY_METHOD.LMEDS' 0.0);                            FTransformOut[slice] = new Matrix4x4(matrix[0' 0]' matrix[1' 0]' 0.0' matrix[2' 0]'                                                               matrix[0' 1]' matrix[1' 1]' 0.0' matrix[2' 1]'                                                               0.0' 0.0' 1.0' 0.0'                                                               matrix[0' 2]' matrix[1' 2]' 0.0' matrix[2' 2]);                            FStatus[slice] = "OK";                      }                      catch (Exception e)                      {                          FTransformOut[slice] = VMath.IdentityMatrix;                          FStatus[slice] = e.Message;                      }                  }              }
Magic Number,VVVV.CV.Nodes,Homography,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\Homography.cs,Evaluate,The following statement contains a magic number: if (FSource.IsChanged || FTarget.IsChanged)              {                  SpreadMax = Math.Max(FSource.SliceCount' FTarget.SliceCount);                  FTransformOut.SliceCount = SpreadMax;                  FStatus.SliceCount = SpreadMax;                    for (int slice = 0; slice < SpreadMax; slice++)                  {                      try                      {                          var source = FSource[slice];                          var target = FTarget[slice];                            if (source.SliceCount < 4 || target.SliceCount < 4)                          {                              throw(new Exception("You need at least 4 source and 4 target points"));                          }                            int sliceSpreadMax = Math.Max(source.SliceCount' target.SliceCount);                          PointF[] sourcePoints = new PointF[sliceSpreadMax];                          PointF[] targetPoints = new PointF[sliceSpreadMax];                            for (int i = 0; i < sliceSpreadMax; i++)                          {                              sourcePoints[i].X = (float)source[i].x;                              sourcePoints[i].Y = (float)source[i].y;                                targetPoints[i].X = (float)target[i].x;                              targetPoints[i].Y = (float)target[i].y;                          }                            var matrix = CameraCalibration.FindHomography(sourcePoints' targetPoints' Emgu.CV.CvEnum.HOMOGRAPHY_METHOD.LMEDS' 0.0);                            FTransformOut[slice] = new Matrix4x4(matrix[0' 0]' matrix[1' 0]' 0.0' matrix[2' 0]'                                                               matrix[0' 1]' matrix[1' 1]' 0.0' matrix[2' 1]'                                                               0.0' 0.0' 1.0' 0.0'                                                               matrix[0' 2]' matrix[1' 2]' 0.0' matrix[2' 2]);                            FStatus[slice] = "OK";                      }                      catch (Exception e)                      {                          FTransformOut[slice] = VMath.IdentityMatrix;                          FStatus[slice] = e.Message;                      }                  }              }
Magic Number,VVVV.CV.Nodes,Homography,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\Homography.cs,Evaluate,The following statement contains a magic number: if (FSource.IsChanged || FTarget.IsChanged)              {                  SpreadMax = Math.Max(FSource.SliceCount' FTarget.SliceCount);                  FTransformOut.SliceCount = SpreadMax;                  FStatus.SliceCount = SpreadMax;                    for (int slice = 0; slice < SpreadMax; slice++)                  {                      try                      {                          var source = FSource[slice];                          var target = FTarget[slice];                            if (source.SliceCount < 4 || target.SliceCount < 4)                          {                              throw(new Exception("You need at least 4 source and 4 target points"));                          }                            int sliceSpreadMax = Math.Max(source.SliceCount' target.SliceCount);                          PointF[] sourcePoints = new PointF[sliceSpreadMax];                          PointF[] targetPoints = new PointF[sliceSpreadMax];                            for (int i = 0; i < sliceSpreadMax; i++)                          {                              sourcePoints[i].X = (float)source[i].x;                              sourcePoints[i].Y = (float)source[i].y;                                targetPoints[i].X = (float)target[i].x;                              targetPoints[i].Y = (float)target[i].y;                          }                            var matrix = CameraCalibration.FindHomography(sourcePoints' targetPoints' Emgu.CV.CvEnum.HOMOGRAPHY_METHOD.LMEDS' 0.0);                            FTransformOut[slice] = new Matrix4x4(matrix[0' 0]' matrix[1' 0]' 0.0' matrix[2' 0]'                                                               matrix[0' 1]' matrix[1' 1]' 0.0' matrix[2' 1]'                                                               0.0' 0.0' 1.0' 0.0'                                                               matrix[0' 2]' matrix[1' 2]' 0.0' matrix[2' 2]);                            FStatus[slice] = "OK";                      }                      catch (Exception e)                      {                          FTransformOut[slice] = VMath.IdentityMatrix;                          FStatus[slice] = e.Message;                      }                  }              }
Magic Number,VVVV.CV.Nodes,Homography,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\Homography.cs,Evaluate,The following statement contains a magic number: if (FSource.IsChanged || FTarget.IsChanged)              {                  SpreadMax = Math.Max(FSource.SliceCount' FTarget.SliceCount);                  FTransformOut.SliceCount = SpreadMax;                  FStatus.SliceCount = SpreadMax;                    for (int slice = 0; slice < SpreadMax; slice++)                  {                      try                      {                          var source = FSource[slice];                          var target = FTarget[slice];                            if (source.SliceCount < 4 || target.SliceCount < 4)                          {                              throw(new Exception("You need at least 4 source and 4 target points"));                          }                            int sliceSpreadMax = Math.Max(source.SliceCount' target.SliceCount);                          PointF[] sourcePoints = new PointF[sliceSpreadMax];                          PointF[] targetPoints = new PointF[sliceSpreadMax];                            for (int i = 0; i < sliceSpreadMax; i++)                          {                              sourcePoints[i].X = (float)source[i].x;                              sourcePoints[i].Y = (float)source[i].y;                                targetPoints[i].X = (float)target[i].x;                              targetPoints[i].Y = (float)target[i].y;                          }                            var matrix = CameraCalibration.FindHomography(sourcePoints' targetPoints' Emgu.CV.CvEnum.HOMOGRAPHY_METHOD.LMEDS' 0.0);                            FTransformOut[slice] = new Matrix4x4(matrix[0' 0]' matrix[1' 0]' 0.0' matrix[2' 0]'                                                               matrix[0' 1]' matrix[1' 1]' 0.0' matrix[2' 1]'                                                               0.0' 0.0' 1.0' 0.0'                                                               matrix[0' 2]' matrix[1' 2]' 0.0' matrix[2' 2]);                            FStatus[slice] = "OK";                      }                      catch (Exception e)                      {                          FTransformOut[slice] = VMath.IdentityMatrix;                          FStatus[slice] = e.Message;                      }                  }              }
Magic Number,VVVV.CV.Nodes,Homography,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\Homography.cs,Evaluate,The following statement contains a magic number: if (FSource.IsChanged || FTarget.IsChanged)              {                  SpreadMax = Math.Max(FSource.SliceCount' FTarget.SliceCount);                  FTransformOut.SliceCount = SpreadMax;                  FStatus.SliceCount = SpreadMax;                    for (int slice = 0; slice < SpreadMax; slice++)                  {                      try                      {                          var source = FSource[slice];                          var target = FTarget[slice];                            if (source.SliceCount < 4 || target.SliceCount < 4)                          {                              throw(new Exception("You need at least 4 source and 4 target points"));                          }                            int sliceSpreadMax = Math.Max(source.SliceCount' target.SliceCount);                          PointF[] sourcePoints = new PointF[sliceSpreadMax];                          PointF[] targetPoints = new PointF[sliceSpreadMax];                            for (int i = 0; i < sliceSpreadMax; i++)                          {                              sourcePoints[i].X = (float)source[i].x;                              sourcePoints[i].Y = (float)source[i].y;                                targetPoints[i].X = (float)target[i].x;                              targetPoints[i].Y = (float)target[i].y;                          }                            var matrix = CameraCalibration.FindHomography(sourcePoints' targetPoints' Emgu.CV.CvEnum.HOMOGRAPHY_METHOD.LMEDS' 0.0);                            FTransformOut[slice] = new Matrix4x4(matrix[0' 0]' matrix[1' 0]' 0.0' matrix[2' 0]'                                                               matrix[0' 1]' matrix[1' 1]' 0.0' matrix[2' 1]'                                                               0.0' 0.0' 1.0' 0.0'                                                               matrix[0' 2]' matrix[1' 2]' 0.0' matrix[2' 2]);                            FStatus[slice] = "OK";                      }                      catch (Exception e)                      {                          FTransformOut[slice] = VMath.IdentityMatrix;                          FStatus[slice] = e.Message;                      }                  }              }
Magic Number,VVVV.CV.Nodes,Homography,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\Homography.cs,Evaluate,The following statement contains a magic number: if (FSource.IsChanged || FTarget.IsChanged)              {                  SpreadMax = Math.Max(FSource.SliceCount' FTarget.SliceCount);                  FTransformOut.SliceCount = SpreadMax;                  FStatus.SliceCount = SpreadMax;                    for (int slice = 0; slice < SpreadMax; slice++)                  {                      try                      {                          var source = FSource[slice];                          var target = FTarget[slice];                            if (source.SliceCount < 4 || target.SliceCount < 4)                          {                              throw(new Exception("You need at least 4 source and 4 target points"));                          }                            int sliceSpreadMax = Math.Max(source.SliceCount' target.SliceCount);                          PointF[] sourcePoints = new PointF[sliceSpreadMax];                          PointF[] targetPoints = new PointF[sliceSpreadMax];                            for (int i = 0; i < sliceSpreadMax; i++)                          {                              sourcePoints[i].X = (float)source[i].x;                              sourcePoints[i].Y = (float)source[i].y;                                targetPoints[i].X = (float)target[i].x;                              targetPoints[i].Y = (float)target[i].y;                          }                            var matrix = CameraCalibration.FindHomography(sourcePoints' targetPoints' Emgu.CV.CvEnum.HOMOGRAPHY_METHOD.LMEDS' 0.0);                            FTransformOut[slice] = new Matrix4x4(matrix[0' 0]' matrix[1' 0]' 0.0' matrix[2' 0]'                                                               matrix[0' 1]' matrix[1' 1]' 0.0' matrix[2' 1]'                                                               0.0' 0.0' 1.0' 0.0'                                                               matrix[0' 2]' matrix[1' 2]' 0.0' matrix[2' 2]);                            FStatus[slice] = "OK";                      }                      catch (Exception e)                      {                          FTransformOut[slice] = VMath.IdentityMatrix;                          FStatus[slice] = e.Message;                      }                  }              }
Magic Number,VVVV.CV.Nodes,StereoCalibrateNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\StereoCalibrate.cs,Evaluate,The following statement contains a magic number: if (FPinInDo[0])  			{  				int nPointsPerImage = FPinInObject.SliceCount;  				if (nPointsPerImage == 0)  				{  					FStatus[0] = "Insufficient points";  					return;  				}  				int nImages = Math.Max(FPinInImage1.SliceCount' FPinInImage2.SliceCount) / nPointsPerImage;    				CALIB_TYPE flags = CALIB_TYPE.DEFAULT;  				MCvTermCriteria termCrit = new MCvTermCriteria(100' 0.001);  				MCvPoint3D32f[][] objectPoints = new MCvPoint3D32f[nImages][];  				PointF[][] imagePoints1 = new PointF[nImages][];  				PointF[][] imagePoints2 = new PointF[nImages][];  				Size imageSize = new Size( (int) FPinInSensorSize[0].x' (int) FPinInSensorSize[0].y);  				ExtrinsicCameraParameters interCameraExtrinsics;  				Matrix<double> foundamentalMatrix;  				Matrix<double> essentialMatrix;  				IntrinsicCameraParameters intrinsics1 = FPinInIntrinsics1[0].intrinsics;  				IntrinsicCameraParameters intrinsics2 = FPinInIntrinsics2[0].intrinsics;    				imagePoints1 = MatrixUtils.ImagePoints(FPinInImage1' nPointsPerImage);  				imagePoints2 = MatrixUtils.ImagePoints(FPinInImage2' nPointsPerImage);    				for (int i=0; i<nImages; i++)  				{  					objectPoints[i] = MatrixUtils.ObjectPoints(FPinInObject' true);  				}    				try  				{  					CameraCalibration.StereoCalibrate(objectPoints' imagePoints1' imagePoints2' intrinsics1' intrinsics2' imageSize' flags' termCrit' out interCameraExtrinsics' out foundamentalMatrix' out essentialMatrix);    					Extrinsics extrinsics = new Extrinsics(interCameraExtrinsics);  					FPinOutExtrinsics[0] = extrinsics;  					FPinOutTransform[0] = extrinsics.Matrix;    					FPinOutSuccess[0] = true;  					FStatus[0] = "OK";  				}  				catch (Exception e)  {  					FPinOutSuccess[0] = false;  					FStatus[0] = e.Message;  				}  			}
Magic Number,VVVV.CV.Nodes,StereoCalibrateNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\StereoCalibrate.cs,Evaluate,The following statement contains a magic number: if (FPinInDo[0])  			{  				int nPointsPerImage = FPinInObject.SliceCount;  				if (nPointsPerImage == 0)  				{  					FStatus[0] = "Insufficient points";  					return;  				}  				int nImages = Math.Max(FPinInImage1.SliceCount' FPinInImage2.SliceCount) / nPointsPerImage;    				CALIB_TYPE flags = CALIB_TYPE.DEFAULT;  				MCvTermCriteria termCrit = new MCvTermCriteria(100' 0.001);  				MCvPoint3D32f[][] objectPoints = new MCvPoint3D32f[nImages][];  				PointF[][] imagePoints1 = new PointF[nImages][];  				PointF[][] imagePoints2 = new PointF[nImages][];  				Size imageSize = new Size( (int) FPinInSensorSize[0].x' (int) FPinInSensorSize[0].y);  				ExtrinsicCameraParameters interCameraExtrinsics;  				Matrix<double> foundamentalMatrix;  				Matrix<double> essentialMatrix;  				IntrinsicCameraParameters intrinsics1 = FPinInIntrinsics1[0].intrinsics;  				IntrinsicCameraParameters intrinsics2 = FPinInIntrinsics2[0].intrinsics;    				imagePoints1 = MatrixUtils.ImagePoints(FPinInImage1' nPointsPerImage);  				imagePoints2 = MatrixUtils.ImagePoints(FPinInImage2' nPointsPerImage);    				for (int i=0; i<nImages; i++)  				{  					objectPoints[i] = MatrixUtils.ObjectPoints(FPinInObject' true);  				}    				try  				{  					CameraCalibration.StereoCalibrate(objectPoints' imagePoints1' imagePoints2' intrinsics1' intrinsics2' imageSize' flags' termCrit' out interCameraExtrinsics' out foundamentalMatrix' out essentialMatrix);    					Extrinsics extrinsics = new Extrinsics(interCameraExtrinsics);  					FPinOutExtrinsics[0] = extrinsics;  					FPinOutTransform[0] = extrinsics.Matrix;    					FPinOutSuccess[0] = true;  					FStatus[0] = "OK";  				}  				catch (Exception e)  {  					FPinOutSuccess[0] = false;  					FStatus[0] = e.Message;  				}  			}
Magic Number,VVVV.CV.Nodes,FindBoardInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\FindBoardInstance.cs,Process,The following statement contains a magic number: if (TestAtLowResolution)  			{  				if (!FLowResolution.Allocated) {  					FLowResolution.Initialise(new Size(1024' 1024)' TColorFormat.L8);  				}  				CvInvoke.cvResize(FGrayscale.CvMat' FLowResolution.CvMat' INTER.CV_INTER_LINEAR);  				var lowResPoints = CameraCalibration.FindChessboardCorners(FLowResolution.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    				if (lowResPoints != null) {  					int minX = FGrayscale.Width;  					int minY = FGrayscale.Height;  					int maxX = 0;  					int maxY = 0;    					foreach(var point in lowResPoints)  					{  						if ((int)point.X > maxX)  							maxX = (int)point.X;    						if ((int)point.Y > maxY)  							maxY = (int)point.Y;    						if ((int)point.X < minX)  							minX = (int)point.X;    						if ((int)point.Y < minY)  							minY = (int)point.Y;  					}    					minX = minX * FGrayscale.Width / 1024;  					maxX = maxX * FGrayscale.Width / 1024;  					minY = minY * FGrayscale.Height / 1024;  					maxY = maxY * FGrayscale.Height / 1024;    					int boardResolutionMin = Math.Min(SizeNow.Width' SizeNow.Height);  					int strideX = (maxX - minX) / boardResolutionMin;  					int strideY = (maxY - minY) / boardResolutionMin;    					minX -= strideX * 2;  					maxX += strideX * 2;  					minY -= strideY * 2;  					maxY += strideY * 2;    					if (minX < 0)  					{  						minX = 0;  					}  					if (minY < 0)  					{  						minY = 0;  					}  					if (maxX > FGrayscale.Width - 1)  					{  						maxX = FGrayscale.Width - 1;  					}  					if (maxY > FGrayscale.Height - 1)  					{  						maxY = FGrayscale.Height - 1;  					}    					Rectangle rect = new Rectangle(minX' minY' maxX-minX' maxY-minY);    					CvInvoke.cvSetImageROI(FGrayscale.CvMat' rect);  					FCropped.Initialise(new Size(rect.Width' rect.Height)' TColorFormat.L8);  					CvInvoke.cvCopy(FGrayscale.CvMat' FCropped.CvMat' IntPtr.Zero);  					CvInvoke.cvResetImageROI(FGrayscale.CvMat);    					points = CameraCalibration.FindChessboardCorners(FCropped.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    					if (points != null)  					{  						for (int iPoint = 0; iPoint < points.Length; iPoint++)  						{  							points[iPoint].X += minX;  							points[iPoint].Y += minY;  						}  					}  				}  			} else {  				points = CameraCalibration.FindChessboardCorners(FGrayscale.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);  			}
Magic Number,VVVV.CV.Nodes,FindBoardInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\FindBoardInstance.cs,Process,The following statement contains a magic number: if (TestAtLowResolution)  			{  				if (!FLowResolution.Allocated) {  					FLowResolution.Initialise(new Size(1024' 1024)' TColorFormat.L8);  				}  				CvInvoke.cvResize(FGrayscale.CvMat' FLowResolution.CvMat' INTER.CV_INTER_LINEAR);  				var lowResPoints = CameraCalibration.FindChessboardCorners(FLowResolution.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    				if (lowResPoints != null) {  					int minX = FGrayscale.Width;  					int minY = FGrayscale.Height;  					int maxX = 0;  					int maxY = 0;    					foreach(var point in lowResPoints)  					{  						if ((int)point.X > maxX)  							maxX = (int)point.X;    						if ((int)point.Y > maxY)  							maxY = (int)point.Y;    						if ((int)point.X < minX)  							minX = (int)point.X;    						if ((int)point.Y < minY)  							minY = (int)point.Y;  					}    					minX = minX * FGrayscale.Width / 1024;  					maxX = maxX * FGrayscale.Width / 1024;  					minY = minY * FGrayscale.Height / 1024;  					maxY = maxY * FGrayscale.Height / 1024;    					int boardResolutionMin = Math.Min(SizeNow.Width' SizeNow.Height);  					int strideX = (maxX - minX) / boardResolutionMin;  					int strideY = (maxY - minY) / boardResolutionMin;    					minX -= strideX * 2;  					maxX += strideX * 2;  					minY -= strideY * 2;  					maxY += strideY * 2;    					if (minX < 0)  					{  						minX = 0;  					}  					if (minY < 0)  					{  						minY = 0;  					}  					if (maxX > FGrayscale.Width - 1)  					{  						maxX = FGrayscale.Width - 1;  					}  					if (maxY > FGrayscale.Height - 1)  					{  						maxY = FGrayscale.Height - 1;  					}    					Rectangle rect = new Rectangle(minX' minY' maxX-minX' maxY-minY);    					CvInvoke.cvSetImageROI(FGrayscale.CvMat' rect);  					FCropped.Initialise(new Size(rect.Width' rect.Height)' TColorFormat.L8);  					CvInvoke.cvCopy(FGrayscale.CvMat' FCropped.CvMat' IntPtr.Zero);  					CvInvoke.cvResetImageROI(FGrayscale.CvMat);    					points = CameraCalibration.FindChessboardCorners(FCropped.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    					if (points != null)  					{  						for (int iPoint = 0; iPoint < points.Length; iPoint++)  						{  							points[iPoint].X += minX;  							points[iPoint].Y += minY;  						}  					}  				}  			} else {  				points = CameraCalibration.FindChessboardCorners(FGrayscale.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);  			}
Magic Number,VVVV.CV.Nodes,FindBoardInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\FindBoardInstance.cs,Process,The following statement contains a magic number: if (TestAtLowResolution)  			{  				if (!FLowResolution.Allocated) {  					FLowResolution.Initialise(new Size(1024' 1024)' TColorFormat.L8);  				}  				CvInvoke.cvResize(FGrayscale.CvMat' FLowResolution.CvMat' INTER.CV_INTER_LINEAR);  				var lowResPoints = CameraCalibration.FindChessboardCorners(FLowResolution.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    				if (lowResPoints != null) {  					int minX = FGrayscale.Width;  					int minY = FGrayscale.Height;  					int maxX = 0;  					int maxY = 0;    					foreach(var point in lowResPoints)  					{  						if ((int)point.X > maxX)  							maxX = (int)point.X;    						if ((int)point.Y > maxY)  							maxY = (int)point.Y;    						if ((int)point.X < minX)  							minX = (int)point.X;    						if ((int)point.Y < minY)  							minY = (int)point.Y;  					}    					minX = minX * FGrayscale.Width / 1024;  					maxX = maxX * FGrayscale.Width / 1024;  					minY = minY * FGrayscale.Height / 1024;  					maxY = maxY * FGrayscale.Height / 1024;    					int boardResolutionMin = Math.Min(SizeNow.Width' SizeNow.Height);  					int strideX = (maxX - minX) / boardResolutionMin;  					int strideY = (maxY - minY) / boardResolutionMin;    					minX -= strideX * 2;  					maxX += strideX * 2;  					minY -= strideY * 2;  					maxY += strideY * 2;    					if (minX < 0)  					{  						minX = 0;  					}  					if (minY < 0)  					{  						minY = 0;  					}  					if (maxX > FGrayscale.Width - 1)  					{  						maxX = FGrayscale.Width - 1;  					}  					if (maxY > FGrayscale.Height - 1)  					{  						maxY = FGrayscale.Height - 1;  					}    					Rectangle rect = new Rectangle(minX' minY' maxX-minX' maxY-minY);    					CvInvoke.cvSetImageROI(FGrayscale.CvMat' rect);  					FCropped.Initialise(new Size(rect.Width' rect.Height)' TColorFormat.L8);  					CvInvoke.cvCopy(FGrayscale.CvMat' FCropped.CvMat' IntPtr.Zero);  					CvInvoke.cvResetImageROI(FGrayscale.CvMat);    					points = CameraCalibration.FindChessboardCorners(FCropped.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    					if (points != null)  					{  						for (int iPoint = 0; iPoint < points.Length; iPoint++)  						{  							points[iPoint].X += minX;  							points[iPoint].Y += minY;  						}  					}  				}  			} else {  				points = CameraCalibration.FindChessboardCorners(FGrayscale.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);  			}
Magic Number,VVVV.CV.Nodes,FindBoardInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\FindBoardInstance.cs,Process,The following statement contains a magic number: if (TestAtLowResolution)  			{  				if (!FLowResolution.Allocated) {  					FLowResolution.Initialise(new Size(1024' 1024)' TColorFormat.L8);  				}  				CvInvoke.cvResize(FGrayscale.CvMat' FLowResolution.CvMat' INTER.CV_INTER_LINEAR);  				var lowResPoints = CameraCalibration.FindChessboardCorners(FLowResolution.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    				if (lowResPoints != null) {  					int minX = FGrayscale.Width;  					int minY = FGrayscale.Height;  					int maxX = 0;  					int maxY = 0;    					foreach(var point in lowResPoints)  					{  						if ((int)point.X > maxX)  							maxX = (int)point.X;    						if ((int)point.Y > maxY)  							maxY = (int)point.Y;    						if ((int)point.X < minX)  							minX = (int)point.X;    						if ((int)point.Y < minY)  							minY = (int)point.Y;  					}    					minX = minX * FGrayscale.Width / 1024;  					maxX = maxX * FGrayscale.Width / 1024;  					minY = minY * FGrayscale.Height / 1024;  					maxY = maxY * FGrayscale.Height / 1024;    					int boardResolutionMin = Math.Min(SizeNow.Width' SizeNow.Height);  					int strideX = (maxX - minX) / boardResolutionMin;  					int strideY = (maxY - minY) / boardResolutionMin;    					minX -= strideX * 2;  					maxX += strideX * 2;  					minY -= strideY * 2;  					maxY += strideY * 2;    					if (minX < 0)  					{  						minX = 0;  					}  					if (minY < 0)  					{  						minY = 0;  					}  					if (maxX > FGrayscale.Width - 1)  					{  						maxX = FGrayscale.Width - 1;  					}  					if (maxY > FGrayscale.Height - 1)  					{  						maxY = FGrayscale.Height - 1;  					}    					Rectangle rect = new Rectangle(minX' minY' maxX-minX' maxY-minY);    					CvInvoke.cvSetImageROI(FGrayscale.CvMat' rect);  					FCropped.Initialise(new Size(rect.Width' rect.Height)' TColorFormat.L8);  					CvInvoke.cvCopy(FGrayscale.CvMat' FCropped.CvMat' IntPtr.Zero);  					CvInvoke.cvResetImageROI(FGrayscale.CvMat);    					points = CameraCalibration.FindChessboardCorners(FCropped.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    					if (points != null)  					{  						for (int iPoint = 0; iPoint < points.Length; iPoint++)  						{  							points[iPoint].X += minX;  							points[iPoint].Y += minY;  						}  					}  				}  			} else {  				points = CameraCalibration.FindChessboardCorners(FGrayscale.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);  			}
Magic Number,VVVV.CV.Nodes,FindBoardInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\FindBoardInstance.cs,Process,The following statement contains a magic number: if (TestAtLowResolution)  			{  				if (!FLowResolution.Allocated) {  					FLowResolution.Initialise(new Size(1024' 1024)' TColorFormat.L8);  				}  				CvInvoke.cvResize(FGrayscale.CvMat' FLowResolution.CvMat' INTER.CV_INTER_LINEAR);  				var lowResPoints = CameraCalibration.FindChessboardCorners(FLowResolution.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    				if (lowResPoints != null) {  					int minX = FGrayscale.Width;  					int minY = FGrayscale.Height;  					int maxX = 0;  					int maxY = 0;    					foreach(var point in lowResPoints)  					{  						if ((int)point.X > maxX)  							maxX = (int)point.X;    						if ((int)point.Y > maxY)  							maxY = (int)point.Y;    						if ((int)point.X < minX)  							minX = (int)point.X;    						if ((int)point.Y < minY)  							minY = (int)point.Y;  					}    					minX = minX * FGrayscale.Width / 1024;  					maxX = maxX * FGrayscale.Width / 1024;  					minY = minY * FGrayscale.Height / 1024;  					maxY = maxY * FGrayscale.Height / 1024;    					int boardResolutionMin = Math.Min(SizeNow.Width' SizeNow.Height);  					int strideX = (maxX - minX) / boardResolutionMin;  					int strideY = (maxY - minY) / boardResolutionMin;    					minX -= strideX * 2;  					maxX += strideX * 2;  					minY -= strideY * 2;  					maxY += strideY * 2;    					if (minX < 0)  					{  						minX = 0;  					}  					if (minY < 0)  					{  						minY = 0;  					}  					if (maxX > FGrayscale.Width - 1)  					{  						maxX = FGrayscale.Width - 1;  					}  					if (maxY > FGrayscale.Height - 1)  					{  						maxY = FGrayscale.Height - 1;  					}    					Rectangle rect = new Rectangle(minX' minY' maxX-minX' maxY-minY);    					CvInvoke.cvSetImageROI(FGrayscale.CvMat' rect);  					FCropped.Initialise(new Size(rect.Width' rect.Height)' TColorFormat.L8);  					CvInvoke.cvCopy(FGrayscale.CvMat' FCropped.CvMat' IntPtr.Zero);  					CvInvoke.cvResetImageROI(FGrayscale.CvMat);    					points = CameraCalibration.FindChessboardCorners(FCropped.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    					if (points != null)  					{  						for (int iPoint = 0; iPoint < points.Length; iPoint++)  						{  							points[iPoint].X += minX;  							points[iPoint].Y += minY;  						}  					}  				}  			} else {  				points = CameraCalibration.FindChessboardCorners(FGrayscale.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);  			}
Magic Number,VVVV.CV.Nodes,FindBoardInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\FindBoardInstance.cs,Process,The following statement contains a magic number: if (TestAtLowResolution)  			{  				if (!FLowResolution.Allocated) {  					FLowResolution.Initialise(new Size(1024' 1024)' TColorFormat.L8);  				}  				CvInvoke.cvResize(FGrayscale.CvMat' FLowResolution.CvMat' INTER.CV_INTER_LINEAR);  				var lowResPoints = CameraCalibration.FindChessboardCorners(FLowResolution.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    				if (lowResPoints != null) {  					int minX = FGrayscale.Width;  					int minY = FGrayscale.Height;  					int maxX = 0;  					int maxY = 0;    					foreach(var point in lowResPoints)  					{  						if ((int)point.X > maxX)  							maxX = (int)point.X;    						if ((int)point.Y > maxY)  							maxY = (int)point.Y;    						if ((int)point.X < minX)  							minX = (int)point.X;    						if ((int)point.Y < minY)  							minY = (int)point.Y;  					}    					minX = minX * FGrayscale.Width / 1024;  					maxX = maxX * FGrayscale.Width / 1024;  					minY = minY * FGrayscale.Height / 1024;  					maxY = maxY * FGrayscale.Height / 1024;    					int boardResolutionMin = Math.Min(SizeNow.Width' SizeNow.Height);  					int strideX = (maxX - minX) / boardResolutionMin;  					int strideY = (maxY - minY) / boardResolutionMin;    					minX -= strideX * 2;  					maxX += strideX * 2;  					minY -= strideY * 2;  					maxY += strideY * 2;    					if (minX < 0)  					{  						minX = 0;  					}  					if (minY < 0)  					{  						minY = 0;  					}  					if (maxX > FGrayscale.Width - 1)  					{  						maxX = FGrayscale.Width - 1;  					}  					if (maxY > FGrayscale.Height - 1)  					{  						maxY = FGrayscale.Height - 1;  					}    					Rectangle rect = new Rectangle(minX' minY' maxX-minX' maxY-minY);    					CvInvoke.cvSetImageROI(FGrayscale.CvMat' rect);  					FCropped.Initialise(new Size(rect.Width' rect.Height)' TColorFormat.L8);  					CvInvoke.cvCopy(FGrayscale.CvMat' FCropped.CvMat' IntPtr.Zero);  					CvInvoke.cvResetImageROI(FGrayscale.CvMat);    					points = CameraCalibration.FindChessboardCorners(FCropped.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    					if (points != null)  					{  						for (int iPoint = 0; iPoint < points.Length; iPoint++)  						{  							points[iPoint].X += minX;  							points[iPoint].Y += minY;  						}  					}  				}  			} else {  				points = CameraCalibration.FindChessboardCorners(FGrayscale.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);  			}
Magic Number,VVVV.CV.Nodes,FindBoardInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\FindBoardInstance.cs,Process,The following statement contains a magic number: if (TestAtLowResolution)  			{  				if (!FLowResolution.Allocated) {  					FLowResolution.Initialise(new Size(1024' 1024)' TColorFormat.L8);  				}  				CvInvoke.cvResize(FGrayscale.CvMat' FLowResolution.CvMat' INTER.CV_INTER_LINEAR);  				var lowResPoints = CameraCalibration.FindChessboardCorners(FLowResolution.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    				if (lowResPoints != null) {  					int minX = FGrayscale.Width;  					int minY = FGrayscale.Height;  					int maxX = 0;  					int maxY = 0;    					foreach(var point in lowResPoints)  					{  						if ((int)point.X > maxX)  							maxX = (int)point.X;    						if ((int)point.Y > maxY)  							maxY = (int)point.Y;    						if ((int)point.X < minX)  							minX = (int)point.X;    						if ((int)point.Y < minY)  							minY = (int)point.Y;  					}    					minX = minX * FGrayscale.Width / 1024;  					maxX = maxX * FGrayscale.Width / 1024;  					minY = minY * FGrayscale.Height / 1024;  					maxY = maxY * FGrayscale.Height / 1024;    					int boardResolutionMin = Math.Min(SizeNow.Width' SizeNow.Height);  					int strideX = (maxX - minX) / boardResolutionMin;  					int strideY = (maxY - minY) / boardResolutionMin;    					minX -= strideX * 2;  					maxX += strideX * 2;  					minY -= strideY * 2;  					maxY += strideY * 2;    					if (minX < 0)  					{  						minX = 0;  					}  					if (minY < 0)  					{  						minY = 0;  					}  					if (maxX > FGrayscale.Width - 1)  					{  						maxX = FGrayscale.Width - 1;  					}  					if (maxY > FGrayscale.Height - 1)  					{  						maxY = FGrayscale.Height - 1;  					}    					Rectangle rect = new Rectangle(minX' minY' maxX-minX' maxY-minY);    					CvInvoke.cvSetImageROI(FGrayscale.CvMat' rect);  					FCropped.Initialise(new Size(rect.Width' rect.Height)' TColorFormat.L8);  					CvInvoke.cvCopy(FGrayscale.CvMat' FCropped.CvMat' IntPtr.Zero);  					CvInvoke.cvResetImageROI(FGrayscale.CvMat);    					points = CameraCalibration.FindChessboardCorners(FCropped.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    					if (points != null)  					{  						for (int iPoint = 0; iPoint < points.Length; iPoint++)  						{  							points[iPoint].X += minX;  							points[iPoint].Y += minY;  						}  					}  				}  			} else {  				points = CameraCalibration.FindChessboardCorners(FGrayscale.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);  			}
Magic Number,VVVV.CV.Nodes,FindBoardInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\FindBoardInstance.cs,Process,The following statement contains a magic number: if (TestAtLowResolution)  			{  				if (!FLowResolution.Allocated) {  					FLowResolution.Initialise(new Size(1024' 1024)' TColorFormat.L8);  				}  				CvInvoke.cvResize(FGrayscale.CvMat' FLowResolution.CvMat' INTER.CV_INTER_LINEAR);  				var lowResPoints = CameraCalibration.FindChessboardCorners(FLowResolution.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    				if (lowResPoints != null) {  					int minX = FGrayscale.Width;  					int minY = FGrayscale.Height;  					int maxX = 0;  					int maxY = 0;    					foreach(var point in lowResPoints)  					{  						if ((int)point.X > maxX)  							maxX = (int)point.X;    						if ((int)point.Y > maxY)  							maxY = (int)point.Y;    						if ((int)point.X < minX)  							minX = (int)point.X;    						if ((int)point.Y < minY)  							minY = (int)point.Y;  					}    					minX = minX * FGrayscale.Width / 1024;  					maxX = maxX * FGrayscale.Width / 1024;  					minY = minY * FGrayscale.Height / 1024;  					maxY = maxY * FGrayscale.Height / 1024;    					int boardResolutionMin = Math.Min(SizeNow.Width' SizeNow.Height);  					int strideX = (maxX - minX) / boardResolutionMin;  					int strideY = (maxY - minY) / boardResolutionMin;    					minX -= strideX * 2;  					maxX += strideX * 2;  					minY -= strideY * 2;  					maxY += strideY * 2;    					if (minX < 0)  					{  						minX = 0;  					}  					if (minY < 0)  					{  						minY = 0;  					}  					if (maxX > FGrayscale.Width - 1)  					{  						maxX = FGrayscale.Width - 1;  					}  					if (maxY > FGrayscale.Height - 1)  					{  						maxY = FGrayscale.Height - 1;  					}    					Rectangle rect = new Rectangle(minX' minY' maxX-minX' maxY-minY);    					CvInvoke.cvSetImageROI(FGrayscale.CvMat' rect);  					FCropped.Initialise(new Size(rect.Width' rect.Height)' TColorFormat.L8);  					CvInvoke.cvCopy(FGrayscale.CvMat' FCropped.CvMat' IntPtr.Zero);  					CvInvoke.cvResetImageROI(FGrayscale.CvMat);    					points = CameraCalibration.FindChessboardCorners(FCropped.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    					if (points != null)  					{  						for (int iPoint = 0; iPoint < points.Length; iPoint++)  						{  							points[iPoint].X += minX;  							points[iPoint].Y += minY;  						}  					}  				}  			} else {  				points = CameraCalibration.FindChessboardCorners(FGrayscale.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);  			}
Magic Number,VVVV.CV.Nodes,FindBoardInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\FindBoardInstance.cs,Process,The following statement contains a magic number: if (TestAtLowResolution)  			{  				if (!FLowResolution.Allocated) {  					FLowResolution.Initialise(new Size(1024' 1024)' TColorFormat.L8);  				}  				CvInvoke.cvResize(FGrayscale.CvMat' FLowResolution.CvMat' INTER.CV_INTER_LINEAR);  				var lowResPoints = CameraCalibration.FindChessboardCorners(FLowResolution.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    				if (lowResPoints != null) {  					int minX = FGrayscale.Width;  					int minY = FGrayscale.Height;  					int maxX = 0;  					int maxY = 0;    					foreach(var point in lowResPoints)  					{  						if ((int)point.X > maxX)  							maxX = (int)point.X;    						if ((int)point.Y > maxY)  							maxY = (int)point.Y;    						if ((int)point.X < minX)  							minX = (int)point.X;    						if ((int)point.Y < minY)  							minY = (int)point.Y;  					}    					minX = minX * FGrayscale.Width / 1024;  					maxX = maxX * FGrayscale.Width / 1024;  					minY = minY * FGrayscale.Height / 1024;  					maxY = maxY * FGrayscale.Height / 1024;    					int boardResolutionMin = Math.Min(SizeNow.Width' SizeNow.Height);  					int strideX = (maxX - minX) / boardResolutionMin;  					int strideY = (maxY - minY) / boardResolutionMin;    					minX -= strideX * 2;  					maxX += strideX * 2;  					minY -= strideY * 2;  					maxY += strideY * 2;    					if (minX < 0)  					{  						minX = 0;  					}  					if (minY < 0)  					{  						minY = 0;  					}  					if (maxX > FGrayscale.Width - 1)  					{  						maxX = FGrayscale.Width - 1;  					}  					if (maxY > FGrayscale.Height - 1)  					{  						maxY = FGrayscale.Height - 1;  					}    					Rectangle rect = new Rectangle(minX' minY' maxX-minX' maxY-minY);    					CvInvoke.cvSetImageROI(FGrayscale.CvMat' rect);  					FCropped.Initialise(new Size(rect.Width' rect.Height)' TColorFormat.L8);  					CvInvoke.cvCopy(FGrayscale.CvMat' FCropped.CvMat' IntPtr.Zero);  					CvInvoke.cvResetImageROI(FGrayscale.CvMat);    					points = CameraCalibration.FindChessboardCorners(FCropped.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    					if (points != null)  					{  						for (int iPoint = 0; iPoint < points.Length; iPoint++)  						{  							points[iPoint].X += minX;  							points[iPoint].Y += minY;  						}  					}  				}  			} else {  				points = CameraCalibration.FindChessboardCorners(FGrayscale.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);  			}
Magic Number,VVVV.CV.Nodes,FindBoardInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\FindBoardInstance.cs,Process,The following statement contains a magic number: if (TestAtLowResolution)  			{  				if (!FLowResolution.Allocated) {  					FLowResolution.Initialise(new Size(1024' 1024)' TColorFormat.L8);  				}  				CvInvoke.cvResize(FGrayscale.CvMat' FLowResolution.CvMat' INTER.CV_INTER_LINEAR);  				var lowResPoints = CameraCalibration.FindChessboardCorners(FLowResolution.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    				if (lowResPoints != null) {  					int minX = FGrayscale.Width;  					int minY = FGrayscale.Height;  					int maxX = 0;  					int maxY = 0;    					foreach(var point in lowResPoints)  					{  						if ((int)point.X > maxX)  							maxX = (int)point.X;    						if ((int)point.Y > maxY)  							maxY = (int)point.Y;    						if ((int)point.X < minX)  							minX = (int)point.X;    						if ((int)point.Y < minY)  							minY = (int)point.Y;  					}    					minX = minX * FGrayscale.Width / 1024;  					maxX = maxX * FGrayscale.Width / 1024;  					minY = minY * FGrayscale.Height / 1024;  					maxY = maxY * FGrayscale.Height / 1024;    					int boardResolutionMin = Math.Min(SizeNow.Width' SizeNow.Height);  					int strideX = (maxX - minX) / boardResolutionMin;  					int strideY = (maxY - minY) / boardResolutionMin;    					minX -= strideX * 2;  					maxX += strideX * 2;  					minY -= strideY * 2;  					maxY += strideY * 2;    					if (minX < 0)  					{  						minX = 0;  					}  					if (minY < 0)  					{  						minY = 0;  					}  					if (maxX > FGrayscale.Width - 1)  					{  						maxX = FGrayscale.Width - 1;  					}  					if (maxY > FGrayscale.Height - 1)  					{  						maxY = FGrayscale.Height - 1;  					}    					Rectangle rect = new Rectangle(minX' minY' maxX-minX' maxY-minY);    					CvInvoke.cvSetImageROI(FGrayscale.CvMat' rect);  					FCropped.Initialise(new Size(rect.Width' rect.Height)' TColorFormat.L8);  					CvInvoke.cvCopy(FGrayscale.CvMat' FCropped.CvMat' IntPtr.Zero);  					CvInvoke.cvResetImageROI(FGrayscale.CvMat);    					points = CameraCalibration.FindChessboardCorners(FCropped.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);    					if (points != null)  					{  						for (int iPoint = 0; iPoint < points.Length; iPoint++)  						{  							points[iPoint].X += minX;  							points[iPoint].Y += minY;  						}  					}  				}  			} else {  				points = CameraCalibration.FindChessboardCorners(FGrayscale.GetImage() as Image<Gray' byte>' SizeNow' CALIB_CB_TYPE.ADAPTIVE_THRESH);  			}
Magic Number,VVVV.CV.Nodes,IntrinsicsSplitNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\IntrinsicsSplitNode.cs,Evaluate,The following statement contains a magic number: if (FPinInIntrinsics[0] == null)  			{  				FPinOutCameraMatrix.SliceCount = 0;  				FPinOutCameraTransform.SliceCount = 0;  				FPinOutProjectionTransform.SliceCount = 0;  				FPinOutDistiortonCoefficients.SliceCount = 0;  				FPinOutSensorSize.SliceCount = 0;  			}  			else  			{  				FPinOutDistiortonCoefficients.SliceCount = SpreadMax;  				FPinOutCameraTransform.SliceCount = SpreadMax;  				FPinOutCameraMatrix.SliceCount = SpreadMax;  				FPinOutProjectionTransform.SliceCount = SpreadMax;  				FPinOutSensorSize.SliceCount = SpreadMax;    				for (int i = 0; i < SpreadMax; i++)  				{  					FPinOutDistiortonCoefficients[i].SliceCount = 5;  					for (int j = 0; j < 5; j++)  						FPinOutDistiortonCoefficients[i][j] = FPinInIntrinsics[i].intrinsics.DistortionCoeffs[j' 0];      					FPinOutCameraMatrix[i].SliceCount = 9;  					for (int k = 0; k < 3; k++)  						for (int j = 0; j < 3; j++)  						{  							FPinOutCameraMatrix[i][k + j * 3] = FPinInIntrinsics[i].intrinsics.IntrinsicMatrix[j' k];  						}    					FPinOutCameraTransform[i] = FPinInIntrinsics[i].Matrix;  					FPinOutProjectionTransform[i] = FPinInIntrinsics[i].NormalisedMatrix;  					FPinOutSensorSize[i] = new Vector2D((double)FPinInIntrinsics[i].SensorSize.Width' (double)FPinInIntrinsics[i].SensorSize.Height);  				}  			}
Magic Number,VVVV.CV.Nodes,IntrinsicsSplitNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\IntrinsicsSplitNode.cs,Evaluate,The following statement contains a magic number: if (FPinInIntrinsics[0] == null)  			{  				FPinOutCameraMatrix.SliceCount = 0;  				FPinOutCameraTransform.SliceCount = 0;  				FPinOutProjectionTransform.SliceCount = 0;  				FPinOutDistiortonCoefficients.SliceCount = 0;  				FPinOutSensorSize.SliceCount = 0;  			}  			else  			{  				FPinOutDistiortonCoefficients.SliceCount = SpreadMax;  				FPinOutCameraTransform.SliceCount = SpreadMax;  				FPinOutCameraMatrix.SliceCount = SpreadMax;  				FPinOutProjectionTransform.SliceCount = SpreadMax;  				FPinOutSensorSize.SliceCount = SpreadMax;    				for (int i = 0; i < SpreadMax; i++)  				{  					FPinOutDistiortonCoefficients[i].SliceCount = 5;  					for (int j = 0; j < 5; j++)  						FPinOutDistiortonCoefficients[i][j] = FPinInIntrinsics[i].intrinsics.DistortionCoeffs[j' 0];      					FPinOutCameraMatrix[i].SliceCount = 9;  					for (int k = 0; k < 3; k++)  						for (int j = 0; j < 3; j++)  						{  							FPinOutCameraMatrix[i][k + j * 3] = FPinInIntrinsics[i].intrinsics.IntrinsicMatrix[j' k];  						}    					FPinOutCameraTransform[i] = FPinInIntrinsics[i].Matrix;  					FPinOutProjectionTransform[i] = FPinInIntrinsics[i].NormalisedMatrix;  					FPinOutSensorSize[i] = new Vector2D((double)FPinInIntrinsics[i].SensorSize.Width' (double)FPinInIntrinsics[i].SensorSize.Height);  				}  			}
Magic Number,VVVV.CV.Nodes,IntrinsicsSplitNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\IntrinsicsSplitNode.cs,Evaluate,The following statement contains a magic number: if (FPinInIntrinsics[0] == null)  			{  				FPinOutCameraMatrix.SliceCount = 0;  				FPinOutCameraTransform.SliceCount = 0;  				FPinOutProjectionTransform.SliceCount = 0;  				FPinOutDistiortonCoefficients.SliceCount = 0;  				FPinOutSensorSize.SliceCount = 0;  			}  			else  			{  				FPinOutDistiortonCoefficients.SliceCount = SpreadMax;  				FPinOutCameraTransform.SliceCount = SpreadMax;  				FPinOutCameraMatrix.SliceCount = SpreadMax;  				FPinOutProjectionTransform.SliceCount = SpreadMax;  				FPinOutSensorSize.SliceCount = SpreadMax;    				for (int i = 0; i < SpreadMax; i++)  				{  					FPinOutDistiortonCoefficients[i].SliceCount = 5;  					for (int j = 0; j < 5; j++)  						FPinOutDistiortonCoefficients[i][j] = FPinInIntrinsics[i].intrinsics.DistortionCoeffs[j' 0];      					FPinOutCameraMatrix[i].SliceCount = 9;  					for (int k = 0; k < 3; k++)  						for (int j = 0; j < 3; j++)  						{  							FPinOutCameraMatrix[i][k + j * 3] = FPinInIntrinsics[i].intrinsics.IntrinsicMatrix[j' k];  						}    					FPinOutCameraTransform[i] = FPinInIntrinsics[i].Matrix;  					FPinOutProjectionTransform[i] = FPinInIntrinsics[i].NormalisedMatrix;  					FPinOutSensorSize[i] = new Vector2D((double)FPinInIntrinsics[i].SensorSize.Width' (double)FPinInIntrinsics[i].SensorSize.Height);  				}  			}
Magic Number,VVVV.CV.Nodes,IntrinsicsSplitNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\IntrinsicsSplitNode.cs,Evaluate,The following statement contains a magic number: if (FPinInIntrinsics[0] == null)  			{  				FPinOutCameraMatrix.SliceCount = 0;  				FPinOutCameraTransform.SliceCount = 0;  				FPinOutProjectionTransform.SliceCount = 0;  				FPinOutDistiortonCoefficients.SliceCount = 0;  				FPinOutSensorSize.SliceCount = 0;  			}  			else  			{  				FPinOutDistiortonCoefficients.SliceCount = SpreadMax;  				FPinOutCameraTransform.SliceCount = SpreadMax;  				FPinOutCameraMatrix.SliceCount = SpreadMax;  				FPinOutProjectionTransform.SliceCount = SpreadMax;  				FPinOutSensorSize.SliceCount = SpreadMax;    				for (int i = 0; i < SpreadMax; i++)  				{  					FPinOutDistiortonCoefficients[i].SliceCount = 5;  					for (int j = 0; j < 5; j++)  						FPinOutDistiortonCoefficients[i][j] = FPinInIntrinsics[i].intrinsics.DistortionCoeffs[j' 0];      					FPinOutCameraMatrix[i].SliceCount = 9;  					for (int k = 0; k < 3; k++)  						for (int j = 0; j < 3; j++)  						{  							FPinOutCameraMatrix[i][k + j * 3] = FPinInIntrinsics[i].intrinsics.IntrinsicMatrix[j' k];  						}    					FPinOutCameraTransform[i] = FPinInIntrinsics[i].Matrix;  					FPinOutProjectionTransform[i] = FPinInIntrinsics[i].NormalisedMatrix;  					FPinOutSensorSize[i] = new Vector2D((double)FPinInIntrinsics[i].SensorSize.Width' (double)FPinInIntrinsics[i].SensorSize.Height);  				}  			}
Magic Number,VVVV.CV.Nodes,IntrinsicsSplitNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\IntrinsicsSplitNode.cs,Evaluate,The following statement contains a magic number: if (FPinInIntrinsics[0] == null)  			{  				FPinOutCameraMatrix.SliceCount = 0;  				FPinOutCameraTransform.SliceCount = 0;  				FPinOutProjectionTransform.SliceCount = 0;  				FPinOutDistiortonCoefficients.SliceCount = 0;  				FPinOutSensorSize.SliceCount = 0;  			}  			else  			{  				FPinOutDistiortonCoefficients.SliceCount = SpreadMax;  				FPinOutCameraTransform.SliceCount = SpreadMax;  				FPinOutCameraMatrix.SliceCount = SpreadMax;  				FPinOutProjectionTransform.SliceCount = SpreadMax;  				FPinOutSensorSize.SliceCount = SpreadMax;    				for (int i = 0; i < SpreadMax; i++)  				{  					FPinOutDistiortonCoefficients[i].SliceCount = 5;  					for (int j = 0; j < 5; j++)  						FPinOutDistiortonCoefficients[i][j] = FPinInIntrinsics[i].intrinsics.DistortionCoeffs[j' 0];      					FPinOutCameraMatrix[i].SliceCount = 9;  					for (int k = 0; k < 3; k++)  						for (int j = 0; j < 3; j++)  						{  							FPinOutCameraMatrix[i][k + j * 3] = FPinInIntrinsics[i].intrinsics.IntrinsicMatrix[j' k];  						}    					FPinOutCameraTransform[i] = FPinInIntrinsics[i].Matrix;  					FPinOutProjectionTransform[i] = FPinInIntrinsics[i].NormalisedMatrix;  					FPinOutSensorSize[i] = new Vector2D((double)FPinInIntrinsics[i].SensorSize.Width' (double)FPinInIntrinsics[i].SensorSize.Height);  				}  			}
Magic Number,VVVV.CV.Nodes,IntrinsicsSplitNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\IntrinsicsSplitNode.cs,Evaluate,The following statement contains a magic number: if (FPinInIntrinsics[0] == null)  			{  				FPinOutCameraMatrix.SliceCount = 0;  				FPinOutCameraTransform.SliceCount = 0;  				FPinOutProjectionTransform.SliceCount = 0;  				FPinOutDistiortonCoefficients.SliceCount = 0;  				FPinOutSensorSize.SliceCount = 0;  			}  			else  			{  				FPinOutDistiortonCoefficients.SliceCount = SpreadMax;  				FPinOutCameraTransform.SliceCount = SpreadMax;  				FPinOutCameraMatrix.SliceCount = SpreadMax;  				FPinOutProjectionTransform.SliceCount = SpreadMax;  				FPinOutSensorSize.SliceCount = SpreadMax;    				for (int i = 0; i < SpreadMax; i++)  				{  					FPinOutDistiortonCoefficients[i].SliceCount = 5;  					for (int j = 0; j < 5; j++)  						FPinOutDistiortonCoefficients[i][j] = FPinInIntrinsics[i].intrinsics.DistortionCoeffs[j' 0];      					FPinOutCameraMatrix[i].SliceCount = 9;  					for (int k = 0; k < 3; k++)  						for (int j = 0; j < 3; j++)  						{  							FPinOutCameraMatrix[i][k + j * 3] = FPinInIntrinsics[i].intrinsics.IntrinsicMatrix[j' k];  						}    					FPinOutCameraTransform[i] = FPinInIntrinsics[i].Matrix;  					FPinOutProjectionTransform[i] = FPinInIntrinsics[i].NormalisedMatrix;  					FPinOutSensorSize[i] = new Vector2D((double)FPinInIntrinsics[i].SensorSize.Width' (double)FPinInIntrinsics[i].SensorSize.Height);  				}  			}
Magic Number,VVVV.CV.Nodes,IntrinsicsJoinNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\IntrinsicsJoinNode.cs,Evaluate,The following statement contains a magic number: if (FPinInCameraTransform[0] == null)  			{                  FPinOutIntrinsics.SliceCount = 0;  			}  			else  			{                  FPinOutIntrinsics.SliceCount = SpreadMax;    				for (int i = 0; i < SpreadMax; i++)  				{                      IntrinsicCameraParameters cp = new IntrinsicCameraParameters();                      // Inspiration / details from http://strawlab.org/2011/11/05/augmented-reality-with-OpenGL/ - See Intrinsics.cs too                      cp.IntrinsicMatrix[0' 0] = FPinInCameraTransform[i][0' 0] * FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 1] = FPinInCameraTransform[i][1' 1] * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[0' 2] = (FPinInCameraTransform[i][2' 0] + 1)* FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 2] = (FPinInCameraTransform[i][2' 1] +1) * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[2' 2] = 1;                      FPinOutIntrinsics[i] = new Intrinsics(cp' new Size((int)FPinInSensorSize[i].x' (int)FPinInSensorSize[i].y));  				}  			}
Magic Number,VVVV.CV.Nodes,IntrinsicsJoinNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\IntrinsicsJoinNode.cs,Evaluate,The following statement contains a magic number: if (FPinInCameraTransform[0] == null)  			{                  FPinOutIntrinsics.SliceCount = 0;  			}  			else  			{                  FPinOutIntrinsics.SliceCount = SpreadMax;    				for (int i = 0; i < SpreadMax; i++)  				{                      IntrinsicCameraParameters cp = new IntrinsicCameraParameters();                      // Inspiration / details from http://strawlab.org/2011/11/05/augmented-reality-with-OpenGL/ - See Intrinsics.cs too                      cp.IntrinsicMatrix[0' 0] = FPinInCameraTransform[i][0' 0] * FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 1] = FPinInCameraTransform[i][1' 1] * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[0' 2] = (FPinInCameraTransform[i][2' 0] + 1)* FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 2] = (FPinInCameraTransform[i][2' 1] +1) * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[2' 2] = 1;                      FPinOutIntrinsics[i] = new Intrinsics(cp' new Size((int)FPinInSensorSize[i].x' (int)FPinInSensorSize[i].y));  				}  			}
Magic Number,VVVV.CV.Nodes,IntrinsicsJoinNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\IntrinsicsJoinNode.cs,Evaluate,The following statement contains a magic number: if (FPinInCameraTransform[0] == null)  			{                  FPinOutIntrinsics.SliceCount = 0;  			}  			else  			{                  FPinOutIntrinsics.SliceCount = SpreadMax;    				for (int i = 0; i < SpreadMax; i++)  				{                      IntrinsicCameraParameters cp = new IntrinsicCameraParameters();                      // Inspiration / details from http://strawlab.org/2011/11/05/augmented-reality-with-OpenGL/ - See Intrinsics.cs too                      cp.IntrinsicMatrix[0' 0] = FPinInCameraTransform[i][0' 0] * FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 1] = FPinInCameraTransform[i][1' 1] * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[0' 2] = (FPinInCameraTransform[i][2' 0] + 1)* FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 2] = (FPinInCameraTransform[i][2' 1] +1) * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[2' 2] = 1;                      FPinOutIntrinsics[i] = new Intrinsics(cp' new Size((int)FPinInSensorSize[i].x' (int)FPinInSensorSize[i].y));  				}  			}
Magic Number,VVVV.CV.Nodes,IntrinsicsJoinNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\IntrinsicsJoinNode.cs,Evaluate,The following statement contains a magic number: if (FPinInCameraTransform[0] == null)  			{                  FPinOutIntrinsics.SliceCount = 0;  			}  			else  			{                  FPinOutIntrinsics.SliceCount = SpreadMax;    				for (int i = 0; i < SpreadMax; i++)  				{                      IntrinsicCameraParameters cp = new IntrinsicCameraParameters();                      // Inspiration / details from http://strawlab.org/2011/11/05/augmented-reality-with-OpenGL/ - See Intrinsics.cs too                      cp.IntrinsicMatrix[0' 0] = FPinInCameraTransform[i][0' 0] * FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 1] = FPinInCameraTransform[i][1' 1] * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[0' 2] = (FPinInCameraTransform[i][2' 0] + 1)* FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 2] = (FPinInCameraTransform[i][2' 1] +1) * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[2' 2] = 1;                      FPinOutIntrinsics[i] = new Intrinsics(cp' new Size((int)FPinInSensorSize[i].x' (int)FPinInSensorSize[i].y));  				}  			}
Magic Number,VVVV.CV.Nodes,IntrinsicsJoinNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\IntrinsicsJoinNode.cs,Evaluate,The following statement contains a magic number: if (FPinInCameraTransform[0] == null)  			{                  FPinOutIntrinsics.SliceCount = 0;  			}  			else  			{                  FPinOutIntrinsics.SliceCount = SpreadMax;    				for (int i = 0; i < SpreadMax; i++)  				{                      IntrinsicCameraParameters cp = new IntrinsicCameraParameters();                      // Inspiration / details from http://strawlab.org/2011/11/05/augmented-reality-with-OpenGL/ - See Intrinsics.cs too                      cp.IntrinsicMatrix[0' 0] = FPinInCameraTransform[i][0' 0] * FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 1] = FPinInCameraTransform[i][1' 1] * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[0' 2] = (FPinInCameraTransform[i][2' 0] + 1)* FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 2] = (FPinInCameraTransform[i][2' 1] +1) * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[2' 2] = 1;                      FPinOutIntrinsics[i] = new Intrinsics(cp' new Size((int)FPinInSensorSize[i].x' (int)FPinInSensorSize[i].y));  				}  			}
Magic Number,VVVV.CV.Nodes,IntrinsicsJoinNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\IntrinsicsJoinNode.cs,Evaluate,The following statement contains a magic number: if (FPinInCameraTransform[0] == null)  			{                  FPinOutIntrinsics.SliceCount = 0;  			}  			else  			{                  FPinOutIntrinsics.SliceCount = SpreadMax;    				for (int i = 0; i < SpreadMax; i++)  				{                      IntrinsicCameraParameters cp = new IntrinsicCameraParameters();                      // Inspiration / details from http://strawlab.org/2011/11/05/augmented-reality-with-OpenGL/ - See Intrinsics.cs too                      cp.IntrinsicMatrix[0' 0] = FPinInCameraTransform[i][0' 0] * FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 1] = FPinInCameraTransform[i][1' 1] * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[0' 2] = (FPinInCameraTransform[i][2' 0] + 1)* FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 2] = (FPinInCameraTransform[i][2' 1] +1) * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[2' 2] = 1;                      FPinOutIntrinsics[i] = new Intrinsics(cp' new Size((int)FPinInSensorSize[i].x' (int)FPinInSensorSize[i].y));  				}  			}
Magic Number,VVVV.CV.Nodes,IntrinsicsJoinNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\IntrinsicsJoinNode.cs,Evaluate,The following statement contains a magic number: if (FPinInCameraTransform[0] == null)  			{                  FPinOutIntrinsics.SliceCount = 0;  			}  			else  			{                  FPinOutIntrinsics.SliceCount = SpreadMax;    				for (int i = 0; i < SpreadMax; i++)  				{                      IntrinsicCameraParameters cp = new IntrinsicCameraParameters();                      // Inspiration / details from http://strawlab.org/2011/11/05/augmented-reality-with-OpenGL/ - See Intrinsics.cs too                      cp.IntrinsicMatrix[0' 0] = FPinInCameraTransform[i][0' 0] * FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 1] = FPinInCameraTransform[i][1' 1] * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[0' 2] = (FPinInCameraTransform[i][2' 0] + 1)* FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 2] = (FPinInCameraTransform[i][2' 1] +1) * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[2' 2] = 1;                      FPinOutIntrinsics[i] = new Intrinsics(cp' new Size((int)FPinInSensorSize[i].x' (int)FPinInSensorSize[i].y));  				}  			}
Magic Number,VVVV.CV.Nodes,IntrinsicsJoinNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\IntrinsicsJoinNode.cs,Evaluate,The following statement contains a magic number: if (FPinInCameraTransform[0] == null)  			{                  FPinOutIntrinsics.SliceCount = 0;  			}  			else  			{                  FPinOutIntrinsics.SliceCount = SpreadMax;    				for (int i = 0; i < SpreadMax; i++)  				{                      IntrinsicCameraParameters cp = new IntrinsicCameraParameters();                      // Inspiration / details from http://strawlab.org/2011/11/05/augmented-reality-with-OpenGL/ - See Intrinsics.cs too                      cp.IntrinsicMatrix[0' 0] = FPinInCameraTransform[i][0' 0] * FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 1] = FPinInCameraTransform[i][1' 1] * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[0' 2] = (FPinInCameraTransform[i][2' 0] + 1)* FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 2] = (FPinInCameraTransform[i][2' 1] +1) * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[2' 2] = 1;                      FPinOutIntrinsics[i] = new Intrinsics(cp' new Size((int)FPinInSensorSize[i].x' (int)FPinInSensorSize[i].y));  				}  			}
Magic Number,VVVV.CV.Nodes,IntrinsicsJoinNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\IntrinsicsJoinNode.cs,Evaluate,The following statement contains a magic number: if (FPinInCameraTransform[0] == null)  			{                  FPinOutIntrinsics.SliceCount = 0;  			}  			else  			{                  FPinOutIntrinsics.SliceCount = SpreadMax;    				for (int i = 0; i < SpreadMax; i++)  				{                      IntrinsicCameraParameters cp = new IntrinsicCameraParameters();                      // Inspiration / details from http://strawlab.org/2011/11/05/augmented-reality-with-OpenGL/ - See Intrinsics.cs too                      cp.IntrinsicMatrix[0' 0] = FPinInCameraTransform[i][0' 0] * FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 1] = FPinInCameraTransform[i][1' 1] * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[0' 2] = (FPinInCameraTransform[i][2' 0] + 1)* FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 2] = (FPinInCameraTransform[i][2' 1] +1) * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[2' 2] = 1;                      FPinOutIntrinsics[i] = new Intrinsics(cp' new Size((int)FPinInSensorSize[i].x' (int)FPinInSensorSize[i].y));  				}  			}
Magic Number,VVVV.CV.Nodes,IntrinsicsJoinNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\IntrinsicsJoinNode.cs,Evaluate,The following statement contains a magic number: if (FPinInCameraTransform[0] == null)  			{                  FPinOutIntrinsics.SliceCount = 0;  			}  			else  			{                  FPinOutIntrinsics.SliceCount = SpreadMax;    				for (int i = 0; i < SpreadMax; i++)  				{                      IntrinsicCameraParameters cp = new IntrinsicCameraParameters();                      // Inspiration / details from http://strawlab.org/2011/11/05/augmented-reality-with-OpenGL/ - See Intrinsics.cs too                      cp.IntrinsicMatrix[0' 0] = FPinInCameraTransform[i][0' 0] * FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 1] = FPinInCameraTransform[i][1' 1] * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[0' 2] = (FPinInCameraTransform[i][2' 0] + 1)* FPinInSensorSize[i].x / 2;// =L15*P8/2                      cp.IntrinsicMatrix[1' 2] = (FPinInCameraTransform[i][2' 1] +1) * FPinInSensorSize[i].y / 2;// =L15*P8/2                      cp.IntrinsicMatrix[2' 2] = 1;                      FPinOutIntrinsics[i] = new Intrinsics(cp' new Size((int)FPinInSensorSize[i].x' (int)FPinInSensorSize[i].y));  				}  			}
Magic Number,VVVV.CV.Nodes,TransformInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\Transform.cs,Process,The following statement contains a magic number: var matrix = new Emgu.CV.Matrix<double>(2' 3);
Magic Number,VVVV.CV.Nodes,TransformInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\Transform.cs,Process,The following statement contains a magic number: var matrix = new Emgu.CV.Matrix<double>(2' 3);
Magic Number,VVVV.CV.Nodes,TransformInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\Transform.cs,Process,The following statement contains a magic number: lock (FTransformLock)  			{  				//copy the transform out  				for (int i = 0; i < 16; i++)  				{  					transform[i] = FTrasform[i];  				}  			}
Magic Number,VVVV.CV.Nodes,TransformInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\Transform.cs,Process,The following statement contains a magic number: if (UseCenter)  			{  				double halfWidth = FInput.ImageAttributes.Width / 2;  				double halfHeight = FInput.ImageAttributes.Height / 2;    				transform = VMath.Translate(-halfWidth' -halfHeight' 0) * transform * VMath.Translate(halfWidth' halfHeight' 0);  			}
Magic Number,VVVV.CV.Nodes,TransformInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\Transform.cs,Process,The following statement contains a magic number: if (UseCenter)  			{  				double halfWidth = FInput.ImageAttributes.Width / 2;  				double halfHeight = FInput.ImageAttributes.Height / 2;    				transform = VMath.Translate(-halfWidth' -halfHeight' 0) * transform * VMath.Translate(halfWidth' halfHeight' 0);  			}
Magic Number,VVVV.CV.Nodes,TransformInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\Transform.cs,Process,The following statement contains a magic number: matrix[0' 2] = transform[3' 0];
Magic Number,VVVV.CV.Nodes,TransformInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\Transform.cs,Process,The following statement contains a magic number: matrix[0' 2] = transform[3' 0];
Magic Number,VVVV.CV.Nodes,TransformInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\Transform.cs,Process,The following statement contains a magic number: matrix[1' 2] = transform[3' 1];
Magic Number,VVVV.CV.Nodes,TransformInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\Transform.cs,Process,The following statement contains a magic number: matrix[1' 2] = transform[3' 1];
Magic Number,VVVV.CV.Nodes,RotateStepInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\RotateStep.cs,Process,The following statement contains a magic number: int anticlockwiseSteps = VVVV.Utils.VMath.VMath.Zmod(Rotations' 4);
Magic Number,VVVV.CV.Nodes,RotateStepInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\RotateStep.cs,Process,The following statement contains a magic number: bool transpose = anticlockwiseSteps % 2 == 1;
Magic Number,VVVV.CV.Nodes,RotateStepInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\RotateStep.cs,Process,The following statement contains a magic number: switch (anticlockwiseSteps)              {                  case 0:                      FInput.GetImage(FOutput.Image);                      break;                    case 1:                      if (FInput.LockForReading())                      {                          try                          {                              CvInvoke.cvTranspose(FInput.CvMat' FOutput.CvMat);                          }                          finally                          {                              FInput.ReleaseForReading();                          }                          CvInvoke.cvFlip(FOutput.CvMat' FOutput.CvMat' FLIP.VERTICAL);                      }                      break;                    case 2:                      if (FInput.LockForReading())                      {                          try                          {                              CvInvoke.cvFlip(FInput.CvMat' FOutput.CvMat' FLIP.HORIZONTAL);                          }                          finally                          {                              FInput.ReleaseForReading();                          }                          CvInvoke.cvFlip(FOutput.CvMat' FOutput.CvMat' FLIP.VERTICAL);                      }                      break;                    case 3:                      if (FInput.LockForReading())                      {                          try                          {                              CvInvoke.cvTranspose(FInput.CvMat' FOutput.CvMat);                          }                          finally                          {                              FInput.ReleaseForReading();                          }                          CvInvoke.cvFlip(FOutput.CvMat' FOutput.CvMat' FLIP.HORIZONTAL);                      }                      break;              }
Magic Number,VVVV.CV.Nodes,RotateStepInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\RotateStep.cs,Process,The following statement contains a magic number: switch (anticlockwiseSteps)              {                  case 0:                      FInput.GetImage(FOutput.Image);                      break;                    case 1:                      if (FInput.LockForReading())                      {                          try                          {                              CvInvoke.cvTranspose(FInput.CvMat' FOutput.CvMat);                          }                          finally                          {                              FInput.ReleaseForReading();                          }                          CvInvoke.cvFlip(FOutput.CvMat' FOutput.CvMat' FLIP.VERTICAL);                      }                      break;                    case 2:                      if (FInput.LockForReading())                      {                          try                          {                              CvInvoke.cvFlip(FInput.CvMat' FOutput.CvMat' FLIP.HORIZONTAL);                          }                          finally                          {                              FInput.ReleaseForReading();                          }                          CvInvoke.cvFlip(FOutput.CvMat' FOutput.CvMat' FLIP.VERTICAL);                      }                      break;                    case 3:                      if (FInput.LockForReading())                      {                          try                          {                              CvInvoke.cvTranspose(FInput.CvMat' FOutput.CvMat);                          }                          finally                          {                              FInput.ReleaseForReading();                          }                          CvInvoke.cvFlip(FOutput.CvMat' FOutput.CvMat' FLIP.HORIZONTAL);                      }                      break;              }
Magic Number,VVVV.CV.Nodes,UnsharpMaskInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\UsharpMask.cs,Process,The following statement contains a magic number: try  			{  				CvInvoke.cvSmooth(FInput.CvMat' FOutput.CvMat' SMOOTH_TYPE.CV_GAUSSIAN' Width * 2 + 1' 0' 0' 0);  				CvInvoke.cvAddWeighted(FInput.CvMat' WeightOrig' FOutput.CvMat' -WeightMask' Gamma' FOutput.CvMat);  			}  			finally  			{   				FInput.ReleaseForReading();  			}
Magic Number,VVVV.CV.Nodes,WithinRangeHsvInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\WithinRangeHSV.cs,Allocate,The following statement contains a magic number: FMult = FInput.ImageAttributes.BytesPerPixel > 4 ? float.MaxValue : byte.MaxValue;
Magic Number,VVVV.CV.Nodes,VideoPlayerInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Sources\VideoPlayer.cs,Open,The following statement contains a magic number: try              {                  if (!System.IO.File.Exists(FFilename))                  {                      throw (new Exception("File '" + FFilename + "' does not exist"));                  }                    FCapture = new Capture(FFilename);                  FCapture.GetCaptureProperty(CAP_PROP.CV_CAP_PROP_FRAME_COUNT);                  this.FrameRate = FCapture.GetCaptureProperty(CAP_PROP.CV_CAP_PROP_FPS);                  this.FrameCount = (int) FCapture.GetCaptureProperty(CAP_PROP.CV_CAP_PROP_FRAME_COUNT);                  this.Length = (double)this.FrameCount / this.FrameRate;                  this.Position = 0.0;                  this.FrameDecodedIndex = 0;                    FTimer = new System.Windows.Forms.Timer();                  FTimer.Interval = (int) (1000.0 * 1.0 / this.FrameRate);                  FStarted = DateTime.Now;                    Status = "OK";                  return true;              }              catch (Exception e)              {                  Status = e.Message;                  return false;              }
Magic Number,VVVV.CV.Nodes,VideoPlayerInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Sources\VideoPlayer.cs,Generate,The following statement contains a magic number: if (newFrame)              {                  this.Position = FCapture.GetCaptureProperty(CAP_PROP.CV_CAP_PROP_POS_MSEC) / 1000.0;                  FOutput.Send();              }
Magic Number,VVVV.CV.Nodes,FramerateInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Destinations\FramerateNode.cs,Process,The following statement contains a magic number: if (FPeriod.TotalSeconds != 0)  			{  				double thisFrame = 1.0d / FPeriod.TotalSeconds;  				if (Mode == FramerateNodeMode.Raw || double.IsNaN(Framerate) || double.IsInfinity(Framerate))  					Framerate = thisFrame;  				else  				{  					Framerate = 0.9 * Framerate + 0.1 * thisFrame;  				}  			}
Magic Number,VVVV.CV.Nodes,FramerateInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Destinations\FramerateNode.cs,Process,The following statement contains a magic number: if (FPeriod.TotalSeconds != 0)  			{  				double thisFrame = 1.0d / FPeriod.TotalSeconds;  				if (Mode == FramerateNodeMode.Raw || double.IsNaN(Framerate) || double.IsInfinity(Framerate))  					Framerate = thisFrame;  				else  				{  					Framerate = 0.9 * Framerate + 0.1 * thisFrame;  				}  			}
Magic Number,VVVV.CV.Nodes,RendererNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Destinations\ImageViewNode.cs,InitializeComponent,The following statement contains a magic number: this.FImageBox.TabIndex = 2;
Magic Number,VVVV.CV.Nodes,RendererNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Destinations\ImageViewNode.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(531' 344);
Magic Number,VVVV.CV.Nodes,RendererNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Destinations\ImageViewNode.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(531' 344);
Magic Number,VVVV.CV.Nodes,BackgroundSubtractInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\BackgroundSubtract.cs,Process,The following statement contains a magic number: if (ThresholdEnabled) 				CvInvoke.cvThreshold(FOutput.CvMat' FOutput.CvMat' 255.0d * Threshold' 255' THRESH.CV_THRESH_BINARY);
Magic Number,VVVV.CV.Nodes,FrameDifferenceInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\FrameDifference.cs,Process,The following statement contains a magic number: if (FThresholdEnabled) 			{ 				if (FInput.ImageAttributes.ColorFormat != TColorFormat.L8) 					Status = "Cannot perform threshold on image type " + FInput.ImageAttributes.ColorFormat.ToString() + ". Can only perform threshold on L8"; 				else 					CvInvoke.cvThreshold(FOutput.CvMat' FOutput.CvMat' 255.0d * Threshold' 255' THRESH.CV_THRESH_BINARY); 			}
Magic Number,VVVV.CV.Nodes,GaussianBlurInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\GaussianBlur.cs,Process,The following statement contains a magic number: if (Width == 0)  				FOutput.Image.SetImage(FInput.Image);  			else  			{  				if (!FInput.LockForReading())  					return;  				CvInvoke.cvSmooth(FInput.CvMat' FOutput.CvMat' SMOOTH_TYPE.CV_GAUSSIAN' Width*2+1' 0' 0' 0);  				FInput.ReleaseForReading();  			}
Magic Number,VVVV.CV.Nodes,TemplateInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\Template.cs,Allocate,The following statement contains a magic number: FHalfSize.Width /=2;
Magic Number,VVVV.CV.Nodes,TemplateInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\Template.cs,Allocate,The following statement contains a magic number: FHalfSize.Height /=2;
Magic Number,VVVV.CV.Nodes,TemplateInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\Template.cs,PixelWiseAdd,The following statement contains a magic number: for (int i = 0; i < width * height; ++i) 			{ 				*rgb++ += FColorAdd[0]; 				*rgb++ += FColorAdd[1]; 				*rgb++ += FColorAdd[2]; 			}
Magic Number,VVVV.CV.Nodes,ContourDelauneyNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Tracking\ContourDelauneyNode.cs,Evaluate,The following statement contains a magic number: if (FResults)  			{  				lock (FLockTriangles)  				{  					FPinOutPosition.SliceCount = FTriangles.SliceCount;  					FPinOutArea.SliceCount = FTriangles.SliceCount;  					FPinOutCentroid.SliceCount = FTriangles.SliceCount;  					  					for (int i = 0; i < FTriangles.SliceCount; i++)  					{  						FPinOutPosition[i].SliceCount = FTriangles[i].Length * 3;  						FPinOutArea[i].SliceCount = FTriangles[i].Length;  						FPinOutCentroid[i].SliceCount = FTriangles[i].Length;    						for (int j = 0; j < FTriangles[i].Length; j++)  						{  							FPinOutPosition[i][j * 3 + 0] = new Vector2D(FTriangles[i][j].V0.X' FTriangles[i][j].V0.Y);  							FPinOutPosition[i][j * 3 + 1] = new Vector2D(FTriangles[i][j].V1.X' FTriangles[i][j].V1.Y);  							FPinOutPosition[i][j * 3 + 2] = new Vector2D(FTriangles[i][j].V2.X' FTriangles[i][j].V2.Y);    							FPinOutArea[i][j] = FTriangles[i][j].Area;  							FPinOutCentroid[i][j] = new Vector2D(FTriangles[i][j].Centeroid.X' FTriangles[i][j].Centeroid.Y);  						}  					}  				}    			}
Magic Number,VVVV.CV.Nodes,ContourDelauneyNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Tracking\ContourDelauneyNode.cs,Evaluate,The following statement contains a magic number: if (FResults)  			{  				lock (FLockTriangles)  				{  					FPinOutPosition.SliceCount = FTriangles.SliceCount;  					FPinOutArea.SliceCount = FTriangles.SliceCount;  					FPinOutCentroid.SliceCount = FTriangles.SliceCount;  					  					for (int i = 0; i < FTriangles.SliceCount; i++)  					{  						FPinOutPosition[i].SliceCount = FTriangles[i].Length * 3;  						FPinOutArea[i].SliceCount = FTriangles[i].Length;  						FPinOutCentroid[i].SliceCount = FTriangles[i].Length;    						for (int j = 0; j < FTriangles[i].Length; j++)  						{  							FPinOutPosition[i][j * 3 + 0] = new Vector2D(FTriangles[i][j].V0.X' FTriangles[i][j].V0.Y);  							FPinOutPosition[i][j * 3 + 1] = new Vector2D(FTriangles[i][j].V1.X' FTriangles[i][j].V1.Y);  							FPinOutPosition[i][j * 3 + 2] = new Vector2D(FTriangles[i][j].V2.X' FTriangles[i][j].V2.Y);    							FPinOutArea[i][j] = FTriangles[i][j].Area;  							FPinOutCentroid[i][j] = new Vector2D(FTriangles[i][j].Centeroid.X' FTriangles[i][j].Centeroid.Y);  						}  					}  				}    			}
Magic Number,VVVV.CV.Nodes,ContourDelauneyNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Tracking\ContourDelauneyNode.cs,Evaluate,The following statement contains a magic number: if (FResults)  			{  				lock (FLockTriangles)  				{  					FPinOutPosition.SliceCount = FTriangles.SliceCount;  					FPinOutArea.SliceCount = FTriangles.SliceCount;  					FPinOutCentroid.SliceCount = FTriangles.SliceCount;  					  					for (int i = 0; i < FTriangles.SliceCount; i++)  					{  						FPinOutPosition[i].SliceCount = FTriangles[i].Length * 3;  						FPinOutArea[i].SliceCount = FTriangles[i].Length;  						FPinOutCentroid[i].SliceCount = FTriangles[i].Length;    						for (int j = 0; j < FTriangles[i].Length; j++)  						{  							FPinOutPosition[i][j * 3 + 0] = new Vector2D(FTriangles[i][j].V0.X' FTriangles[i][j].V0.Y);  							FPinOutPosition[i][j * 3 + 1] = new Vector2D(FTriangles[i][j].V1.X' FTriangles[i][j].V1.Y);  							FPinOutPosition[i][j * 3 + 2] = new Vector2D(FTriangles[i][j].V2.X' FTriangles[i][j].V2.Y);    							FPinOutArea[i][j] = FTriangles[i][j].Area;  							FPinOutCentroid[i][j] = new Vector2D(FTriangles[i][j].Centeroid.X' FTriangles[i][j].Centeroid.Y);  						}  					}  				}    			}
Magic Number,VVVV.CV.Nodes,ContourDelauneyNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Tracking\ContourDelauneyNode.cs,Evaluate,The following statement contains a magic number: if (FResults)  			{  				lock (FLockTriangles)  				{  					FPinOutPosition.SliceCount = FTriangles.SliceCount;  					FPinOutArea.SliceCount = FTriangles.SliceCount;  					FPinOutCentroid.SliceCount = FTriangles.SliceCount;  					  					for (int i = 0; i < FTriangles.SliceCount; i++)  					{  						FPinOutPosition[i].SliceCount = FTriangles[i].Length * 3;  						FPinOutArea[i].SliceCount = FTriangles[i].Length;  						FPinOutCentroid[i].SliceCount = FTriangles[i].Length;    						for (int j = 0; j < FTriangles[i].Length; j++)  						{  							FPinOutPosition[i][j * 3 + 0] = new Vector2D(FTriangles[i][j].V0.X' FTriangles[i][j].V0.Y);  							FPinOutPosition[i][j * 3 + 1] = new Vector2D(FTriangles[i][j].V1.X' FTriangles[i][j].V1.Y);  							FPinOutPosition[i][j * 3 + 2] = new Vector2D(FTriangles[i][j].V2.X' FTriangles[i][j].V2.Y);    							FPinOutArea[i][j] = FTriangles[i][j].Area;  							FPinOutCentroid[i][j] = new Vector2D(FTriangles[i][j].Centeroid.X' FTriangles[i][j].Centeroid.Y);  						}  					}  				}    			}
Magic Number,VVVV.CV.Nodes,ContourDelauneyNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Tracking\ContourDelauneyNode.cs,Evaluate,The following statement contains a magic number: if (FResults)  			{  				lock (FLockTriangles)  				{  					FPinOutPosition.SliceCount = FTriangles.SliceCount;  					FPinOutArea.SliceCount = FTriangles.SliceCount;  					FPinOutCentroid.SliceCount = FTriangles.SliceCount;  					  					for (int i = 0; i < FTriangles.SliceCount; i++)  					{  						FPinOutPosition[i].SliceCount = FTriangles[i].Length * 3;  						FPinOutArea[i].SliceCount = FTriangles[i].Length;  						FPinOutCentroid[i].SliceCount = FTriangles[i].Length;    						for (int j = 0; j < FTriangles[i].Length; j++)  						{  							FPinOutPosition[i][j * 3 + 0] = new Vector2D(FTriangles[i][j].V0.X' FTriangles[i][j].V0.Y);  							FPinOutPosition[i][j * 3 + 1] = new Vector2D(FTriangles[i][j].V1.X' FTriangles[i][j].V1.Y);  							FPinOutPosition[i][j * 3 + 2] = new Vector2D(FTriangles[i][j].V2.X' FTriangles[i][j].V2.Y);    							FPinOutArea[i][j] = FTriangles[i][j].Area;  							FPinOutCentroid[i][j] = new Vector2D(FTriangles[i][j].Centeroid.X' FTriangles[i][j].Centeroid.Y);  						}  					}  				}    			}
Magic Number,VVVV.CV.Nodes,ContourDelauneyNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Tracking\ContourDelauneyNode.cs,ThreadedFunction,The following statement contains a magic number: while (true)  			{  				while (!FApply)  					Thread.Sleep(5);    				int SliceCount;  				Spread<PointF[]> points;  				Spread<Triangle2DF[]> triangles;    				lock (FLockPoints)  				{  					SliceCount = FPoints.SliceCount;  					points = new Spread<PointF[]>(SliceCount);    					for (int i = 0; i < SliceCount; i++)  					{  						points[i] = new PointF[FPoints[i].Length];  						Array.Copy(FPoints[i]' points[i]' FPoints[i].Length);  					}  	  				}    				triangles = new Spread<Triangle2DF[]>(SliceCount);    				for (int i = 0; i < SliceCount; i++)  				{  					PlanarSubdivision subdivision = new PlanarSubdivision(points[i] as PointF[]);  					triangles[i] = subdivision.GetDelaunayTriangles(false);  				}    				lock (FTriangles)  				{  					FTriangles.SliceCount = SliceCount;    					Triangle2DF t;  					for (int i = 0; i < SliceCount; i++)  					{  						FTriangles[i] = new Triangle2DF[triangles[i].Length];  						for (int j = 0; j < triangles[i].Length; j++ )  						{  							t = triangles[i][j];  							FTriangles[i][j] = new Triangle2DF(t.V0' t.V1' t.V2);  						}  					}  				}    				FResults = true;  			}
Magic Number,VVVV.CV.Nodes.Calibration,CalibrateCameraNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\CalibrateCamera.cs,Evaluate,The following statement contains a magic number: if (FPinInDo[0])  			{  				int nPointsPerImage = FPinInObject.SliceCount;  				bool useVVVVCoords = FPinInCoordSystem[0] == TCoordinateSystem.VVVV;    				if (nPointsPerImage == 0)  				{  					FStatus[0] = "Insufficient points";  					return;  				}  				int nImages = FPinInImage.SliceCount / nPointsPerImage;    				MCvPoint3D32f[][] objectPoints = new MCvPoint3D32f[nImages][];  				PointF[][] imagePoints = new PointF[nImages][];  				Size imageSize = new Size( (int) FPinInSensorSize[0].x' (int) FPinInSensorSize[0].y);  				CALIB_TYPE flags = new CALIB_TYPE();  				IntrinsicCameraParameters intrinsicParam = new IntrinsicCameraParameters();  				ExtrinsicCameraParameters[] extrinsicsPerView;  				GetFlags(out flags);    				if (flags.HasFlag(CALIB_TYPE.CV_CALIB_USE_INTRINSIC_GUESS))  				{  					if (FPinInIntrinsics[0] == null)  					{  						Matrix<double> mat = intrinsicParam.IntrinsicMatrix;  						mat[0' 0] = FPinInSensorSize[0].x / 2.0d;  						mat[1' 1] = FPinInSensorSize[0].y / 2.0d;  						mat[0' 2] = FPinInSensorSize[0].x / 2.0d;  						mat[1' 2] = FPinInSensorSize[0].y / 2.0d;  						mat[2' 2] = 1;  					}  					else  					{  						intrinsicParam.DistortionCoeffs = FPinInIntrinsics[0].intrinsics.DistortionCoeffs.Clone();  						intrinsicParam.IntrinsicMatrix = FPinInIntrinsics[0].intrinsics.IntrinsicMatrix.Clone();  					}    				}    				imagePoints = MatrixUtils.ImagePoints(FPinInImage' nPointsPerImage);    				for (int i=0; i<nImages; i++)  				{  					objectPoints[i] = MatrixUtils.ObjectPoints(FPinInObject' useVVVVCoords);  				}    				try  				{  					FPinOutError[0] = CameraCalibration.CalibrateCamera(objectPoints' imagePoints' imageSize' intrinsicParam' flags' out extrinsicsPerView);    					Intrinsics intrinsics = new Intrinsics(intrinsicParam' imageSize);  					FPinOutIntrinsics[0] = intrinsics;  					if (useVVVVCoords)  						FPinOutProjection[0] = intrinsics.Matrix;  					else  						FPinOutProjection[0] = intrinsics.Matrix;    					FPinOutExtrinsics.SliceCount = nImages;  					FPinOutView.SliceCount = nImages;  					for (int i = 0; i < nImages; i++)  					{  						Extrinsics extrinsics = new Extrinsics(extrinsicsPerView[i]);  						FPinOutExtrinsics[i] = extrinsics;    						if (useVVVVCoords)  							FPinOutView[i] = MatrixUtils.ConvertToVVVV(extrinsics.Matrix);  						else  							FPinOutView[i] = extrinsics.Matrix;  					}    					FPinOutSuccess[0] = true;  					FStatus[0] = "OK";  				}  				catch (Exception e)  {  					FPinOutSuccess[0] = false;  					FStatus[0] = e.Message;  				}  			}
Magic Number,VVVV.CV.Nodes.Calibration,CalibrateCameraNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\CalibrateCamera.cs,Evaluate,The following statement contains a magic number: if (FPinInDo[0])  			{  				int nPointsPerImage = FPinInObject.SliceCount;  				bool useVVVVCoords = FPinInCoordSystem[0] == TCoordinateSystem.VVVV;    				if (nPointsPerImage == 0)  				{  					FStatus[0] = "Insufficient points";  					return;  				}  				int nImages = FPinInImage.SliceCount / nPointsPerImage;    				MCvPoint3D32f[][] objectPoints = new MCvPoint3D32f[nImages][];  				PointF[][] imagePoints = new PointF[nImages][];  				Size imageSize = new Size( (int) FPinInSensorSize[0].x' (int) FPinInSensorSize[0].y);  				CALIB_TYPE flags = new CALIB_TYPE();  				IntrinsicCameraParameters intrinsicParam = new IntrinsicCameraParameters();  				ExtrinsicCameraParameters[] extrinsicsPerView;  				GetFlags(out flags);    				if (flags.HasFlag(CALIB_TYPE.CV_CALIB_USE_INTRINSIC_GUESS))  				{  					if (FPinInIntrinsics[0] == null)  					{  						Matrix<double> mat = intrinsicParam.IntrinsicMatrix;  						mat[0' 0] = FPinInSensorSize[0].x / 2.0d;  						mat[1' 1] = FPinInSensorSize[0].y / 2.0d;  						mat[0' 2] = FPinInSensorSize[0].x / 2.0d;  						mat[1' 2] = FPinInSensorSize[0].y / 2.0d;  						mat[2' 2] = 1;  					}  					else  					{  						intrinsicParam.DistortionCoeffs = FPinInIntrinsics[0].intrinsics.DistortionCoeffs.Clone();  						intrinsicParam.IntrinsicMatrix = FPinInIntrinsics[0].intrinsics.IntrinsicMatrix.Clone();  					}    				}    				imagePoints = MatrixUtils.ImagePoints(FPinInImage' nPointsPerImage);    				for (int i=0; i<nImages; i++)  				{  					objectPoints[i] = MatrixUtils.ObjectPoints(FPinInObject' useVVVVCoords);  				}    				try  				{  					FPinOutError[0] = CameraCalibration.CalibrateCamera(objectPoints' imagePoints' imageSize' intrinsicParam' flags' out extrinsicsPerView);    					Intrinsics intrinsics = new Intrinsics(intrinsicParam' imageSize);  					FPinOutIntrinsics[0] = intrinsics;  					if (useVVVVCoords)  						FPinOutProjection[0] = intrinsics.Matrix;  					else  						FPinOutProjection[0] = intrinsics.Matrix;    					FPinOutExtrinsics.SliceCount = nImages;  					FPinOutView.SliceCount = nImages;  					for (int i = 0; i < nImages; i++)  					{  						Extrinsics extrinsics = new Extrinsics(extrinsicsPerView[i]);  						FPinOutExtrinsics[i] = extrinsics;    						if (useVVVVCoords)  							FPinOutView[i] = MatrixUtils.ConvertToVVVV(extrinsics.Matrix);  						else  							FPinOutView[i] = extrinsics.Matrix;  					}    					FPinOutSuccess[0] = true;  					FStatus[0] = "OK";  				}  				catch (Exception e)  {  					FPinOutSuccess[0] = false;  					FStatus[0] = e.Message;  				}  			}
Magic Number,VVVV.CV.Nodes.Calibration,CalibrateCameraNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\CalibrateCamera.cs,Evaluate,The following statement contains a magic number: if (FPinInDo[0])  			{  				int nPointsPerImage = FPinInObject.SliceCount;  				bool useVVVVCoords = FPinInCoordSystem[0] == TCoordinateSystem.VVVV;    				if (nPointsPerImage == 0)  				{  					FStatus[0] = "Insufficient points";  					return;  				}  				int nImages = FPinInImage.SliceCount / nPointsPerImage;    				MCvPoint3D32f[][] objectPoints = new MCvPoint3D32f[nImages][];  				PointF[][] imagePoints = new PointF[nImages][];  				Size imageSize = new Size( (int) FPinInSensorSize[0].x' (int) FPinInSensorSize[0].y);  				CALIB_TYPE flags = new CALIB_TYPE();  				IntrinsicCameraParameters intrinsicParam = new IntrinsicCameraParameters();  				ExtrinsicCameraParameters[] extrinsicsPerView;  				GetFlags(out flags);    				if (flags.HasFlag(CALIB_TYPE.CV_CALIB_USE_INTRINSIC_GUESS))  				{  					if (FPinInIntrinsics[0] == null)  					{  						Matrix<double> mat = intrinsicParam.IntrinsicMatrix;  						mat[0' 0] = FPinInSensorSize[0].x / 2.0d;  						mat[1' 1] = FPinInSensorSize[0].y / 2.0d;  						mat[0' 2] = FPinInSensorSize[0].x / 2.0d;  						mat[1' 2] = FPinInSensorSize[0].y / 2.0d;  						mat[2' 2] = 1;  					}  					else  					{  						intrinsicParam.DistortionCoeffs = FPinInIntrinsics[0].intrinsics.DistortionCoeffs.Clone();  						intrinsicParam.IntrinsicMatrix = FPinInIntrinsics[0].intrinsics.IntrinsicMatrix.Clone();  					}    				}    				imagePoints = MatrixUtils.ImagePoints(FPinInImage' nPointsPerImage);    				for (int i=0; i<nImages; i++)  				{  					objectPoints[i] = MatrixUtils.ObjectPoints(FPinInObject' useVVVVCoords);  				}    				try  				{  					FPinOutError[0] = CameraCalibration.CalibrateCamera(objectPoints' imagePoints' imageSize' intrinsicParam' flags' out extrinsicsPerView);    					Intrinsics intrinsics = new Intrinsics(intrinsicParam' imageSize);  					FPinOutIntrinsics[0] = intrinsics;  					if (useVVVVCoords)  						FPinOutProjection[0] = intrinsics.Matrix;  					else  						FPinOutProjection[0] = intrinsics.Matrix;    					FPinOutExtrinsics.SliceCount = nImages;  					FPinOutView.SliceCount = nImages;  					for (int i = 0; i < nImages; i++)  					{  						Extrinsics extrinsics = new Extrinsics(extrinsicsPerView[i]);  						FPinOutExtrinsics[i] = extrinsics;    						if (useVVVVCoords)  							FPinOutView[i] = MatrixUtils.ConvertToVVVV(extrinsics.Matrix);  						else  							FPinOutView[i] = extrinsics.Matrix;  					}    					FPinOutSuccess[0] = true;  					FStatus[0] = "OK";  				}  				catch (Exception e)  {  					FPinOutSuccess[0] = false;  					FStatus[0] = e.Message;  				}  			}
Magic Number,VVVV.CV.Nodes.Calibration,CalibrateCameraNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Calibration\CalibrateCamera.cs,Evaluate,The following statement contains a magic number: if (FPinInDo[0])  			{  				int nPointsPerImage = FPinInObject.SliceCount;  				bool useVVVVCoords = FPinInCoordSystem[0] == TCoordinateSystem.VVVV;    				if (nPointsPerImage == 0)  				{  					FStatus[0] = "Insufficient points";  					return;  				}  				int nImages = FPinInImage.SliceCount / nPointsPerImage;    				MCvPoint3D32f[][] objectPoints = new MCvPoint3D32f[nImages][];  				PointF[][] imagePoints = new PointF[nImages][];  				Size imageSize = new Size( (int) FPinInSensorSize[0].x' (int) FPinInSensorSize[0].y);  				CALIB_TYPE flags = new CALIB_TYPE();  				IntrinsicCameraParameters intrinsicParam = new IntrinsicCameraParameters();  				ExtrinsicCameraParameters[] extrinsicsPerView;  				GetFlags(out flags);    				if (flags.HasFlag(CALIB_TYPE.CV_CALIB_USE_INTRINSIC_GUESS))  				{  					if (FPinInIntrinsics[0] == null)  					{  						Matrix<double> mat = intrinsicParam.IntrinsicMatrix;  						mat[0' 0] = FPinInSensorSize[0].x / 2.0d;  						mat[1' 1] = FPinInSensorSize[0].y / 2.0d;  						mat[0' 2] = FPinInSensorSize[0].x / 2.0d;  						mat[1' 2] = FPinInSensorSize[0].y / 2.0d;  						mat[2' 2] = 1;  					}  					else  					{  						intrinsicParam.DistortionCoeffs = FPinInIntrinsics[0].intrinsics.DistortionCoeffs.Clone();  						intrinsicParam.IntrinsicMatrix = FPinInIntrinsics[0].intrinsics.IntrinsicMatrix.Clone();  					}    				}    				imagePoints = MatrixUtils.ImagePoints(FPinInImage' nPointsPerImage);    				for (int i=0; i<nImages; i++)  				{  					objectPoints[i] = MatrixUtils.ObjectPoints(FPinInObject' useVVVVCoords);  				}    				try  				{  					FPinOutError[0] = CameraCalibration.CalibrateCamera(objectPoints' imagePoints' imageSize' intrinsicParam' flags' out extrinsicsPerView);    					Intrinsics intrinsics = new Intrinsics(intrinsicParam' imageSize);  					FPinOutIntrinsics[0] = intrinsics;  					if (useVVVVCoords)  						FPinOutProjection[0] = intrinsics.Matrix;  					else  						FPinOutProjection[0] = intrinsics.Matrix;    					FPinOutExtrinsics.SliceCount = nImages;  					FPinOutView.SliceCount = nImages;  					for (int i = 0; i < nImages; i++)  					{  						Extrinsics extrinsics = new Extrinsics(extrinsicsPerView[i]);  						FPinOutExtrinsics[i] = extrinsics;    						if (useVVVVCoords)  							FPinOutView[i] = MatrixUtils.ConvertToVVVV(extrinsics.Matrix);  						else  							FPinOutView[i] = extrinsics.Matrix;  					}    					FPinOutSuccess[0] = true;  					FStatus[0] = "OK";  				}  				catch (Exception e)  {  					FPinOutSuccess[0] = false;  					FStatus[0] = e.Message;  				}  			}
Magic Number,VVVV.CV.Nodes.Features.Criteria,ImageRegion,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Features\Criteria\Position.cs,Accept,The following statement contains a magic number: return (x > Position.x - Scale.x * 0.5 && x < Position.x + Scale.x * 0.5 && y > Position.y - Scale.y * 0.5 && y < Position.y + Scale.y * 0.5);
Magic Number,VVVV.CV.Nodes.Features.Criteria,ImageRegion,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Features\Criteria\Position.cs,Accept,The following statement contains a magic number: return (x > Position.x - Scale.x * 0.5 && x < Position.x + Scale.x * 0.5 && y > Position.y - Scale.y * 0.5 && y < Position.y + Scale.y * 0.5);
Magic Number,VVVV.CV.Nodes.Features.Criteria,ImageRegion,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Features\Criteria\Position.cs,Accept,The following statement contains a magic number: return (x > Position.x - Scale.x * 0.5 && x < Position.x + Scale.x * 0.5 && y > Position.y - Scale.y * 0.5 && y < Position.y + Scale.y * 0.5);
Magic Number,VVVV.CV.Nodes.Features.Criteria,ImageRegion,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Features\Criteria\Position.cs,Accept,The following statement contains a magic number: return (x > Position.x - Scale.x * 0.5 && x < Position.x + Scale.x * 0.5 && y > Position.y - Scale.y * 0.5 && y < Position.y + Scale.y * 0.5);
Magic Number,VVVV.CV.Nodes.Features,MatchFeatures,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Features\MatchFeatures.cs,Evaluate,The following statement contains a magic number: for (int i = 0; i < SpreadMax; i++)              {                  if (!FDo[i])                      continue;                    var input1 = FInput1[i];                  var input2 = FInput2[i];                    if (input1 == null || input2 == null)                      continue;                  if (!input1.Allocated || !input2.Allocated)                      continue;                    Matrix<byte> mask;                  var matcher = new BruteForceMatcher<float>(DistanceType.L2);                  matcher.Add(input2.Descriptors);                    var indices = new Matrix<int>(input1.Descriptors.Rows' 2);                  using (Matrix<float> distance = new Matrix<float>(input1.Descriptors.Rows' 2))                  {                      matcher.KnnMatch(input1.Descriptors' indices' distance' 2' null);                      mask = new Matrix<byte>(distance.Rows' 1);                      mask.SetValue(255);                      Features2DToolbox.VoteForUniqueness(distance' FUniqueness[i]' mask);                  }                    int nonZeroCount = CvInvoke.cvCountNonZero(mask);                  nonZeroCount = Features2DToolbox.VoteForSizeAndOrientation(input2.KeyPoints' input1.KeyPoints' indices' mask' 1.5' 20);                    var positions1 = FOutPositions1[i];                  var positions2 = FOutPositions2[i];                    positions1.SliceCount = 0;                  positions2.SliceCount = 0;                    for (int j = 0; j < mask.Rows; j++)                  {                      if (mask[j' 0] != 0)                      {                          var index2 = indices[j' 0];                          var point1 = input1.KeyPoints[j];                          var point2 = input2.KeyPoints[index2];                            positions1.Add(new Vector2D(point1.Point.X' point1.Point.Y));                          positions2.Add(new Vector2D(point2.Point.X' point2.Point.Y));                      }                  }              }
Magic Number,VVVV.CV.Nodes.Features,MatchFeatures,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Features\MatchFeatures.cs,Evaluate,The following statement contains a magic number: for (int i = 0; i < SpreadMax; i++)              {                  if (!FDo[i])                      continue;                    var input1 = FInput1[i];                  var input2 = FInput2[i];                    if (input1 == null || input2 == null)                      continue;                  if (!input1.Allocated || !input2.Allocated)                      continue;                    Matrix<byte> mask;                  var matcher = new BruteForceMatcher<float>(DistanceType.L2);                  matcher.Add(input2.Descriptors);                    var indices = new Matrix<int>(input1.Descriptors.Rows' 2);                  using (Matrix<float> distance = new Matrix<float>(input1.Descriptors.Rows' 2))                  {                      matcher.KnnMatch(input1.Descriptors' indices' distance' 2' null);                      mask = new Matrix<byte>(distance.Rows' 1);                      mask.SetValue(255);                      Features2DToolbox.VoteForUniqueness(distance' FUniqueness[i]' mask);                  }                    int nonZeroCount = CvInvoke.cvCountNonZero(mask);                  nonZeroCount = Features2DToolbox.VoteForSizeAndOrientation(input2.KeyPoints' input1.KeyPoints' indices' mask' 1.5' 20);                    var positions1 = FOutPositions1[i];                  var positions2 = FOutPositions2[i];                    positions1.SliceCount = 0;                  positions2.SliceCount = 0;                    for (int j = 0; j < mask.Rows; j++)                  {                      if (mask[j' 0] != 0)                      {                          var index2 = indices[j' 0];                          var point1 = input1.KeyPoints[j];                          var point2 = input2.KeyPoints[index2];                            positions1.Add(new Vector2D(point1.Point.X' point1.Point.Y));                          positions2.Add(new Vector2D(point2.Point.X' point2.Point.Y));                      }                  }              }
Magic Number,VVVV.CV.Nodes.Features,MatchFeatures,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Features\MatchFeatures.cs,Evaluate,The following statement contains a magic number: for (int i = 0; i < SpreadMax; i++)              {                  if (!FDo[i])                      continue;                    var input1 = FInput1[i];                  var input2 = FInput2[i];                    if (input1 == null || input2 == null)                      continue;                  if (!input1.Allocated || !input2.Allocated)                      continue;                    Matrix<byte> mask;                  var matcher = new BruteForceMatcher<float>(DistanceType.L2);                  matcher.Add(input2.Descriptors);                    var indices = new Matrix<int>(input1.Descriptors.Rows' 2);                  using (Matrix<float> distance = new Matrix<float>(input1.Descriptors.Rows' 2))                  {                      matcher.KnnMatch(input1.Descriptors' indices' distance' 2' null);                      mask = new Matrix<byte>(distance.Rows' 1);                      mask.SetValue(255);                      Features2DToolbox.VoteForUniqueness(distance' FUniqueness[i]' mask);                  }                    int nonZeroCount = CvInvoke.cvCountNonZero(mask);                  nonZeroCount = Features2DToolbox.VoteForSizeAndOrientation(input2.KeyPoints' input1.KeyPoints' indices' mask' 1.5' 20);                    var positions1 = FOutPositions1[i];                  var positions2 = FOutPositions2[i];                    positions1.SliceCount = 0;                  positions2.SliceCount = 0;                    for (int j = 0; j < mask.Rows; j++)                  {                      if (mask[j' 0] != 0)                      {                          var index2 = indices[j' 0];                          var point1 = input1.KeyPoints[j];                          var point2 = input2.KeyPoints[index2];                            positions1.Add(new Vector2D(point1.Point.X' point1.Point.Y));                          positions2.Add(new Vector2D(point2.Point.X' point2.Point.Y));                      }                  }              }
Magic Number,VVVV.CV.Nodes.Features,MatchFeatures,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Features\MatchFeatures.cs,Evaluate,The following statement contains a magic number: for (int i = 0; i < SpreadMax; i++)              {                  if (!FDo[i])                      continue;                    var input1 = FInput1[i];                  var input2 = FInput2[i];                    if (input1 == null || input2 == null)                      continue;                  if (!input1.Allocated || !input2.Allocated)                      continue;                    Matrix<byte> mask;                  var matcher = new BruteForceMatcher<float>(DistanceType.L2);                  matcher.Add(input2.Descriptors);                    var indices = new Matrix<int>(input1.Descriptors.Rows' 2);                  using (Matrix<float> distance = new Matrix<float>(input1.Descriptors.Rows' 2))                  {                      matcher.KnnMatch(input1.Descriptors' indices' distance' 2' null);                      mask = new Matrix<byte>(distance.Rows' 1);                      mask.SetValue(255);                      Features2DToolbox.VoteForUniqueness(distance' FUniqueness[i]' mask);                  }                    int nonZeroCount = CvInvoke.cvCountNonZero(mask);                  nonZeroCount = Features2DToolbox.VoteForSizeAndOrientation(input2.KeyPoints' input1.KeyPoints' indices' mask' 1.5' 20);                    var positions1 = FOutPositions1[i];                  var positions2 = FOutPositions2[i];                    positions1.SliceCount = 0;                  positions2.SliceCount = 0;                    for (int j = 0; j < mask.Rows; j++)                  {                      if (mask[j' 0] != 0)                      {                          var index2 = indices[j' 0];                          var point1 = input1.KeyPoints[j];                          var point2 = input2.KeyPoints[index2];                            positions1.Add(new Vector2D(point1.Point.X' point1.Point.Y));                          positions2.Add(new Vector2D(point2.Point.X' point2.Point.Y));                      }                  }              }
Magic Number,VVVV.CV.Nodes.Features,MatchFeatures,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Features\MatchFeatures.cs,Evaluate,The following statement contains a magic number: for (int i = 0; i < SpreadMax; i++)              {                  if (!FDo[i])                      continue;                    var input1 = FInput1[i];                  var input2 = FInput2[i];                    if (input1 == null || input2 == null)                      continue;                  if (!input1.Allocated || !input2.Allocated)                      continue;                    Matrix<byte> mask;                  var matcher = new BruteForceMatcher<float>(DistanceType.L2);                  matcher.Add(input2.Descriptors);                    var indices = new Matrix<int>(input1.Descriptors.Rows' 2);                  using (Matrix<float> distance = new Matrix<float>(input1.Descriptors.Rows' 2))                  {                      matcher.KnnMatch(input1.Descriptors' indices' distance' 2' null);                      mask = new Matrix<byte>(distance.Rows' 1);                      mask.SetValue(255);                      Features2DToolbox.VoteForUniqueness(distance' FUniqueness[i]' mask);                  }                    int nonZeroCount = CvInvoke.cvCountNonZero(mask);                  nonZeroCount = Features2DToolbox.VoteForSizeAndOrientation(input2.KeyPoints' input1.KeyPoints' indices' mask' 1.5' 20);                    var positions1 = FOutPositions1[i];                  var positions2 = FOutPositions2[i];                    positions1.SliceCount = 0;                  positions2.SliceCount = 0;                    for (int j = 0; j < mask.Rows; j++)                  {                      if (mask[j' 0] != 0)                      {                          var index2 = indices[j' 0];                          var point1 = input1.KeyPoints[j];                          var point2 = input2.KeyPoints[index2];                            positions1.Add(new Vector2D(point1.Point.X' point1.Point.Y));                          positions2.Add(new Vector2D(point2.Point.X' point2.Point.Y));                      }                  }              }
Magic Number,VVVV.CV.Nodes.Features,MatchFeatures,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Features\MatchFeatures.cs,Evaluate,The following statement contains a magic number: for (int i = 0; i < SpreadMax; i++)              {                  if (!FDo[i])                      continue;                    var input1 = FInput1[i];                  var input2 = FInput2[i];                    if (input1 == null || input2 == null)                      continue;                  if (!input1.Allocated || !input2.Allocated)                      continue;                    Matrix<byte> mask;                  var matcher = new BruteForceMatcher<float>(DistanceType.L2);                  matcher.Add(input2.Descriptors);                    var indices = new Matrix<int>(input1.Descriptors.Rows' 2);                  using (Matrix<float> distance = new Matrix<float>(input1.Descriptors.Rows' 2))                  {                      matcher.KnnMatch(input1.Descriptors' indices' distance' 2' null);                      mask = new Matrix<byte>(distance.Rows' 1);                      mask.SetValue(255);                      Features2DToolbox.VoteForUniqueness(distance' FUniqueness[i]' mask);                  }                    int nonZeroCount = CvInvoke.cvCountNonZero(mask);                  nonZeroCount = Features2DToolbox.VoteForSizeAndOrientation(input2.KeyPoints' input1.KeyPoints' indices' mask' 1.5' 20);                    var positions1 = FOutPositions1[i];                  var positions2 = FOutPositions2[i];                    positions1.SliceCount = 0;                  positions2.SliceCount = 0;                    for (int j = 0; j < mask.Rows; j++)                  {                      if (mask[j' 0] != 0)                      {                          var index2 = indices[j' 0];                          var point1 = input1.KeyPoints[j];                          var point2 = input2.KeyPoints[index2];                            positions1.Add(new Vector2D(point1.Point.X' point1.Point.Y));                          positions2.Add(new Vector2D(point2.Point.X' point2.Point.Y));                      }                  }              }
Magic Number,VVVV.CV.Nodes.StructuredLight,SpaceInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\DataViewNode.cs,UpdateCameraInProjector,The following statement contains a magic number: fixed (ulong* camInProjFixed = &FScanSet.CameraInProjector[0])  			{  				fixed (ulong* projInCamFixed = &FScanSet.ProjectorInCamera[0])  				{  					ulong* projInCamPtr = projInCamFixed;  					fixed (float* distanceFixed = &FScanSet.Distance[0])  					{  						long start = DateTime.Now.Ticks;  						  						float* distancePtr = distanceFixed;  						Parallel.For(0' PixelCount' i =>  						{  							if (distancePtr[i] > threshold)  							{  								float* pixel;  								ulong projInCam = projInCamPtr[i]; /// An index of a camera pixel' index is a projector pixel's index    								//index of this projector pixel  								pixel = pixels + (int)(projInCam) * 4;    								*pixel++ = (float)(i % width) / floatWidth;  								*pixel++ = (float)(i / width) / floatHeight;  								*pixel++ = 0.0f;  								*pixel++ = 1.0f;  							}  						});    						long parallel = DateTime.Now.Ticks - start;    						for (int i = 0; i < PixelCount; i++)  						{  							if (distancePtr[i] > threshold)  							{  								float* pixel;  								ulong projInCam = projInCamPtr[i]; /// An index of a camera pixel' index is a projector pixel's index    								//index of this projector pixel  								pixel = pixels + (int)(projInCam) * 4;    								*pixel++ = (float)(i % width) / floatWidth;  								*pixel++ = (float)(i / width) / floatHeight;  								*pixel++ = 0.0f;  								*pixel++ = 1.0f;  							}  						}    						long sequential = DateTime.Now.Ticks - (start + parallel);  						Debug.Print("parallel = " + parallel.ToString() + "' sequential = " + sequential.ToString());  					}  				}  			}
Magic Number,VVVV.CV.Nodes.StructuredLight,SpaceInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\DataViewNode.cs,UpdateCameraInProjector,The following statement contains a magic number: fixed (ulong* camInProjFixed = &FScanSet.CameraInProjector[0])  			{  				fixed (ulong* projInCamFixed = &FScanSet.ProjectorInCamera[0])  				{  					ulong* projInCamPtr = projInCamFixed;  					fixed (float* distanceFixed = &FScanSet.Distance[0])  					{  						long start = DateTime.Now.Ticks;  						  						float* distancePtr = distanceFixed;  						Parallel.For(0' PixelCount' i =>  						{  							if (distancePtr[i] > threshold)  							{  								float* pixel;  								ulong projInCam = projInCamPtr[i]; /// An index of a camera pixel' index is a projector pixel's index    								//index of this projector pixel  								pixel = pixels + (int)(projInCam) * 4;    								*pixel++ = (float)(i % width) / floatWidth;  								*pixel++ = (float)(i / width) / floatHeight;  								*pixel++ = 0.0f;  								*pixel++ = 1.0f;  							}  						});    						long parallel = DateTime.Now.Ticks - start;    						for (int i = 0; i < PixelCount; i++)  						{  							if (distancePtr[i] > threshold)  							{  								float* pixel;  								ulong projInCam = projInCamPtr[i]; /// An index of a camera pixel' index is a projector pixel's index    								//index of this projector pixel  								pixel = pixels + (int)(projInCam) * 4;    								*pixel++ = (float)(i % width) / floatWidth;  								*pixel++ = (float)(i / width) / floatHeight;  								*pixel++ = 0.0f;  								*pixel++ = 1.0f;  							}  						}    						long sequential = DateTime.Now.Ticks - (start + parallel);  						Debug.Print("parallel = " + parallel.ToString() + "' sequential = " + sequential.ToString());  					}  				}  			}
Magic Number,VVVV.CV.Nodes.StructuredLight,DecodeInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\DecodeNode.cs,Process,The following statement contains a magic number: if (FApply && TimestampRegister != null)  			{  				FInput.LockForReading();  				try  				{  					ulong Frame;  					if (TimestampRegister.Lookup(FInput.Image.Timestamp' out Frame))  					{  						if (!(WaitForTimestamp && Frame == LastFrameCaptured))  						{  							LastFrameCaptured = Frame;  							FFramesDetected++;    							if (!WaitForTimestamp)  								FApply = false;    							if (ScanSet.Payload.Balanced)  							{  								bool positive = Frame % 2 == 0;  								FInput.GetImage(positive ? FPositive : FNegative);    								if (!positive && Frame / 2 == CurrentBalancedFrame)  									ApplyBalanced(Frame / 2);  								CurrentBalancedFrame = Frame / 2;  							}  						}  				  					}    				}  				finally  				{  					FInput.ReleaseForReading();  				}  				ScanSet.Evaluate();  			}
Magic Number,VVVV.CV.Nodes.StructuredLight,DecodeInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\DecodeNode.cs,Process,The following statement contains a magic number: if (FApply && TimestampRegister != null)  			{  				FInput.LockForReading();  				try  				{  					ulong Frame;  					if (TimestampRegister.Lookup(FInput.Image.Timestamp' out Frame))  					{  						if (!(WaitForTimestamp && Frame == LastFrameCaptured))  						{  							LastFrameCaptured = Frame;  							FFramesDetected++;    							if (!WaitForTimestamp)  								FApply = false;    							if (ScanSet.Payload.Balanced)  							{  								bool positive = Frame % 2 == 0;  								FInput.GetImage(positive ? FPositive : FNegative);    								if (!positive && Frame / 2 == CurrentBalancedFrame)  									ApplyBalanced(Frame / 2);  								CurrentBalancedFrame = Frame / 2;  							}  						}  				  					}    				}  				finally  				{  					FInput.ReleaseForReading();  				}  				ScanSet.Evaluate();  			}
Magic Number,VVVV.CV.Nodes.StructuredLight,DecodeInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\DecodeNode.cs,Process,The following statement contains a magic number: if (FApply && TimestampRegister != null)  			{  				FInput.LockForReading();  				try  				{  					ulong Frame;  					if (TimestampRegister.Lookup(FInput.Image.Timestamp' out Frame))  					{  						if (!(WaitForTimestamp && Frame == LastFrameCaptured))  						{  							LastFrameCaptured = Frame;  							FFramesDetected++;    							if (!WaitForTimestamp)  								FApply = false;    							if (ScanSet.Payload.Balanced)  							{  								bool positive = Frame % 2 == 0;  								FInput.GetImage(positive ? FPositive : FNegative);    								if (!positive && Frame / 2 == CurrentBalancedFrame)  									ApplyBalanced(Frame / 2);  								CurrentBalancedFrame = Frame / 2;  							}  						}  				  					}    				}  				finally  				{  					FInput.ReleaseForReading();  				}  				ScanSet.Evaluate();  			}
Magic Number,VVVV.CV.Nodes.StructuredLight,DecodeInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\DecodeNode.cs,Process,The following statement contains a magic number: if (FApply && TimestampRegister != null)  			{  				FInput.LockForReading();  				try  				{  					ulong Frame;  					if (TimestampRegister.Lookup(FInput.Image.Timestamp' out Frame))  					{  						if (!(WaitForTimestamp && Frame == LastFrameCaptured))  						{  							LastFrameCaptured = Frame;  							FFramesDetected++;    							if (!WaitForTimestamp)  								FApply = false;    							if (ScanSet.Payload.Balanced)  							{  								bool positive = Frame % 2 == 0;  								FInput.GetImage(positive ? FPositive : FNegative);    								if (!positive && Frame / 2 == CurrentBalancedFrame)  									ApplyBalanced(Frame / 2);  								CurrentBalancedFrame = Frame / 2;  							}  						}  				  					}    				}  				finally  				{  					FInput.ReleaseForReading();  				}  				ScanSet.Evaluate();  			}
Magic Number,VVVV.CV.Nodes.StructuredLight,DecodeInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\DecodeNode.cs,ApplyBalanced,The following statement contains a magic number: float additionFactor = 1.0f / (float)(ScanSet.Payload.FrameCount / 2);
Magic Number,VVVV.CV.Nodes.StructuredLight,EncodeInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\EncodeNode.cs,Update,The following statement contains a magic number: lock (FPayload)  			{  				if (FPayload.Width != FOutput.Image.Width || FPayload.Height != FOutput.Image.Height)  					return;  				fixed (ulong* inPix = &FPayload.Data[0])  				{  					ulong* mov = inPix;    					int extraStride = FOutput.Image.ImageAttributes.Stride - FOutput.Image.Width;    					if (FPayload.Balanced)  					{  						byte high = frame % 2 == 0 ? (byte)255 : (byte)0;  						byte low = high == (byte)255 ? (byte)0 : (byte)255;    						frame /= 2;    						for (uint y = 0; y < FPayload.Height; y++)  						{  							for (uint x = 0; x < FPayload.Width; x++)  								*outPix++ = (*mov++ & (ulong)1 << frame) == (ulong)1 << frame? high : low;  							outPix += extraStride;  						}  					}  					else  						for (uint y = 0; y < FPayload.Height; y++)  						{  							for (uint x = 0; x < FPayload.Width; x++)  								*outPix++ = (*mov++ & (ulong)1 << frame) == (ulong)1 << frame ? (byte)255 : (byte)0;  							outPix += extraStride;  						}  				}  			}
Magic Number,VVVV.CV.Nodes.StructuredLight,EncodeInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\EncodeNode.cs,Update,The following statement contains a magic number: lock (FPayload)  			{  				if (FPayload.Width != FOutput.Image.Width || FPayload.Height != FOutput.Image.Height)  					return;  				fixed (ulong* inPix = &FPayload.Data[0])  				{  					ulong* mov = inPix;    					int extraStride = FOutput.Image.ImageAttributes.Stride - FOutput.Image.Width;    					if (FPayload.Balanced)  					{  						byte high = frame % 2 == 0 ? (byte)255 : (byte)0;  						byte low = high == (byte)255 ? (byte)0 : (byte)255;    						frame /= 2;    						for (uint y = 0; y < FPayload.Height; y++)  						{  							for (uint x = 0; x < FPayload.Width; x++)  								*outPix++ = (*mov++ & (ulong)1 << frame) == (ulong)1 << frame? high : low;  							outPix += extraStride;  						}  					}  					else  						for (uint y = 0; y < FPayload.Height; y++)  						{  							for (uint x = 0; x < FPayload.Width; x++)  								*outPix++ = (*mov++ & (ulong)1 << frame) == (ulong)1 << frame ? (byte)255 : (byte)0;  							outPix += extraStride;  						}  				}  			}
Magic Number,VVVV.CV.Nodes.StructuredLight,EncodeInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\EncodeNode.cs,Update,The following statement contains a magic number: lock (FPayload)  			{  				if (FPayload.Width != FOutput.Image.Width || FPayload.Height != FOutput.Image.Height)  					return;  				fixed (ulong* inPix = &FPayload.Data[0])  				{  					ulong* mov = inPix;    					int extraStride = FOutput.Image.ImageAttributes.Stride - FOutput.Image.Width;    					if (FPayload.Balanced)  					{  						byte high = frame % 2 == 0 ? (byte)255 : (byte)0;  						byte low = high == (byte)255 ? (byte)0 : (byte)255;    						frame /= 2;    						for (uint y = 0; y < FPayload.Height; y++)  						{  							for (uint x = 0; x < FPayload.Width; x++)  								*outPix++ = (*mov++ & (ulong)1 << frame) == (ulong)1 << frame? high : low;  							outPix += extraStride;  						}  					}  					else  						for (uint y = 0; y < FPayload.Height; y++)  						{  							for (uint x = 0; x < FPayload.Width; x++)  								*outPix++ = (*mov++ & (ulong)1 << frame) == (ulong)1 << frame ? (byte)255 : (byte)0;  							outPix += extraStride;  						}  				}  			}
Magic Number,VVVV.CV.Nodes.StructuredLight,EncodeInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\EncodeNode.cs,Update,The following statement contains a magic number: lock (FPayload)  			{  				if (FPayload.Width != FOutput.Image.Width || FPayload.Height != FOutput.Image.Height)  					return;  				fixed (ulong* inPix = &FPayload.Data[0])  				{  					ulong* mov = inPix;    					int extraStride = FOutput.Image.ImageAttributes.Stride - FOutput.Image.Width;    					if (FPayload.Balanced)  					{  						byte high = frame % 2 == 0 ? (byte)255 : (byte)0;  						byte low = high == (byte)255 ? (byte)0 : (byte)255;    						frame /= 2;    						for (uint y = 0; y < FPayload.Height; y++)  						{  							for (uint x = 0; x < FPayload.Width; x++)  								*outPix++ = (*mov++ & (ulong)1 << frame) == (ulong)1 << frame? high : low;  							outPix += extraStride;  						}  					}  					else  						for (uint y = 0; y < FPayload.Height; y++)  						{  							for (uint x = 0; x < FPayload.Width; x++)  								*outPix++ = (*mov++ & (ulong)1 << frame) == (ulong)1 << frame ? (byte)255 : (byte)0;  							outPix += extraStride;  						}  				}  			}
Magic Number,VVVV.CV.Nodes.StructuredLight,EncodeInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\EncodeNode.cs,Update,The following statement contains a magic number: lock (FPayload)  			{  				if (FPayload.Width != FOutput.Image.Width || FPayload.Height != FOutput.Image.Height)  					return;  				fixed (ulong* inPix = &FPayload.Data[0])  				{  					ulong* mov = inPix;    					int extraStride = FOutput.Image.ImageAttributes.Stride - FOutput.Image.Width;    					if (FPayload.Balanced)  					{  						byte high = frame % 2 == 0 ? (byte)255 : (byte)0;  						byte low = high == (byte)255 ? (byte)0 : (byte)255;    						frame /= 2;    						for (uint y = 0; y < FPayload.Height; y++)  						{  							for (uint x = 0; x < FPayload.Width; x++)  								*outPix++ = (*mov++ & (ulong)1 << frame) == (ulong)1 << frame? high : low;  							outPix += extraStride;  						}  					}  					else  						for (uint y = 0; y < FPayload.Height; y++)  						{  							for (uint x = 0; x < FPayload.Width; x++)  								*outPix++ = (*mov++ & (ulong)1 << frame) == (ulong)1 << frame ? (byte)255 : (byte)0;  							outPix += extraStride;  						}  				}  			}
Magic Number,VVVV.CV.Nodes.StructuredLight,EncodeInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\EncodeNode.cs,Update,The following statement contains a magic number: lock (FPayload)  			{  				if (FPayload.Width != FOutput.Image.Width || FPayload.Height != FOutput.Image.Height)  					return;  				fixed (ulong* inPix = &FPayload.Data[0])  				{  					ulong* mov = inPix;    					int extraStride = FOutput.Image.ImageAttributes.Stride - FOutput.Image.Width;    					if (FPayload.Balanced)  					{  						byte high = frame % 2 == 0 ? (byte)255 : (byte)0;  						byte low = high == (byte)255 ? (byte)0 : (byte)255;    						frame /= 2;    						for (uint y = 0; y < FPayload.Height; y++)  						{  							for (uint x = 0; x < FPayload.Width; x++)  								*outPix++ = (*mov++ & (ulong)1 << frame) == (ulong)1 << frame? high : low;  							outPix += extraStride;  						}  					}  					else  						for (uint y = 0; y < FPayload.Height; y++)  						{  							for (uint x = 0; x < FPayload.Width; x++)  								*outPix++ = (*mov++ & (ulong)1 << frame) == (ulong)1 << frame ? (byte)255 : (byte)0;  							outPix += extraStride;  						}  				}  			}
Magic Number,VVVV.CV.Nodes.Tracking,TrackingInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Tracking\DetectObject.cs,TrackingInstance,The following statement contains a magic number: ScaleFactor = 1.8;
Magic Number,VVVV.CV.Nodes.Tracking,TrackingInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Tracking\DetectObject.cs,TrackingInstance,The following statement contains a magic number: MinSize = new Size(20' 20);
Magic Number,VVVV.CV.Nodes.Tracking,TrackingInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Tracking\DetectObject.cs,TrackingInstance,The following statement contains a magic number: MinSize = new Size(20' 20);
Magic Number,VVVV.CV.Nodes.Tracking,TrackingInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Tracking\DetectObject.cs,Process,The following statement contains a magic number: foreach (var rectangle in rectangles)  			{  				var trackingObject = new TrackingObject();    				var center = new Vector2D(rectangle.X + rectangle.Width / 2' rectangle.Y + rectangle.Height / 2);  				var maximumSourceXY = new Vector2D(FGrayScale.Width' FGrayScale.Height);    				trackingObject.Position = VMath.Map(center' FMinimumSourceXY' maximumSourceXY' FMinimumDestXY'  													FMaximumDestXY' TMapMode.Float);  				trackingObject.Scale = VMath.Map(new Vector2D(rectangle.Width' rectangle.Height)' FMinimumSourceXY.x' maximumSourceXY.x' 0'  												 1' TMapMode.Float);    				FTrackingObjects.Add(trackingObject);  			}
Magic Number,VVVV.CV.Nodes.Tracking,TrackingInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Tracking\DetectObject.cs,Process,The following statement contains a magic number: foreach (var rectangle in rectangles)  			{  				var trackingObject = new TrackingObject();    				var center = new Vector2D(rectangle.X + rectangle.Width / 2' rectangle.Y + rectangle.Height / 2);  				var maximumSourceXY = new Vector2D(FGrayScale.Width' FGrayScale.Height);    				trackingObject.Position = VMath.Map(center' FMinimumSourceXY' maximumSourceXY' FMinimumDestXY'  													FMaximumDestXY' TMapMode.Float);  				trackingObject.Scale = VMath.Map(new Vector2D(rectangle.Width' rectangle.Height)' FMinimumSourceXY.x' maximumSourceXY.x' 0'  												 1' TMapMode.Float);    				FTrackingObjects.Add(trackingObject);  			}
Missing Default,VVVV.CV.Nodes,RotateStepInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\RotateStep.cs,Process,The following switch statement is missing a default case: switch (anticlockwiseSteps)              {                  case 0:                      FInput.GetImage(FOutput.Image);                      break;                    case 1:                      if (FInput.LockForReading())                      {                          try                          {                              CvInvoke.cvTranspose(FInput.CvMat' FOutput.CvMat);                          }                          finally                          {                              FInput.ReleaseForReading();                          }                          CvInvoke.cvFlip(FOutput.CvMat' FOutput.CvMat' FLIP.VERTICAL);                      }                      break;                    case 2:                      if (FInput.LockForReading())                      {                          try                          {                              CvInvoke.cvFlip(FInput.CvMat' FOutput.CvMat' FLIP.HORIZONTAL);                          }                          finally                          {                              FInput.ReleaseForReading();                          }                          CvInvoke.cvFlip(FOutput.CvMat' FOutput.CvMat' FLIP.VERTICAL);                      }                      break;                    case 3:                      if (FInput.LockForReading())                      {                          try                          {                              CvInvoke.cvTranspose(FInput.CvMat' FOutput.CvMat);                          }                          finally                          {                              FInput.ReleaseForReading();                          }                          CvInvoke.cvFlip(FOutput.CvMat' FOutput.CvMat' FLIP.HORIZONTAL);                      }                      break;              }
Missing Default,VVVV.CV.Nodes,FrameDifferenceInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\Filters\FrameDifference.cs,Process,The following switch statement is missing a default case: switch (DifferenceMode) 				{ 					case TDifferenceMode.AbsoluteDifference: 						CvInvoke.cvAbsDiff(FInput.CvMat' FLastFrame.CvMat' FOutput.CvMat); 						break; 					case TDifferenceMode.Negative: 						CvInvoke.cvSub(FInput.CvMat' FLastFrame.CvMat' FOutput.CvMat' new IntPtr()); 						break; 					case TDifferenceMode.Positive: 						CvInvoke.cvSub(FLastFrame.CvMat' FInput.CvMat' FOutput.CvMat' new IntPtr()); 						break; 				}
Missing Default,VVVV.CV.Nodes.StructuredLight,SpaceInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\DataViewNode.cs,Allocate,The following switch statement is missing a default case: switch (FDataSetType)  					{  						case TDataSet.ProjectorInCamera:  							FOutput.Image.Initialise(FScanSet.CameraSize' TColorFormat.RGBA32F);  							break;  						case TDataSet.CameraInProjector:  							FOutput.Image.Initialise(FScanSet.ProjectorSize' TColorFormat.RGBA32F);  							break;  						case TDataSet.LuminanceInCamera:  							FOutput.Image.Initialise(FScanSet.CameraSize' TColorFormat.L8);  							break;  					}
Missing Default,VVVV.CV.Nodes.StructuredLight,SpaceInstance,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\DataViewNode.cs,UpdateData,The following switch statement is missing a default case: switch (FDataSetType)  					{  						case TDataSet.ProjectorInCamera:  							UpdateProjectorInCamera();  							break;  						case TDataSet.CameraInProjector:  							UpdateCameraInProjector();  							break;  						case TDataSet.LuminanceInCamera:  							UpdateLuminanceInCamera();  							break;  					}
Missing Default,VVVV.CV.Nodes.StructuredLight.Payload,PayloadNode,C:\repos\elliotwoods_VVVV.Packs.Image\src\nodes\plugins\Image\OpenCV\src\StructuredLight\Payload\PayloadNode.cs,Evaluate,The following switch statement is missing a default case: switch (FMode[0])  				{  					case PayloadMode.Graycode:  						{  							FPayload = new PayloadGraycode(FWidth[0]' FHeight[0]' FBalanced[0]);  						}  						break;  				}
