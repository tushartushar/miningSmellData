Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Cosmos.Core_Asm,ArrayImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\ArrayImpl.cs,Copy,The method has 6 parameters. Parameters: sourceArray' sourceIndex' destinationArray' destinationIndex' length' reliable
Long Parameter List,Cosmos.Core_Asm,BufferImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\BufferImpl.cs,BlockCopy,The method has 5 parameters. Parameters: src' srcOffset' dst' dstOffset' count
Long Statement,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The length of the statement  "                    xHandler = GetMethodDef(typeof(Cosmos.Core.INTs).Assembly' typeof(Cosmos.Core.INTs).FullName' "HandleInterrupt_Default"' true); " is 127.
Long Statement,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The length of the statement  "            XS.Set(AsmMarker.Labels[AsmMarker.Type.Processor_IntsEnabled]' 1' destinationIsIndirect: true' size: RegisterSize.Byte8); " is 121.
Long Statement,Cosmos.Core_Asm,DelegateCtorAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateCtorAsm.cs,AssembleNew,The length of the statement  "            Stfld.DoExecute(xAssembler' xMethodInfo' "System.Object System.Delegate._target"' xMethodInfo.MethodBase.DeclaringType' true' false); " is 133.
Long Statement,Cosmos.Core_Asm,DelegateCtorAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateCtorAsm.cs,AssembleNew,The length of the statement  "            Stfld.DoExecute(xAssembler' xMethodInfo' "System.IntPtr System.Delegate._methodPtr"' xMethodInfo.MethodBase.DeclaringType' true' false); " is 136.
Long Statement,Cosmos.Core_Asm,DelegateInvokeAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateInvokeAsm.cs,AssembleNew,The length of the statement  "                XS.Set(XSRegisters.EDI' XSRegisters.EDI' sourceDisplacement: Ldfld.GetFieldOffset(xMethodInfo.MethodBase.DeclaringType' "System.Object System.Delegate._target")); " is 162.
Long Statement,Cosmos.Core_Asm,DelegateInvokeAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateInvokeAsm.cs,AssembleNew,The length of the statement  "                XS.Set(XSRegisters.EDI' XSRegisters.EDI' sourceDisplacement: Ldfld.GetFieldOffset(xMethodInfo.MethodBase.DeclaringType' "System.IntPtr System.Delegate._methodPtr")); " is 165.
Long Statement,Cosmos.Core_Asm,DelegateInvokeAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateInvokeAsm.cs,AssembleNew,The length of the statement  "            XS.Set(XSRegisters.EDX' XSRegisters.EDX' sourceDisplacement: Ldfld.GetFieldOffset(xMethodInfo.MethodBase.DeclaringType' "$$ReturnsValue$$")); " is 141.
Long Statement,Cosmos.Core_Asm,ProcessorInformationImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\ProcessorInformationImpl.cs,FetchCPUVendor,The length of the statement  "            XS.Lea(XSRegisters.ESI' intname); // new Lea { DestinationReg = RegistersEnum.ESI' SourceRef = ElementReference.New(intname) }; " is 127.
Magic Number,Cosmos.Core_Asm,ArrayGetLengthAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Array\ArrayGetLengthAsm.cs,AssembleNew,The following statement contains a magic number: XS.Set(XSRegisters.EAX' XSRegisters.EBP' sourceDisplacement: 8);
Magic Number,Cosmos.Core_Asm,ArrayGetLengthAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Array\ArrayGetLengthAsm.cs,AssembleNew,The following statement contains a magic number: XS.Set(XSRegisters.EAX' XSRegisters.EAX' sourceDisplacement: 8' sourceIsIndirect: true);
Magic Number,Cosmos.Core_Asm,ArrayInternalCopyAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Array\ArrayInternalCopyAsm.cs,AssembleNew,The following statement contains a magic number: XS.Add(EAX' ObjectUtils.FieldDataOffset + 4);
Magic Number,Cosmos.Core_Asm,ArrayInternalCopyAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Array\ArrayInternalCopyAsm.cs,AssembleNew,The following statement contains a magic number: XS.Add(EAX' ObjectUtils.FieldDataOffset + 4);
Magic Number,Cosmos.Core_Asm,ArrayInternalCopyAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Array\ArrayInternalCopyAsm.cs,AssembleNew,The following statement contains a magic number: new Movs { Size = 8' Prefixes = InstructionPrefixes.Repeat };
Magic Number,Cosmos.Core_Asm,BufferBlockCopyAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Buffer\BufferBlockCopyAsm.cs,AssembleNew,The following statement contains a magic number: XS.Add(XSRegisters.ESI' ObjectUtils.FieldDataOffset + 4);
Magic Number,Cosmos.Core_Asm,BufferBlockCopyAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Buffer\BufferBlockCopyAsm.cs,AssembleNew,The following statement contains a magic number: XS.Add(XSRegisters.EDI' ObjectUtils.FieldDataOffset + 4);
Magic Number,Cosmos.Core_Asm,BufferBlockCopyAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Buffer\BufferBlockCopyAsm.cs,AssembleNew,The following statement contains a magic number: new CPUx86.Movs { Size = 8' Prefixes = CPUx86.InstructionPrefixes.Repeat };
Magic Number,Cosmos.Core_Asm,CPUGetAmountOfRAMAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUGetAmountOfRAMAsm.cs,AssembleNew,The following statement contains a magic number: XS.Set(XSRegisters.ECX' 1024);
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  // These are already mapped' don't remap them.                  // Maybe in the future we can look at ones that are present                  // and skip them' but some we may want to overwrite anyways.                  if (i == 1 || i == 3)                  {                      continue;                  }                    XS.Set(EAX' "__ISR_Handler_" + i.ToString("X2"));                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 0);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 1);                  XS.Set("_NATIVE_IDT_Contents"' 0x8' destinationDisplacement: (i * 8) + 2' size: RegisterSize.Byte8);                  XS.Set("_NATIVE_IDT_Contents"' 0x8E' destinationDisplacement: (i * 8) + 5' size: RegisterSize.Byte8);                  XS.ShiftRight(EAX' 16);                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 6);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 7);              }
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  // These are already mapped' don't remap them.                  // Maybe in the future we can look at ones that are present                  // and skip them' but some we may want to overwrite anyways.                  if (i == 1 || i == 3)                  {                      continue;                  }                    XS.Set(EAX' "__ISR_Handler_" + i.ToString("X2"));                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 0);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 1);                  XS.Set("_NATIVE_IDT_Contents"' 0x8' destinationDisplacement: (i * 8) + 2' size: RegisterSize.Byte8);                  XS.Set("_NATIVE_IDT_Contents"' 0x8E' destinationDisplacement: (i * 8) + 5' size: RegisterSize.Byte8);                  XS.ShiftRight(EAX' 16);                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 6);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 7);              }
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  // These are already mapped' don't remap them.                  // Maybe in the future we can look at ones that are present                  // and skip them' but some we may want to overwrite anyways.                  if (i == 1 || i == 3)                  {                      continue;                  }                    XS.Set(EAX' "__ISR_Handler_" + i.ToString("X2"));                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 0);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 1);                  XS.Set("_NATIVE_IDT_Contents"' 0x8' destinationDisplacement: (i * 8) + 2' size: RegisterSize.Byte8);                  XS.Set("_NATIVE_IDT_Contents"' 0x8E' destinationDisplacement: (i * 8) + 5' size: RegisterSize.Byte8);                  XS.ShiftRight(EAX' 16);                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 6);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 7);              }
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  // These are already mapped' don't remap them.                  // Maybe in the future we can look at ones that are present                  // and skip them' but some we may want to overwrite anyways.                  if (i == 1 || i == 3)                  {                      continue;                  }                    XS.Set(EAX' "__ISR_Handler_" + i.ToString("X2"));                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 0);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 1);                  XS.Set("_NATIVE_IDT_Contents"' 0x8' destinationDisplacement: (i * 8) + 2' size: RegisterSize.Byte8);                  XS.Set("_NATIVE_IDT_Contents"' 0x8E' destinationDisplacement: (i * 8) + 5' size: RegisterSize.Byte8);                  XS.ShiftRight(EAX' 16);                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 6);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 7);              }
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  // These are already mapped' don't remap them.                  // Maybe in the future we can look at ones that are present                  // and skip them' but some we may want to overwrite anyways.                  if (i == 1 || i == 3)                  {                      continue;                  }                    XS.Set(EAX' "__ISR_Handler_" + i.ToString("X2"));                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 0);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 1);                  XS.Set("_NATIVE_IDT_Contents"' 0x8' destinationDisplacement: (i * 8) + 2' size: RegisterSize.Byte8);                  XS.Set("_NATIVE_IDT_Contents"' 0x8E' destinationDisplacement: (i * 8) + 5' size: RegisterSize.Byte8);                  XS.ShiftRight(EAX' 16);                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 6);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 7);              }
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  // These are already mapped' don't remap them.                  // Maybe in the future we can look at ones that are present                  // and skip them' but some we may want to overwrite anyways.                  if (i == 1 || i == 3)                  {                      continue;                  }                    XS.Set(EAX' "__ISR_Handler_" + i.ToString("X2"));                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 0);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 1);                  XS.Set("_NATIVE_IDT_Contents"' 0x8' destinationDisplacement: (i * 8) + 2' size: RegisterSize.Byte8);                  XS.Set("_NATIVE_IDT_Contents"' 0x8E' destinationDisplacement: (i * 8) + 5' size: RegisterSize.Byte8);                  XS.ShiftRight(EAX' 16);                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 6);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 7);              }
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  // These are already mapped' don't remap them.                  // Maybe in the future we can look at ones that are present                  // and skip them' but some we may want to overwrite anyways.                  if (i == 1 || i == 3)                  {                      continue;                  }                    XS.Set(EAX' "__ISR_Handler_" + i.ToString("X2"));                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 0);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 1);                  XS.Set("_NATIVE_IDT_Contents"' 0x8' destinationDisplacement: (i * 8) + 2' size: RegisterSize.Byte8);                  XS.Set("_NATIVE_IDT_Contents"' 0x8E' destinationDisplacement: (i * 8) + 5' size: RegisterSize.Byte8);                  XS.ShiftRight(EAX' 16);                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 6);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 7);              }
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  // These are already mapped' don't remap them.                  // Maybe in the future we can look at ones that are present                  // and skip them' but some we may want to overwrite anyways.                  if (i == 1 || i == 3)                  {                      continue;                  }                    XS.Set(EAX' "__ISR_Handler_" + i.ToString("X2"));                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 0);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 1);                  XS.Set("_NATIVE_IDT_Contents"' 0x8' destinationDisplacement: (i * 8) + 2' size: RegisterSize.Byte8);                  XS.Set("_NATIVE_IDT_Contents"' 0x8E' destinationDisplacement: (i * 8) + 5' size: RegisterSize.Byte8);                  XS.ShiftRight(EAX' 16);                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 6);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 7);              }
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  // These are already mapped' don't remap them.                  // Maybe in the future we can look at ones that are present                  // and skip them' but some we may want to overwrite anyways.                  if (i == 1 || i == 3)                  {                      continue;                  }                    XS.Set(EAX' "__ISR_Handler_" + i.ToString("X2"));                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 0);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 1);                  XS.Set("_NATIVE_IDT_Contents"' 0x8' destinationDisplacement: (i * 8) + 2' size: RegisterSize.Byte8);                  XS.Set("_NATIVE_IDT_Contents"' 0x8E' destinationDisplacement: (i * 8) + 5' size: RegisterSize.Byte8);                  XS.ShiftRight(EAX' 16);                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 6);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 7);              }
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  // These are already mapped' don't remap them.                  // Maybe in the future we can look at ones that are present                  // and skip them' but some we may want to overwrite anyways.                  if (i == 1 || i == 3)                  {                      continue;                  }                    XS.Set(EAX' "__ISR_Handler_" + i.ToString("X2"));                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 0);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 1);                  XS.Set("_NATIVE_IDT_Contents"' 0x8' destinationDisplacement: (i * 8) + 2' size: RegisterSize.Byte8);                  XS.Set("_NATIVE_IDT_Contents"' 0x8E' destinationDisplacement: (i * 8) + 5' size: RegisterSize.Byte8);                  XS.ShiftRight(EAX' 16);                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 6);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 7);              }
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  // These are already mapped' don't remap them.                  // Maybe in the future we can look at ones that are present                  // and skip them' but some we may want to overwrite anyways.                  if (i == 1 || i == 3)                  {                      continue;                  }                    XS.Set(EAX' "__ISR_Handler_" + i.ToString("X2"));                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 0);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 1);                  XS.Set("_NATIVE_IDT_Contents"' 0x8' destinationDisplacement: (i * 8) + 2' size: RegisterSize.Byte8);                  XS.Set("_NATIVE_IDT_Contents"' 0x8E' destinationDisplacement: (i * 8) + 5' size: RegisterSize.Byte8);                  XS.ShiftRight(EAX' 16);                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 6);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 7);              }
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  // These are already mapped' don't remap them.                  // Maybe in the future we can look at ones that are present                  // and skip them' but some we may want to overwrite anyways.                  if (i == 1 || i == 3)                  {                      continue;                  }                    XS.Set(EAX' "__ISR_Handler_" + i.ToString("X2"));                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 0);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 1);                  XS.Set("_NATIVE_IDT_Contents"' 0x8' destinationDisplacement: (i * 8) + 2' size: RegisterSize.Byte8);                  XS.Set("_NATIVE_IDT_Contents"' 0x8E' destinationDisplacement: (i * 8) + 5' size: RegisterSize.Byte8);                  XS.ShiftRight(EAX' 16);                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 6);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 7);              }
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  // These are already mapped' don't remap them.                  // Maybe in the future we can look at ones that are present                  // and skip them' but some we may want to overwrite anyways.                  if (i == 1 || i == 3)                  {                      continue;                  }                    XS.Set(EAX' "__ISR_Handler_" + i.ToString("X2"));                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 0);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 1);                  XS.Set("_NATIVE_IDT_Contents"' 0x8' destinationDisplacement: (i * 8) + 2' size: RegisterSize.Byte8);                  XS.Set("_NATIVE_IDT_Contents"' 0x8E' destinationDisplacement: (i * 8) + 5' size: RegisterSize.Byte8);                  XS.ShiftRight(EAX' 16);                  XS.Set("_NATIVE_IDT_Contents"' AL' destinationDisplacement: (i * 8) + 6);                  XS.Set("_NATIVE_IDT_Contents"' AH' destinationDisplacement: (i * 8) + 7);              }
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: var xInterruptsWithParam = new[] { 8' 10' 11' 12' 13' 14 };
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: var xInterruptsWithParam = new[] { 8' 10' 11' 12' 13' 14 };
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: var xInterruptsWithParam = new[] { 8' 10' 11' 12' 13' 14 };
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: var xInterruptsWithParam = new[] { 8' 10' 11' 12' 13' 14 };
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: var xInterruptsWithParam = new[] { 8' 10' 11' 12' 13' 14 };
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: var xInterruptsWithParam = new[] { 8' 10' 11' 12' 13' 14 };
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: for (int j = 0; j < 256; j++)              {                  XS.Label("__ISR_Handler_" + j.ToString("X2"));                  XS.Call("__INTERRUPT_OCCURRED__");                    if (Array.IndexOf(xInterruptsWithParam' j) == -1)                  {                      XS.Push(0);                  }                  XS.Push((uint)j);                  XS.PushAllRegisters();                    XS.Sub(ESP' 4);                  XS.Set(EAX' ESP); // preserve old stack address for passing to interrupt handler                    // store floating point data                  XS.And(ESP' 0xfffffff0); // fxsave needs to be 16-byte alligned                  XS.Sub(ESP' 512); // fxsave needs 512 bytes                  XS.SSE.FXSave(ESP' isIndirect: true); // save the registers                  XS.Set(EAX' ESP' destinationIsIndirect: true);                    XS.Push(EAX); //                  XS.Push(EAX); // pass old stack address (pointer to InterruptContext struct) to the interrupt handler                    XS.JumpToSegment(8' "__ISR_Handler_" + j.ToString("X2") + "_SetCS");                  XS.Label("__ISR_Handler_" + j.ToString("X2") + "_SetCS");                  MethodBase xHandler = GetInterruptHandler((byte)j);                  if (xHandler == null)                  {                      xHandler = GetMethodDef(typeof(Cosmos.Core.INTs).Assembly' typeof(Cosmos.Core.INTs).FullName' "HandleInterrupt_Default"' true);                  }                  XS.Call(LabelName.Get(xHandler));                  XS.Pop(EAX);                  XS.SSE.FXRestore(ESP' isIndirect: true);                    XS.Set(ESP' EAX); // this restores the stack for the FX stuff' except the pointer to the FX data                  XS.Add(ESP' 4); // "pop" the pointer                    XS.PopAllRegisters();                    XS.Add(ESP' 8);                  XS.Label("__ISR_Handler_" + j.ToString("X2") + "_END");                  XS.InterruptReturn();              }
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: for (int j = 0; j < 256; j++)              {                  XS.Label("__ISR_Handler_" + j.ToString("X2"));                  XS.Call("__INTERRUPT_OCCURRED__");                    if (Array.IndexOf(xInterruptsWithParam' j) == -1)                  {                      XS.Push(0);                  }                  XS.Push((uint)j);                  XS.PushAllRegisters();                    XS.Sub(ESP' 4);                  XS.Set(EAX' ESP); // preserve old stack address for passing to interrupt handler                    // store floating point data                  XS.And(ESP' 0xfffffff0); // fxsave needs to be 16-byte alligned                  XS.Sub(ESP' 512); // fxsave needs 512 bytes                  XS.SSE.FXSave(ESP' isIndirect: true); // save the registers                  XS.Set(EAX' ESP' destinationIsIndirect: true);                    XS.Push(EAX); //                  XS.Push(EAX); // pass old stack address (pointer to InterruptContext struct) to the interrupt handler                    XS.JumpToSegment(8' "__ISR_Handler_" + j.ToString("X2") + "_SetCS");                  XS.Label("__ISR_Handler_" + j.ToString("X2") + "_SetCS");                  MethodBase xHandler = GetInterruptHandler((byte)j);                  if (xHandler == null)                  {                      xHandler = GetMethodDef(typeof(Cosmos.Core.INTs).Assembly' typeof(Cosmos.Core.INTs).FullName' "HandleInterrupt_Default"' true);                  }                  XS.Call(LabelName.Get(xHandler));                  XS.Pop(EAX);                  XS.SSE.FXRestore(ESP' isIndirect: true);                    XS.Set(ESP' EAX); // this restores the stack for the FX stuff' except the pointer to the FX data                  XS.Add(ESP' 4); // "pop" the pointer                    XS.PopAllRegisters();                    XS.Add(ESP' 8);                  XS.Label("__ISR_Handler_" + j.ToString("X2") + "_END");                  XS.InterruptReturn();              }
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: for (int j = 0; j < 256; j++)              {                  XS.Label("__ISR_Handler_" + j.ToString("X2"));                  XS.Call("__INTERRUPT_OCCURRED__");                    if (Array.IndexOf(xInterruptsWithParam' j) == -1)                  {                      XS.Push(0);                  }                  XS.Push((uint)j);                  XS.PushAllRegisters();                    XS.Sub(ESP' 4);                  XS.Set(EAX' ESP); // preserve old stack address for passing to interrupt handler                    // store floating point data                  XS.And(ESP' 0xfffffff0); // fxsave needs to be 16-byte alligned                  XS.Sub(ESP' 512); // fxsave needs 512 bytes                  XS.SSE.FXSave(ESP' isIndirect: true); // save the registers                  XS.Set(EAX' ESP' destinationIsIndirect: true);                    XS.Push(EAX); //                  XS.Push(EAX); // pass old stack address (pointer to InterruptContext struct) to the interrupt handler                    XS.JumpToSegment(8' "__ISR_Handler_" + j.ToString("X2") + "_SetCS");                  XS.Label("__ISR_Handler_" + j.ToString("X2") + "_SetCS");                  MethodBase xHandler = GetInterruptHandler((byte)j);                  if (xHandler == null)                  {                      xHandler = GetMethodDef(typeof(Cosmos.Core.INTs).Assembly' typeof(Cosmos.Core.INTs).FullName' "HandleInterrupt_Default"' true);                  }                  XS.Call(LabelName.Get(xHandler));                  XS.Pop(EAX);                  XS.SSE.FXRestore(ESP' isIndirect: true);                    XS.Set(ESP' EAX); // this restores the stack for the FX stuff' except the pointer to the FX data                  XS.Add(ESP' 4); // "pop" the pointer                    XS.PopAllRegisters();                    XS.Add(ESP' 8);                  XS.Label("__ISR_Handler_" + j.ToString("X2") + "_END");                  XS.InterruptReturn();              }
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: for (int j = 0; j < 256; j++)              {                  XS.Label("__ISR_Handler_" + j.ToString("X2"));                  XS.Call("__INTERRUPT_OCCURRED__");                    if (Array.IndexOf(xInterruptsWithParam' j) == -1)                  {                      XS.Push(0);                  }                  XS.Push((uint)j);                  XS.PushAllRegisters();                    XS.Sub(ESP' 4);                  XS.Set(EAX' ESP); // preserve old stack address for passing to interrupt handler                    // store floating point data                  XS.And(ESP' 0xfffffff0); // fxsave needs to be 16-byte alligned                  XS.Sub(ESP' 512); // fxsave needs 512 bytes                  XS.SSE.FXSave(ESP' isIndirect: true); // save the registers                  XS.Set(EAX' ESP' destinationIsIndirect: true);                    XS.Push(EAX); //                  XS.Push(EAX); // pass old stack address (pointer to InterruptContext struct) to the interrupt handler                    XS.JumpToSegment(8' "__ISR_Handler_" + j.ToString("X2") + "_SetCS");                  XS.Label("__ISR_Handler_" + j.ToString("X2") + "_SetCS");                  MethodBase xHandler = GetInterruptHandler((byte)j);                  if (xHandler == null)                  {                      xHandler = GetMethodDef(typeof(Cosmos.Core.INTs).Assembly' typeof(Cosmos.Core.INTs).FullName' "HandleInterrupt_Default"' true);                  }                  XS.Call(LabelName.Get(xHandler));                  XS.Pop(EAX);                  XS.SSE.FXRestore(ESP' isIndirect: true);                    XS.Set(ESP' EAX); // this restores the stack for the FX stuff' except the pointer to the FX data                  XS.Add(ESP' 4); // "pop" the pointer                    XS.PopAllRegisters();                    XS.Add(ESP' 8);                  XS.Label("__ISR_Handler_" + j.ToString("X2") + "_END");                  XS.InterruptReturn();              }
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: for (int j = 0; j < 256; j++)              {                  XS.Label("__ISR_Handler_" + j.ToString("X2"));                  XS.Call("__INTERRUPT_OCCURRED__");                    if (Array.IndexOf(xInterruptsWithParam' j) == -1)                  {                      XS.Push(0);                  }                  XS.Push((uint)j);                  XS.PushAllRegisters();                    XS.Sub(ESP' 4);                  XS.Set(EAX' ESP); // preserve old stack address for passing to interrupt handler                    // store floating point data                  XS.And(ESP' 0xfffffff0); // fxsave needs to be 16-byte alligned                  XS.Sub(ESP' 512); // fxsave needs 512 bytes                  XS.SSE.FXSave(ESP' isIndirect: true); // save the registers                  XS.Set(EAX' ESP' destinationIsIndirect: true);                    XS.Push(EAX); //                  XS.Push(EAX); // pass old stack address (pointer to InterruptContext struct) to the interrupt handler                    XS.JumpToSegment(8' "__ISR_Handler_" + j.ToString("X2") + "_SetCS");                  XS.Label("__ISR_Handler_" + j.ToString("X2") + "_SetCS");                  MethodBase xHandler = GetInterruptHandler((byte)j);                  if (xHandler == null)                  {                      xHandler = GetMethodDef(typeof(Cosmos.Core.INTs).Assembly' typeof(Cosmos.Core.INTs).FullName' "HandleInterrupt_Default"' true);                  }                  XS.Call(LabelName.Get(xHandler));                  XS.Pop(EAX);                  XS.SSE.FXRestore(ESP' isIndirect: true);                    XS.Set(ESP' EAX); // this restores the stack for the FX stuff' except the pointer to the FX data                  XS.Add(ESP' 4); // "pop" the pointer                    XS.PopAllRegisters();                    XS.Add(ESP' 8);                  XS.Label("__ISR_Handler_" + j.ToString("X2") + "_END");                  XS.InterruptReturn();              }
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: for (int j = 0; j < 256; j++)              {                  XS.Label("__ISR_Handler_" + j.ToString("X2"));                  XS.Call("__INTERRUPT_OCCURRED__");                    if (Array.IndexOf(xInterruptsWithParam' j) == -1)                  {                      XS.Push(0);                  }                  XS.Push((uint)j);                  XS.PushAllRegisters();                    XS.Sub(ESP' 4);                  XS.Set(EAX' ESP); // preserve old stack address for passing to interrupt handler                    // store floating point data                  XS.And(ESP' 0xfffffff0); // fxsave needs to be 16-byte alligned                  XS.Sub(ESP' 512); // fxsave needs 512 bytes                  XS.SSE.FXSave(ESP' isIndirect: true); // save the registers                  XS.Set(EAX' ESP' destinationIsIndirect: true);                    XS.Push(EAX); //                  XS.Push(EAX); // pass old stack address (pointer to InterruptContext struct) to the interrupt handler                    XS.JumpToSegment(8' "__ISR_Handler_" + j.ToString("X2") + "_SetCS");                  XS.Label("__ISR_Handler_" + j.ToString("X2") + "_SetCS");                  MethodBase xHandler = GetInterruptHandler((byte)j);                  if (xHandler == null)                  {                      xHandler = GetMethodDef(typeof(Cosmos.Core.INTs).Assembly' typeof(Cosmos.Core.INTs).FullName' "HandleInterrupt_Default"' true);                  }                  XS.Call(LabelName.Get(xHandler));                  XS.Pop(EAX);                  XS.SSE.FXRestore(ESP' isIndirect: true);                    XS.Set(ESP' EAX); // this restores the stack for the FX stuff' except the pointer to the FX data                  XS.Add(ESP' 4); // "pop" the pointer                    XS.PopAllRegisters();                    XS.Add(ESP' 8);                  XS.Label("__ISR_Handler_" + j.ToString("X2") + "_END");                  XS.InterruptReturn();              }
Magic Number,Cosmos.Core_Asm,CPUUpdateIDTAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUUpdateIDTAsm.cs,AssembleNew,The following statement contains a magic number: XS.Set(EAX' EBP' sourceDisplacement: 8);
Magic Number,Cosmos.Core_Asm,CPUZeroFillAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\CPU\CPUZeroFillAsm.cs,AssembleNew,The following statement contains a magic number: new x86.Stos { Size = 32' Prefixes = x86.InstructionPrefixes.Repeat };
Magic Number,Cosmos.Core_Asm,DelegateCtorAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateCtorAsm.cs,AssembleNew,The following statement contains a magic number: Ldarg.DoExecute(xAssembler' xMethodInfo' 2);
Magic Number,Cosmos.Core_Asm,DelegateCtorAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateCtorAsm.cs,AssembleNew,The following statement contains a magic number: foreach (var xArg in xMethodInfo.MethodBase.DeclaringType.GetMethod("Invoke").GetParameters())              {                  xSize += ILOp.Align(ILOp.SizeOfType(xArg.ParameterType)' 4);              }
Magic Number,Cosmos.Core_Asm,DelegateInvokeAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateInvokeAsm.cs,AssembleNew,The following statement contains a magic number: XS.Add(XSRegisters.ESP' 4);
Magic Number,Cosmos.Core_Asm,DelegateInvokeAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateInvokeAsm.cs,AssembleNew,The following statement contains a magic number: XS.Add(XSRegisters.EAX' 8);
Magic Number,Cosmos.Core_Asm,DelegateInvokeAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateInvokeAsm.cs,AssembleNew,The following statement contains a magic number: XS.Add(XSRegisters.EAX' 8);
Magic Number,Cosmos.Core_Asm,DelegateInvokeAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateInvokeAsm.cs,AssembleNew,The following statement contains a magic number: XS.Set(XSRegisters.EDI' XSRegisters.EAX' sourceIsIndirect: true' sourceDisplacement: 4);
Magic Number,Cosmos.Core_Asm,DelegateInvokeAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateInvokeAsm.cs,AssembleNew,The following statement contains a magic number: XS.Add(XSRegisters.ESP' 4);
Magic Number,Cosmos.Core_Asm,DelegateInvokeAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateInvokeAsm.cs,AssembleNew,The following statement contains a magic number: {                  XS.Compare(XSRegisters.EDX' XSRegisters.EBX);                  XS.Jump(x86.ConditionalTestEnum.GreaterThanOrEqualTo' ".END_OF_INVOKE");                    XS.PushAllRegisters();                    XS.Comment("Check if delegate has $this");                  XS.Set(XSRegisters.EDI' XSRegisters.EBP' sourceDisplacement: Ldarg.GetArgumentDisplacement(xMethodInfo' 0));                  XS.Add(XSRegisters.EDI' 4);                  XS.Set(XSRegisters.EDI' XSRegisters.EDI' sourceDisplacement: Ldfld.GetFieldOffset(xMethodInfo.MethodBase.DeclaringType' "System.Object System.Delegate._target"));                  XS.Compare(XSRegisters.EDI' 0);                  XS.Jump(x86.ConditionalTestEnum.Zero' ".NO_THIS");                  XS.Label(".HAS_THIS");                  XS.Push(XSRegisters.EDI);                  XS.Push(0);                  XS.Label(".NO_THIS");                  XS.Set(XSRegisters.EDI' XSRegisters.EAX' sourceIsIndirect: true' sourceDisplacement: 4);                  XS.Set(XSRegisters.EDI' XSRegisters.EDI' sourceDisplacement: Ldfld.GetFieldOffset(xMethodInfo.MethodBase.DeclaringType' "System.IntPtr System.Delegate._methodPtr"));                    XS.Comment("Check if delegate has args");                  XS.Compare(XSRegisters.ECX' 0);                  XS.Jump(x86.ConditionalTestEnum.Zero' ".NO_ARGS");                  XS.Label(".HAS_ARGS");                  XS.Sub(XSRegisters.ESP' XSRegisters.ECX);                  XS.Push(XSRegisters.EDI);                  XS.Set(XSRegisters.EDI' XSRegisters.ESP);                  XS.Add(XSRegisters.EDI' 4);                  XS.Set(XSRegisters.ESI' XSRegisters.EBP);                  XS.Add(XSRegisters.ESI' 8);                  new x86.Movs { Size = 8' Prefixes = x86.InstructionPrefixes.Repeat };                  XS.Pop(XSRegisters.EDI);                  XS.Label(".NO_ARGS");                  XS.Call(XSRegisters.EDI);                    XS.PopAllRegisters();                  XS.Increment(XSRegisters.EDX);                  XS.Jump(".BEGIN_OF_LOOP");              }
Magic Number,Cosmos.Core_Asm,DelegateInvokeAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateInvokeAsm.cs,AssembleNew,The following statement contains a magic number: {                  XS.Compare(XSRegisters.EDX' XSRegisters.EBX);                  XS.Jump(x86.ConditionalTestEnum.GreaterThanOrEqualTo' ".END_OF_INVOKE");                    XS.PushAllRegisters();                    XS.Comment("Check if delegate has $this");                  XS.Set(XSRegisters.EDI' XSRegisters.EBP' sourceDisplacement: Ldarg.GetArgumentDisplacement(xMethodInfo' 0));                  XS.Add(XSRegisters.EDI' 4);                  XS.Set(XSRegisters.EDI' XSRegisters.EDI' sourceDisplacement: Ldfld.GetFieldOffset(xMethodInfo.MethodBase.DeclaringType' "System.Object System.Delegate._target"));                  XS.Compare(XSRegisters.EDI' 0);                  XS.Jump(x86.ConditionalTestEnum.Zero' ".NO_THIS");                  XS.Label(".HAS_THIS");                  XS.Push(XSRegisters.EDI);                  XS.Push(0);                  XS.Label(".NO_THIS");                  XS.Set(XSRegisters.EDI' XSRegisters.EAX' sourceIsIndirect: true' sourceDisplacement: 4);                  XS.Set(XSRegisters.EDI' XSRegisters.EDI' sourceDisplacement: Ldfld.GetFieldOffset(xMethodInfo.MethodBase.DeclaringType' "System.IntPtr System.Delegate._methodPtr"));                    XS.Comment("Check if delegate has args");                  XS.Compare(XSRegisters.ECX' 0);                  XS.Jump(x86.ConditionalTestEnum.Zero' ".NO_ARGS");                  XS.Label(".HAS_ARGS");                  XS.Sub(XSRegisters.ESP' XSRegisters.ECX);                  XS.Push(XSRegisters.EDI);                  XS.Set(XSRegisters.EDI' XSRegisters.ESP);                  XS.Add(XSRegisters.EDI' 4);                  XS.Set(XSRegisters.ESI' XSRegisters.EBP);                  XS.Add(XSRegisters.ESI' 8);                  new x86.Movs { Size = 8' Prefixes = x86.InstructionPrefixes.Repeat };                  XS.Pop(XSRegisters.EDI);                  XS.Label(".NO_ARGS");                  XS.Call(XSRegisters.EDI);                    XS.PopAllRegisters();                  XS.Increment(XSRegisters.EDX);                  XS.Jump(".BEGIN_OF_LOOP");              }
Magic Number,Cosmos.Core_Asm,DelegateInvokeAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateInvokeAsm.cs,AssembleNew,The following statement contains a magic number: {                  XS.Compare(XSRegisters.EDX' XSRegisters.EBX);                  XS.Jump(x86.ConditionalTestEnum.GreaterThanOrEqualTo' ".END_OF_INVOKE");                    XS.PushAllRegisters();                    XS.Comment("Check if delegate has $this");                  XS.Set(XSRegisters.EDI' XSRegisters.EBP' sourceDisplacement: Ldarg.GetArgumentDisplacement(xMethodInfo' 0));                  XS.Add(XSRegisters.EDI' 4);                  XS.Set(XSRegisters.EDI' XSRegisters.EDI' sourceDisplacement: Ldfld.GetFieldOffset(xMethodInfo.MethodBase.DeclaringType' "System.Object System.Delegate._target"));                  XS.Compare(XSRegisters.EDI' 0);                  XS.Jump(x86.ConditionalTestEnum.Zero' ".NO_THIS");                  XS.Label(".HAS_THIS");                  XS.Push(XSRegisters.EDI);                  XS.Push(0);                  XS.Label(".NO_THIS");                  XS.Set(XSRegisters.EDI' XSRegisters.EAX' sourceIsIndirect: true' sourceDisplacement: 4);                  XS.Set(XSRegisters.EDI' XSRegisters.EDI' sourceDisplacement: Ldfld.GetFieldOffset(xMethodInfo.MethodBase.DeclaringType' "System.IntPtr System.Delegate._methodPtr"));                    XS.Comment("Check if delegate has args");                  XS.Compare(XSRegisters.ECX' 0);                  XS.Jump(x86.ConditionalTestEnum.Zero' ".NO_ARGS");                  XS.Label(".HAS_ARGS");                  XS.Sub(XSRegisters.ESP' XSRegisters.ECX);                  XS.Push(XSRegisters.EDI);                  XS.Set(XSRegisters.EDI' XSRegisters.ESP);                  XS.Add(XSRegisters.EDI' 4);                  XS.Set(XSRegisters.ESI' XSRegisters.EBP);                  XS.Add(XSRegisters.ESI' 8);                  new x86.Movs { Size = 8' Prefixes = x86.InstructionPrefixes.Repeat };                  XS.Pop(XSRegisters.EDI);                  XS.Label(".NO_ARGS");                  XS.Call(XSRegisters.EDI);                    XS.PopAllRegisters();                  XS.Increment(XSRegisters.EDX);                  XS.Jump(".BEGIN_OF_LOOP");              }
Magic Number,Cosmos.Core_Asm,DelegateInvokeAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateInvokeAsm.cs,AssembleNew,The following statement contains a magic number: {                  XS.Compare(XSRegisters.EDX' XSRegisters.EBX);                  XS.Jump(x86.ConditionalTestEnum.GreaterThanOrEqualTo' ".END_OF_INVOKE");                    XS.PushAllRegisters();                    XS.Comment("Check if delegate has $this");                  XS.Set(XSRegisters.EDI' XSRegisters.EBP' sourceDisplacement: Ldarg.GetArgumentDisplacement(xMethodInfo' 0));                  XS.Add(XSRegisters.EDI' 4);                  XS.Set(XSRegisters.EDI' XSRegisters.EDI' sourceDisplacement: Ldfld.GetFieldOffset(xMethodInfo.MethodBase.DeclaringType' "System.Object System.Delegate._target"));                  XS.Compare(XSRegisters.EDI' 0);                  XS.Jump(x86.ConditionalTestEnum.Zero' ".NO_THIS");                  XS.Label(".HAS_THIS");                  XS.Push(XSRegisters.EDI);                  XS.Push(0);                  XS.Label(".NO_THIS");                  XS.Set(XSRegisters.EDI' XSRegisters.EAX' sourceIsIndirect: true' sourceDisplacement: 4);                  XS.Set(XSRegisters.EDI' XSRegisters.EDI' sourceDisplacement: Ldfld.GetFieldOffset(xMethodInfo.MethodBase.DeclaringType' "System.IntPtr System.Delegate._methodPtr"));                    XS.Comment("Check if delegate has args");                  XS.Compare(XSRegisters.ECX' 0);                  XS.Jump(x86.ConditionalTestEnum.Zero' ".NO_ARGS");                  XS.Label(".HAS_ARGS");                  XS.Sub(XSRegisters.ESP' XSRegisters.ECX);                  XS.Push(XSRegisters.EDI);                  XS.Set(XSRegisters.EDI' XSRegisters.ESP);                  XS.Add(XSRegisters.EDI' 4);                  XS.Set(XSRegisters.ESI' XSRegisters.EBP);                  XS.Add(XSRegisters.ESI' 8);                  new x86.Movs { Size = 8' Prefixes = x86.InstructionPrefixes.Repeat };                  XS.Pop(XSRegisters.EDI);                  XS.Label(".NO_ARGS");                  XS.Call(XSRegisters.EDI);                    XS.PopAllRegisters();                  XS.Increment(XSRegisters.EDX);                  XS.Jump(".BEGIN_OF_LOOP");              }
Magic Number,Cosmos.Core_Asm,DelegateInvokeAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateInvokeAsm.cs,AssembleNew,The following statement contains a magic number: {                  XS.Compare(XSRegisters.EDX' XSRegisters.EBX);                  XS.Jump(x86.ConditionalTestEnum.GreaterThanOrEqualTo' ".END_OF_INVOKE");                    XS.PushAllRegisters();                    XS.Comment("Check if delegate has $this");                  XS.Set(XSRegisters.EDI' XSRegisters.EBP' sourceDisplacement: Ldarg.GetArgumentDisplacement(xMethodInfo' 0));                  XS.Add(XSRegisters.EDI' 4);                  XS.Set(XSRegisters.EDI' XSRegisters.EDI' sourceDisplacement: Ldfld.GetFieldOffset(xMethodInfo.MethodBase.DeclaringType' "System.Object System.Delegate._target"));                  XS.Compare(XSRegisters.EDI' 0);                  XS.Jump(x86.ConditionalTestEnum.Zero' ".NO_THIS");                  XS.Label(".HAS_THIS");                  XS.Push(XSRegisters.EDI);                  XS.Push(0);                  XS.Label(".NO_THIS");                  XS.Set(XSRegisters.EDI' XSRegisters.EAX' sourceIsIndirect: true' sourceDisplacement: 4);                  XS.Set(XSRegisters.EDI' XSRegisters.EDI' sourceDisplacement: Ldfld.GetFieldOffset(xMethodInfo.MethodBase.DeclaringType' "System.IntPtr System.Delegate._methodPtr"));                    XS.Comment("Check if delegate has args");                  XS.Compare(XSRegisters.ECX' 0);                  XS.Jump(x86.ConditionalTestEnum.Zero' ".NO_ARGS");                  XS.Label(".HAS_ARGS");                  XS.Sub(XSRegisters.ESP' XSRegisters.ECX);                  XS.Push(XSRegisters.EDI);                  XS.Set(XSRegisters.EDI' XSRegisters.ESP);                  XS.Add(XSRegisters.EDI' 4);                  XS.Set(XSRegisters.ESI' XSRegisters.EBP);                  XS.Add(XSRegisters.ESI' 8);                  new x86.Movs { Size = 8' Prefixes = x86.InstructionPrefixes.Repeat };                  XS.Pop(XSRegisters.EDI);                  XS.Label(".NO_ARGS");                  XS.Call(XSRegisters.EDI);                    XS.PopAllRegisters();                  XS.Increment(XSRegisters.EDX);                  XS.Jump(".BEGIN_OF_LOOP");              }
Magic Number,Cosmos.Core_Asm,DelegateInvokeAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateInvokeAsm.cs,AssembleNew,The following statement contains a magic number: XS.Exchange(XSRegisters.EBP' XSRegisters.EDX' destinationDisplacement: 8);
Magic Number,Cosmos.Core_Asm,DelegateInvokeAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateInvokeAsm.cs,AssembleNew,The following statement contains a magic number: XS.Exchange(XSRegisters.EBP' XSRegisters.EDX' destinationDisplacement: 4);
Magic Number,Cosmos.Core_Asm,DelegateInvokeAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\Delegate\DelegateInvokeAsm.cs,AssembleNew,The following statement contains a magic number: XS.Set(XSRegisters.ESP' XSRegisters.EDI' destinationDisplacement: 12);
Magic Number,Cosmos.Core_Asm,ProcessorInformationImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\ProcessorInformationImpl.cs,GetCycleCount,The following statement contains a magic number: int[] val = new int[2];
Magic Number,Cosmos.Core_Asm,ProcessorInformationImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\ProcessorInformationImpl.cs,GetCycleCount,The following statement contains a magic number: return ((long)val[0] << 32) | (uint)val[1];
Magic Number,Cosmos.Core_Asm,ProcessorInformationImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\ProcessorInformationImpl.cs,GetCycleRate,The following statement contains a magic number: if (__ticktate == -1)              {                  int[] raw = new int[4];                    fixed (int* ptr = raw)                      __raterdmsr(ptr);                    ulong l1 = (ulong)__maxrate();                  ulong l2 = ((ulong)raw[0] << 32) | (uint)raw[1];                  ulong l3 = ((ulong)raw[2] << 32) | (uint)raw[3];                    __ticktate = (long)l2; // (long)((double)l1 * l3 / l2);              }
Magic Number,Cosmos.Core_Asm,ProcessorInformationImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\ProcessorInformationImpl.cs,GetCycleRate,The following statement contains a magic number: if (__ticktate == -1)              {                  int[] raw = new int[4];                    fixed (int* ptr = raw)                      __raterdmsr(ptr);                    ulong l1 = (ulong)__maxrate();                  ulong l2 = ((ulong)raw[0] << 32) | (uint)raw[1];                  ulong l3 = ((ulong)raw[2] << 32) | (uint)raw[3];                    __ticktate = (long)l2; // (long)((double)l1 * l3 / l2);              }
Magic Number,Cosmos.Core_Asm,ProcessorInformationImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\ProcessorInformationImpl.cs,GetCycleRate,The following statement contains a magic number: if (__ticktate == -1)              {                  int[] raw = new int[4];                    fixed (int* ptr = raw)                      __raterdmsr(ptr);                    ulong l1 = (ulong)__maxrate();                  ulong l2 = ((ulong)raw[0] << 32) | (uint)raw[1];                  ulong l3 = ((ulong)raw[2] << 32) | (uint)raw[3];                    __ticktate = (long)l2; // (long)((double)l1 * l3 / l2);              }
Magic Number,Cosmos.Core_Asm,ProcessorInformationImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\ProcessorInformationImpl.cs,GetCycleRate,The following statement contains a magic number: if (__ticktate == -1)              {                  int[] raw = new int[4];                    fixed (int* ptr = raw)                      __raterdmsr(ptr);                    ulong l1 = (ulong)__maxrate();                  ulong l2 = ((ulong)raw[0] << 32) | (uint)raw[1];                  ulong l3 = ((ulong)raw[2] << 32) | (uint)raw[3];                    __ticktate = (long)l2; // (long)((double)l1 * l3 / l2);              }
Magic Number,Cosmos.Core_Asm,ProcessorInformationImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\ProcessorInformationImpl.cs,GetCycleRate,The following statement contains a magic number: if (__ticktate == -1)              {                  int[] raw = new int[4];                    fixed (int* ptr = raw)                      __raterdmsr(ptr);                    ulong l1 = (ulong)__maxrate();                  ulong l2 = ((ulong)raw[0] << 32) | (uint)raw[1];                  ulong l3 = ((ulong)raw[2] << 32) | (uint)raw[3];                    __ticktate = (long)l2; // (long)((double)l1 * l3 / l2);              }
Magic Number,Cosmos.Core_Asm,ProcessorInformationImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\ProcessorInformationImpl.cs,__cyclesrdtsc,The following statement contains a magic number: XS.Set(XSRegisters.ESI' XSRegisters.EAX' destinationIsIndirect: true' destinationDisplacement: 4);
Magic Number,Cosmos.Core_Asm,ProcessorInformationImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\ProcessorInformationImpl.cs,__raterdmsr,The following statement contains a magic number: XS.Set(XSRegisters.EAX' XSRegisters.ESI' destinationIsIndirect: true' destinationDisplacement: 4);
Magic Number,Cosmos.Core_Asm,ProcessorInformationImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\ProcessorInformationImpl.cs,__raterdmsr,The following statement contains a magic number: XS.Set(XSRegisters.EAX' XSRegisters.ESI' destinationIsIndirect: true' destinationDisplacement: 12);
Magic Number,Cosmos.Core_Asm,ProcessorInformationImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\ProcessorInformationImpl.cs,__raterdmsr,The following statement contains a magic number: XS.Set(XSRegisters.EDX' XSRegisters.ESI' destinationIsIndirect: true' destinationDisplacement: 8);
Magic Number,Cosmos.Core_Asm,ProcessorInformationImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\ProcessorInformationImpl.cs,FetchCPUVendor,The following statement contains a magic number: XS.Set(XSRegisters.ESI' XSRegisters.EDX' destinationIsIndirect: true' destinationDisplacement: 4);
Magic Number,Cosmos.Core_Asm,ProcessorInformationImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\ProcessorInformationImpl.cs,FetchCPUVendor,The following statement contains a magic number: XS.Set(XSRegisters.ESI' XSRegisters.ECX' destinationIsIndirect: true' destinationDisplacement: 8);
Magic Number,Cosmos.Core_Asm,RuntimeHelpersImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\RuntimeHelpers\RuntimeHelpersImpl.cs,InitializeArray,The following statement contains a magic number: XS.Set(XSRegisters.EDI' XSRegisters.EBP' sourceDisplacement: 20);
Magic Number,Cosmos.Core_Asm,RuntimeHelpersImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\RuntimeHelpers\RuntimeHelpersImpl.cs,InitializeArray,The following statement contains a magic number: XS.Set(XSRegisters.ESI' XSRegisters.EBP' sourceDisplacement: 12);
Magic Number,Cosmos.Core_Asm,RuntimeHelpersImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\RuntimeHelpers\RuntimeHelpersImpl.cs,InitializeArray,The following statement contains a magic number: XS.Add(XSRegisters.EDI' 8);
Magic Number,Cosmos.Core_Asm,RuntimeHelpersImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\RuntimeHelpers\RuntimeHelpersImpl.cs,InitializeArray,The following statement contains a magic number: XS.Add(XSRegisters.EDI' 4);
Magic Number,Cosmos.Core_Asm,RuntimeHelpersImpl,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\RuntimeHelpers\RuntimeHelpersImpl.cs,InitializeArray,The following statement contains a magic number: XS.Add(XSRegisters.EDI' 4);
Magic Number,Cosmos.Core_Asm.MemoryOperations,MemoryOperationsFill16BlocksAsm,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core_Asm\MemoryOperations\MemoryOperationsFillFastAsm.cs,AssembleNew,The following statement contains a magic number: XS.Add(EDI' 16);
