Implementation smell,Namespace,Class,File,Method,Description
Long Statement,Cosmos.Debug.Common,PipeServer,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.Common\PipeServer.cs,ThreadStartServer,The length of the statement  "          using (mPipe = new NamedPipeServerStream(mPipeName' PipeDirection.In' 1' PipeTransmissionMode.Message' PipeOptions.Asynchronous)) { " is 131.
Empty Catch Block,Cosmos.Debug.Common,PipeClient,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.Common\PipeClient.cs,SendCommand,The method has an empty catch block.
Empty Catch Block,Cosmos.Debug.Common,PipeServer,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.Common\PipeServer.cs,ThreadStartServer,The method has an empty catch block.
Magic Number,Cosmos.Debug.Common,PipeClient,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.Common\PipeClient.cs,Read,The following statement contains a magic number: mPipe.ReadTimeout = 25;
Magic Number,Cosmos.Debug.Common,PipeClient,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.Common\PipeClient.cs,SendRawToChannel,The following statement contains a magic number: SendCommand((ushort)((aChannel << 8) | aCommand)' aData);
Magic Number,Cosmos.Debug.Common,PipeClient,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.Common\PipeClient.cs,SendCommand,The following statement contains a magic number: try        {          mPipe.WriteByte((byte)(aCmd >> 8));          mPipe.WriteByte((byte)(aCmd & 0xFF));            byte[] xData = aData;          if (xData == null)          {              xData = new byte[0];          }            //int xLength = Math.Min(xData.Length' 32768);          int xLength = xData.Length;          mPipe.WriteByte((byte) (xLength >> 24));          mPipe.WriteByte((byte) (xLength >> 16));          mPipe.WriteByte((byte) (xLength >> 8));          mPipe.WriteByte((byte) (xLength & 0xFF));          if (xLength > 0)          {              mPipe.Write(xData' 0' xLength);          }          mPipe.Flush();        }        catch        {        }
Magic Number,Cosmos.Debug.Common,PipeClient,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.Common\PipeClient.cs,SendCommand,The following statement contains a magic number: try        {          mPipe.WriteByte((byte)(aCmd >> 8));          mPipe.WriteByte((byte)(aCmd & 0xFF));            byte[] xData = aData;          if (xData == null)          {              xData = new byte[0];          }            //int xLength = Math.Min(xData.Length' 32768);          int xLength = xData.Length;          mPipe.WriteByte((byte) (xLength >> 24));          mPipe.WriteByte((byte) (xLength >> 16));          mPipe.WriteByte((byte) (xLength >> 8));          mPipe.WriteByte((byte) (xLength & 0xFF));          if (xLength > 0)          {              mPipe.Write(xData' 0' xLength);          }          mPipe.Flush();        }        catch        {        }
Magic Number,Cosmos.Debug.Common,PipeClient,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.Common\PipeClient.cs,SendCommand,The following statement contains a magic number: try        {          mPipe.WriteByte((byte)(aCmd >> 8));          mPipe.WriteByte((byte)(aCmd & 0xFF));            byte[] xData = aData;          if (xData == null)          {              xData = new byte[0];          }            //int xLength = Math.Min(xData.Length' 32768);          int xLength = xData.Length;          mPipe.WriteByte((byte) (xLength >> 24));          mPipe.WriteByte((byte) (xLength >> 16));          mPipe.WriteByte((byte) (xLength >> 8));          mPipe.WriteByte((byte) (xLength & 0xFF));          if (xLength > 0)          {              mPipe.Write(xData' 0' xLength);          }          mPipe.Flush();        }        catch        {        }
Magic Number,Cosmos.Debug.Common,PipeClient,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.Common\PipeClient.cs,SendCommand,The following statement contains a magic number: try        {          mPipe.WriteByte((byte)(aCmd >> 8));          mPipe.WriteByte((byte)(aCmd & 0xFF));            byte[] xData = aData;          if (xData == null)          {              xData = new byte[0];          }            //int xLength = Math.Min(xData.Length' 32768);          int xLength = xData.Length;          mPipe.WriteByte((byte) (xLength >> 24));          mPipe.WriteByte((byte) (xLength >> 16));          mPipe.WriteByte((byte) (xLength >> 8));          mPipe.WriteByte((byte) (xLength & 0xFF));          if (xLength > 0)          {              mPipe.Write(xData' 0' xLength);          }          mPipe.Flush();        }        catch        {        }
Magic Number,Cosmos.Debug.Common,PipeClient,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.Common\PipeClient.cs,TryConnect,The following statement contains a magic number: lock (this)        {          if (mPipe == null|| !mPipe.IsConnected)          {            var xPipe = new NamedPipeClientStream("."' mPipeName' PipeDirection.Out);            try            {              // For now we assume its there or not from the first call.              // If we don't find the server' we disable it to avoid causing lag.              // TODO: In future - try this instead:              // String[] listOfPipes = System.IO.Directory.GetFiles(@"\.\pipe\");              // or maybe not - what we have seems to work just fine...                xPipe.Connect(500);            }            catch (Exception)            {              xPipe.Dispose();              //xPipe.Close();              return false;            }            mWriter = new StreamWriter(xPipe);            // Only set mPipe if we are truly ready. Other code can check it.            mPipe = xPipe;          }        }
Magic Number,Cosmos.Debug.Common,PipeServer,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.Common\PipeServer.cs,Stop,The following statement contains a magic number: if (mPipe.IsConnected) {          mPipe.Dispose();          //mPipe.Close();        } else {          // Kick it out of the WaitForConnection          var xPipe = new NamedPipeClientStream("."' mPipeName' PipeDirection.Out);          xPipe.Connect(100);        }
Magic Number,Cosmos.Debug.Common,PipeServer,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.Common\PipeServer.cs,ThreadStartServer,The following statement contains a magic number: while (!KillThread)        {          // Loop again to allow mult incoming connections between debug sessions          try          {            using (mPipe = new NamedPipeServerStream(mPipeName' PipeDirection.In' 1' PipeTransmissionMode.Message' PipeOptions.Asynchronous)) {              mPipe.WaitForConnection();                ushort xCmd;              int xSize;              while (mPipe.IsConnected && !KillThread) {                xCmd = (ushort)(ReadByte() << 8);                xCmd |= ReadByte();                  xSize = ReadByte() << 24;                xSize = xSize | ReadByte() << 16;                xSize = xSize | ReadByte() << 8;                xSize = xSize | ReadByte();                  byte[] xMsg = new byte[xSize];                mPipe.Read(xMsg' 0' xSize);                  if (DataPacketReceived != null)                {                    DataPacketReceived(xCmd' xMsg);                }              }            }          } catch (Exception) {            // Threads MUST have an exception handler            // Otherwise there are side effects when an exception occurs          }        }
Magic Number,Cosmos.Debug.Common,PipeServer,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.Common\PipeServer.cs,ThreadStartServer,The following statement contains a magic number: while (!KillThread)        {          // Loop again to allow mult incoming connections between debug sessions          try          {            using (mPipe = new NamedPipeServerStream(mPipeName' PipeDirection.In' 1' PipeTransmissionMode.Message' PipeOptions.Asynchronous)) {              mPipe.WaitForConnection();                ushort xCmd;              int xSize;              while (mPipe.IsConnected && !KillThread) {                xCmd = (ushort)(ReadByte() << 8);                xCmd |= ReadByte();                  xSize = ReadByte() << 24;                xSize = xSize | ReadByte() << 16;                xSize = xSize | ReadByte() << 8;                xSize = xSize | ReadByte();                  byte[] xMsg = new byte[xSize];                mPipe.Read(xMsg' 0' xSize);                  if (DataPacketReceived != null)                {                    DataPacketReceived(xCmd' xMsg);                }              }            }          } catch (Exception) {            // Threads MUST have an exception handler            // Otherwise there are side effects when an exception occurs          }        }
Magic Number,Cosmos.Debug.Common,PipeServer,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.Common\PipeServer.cs,ThreadStartServer,The following statement contains a magic number: while (!KillThread)        {          // Loop again to allow mult incoming connections between debug sessions          try          {            using (mPipe = new NamedPipeServerStream(mPipeName' PipeDirection.In' 1' PipeTransmissionMode.Message' PipeOptions.Asynchronous)) {              mPipe.WaitForConnection();                ushort xCmd;              int xSize;              while (mPipe.IsConnected && !KillThread) {                xCmd = (ushort)(ReadByte() << 8);                xCmd |= ReadByte();                  xSize = ReadByte() << 24;                xSize = xSize | ReadByte() << 16;                xSize = xSize | ReadByte() << 8;                xSize = xSize | ReadByte();                  byte[] xMsg = new byte[xSize];                mPipe.Read(xMsg' 0' xSize);                  if (DataPacketReceived != null)                {                    DataPacketReceived(xCmd' xMsg);                }              }            }          } catch (Exception) {            // Threads MUST have an exception handler            // Otherwise there are side effects when an exception occurs          }        }
Magic Number,Cosmos.Debug.Common,PipeServer,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.Common\PipeServer.cs,ThreadStartServer,The following statement contains a magic number: while (!KillThread)        {          // Loop again to allow mult incoming connections between debug sessions          try          {            using (mPipe = new NamedPipeServerStream(mPipeName' PipeDirection.In' 1' PipeTransmissionMode.Message' PipeOptions.Asynchronous)) {              mPipe.WaitForConnection();                ushort xCmd;              int xSize;              while (mPipe.IsConnected && !KillThread) {                xCmd = (ushort)(ReadByte() << 8);                xCmd |= ReadByte();                  xSize = ReadByte() << 24;                xSize = xSize | ReadByte() << 16;                xSize = xSize | ReadByte() << 8;                xSize = xSize | ReadByte();                  byte[] xMsg = new byte[xSize];                mPipe.Read(xMsg' 0' xSize);                  if (DataPacketReceived != null)                {                    DataPacketReceived(xCmd' xMsg);                }              }            }          } catch (Exception) {            // Threads MUST have an exception handler            // Otherwise there are side effects when an exception occurs          }        }
