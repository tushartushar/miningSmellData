Implementation smell,Namespace,Class,File,Method,Description
Long Method,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The method has 128 lines of code.
Long Method,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,The method has 154 lines of code.
Long Method,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,z_restore,The method has 111 lines of code.
Long Method,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The method has 245 lines of code.
Long Method,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,save_quetzal,The method has 126 lines of code.
Long Method,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,read_line,The method has 138 lines of code.
Long Method,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,show_map,The method has 114 lines of code.
Long Method,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,show_dictionary,The method has 115 lines of code.
Long Method,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The method has 222 lines of code.
Long Method,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The method has 288 lines of code.
Long Method,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_parse_table,The method has 141 lines of code.
Long Method,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_syntax_of_action,The method has 109 lines of code.
Long Method,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The method has 230 lines of code.
Long Method,ZTools,symbols,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\symbols.cs,init_symbols,The method has 140 lines of code.
Long Method,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_program,The method has 132 lines of code.
Long Method,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_routine,The method has 110 lines of code.
Long Method,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The method has 281 lines of code.
Long Method,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameter,The method has 256 lines of code.
Long Method,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,configure,The method has 110 lines of code.
Long Method,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The method has 210 lines of code.
Complex Method,Frotz.Generic,Buffer,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\buffer.cs,print_char,Cyclomatic complexity of the method is 8
Complex Method,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,Cyclomatic complexity of the method is 21
Complex Method,Frotz.Generic,Files,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\files.cs,script_word,Cyclomatic complexity of the method is 8
Complex Method,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,z_read,Cyclomatic complexity of the method is 14
Complex Method,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_get_prop_addr,Cyclomatic complexity of the method is 8
Complex Method,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,call,Cyclomatic complexity of the method is 10
Complex Method,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,Cyclomatic complexity of the method is 13
Complex Method,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,screen_new_line,Cyclomatic complexity of the method is 11
Complex Method,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,screen_word,Cyclomatic complexity of the method is 10
Complex Method,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_draw_picture,Cyclomatic complexity of the method is 8
Complex Method,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_colour,Cyclomatic complexity of the method is 15
Complex Method,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_cursor,Cyclomatic complexity of the method is 11
Complex Method,Frotz.Generic,Sound,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\sound.cs,z_sound_effect,Cyclomatic complexity of the method is 9
Complex Method,Frotz.Generic,Stream,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\stream.cs,stream_read_key,Cyclomatic complexity of the method is 9
Complex Method,Frotz.Generic,Stream,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\stream.cs,stream_read_input,Cyclomatic complexity of the method is 15
Complex Method,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,translate_from_zscii,Cyclomatic complexity of the method is 8
Complex Method,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,encode_text,Cyclomatic complexity of the method is 12
Complex Method,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,lookup_text,Cyclomatic complexity of the method is 9
Complex Method,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,completion,Cyclomatic complexity of the method is 10
Complex Method,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,GetColourIndex,Cyclomatic complexity of the method is 10
Complex Method,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,init_screen,Cyclomatic complexity of the method is 10
Complex Method,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,read_line,Cyclomatic complexity of the method is 8
Complex Method,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,clearInputAndShowHistory,Cyclomatic complexity of the method is 8
Complex Method,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,show_map,Cyclomatic complexity of the method is 12
Complex Method,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,show_dictionary,Cyclomatic complexity of the method is 17
Complex Method,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,Cyclomatic complexity of the method is 24
Complex Method,ZTools,showobj,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showobj.cs,show_objects,Cyclomatic complexity of the method is 10
Complex Method,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,Cyclomatic complexity of the method is 30
Complex Method,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_parse_table,Cyclomatic complexity of the method is 12
Complex Method,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_syntax_of_action,Cyclomatic complexity of the method is 11
Complex Method,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_syntax_of_parsing_routine,Cyclomatic complexity of the method is 8
Complex Method,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_action_tables,Cyclomatic complexity of the method is 9
Complex Method,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_words,Cyclomatic complexity of the method is 12
Complex Method,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,lookup_word,Cyclomatic complexity of the method is 8
Complex Method,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,process_story,Cyclomatic complexity of the method is 11
Complex Method,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_program,Cyclomatic complexity of the method is 13
Complex Method,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_routine,Cyclomatic complexity of the method is 10
Complex Method,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_extra,Cyclomatic complexity of the method is 18
Complex Method,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,tx_write_char,Cyclomatic complexity of the method is 9
Long Parameter List,Frotz.Other,ArrayCopy,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\ArrayCopy.cs,Copy,The method has 5 parameters. Parameters: sourceArray' sourceIndex' destinationArray' destinationIndex' length
Long Parameter List,Frotz.Other,ArrayCopy,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\ArrayCopy.cs,Copy,The method has 5 parameters. Parameters: sourceArray' sourceIndex' destinationArray' destinationIndex' length
Long Parameter List,Frotz.Generic,Stream,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\stream.cs,stream_read_input,The method has 6 parameters. Parameters: max' buf' timeout' routine' hot_keys' no_scripting
Long Parameter List,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,tokenise_text,The method has 6 parameters. Parameters: text' length' from' parse' dct' flag
Long Parameter List,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,erase_area,The method has 5 parameters. Parameters: top' left' bottom' right' win
Long Parameter List,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,read_line,The method has 5 parameters. Parameters: max' buf' timeout' width' continued
Long Parameter List,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,scroll_area,The method has 5 parameters. Parameters: top' left' bottom' right' units
Long Parameter List,Frotz.Screen,IZScreen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Screen\IZScreen.cs,ScrollArea,The method has 5 parameters. Parameters: top' bottom' left' right' units
Long Parameter List,Frotz.Screen,IZScreen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Screen\IZScreen.cs,SetWindowSize,The method has 5 parameters. Parameters: win' top' left' height' width
Long Parameter List,Frotz.Screen,ScreenLines,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Screen\ScreenLines.cs,ScrollArea,The method has 5 parameters. Parameters: top' bottom' left' right' units
Long Parameter List,Frotz.Screen,ScreenMetrics,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Screen\ScreenStuff.cs,ScreenMetrics,The method has 5 parameters. Parameters: FontSize' WindowSize' Rows' Columns' Scale
Long Parameter List,ZTools,infinfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infinfo.cs,configure_inform_tables,The method has 8 parameters. Parameters: obj_data_end' inform_version' class_numbers_base' class_numbers_end' property_names_base' property_names_end' attr_names_base' attr_names_end
Long Parameter List,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,configure_abbreviations,The method has 5 parameters. Parameters: abbr_count' abbr_table_base' abbr_table_end' abbr_data_base' abbr_data_end
Long Parameter List,ZTools,showobj,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showobj.cs,configure_object_tables,The method has 5 parameters. Parameters: obj_count' obj_table_base' obj_table_end' obj_data_base' obj_data_end
Long Parameter List,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The method has 11 parameters. Parameters: verb_count' action_count' parse_count' parser_type' prep_type' verb_table_base' verb_data_base' action_table_base' preact_table_base' prep_table_base' prep_table_end
Long Parameter List,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_parse_table,The method has 6 parameters. Parameters: verb_table_base' verb_count' parser_type' prep_type' prep_table_base' attr_names_base
Long Parameter List,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_syntax_of_action,The method has 7 parameters. Parameters: action' verb_table_base' verb_count' parser_type' prep_type' prep_table_base' attr_names_base
Long Parameter List,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_syntax_of_parsing_routine,The method has 7 parameters. Parameters: parsing_routine' verb_table_base' verb_count' parser_type' prep_type' prep_table_base' attr_names_base
Long Parameter List,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_action_tables,The method has 11 parameters. Parameters: verb_table_base' verb_count' action_count' parse_count' parser_type' prep_type' action_table_base' preact_table_base' prep_table_base' attr_names_base' action_names_base
Long Parameter List,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The method has 7 parameters. Parameters: verb_entry' verb_index' parser_type' v6_number_objects' prep_type' prep_table_base' attr_names_base
Long Parameter List,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_operands,The method has 7 parameters. Parameters: opcode_name' par1' par2' par3' par4' extra' type
Long Parameter List,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,dump_opcode,The method has 5 parameters. Parameters: addr' op' opclass' par' extra
Long Parameter List,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,dump_operand,The method has 5 parameters. Parameters: addr' addr_mode' opers' par' count
Long Statement,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,z_read,The length of the statement  "                FastMem.storeb((zword)(Process.zargs[0] + ((main.h_version <= ZMachine.V4) ? 1 : 2) + i)' Text.translate_to_zscii(buffer[i])); " is 126.
Long Statement,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_get_prop,The length of the statement  "                if ((main.h_version <= ZMachine.V3 && !((value & 0xe0) > 0)) || (main.h_version >= ZMachine.V4 && !((value & 0xc0) > 0))) { " is 123.
Long Statement,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_put_prop,The length of the statement  "            if ((main.h_version <= ZMachine.V3 && !((value & 0xe0) > 0)) || (main.h_version >= ZMachine.V4 && !((value & 0xc0) > 0))) { " is 123.
Long Statement,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,read_file_name,The length of the statement  "                    fileName = _screen.OpenNewOrExistingFile(FastMem.save_name' "Choose save game file"' "Save Files (*.sav)|*.sav"' ".sav"); " is 121.
Long Statement,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,read_file_name,The length of the statement  "                    fileName = _screen.OpenNewOrExistingFile(General.DEFAULT_SCRIPT_NAME' "Choose Script File"' "Script File (*.scr)|*.scr"' ".scr"); " is 129.
Long Statement,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,read_line,The length of the statement  "                        int w = _screen.GetStringWidth(((char)c).ToString()' new CharDisplayInfo(ZFont.TEXT_FONT' ZStyles.NORMAL_STYLE' -1' -1)); " is 121.
Long Statement,Frotz,DebugState,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\TestStuff\DebugState.cs,Output,The length of the statement  "                //        System.Diagnostics.Debug.WriteLine("mismatch! Expected:" + expected + ": Current:" + current + ":" + currentState); " is 125.
Long Statement,Frotz.Screen,CharDisplayInfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Screen\CharDisplayInfo.cs,AreSame,The length of the statement  "            return (fs.Font == this.Font && fs.Style == this.Style && fs.ForegroundColor == this.ForegroundColor && fs.BackgroundColor == this.BackgroundColor); " is 148.
Long Statement,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,show_map,The length of the statement  "                    set_area(preact_table_base' prep_table_base - 1' (verb_type >= (int)tx_h.parser_types.inform5_grammar) ? "Parsing routine table" : "Pre-action routine table"); " is 159.
Long Statement,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verbs,The length of the statement  "            if ((parser_type <= (uint)tx_h.parser_types.inform_gv2) && (parser_type != (int)tx_h.parser_types.infocom6_grammar)) /* no preposition table in GV2 */ " is 150.
Long Statement,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,is_gv2_parsing_routine,The length of the statement  "            ulong parsing_routine_packed = (parsing_routine - (ulong)txio.story_scaler * txio.header.routines_offset) / txio.code_scaler; " is 125.
Long Statement,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_syntax_of_parsing_routine,The length of the statement  "            ulong parsing_routine_packed = (parsing_routine - (ulong)txio.story_scaler * txio.header.routines_offset) / txio.code_scaler; " is 125.
Long Statement,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_action_tables,The length of the statement  "                    txio.tx_printf("{0:X5} "' (ulong)txio.read_data_word(ref preacts_address) * txio.code_scaler + (ulong)txio.story_scaler * header.routines_offset); " is 146.
Long Statement,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The length of the statement  "                        //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */ " is 151.
Long Statement,ZTools,symbols,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\symbols.cs,print_property_name,The length of the statement  "            else if ((prop_no < property_entries) && symbols.property_names_table[prop_no].symtype == symbols.symtypes.sym_property) " is 120.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x01: return decode_operands("RESTORE"' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.LOW_ADDR' tx_h.NIL' tx_h.STORE' tx_h.PLAIN); " is 122.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x05: return decode_operands("DRAW_PICTURE"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NUMBER' tx_h.NIL' tx_h.NONE' tx_h.PLAIN); " is 122.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x06: return decode_operands("PICTURE_DATA"' tx_h.NUMBER' tx_h.LOW_ADDR' tx_h.NIL' tx_h.NIL' tx_h.BRANCH' tx_h.PLAIN); " is 123.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x07: return decode_operands("ERASE_PICTURE"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NUMBER' tx_h.NIL' tx_h.NONE' tx_h.PLAIN); " is 123.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x08: return decode_operands("SET_MARGINS"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NUMBER' tx_h.NIL' tx_h.NONE' tx_h.PLAIN); " is 121.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x10: return decode_operands("MOVE_WINDOW"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NUMBER' tx_h.NIL' tx_h.NONE' tx_h.PLAIN); " is 121.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x11: return decode_operands("WINDOW_SIZE"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NUMBER' tx_h.NIL' tx_h.NONE' tx_h.PLAIN); " is 121.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x12: return decode_operands("WINDOW_STYLE"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NUMBER' tx_h.NIL' tx_h.NONE' tx_h.PLAIN); " is 122.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x13: return decode_operands("GET_WIND_PROP"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.PLAIN); " is 121.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x14: return decode_operands("SCROLL_WINDOW"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN); " is 120.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x18: return decode_operands("PUSH_STACK"' tx_h.NUMBER' tx_h.LOW_ADDR' tx_h.NIL' tx_h.NIL' tx_h.BRANCH' tx_h.PLAIN); " is 121.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x19: return decode_operands("PUT_WIND_PROP"' tx_h.NUMBER' tx_h.NUMBER' tx_h.ANYTHING' tx_h.NIL' tx_h.NONE' tx_h.PLAIN); " is 125.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x1B: return decode_operands("MAKE_MENU"' tx_h.NUMBER' tx_h.LOW_ADDR' tx_h.NIL' tx_h.NIL' tx_h.BRANCH' tx_h.PLAIN); " is 120.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x01: return decode_operands("JE"' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.BRANCH' tx_h.PLAIN); " is 125.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x12: return decode_operands("GET_PROP_ADDR"' tx_h.OBJECT' tx_h.PROPNUM' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.PLAIN); " is 122.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x13: return decode_operands("GET_NEXT_PROP"' tx_h.OBJECT' tx_h.PROPNUM' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.PLAIN); " is 122.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x21: return decode_operands("STOREW"' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.ANYTHING' tx_h.NIL' tx_h.NONE' tx_h.PLAIN); " is 120.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x22: return decode_operands("STOREB"' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.ANYTHING' tx_h.NIL' tx_h.NONE' tx_h.PLAIN); " is 120.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x23: return decode_operands("PUT_PROP"' tx_h.OBJECT' tx_h.NUMBER' tx_h.ANYTHING' tx_h.NIL' tx_h.NONE' tx_h.PLAIN); " is 120.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x33: return decode_operands("OUTPUT_STREAM"' tx_h.PATTR' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NIL' tx_h.NONE' tx_h.PLAIN); " is 124.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                        case 0x35: return decode_operands("SOUND_EFFECT"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NUMBER' tx_h.ROUTINE' tx_h.NONE' tx_h.PLAIN); " is 126.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x20: return decode_operands("CALL"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL); " is 124.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x20: return decode_operands("CALL_VS"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL); " is 127.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x24: return decode_operands("READ"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.ROUTINE' tx_h.NONE' tx_h.PLAIN); " is 122.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x2C: return decode_operands("CALL_VS2"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL); " is 128.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x36: return decode_operands("READ_CHAR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.ROUTINE' tx_h.NIL' tx_h.STORE' tx_h.PLAIN); " is 121.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x37: return decode_operands("SCAN_TABLE"' tx_h.ANYTHING' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.BOTH' tx_h.PLAIN); " is 127.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x20: return decode_operands("CALL_VS"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL); " is 127.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x24: return decode_operands("READ"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.ROUTINE' tx_h.STORE' tx_h.PLAIN); " is 123.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x2C: return decode_operands("CALL_VS2"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL); " is 128.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x36: return decode_operands("READ_CHAR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.ROUTINE' tx_h.NIL' tx_h.STORE' tx_h.PLAIN); " is 121.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x37: return decode_operands("SCAN_TABLE"' tx_h.ANYTHING' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.BOTH' tx_h.PLAIN); " is 127.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x39: return decode_operands("CALL_VN"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.NONE' tx_h.CALL); " is 126.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x3A: return decode_operands("CALL_VN2"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.NONE' tx_h.CALL); " is 127.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x3B: return decode_operands("TOKENISE"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NONE' tx_h.PLAIN); " is 127.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x3C: return decode_operands("ENCODE_TEXT"' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.LOW_ADDR' tx_h.NONE' tx_h.PLAIN); " is 128.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x3D: return decode_operands("COPY_TABLE"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NIL' tx_h.NONE' tx_h.PLAIN); " is 124.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x3E: return decode_operands("PRINT_TABLE"' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.NUMBER' tx_h.NONE' tx_h.PLAIN); " is 126.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x3F: return decode_operands("CHECK_ARG_COUNT"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.BRANCH' tx_h.PLAIN); " is 121.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x20: return decode_operands("CALL_VS"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL); " is 127.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x24: return decode_operands("READ"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.ROUTINE' tx_h.STORE' tx_h.PLAIN); " is 123.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x2C: return decode_operands("CALL_VS2"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL); " is 128.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x2F: return decode_operands("SET_CURSOR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NUMBER' tx_h.NIL' tx_h.NONE' tx_h.PLAIN); " is 120.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x36: return decode_operands("READ_CHAR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.ROUTINE' tx_h.NIL' tx_h.STORE' tx_h.PLAIN); " is 121.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x37: return decode_operands("SCAN_TABLE"' tx_h.ANYTHING' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.BOTH' tx_h.PLAIN); " is 127.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x39: return decode_operands("CALL_VN"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.NONE' tx_h.CALL); " is 126.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x3A: return decode_operands("CALL_VN2"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.NONE' tx_h.CALL); " is 127.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x3B: return decode_operands("TOKENISE"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NONE' tx_h.PLAIN); " is 127.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x3C: return decode_operands("ENCODE_TEXT"' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.LOW_ADDR' tx_h.NONE' tx_h.PLAIN); " is 128.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x3D: return decode_operands("COPY_TABLE"' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.LOW_ADDR' tx_h.NIL' tx_h.NONE' tx_h.PLAIN); " is 124.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x3E: return decode_operands("PRINT_TABLE"' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.NUMBER' tx_h.NONE' tx_h.PLAIN); " is 126.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The length of the statement  "                                        case 0x3F: return decode_operands("CHECK_ARG_COUNT"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.BRANCH' tx_h.PLAIN); " is 121.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,lookup_verb,The length of the statement  "                routine = (ulong)txio.read_data_word(ref address) * txio.code_scaler + (ulong)txio.story_scaler * header.routines_offset; " is 121.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,lookup_verb,The length of the statement  "                    routine = (ulong)txio.read_data_word(ref address) * txio.code_scaler + (ulong)txio.story_scaler * header.routines_offset; " is 121.
Long Statement,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,lookup_verb,The length of the statement  "                    routine = (ulong)txio.read_data_word(ref address) * txio.code_scaler + (ulong)txio.story_scaler * header.routines_offset; " is 121.
Complex Conditional,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The conditional expression  "buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F'"  is complex.
Complex Conditional,Frotz.Generic,Buffer,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\buffer.cs,print_char,The conditional expression  "c == ' ' || c == CharCodes.ZC_INDENT || c == CharCodes.ZC_GAP || (prev_c == '-' && c != '-')"  is complex.
Complex Conditional,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,The conditional expression  "main.h_release == 96 || main.h_release == 153 ||                          main.h_release == 242 || main.h_release == 296"  is complex.
Complex Conditional,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,z_restore,The conditional expression  "main.h_version > ZMachine.V3 && main.h_version != ZMachine.V6                          && (main.h_screen_rows != old_screen_rows                          || main.h_screen_cols != old_screen_cols)"  is complex.
Complex Conditional,Frotz.Generic,Files,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\files.cs,record_code,The conditional expression  "force_encoding || c == '[' || c < 0x20 || c > 0x7e"  is complex.
Complex Conditional,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_get_prop,The conditional expression  "(main.h_version <= ZMachine.V3 && !((value & 0xe0) > 0)) || (main.h_version >= ZMachine.V4 && !((value & 0xc0) > 0))"  is complex.
Complex Conditional,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_put_prop,The conditional expression  "(main.h_version <= ZMachine.V3 && !((value & 0xe0) > 0)) || (main.h_version >= ZMachine.V4 && !((value & 0xc0) > 0))"  is complex.
Complex Conditional,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,path_open,The conditional expression  "story_data[0] == (char)'F' && story_data[1] == (byte)'O' &&                      story_data[2] == (byte)'R' && story_data[3] == (byte)'M'"  is complex.
Complex Conditional,ZTools,infinfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infinfo.cs,configure_inform_tables,The conditional expression  "header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8'"  is complex.
Complex Conditional,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,show_dictionary,The conditional expression  "header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8'"  is complex.
Complex Conditional,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The conditional expression  "header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8'"  is complex.
Complex Conditional,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The conditional expression  "header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8'"  is complex.
Complex Conditional,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The conditional expression  "(val & 1) != 0 && (val & 0x80) == 0 && (parse_index != 0) && (parse_index < action_table_base)"  is complex.
Complex Conditional,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The conditional expression  "(val >= 9) || (val <= 15) || (val >= 112) || (val <= 127)"  is complex.
Complex Conditional,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,lookup_word,The conditional expression  "((mask == tx_h.VERB) && (flags & tx_h.DATA_FIRST) != tx_h.VERB_FIRST) ||                              ((mask == tx_h.DESC) && (flags & tx_h.DATA_FIRST) != tx_h.ADJ_FIRST)"  is complex.
Complex Conditional,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameters,The conditional expression  "!txio.option_inform && !decode.first_pass && opcode.type == tx_h.CALL && opers > 1"  is complex.
Complex Conditional,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameters,The conditional expression  "!txio.option_inform && !decode.first_pass && opcode.type == tx_h.CALL && opers > 1"  is complex.
Complex Conditional,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_extra,The conditional expression  "(addr > 1) && (firstbyte & 0x40) == 0 && (txio.option_inform) && (option_labels > 0)"  is complex.
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,GraphicsFont,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\GraphicsFont.cs,getLines,The following statement contains a magic number: switch (id)              {                  case 32: return "0000000000000000";                  case 33: return "000004067F060400";                  case 34: return "000010307F301000";                  case 35: return "8040201008040201";                  case 36: return "0102040810204080";                  case 37: return "0000000000000000";                  case 38: return "00000000FF000000";                  case 39: return "000000FF00000000";                  case 40: return "1010101010101010";                  case 41: return "0808080808080808";                  case 42: return "101010FF00000000";                  case 43: return "00000000FF101010";                  case 44: return "10101010F0101010";                  case 45: return "080808080F080808";                  case 46: return "08080808F8000000";                  case 47: return "000000F808080808";                  case 48: return "0000001F10101010";                  case 49: return "101010101F000000";                  case 50: return "08080808F8040201";                  case 51: return "010204F808080808";                  case 52: return "8040201F10101010";                  case 53: return "101010101F204080";                  case 54: return "FFFFFFFFFFFFFFFF";                  case 55: return "FFFFFFFFFF000000";                  case 56: return "000000FFFFFFFFFF";                  case 57: return "1F1F1F1F1F1F1F1F";                  case 58: return "F8F8F8F8F8F8F8F8";                  default:                      return "FF818181818181FF";              }
Magic Number,Frotz.Other,ZMath,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\ZMath.cs,MakeInt,The following statement contains a magic number: return ((zlong)(((a) << 24) | ((b) << 16) | ((c) << 8) | (d)));
Magic Number,Frotz.Other,ZMath,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\ZMath.cs,MakeInt,The following statement contains a magic number: return ((zlong)(((a) << 24) | ((b) << 16) | ((c) << 8) | (d)));
Magic Number,Frotz.Other,ZMath,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\ZMath.cs,MakeInt,The following statement contains a magic number: return ((zlong)(((a) << 24) | ((b) << 16) | ((c) << 8) | (d)));
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_chunks.ContainsKey(start - 8)) {                  Chunk c = _chunks[start - 8];                  if (c.Usage == "Exec") {                      _blorb.ZCode = buffer;                  } else if (c.Usage == "Pict") {                      _blorb.Pictures[c.Number] = new BlorbPicture(buffer);  #if DEBUGPICTURES                      // Keeping this snippet around in case I want to see the graphics in the Blorb file                      if (buffer.Length != 8)                      {                          FileStream fs = new FileStream(                              String.Format("c:\\temp\\{0:d3}.png"' c.Number)' FileMode.Create);                          fs.Write(buffer' 0' buffer.Length);                          fs.Close();                      }  #endif                  } else if (c.Usage == "Snd ") {                      byte[] temp = new byte[buffer.Length + 8];                        if (buffer[0] == 'A' && buffer[1] == 'I' && buffer[2] == 'F' && buffer[3] == 'F') {                          temp[0] = (byte)'F';                          temp[1] = (byte)'O';                          temp[2] = (byte)'R';                          temp[3] = (byte)'M';                          temp[4] = (byte)((buffer.Length >> 24) & 0xff);                          temp[5] = (byte)((buffer.Length >> 16) & 0xff);                          temp[6] = (byte)((buffer.Length >> 8) & 0xff);                          temp[7] = (byte)((buffer.Length) & 0xff);                            Array.Copy(buffer' 0' temp' 8' buffer.Length);                            _blorb.Sounds[c.Number] = temp;                      } else {                          os_.fatal("Unhandled sound type in blorb file");                      }                  } else {                      os_.fatal("Unknown usage chunk in blorb file:" + c.Usage);                  }                  } else {                  switch (type) {                      case "FORM":                          String formType = ReadString();                          handleForm(start' length);                          break;                      case "RIdx":                          _stream.Position = start;                          int numResources = ReadInt();                          for (int i = 0; i < numResources; i++) {                              Chunk c = new Chunk(ReadString()' ReadInt()' ReadInt());                              _chunks.Add(c.Start' c);                          }                          break;                      case "IFmd": // Metadata                          _blorb.MetaData = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          if (_blorb.MetaData[0] != '<')                          {                              // TODO Make sure that this is being handled correctly                              int index = _blorb.MetaData.IndexOf('<');                              _blorb.MetaData = _blorb.MetaData.Substring(index);                          }                          break;                      case "Loop":                          break;                      case "Fspc":                          _stream.Position = start;                          ReadInt();                          break;                      case "SNam": // TODO It seems that when it gets the story name' it is actually stored as 2 byte words'                          // not one byte chars                          _blorb.StoryName = Encoding.UTF8.GetString(buffer' 0' buffer.Length);                          break;                      case "AUTH":                      case "ANNO":                      case "(c) ":                          break;                      case "APal":                          int len = buffer.Length / 4;                          for (int i = 0; i < len; i++)                          {                              int pos = i * 4;                              byte a = buffer[pos + 0];                              byte b = buffer[pos + 1];                              byte c = buffer[pos + 2];                              byte d = buffer[pos + 3];                                UInt32 result = Frotz.Other.ZMath.MakeInt(a' b' c' d);                                _blorb.AdaptivePalatte.Add( (int) result);                          }                          break;                      case "IFhd":                          _blorb.IFhd = buffer;                          break;                      case "RelN":                          _blorb.ReleaseNumber = (buffer[0] << 8) + (buffer[1]);                          break;                      case "Reso":                          _stream.Position = start;                          int px = ReadInt();                          int py = ReadInt();                          int minx = ReadInt();                          int miny = ReadInt();                          int maxx = ReadInt();                          int maxy = ReadInt();                            _blorb.StandardSize = new ZSize(py' px);                          _blorb.MinSize = new ZSize(miny' minx);                          _blorb.MaxSize = new ZSize(maxy' maxx);                            while (_stream.Position < start + length) {                              int number = ReadInt();                              int ratnum = ReadInt();                              int ratden = ReadInt();                              int minnum = ReadInt();                              int minden = ReadInt();                              int maxnum = ReadInt();                              int maxden = ReadInt();                                if (ratden != 0) _blorb.Pictures[number].StandardRatio = ratnum / ratden;                              if (minden != 0) _blorb.Pictures[number].MinRatio = minnum / minden;                              if (maxden != 0) _blorb.Pictures[number].MaxRatio = maxnum / maxden;                          }                          break;                      case "Plte":                          System.Diagnostics.Debug.WriteLine("Palatte");                          break;                      default:                          Console.WriteLine("".PadRight(level) + ":" + "Type:" + type + ":" + length);                          break;                  }              }
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,readChunk,The following statement contains a magic number: if (_stream.Position % 2 == 1) _stream.Position++;
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,ReadBlorbFile,The following statement contains a magic number: handleForm((int)_stream.Position - 4' len);
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,ReadString,The following statement contains a magic number: byte[] buffer = new byte[4];
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,ReadString,The following statement contains a magic number: _stream.Read(buffer' 0' 4);
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,ReadInt,The following statement contains a magic number: byte[] buffer = new byte[4];
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,ReadInt,The following statement contains a magic number: _stream.Read(buffer' 0' 4);
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,ReadInt,The following statement contains a magic number: return ((buffer[0] << 24) + (buffer[1] << 16) + (buffer[2] << 8) + (buffer[3]));
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,ReadInt,The following statement contains a magic number: return ((buffer[0] << 24) + (buffer[1] << 16) + (buffer[2] << 8) + (buffer[3]));
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,ReadInt,The following statement contains a magic number: return ((buffer[0] << 24) + (buffer[1] << 16) + (buffer[2] << 8) + (buffer[3]));
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,ReadInt,The following statement contains a magic number: return ((buffer[0] << 24) + (buffer[1] << 16) + (buffer[2] << 8) + (buffer[3]));
Magic Number,Frotz.Blorb,BlorbReader,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\BlorbFiles.cs,ReadInt,The following statement contains a magic number: return ((buffer[0] << 24) + (buffer[1] << 16) + (buffer[2] << 8) + (buffer[3]));
Magic Number,Frotz.Generic,Err,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\err.cs,runtime_error,The following statement contains a magic number: if ((err_report_mode == ErrorCodes.ERR_REPORT_ALWAYS)              || (err_report_mode == ErrorCodes.ERR_REPORT_ONCE && wasfirst)) {                  long pc;                    FastMem.GET_PC(out pc);                  Text.print_string("Warning: ");                  Text.print_string(err_messages[errnum - 1]);                  Text.print_string(" (PC = ");                  print_long(pc' 16);                  Buffer.print_char(')');                    if (err_report_mode == ErrorCodes.ERR_REPORT_ONCE) {                      Text.print_string(" (will ignore further occurrences)");                  } else {                      Text.print_string(" (occurence ");                      print_long(error_count[errnum - 1]' 10);                      Buffer.print_char(')');                  }                  Buffer.new_line();              }
Magic Number,Frotz.Generic,Err,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\err.cs,runtime_error,The following statement contains a magic number: if ((err_report_mode == ErrorCodes.ERR_REPORT_ALWAYS)              || (err_report_mode == ErrorCodes.ERR_REPORT_ONCE && wasfirst)) {                  long pc;                    FastMem.GET_PC(out pc);                  Text.print_string("Warning: ");                  Text.print_string(err_messages[errnum - 1]);                  Text.print_string(" (PC = ");                  print_long(pc' 16);                  Buffer.print_char(')');                    if (err_report_mode == ErrorCodes.ERR_REPORT_ONCE) {                      Text.print_string(" (will ignore further occurrences)");                  } else {                      Text.print_string(" (occurence ");                      print_long(error_count[errnum - 1]' 10);                      Buffer.print_char(')');                  }                  Buffer.new_line();              }
Magic Number,Frotz.Generic,Err,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\err.cs,print_long,The following statement contains a magic number: switch (base_val) {                  case 10:  s = value.ToString(); break;                  case 16: s = value.ToString("X"); break;                  default: os_.fail("Unsupported print_long base"); break;              }
Magic Number,Frotz.Generic,Err,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\err.cs,print_long,The following statement contains a magic number: switch (base_val) {                  case 10:  s = value.ToString(); break;                  case 16: s = value.ToString("X"); break;                  default: os_.fail("Unsupported print_long base"); break;              }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,HI,The following statement contains a magic number: return (byte)(v >> 8);
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,LOW_WORD,The following statement contains a magic number: v = (byte)((ZMData[addr] << 8) | ZMData[addr + 1]);
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,LOW_WORD,The following statement contains a magic number: v = (ushort)((ZMData[addr] << 8) | ZMData[addr + 1]);
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,CODE_WORD,The following statement contains a magic number: v = (zword)(ZMData[pcp] << 8 | ZMData[pcp + 1]);
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,CODE_WORD,The following statement contains a magic number: pcp += 2;
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,get_header_extension,The following statement contains a magic number: addr = (zword)(main.h_extension_table + 2 * entry);
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,set_header_extension,The following statement contains a magic number: addr = (zword)(main.h_extension_table + 2 * entry);
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,restart_header,The following statement contains a magic number: if ((main.h_version >= ZMachine.V3) && (main.h_user_name[0] != 0))              {                  for (i = 0; i < 8; i++)                  {                      storeb((zword)(ZMachine.H_USER_NAME + i)' main.h_user_name[i]);                  }              }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,The following statement contains a magic number: ZMData = new byte[64];
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,The following statement contains a magic number: if (story_fp.Read(ZMData' 0' 64) != 64)              {                  os_.fatal("Story file read error");              }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,The following statement contains a magic number: if (story_fp.Read(ZMData' 0' 64) != 64)              {                  os_.fatal("Story file read error");              }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,The following statement contains a magic number: for (i = 0' addr = ZMachine.H_SERIAL; i < 6; i++' addr++)              {                  LOW_BYTE(addr' out main.h_serial[i]);              }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,The following statement contains a magic number: for (i = 0; records[i].story_id != Story.UNKNOWN; i++)              {                    if (main.h_release == records[i].release)                  {                        for (j = 0; j < 6; j++)                          if (main.h_serial[j] != records[i].serial[j])                              goto no_match;                        main.story_id = records[i].story_id;                    }                no_match: ; /* null statement */                }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,The following statement contains a magic number: if (main.h_file_size != 0)              {                  main.story_size = 2 * main.h_file_size;                    if (main.h_version >= ZMachine.V4)                  {                      main.story_size *= 2;                  }                    if (main.h_version >= ZMachine.V6)                  {                      main.story_size *= 2;                  }                    if (main.story_id == Story.AMFV && main.h_release == 47)                  {                      main.story_size = 2 * main.h_file_size;                  }                  else if (main.story_size > 0)                  {/* os_path_open() set the size */                  }                  else                  {/* some old games lack the file size entry */                      main.story_size = story_fp.Length - init_fp_pos;                      story_fp.Position = init_fp_pos + 64;                  }                    LOW_WORD(ZMachine.H_CHECKSUM' out main.h_checksum);                  LOW_WORD(ZMachine.H_ALPHABET' out main.h_alphabet);                  LOW_WORD(ZMachine.H_FUNCTIONS_OFFSET' out main.h_functions_offset);                  LOW_WORD(ZMachine.H_STRINGS_OFFSET' out main.h_strings_offset);                  LOW_WORD(ZMachine.H_TERMINATING_KEYS' out main.h_terminating_keys);                  LOW_WORD(ZMachine.H_EXTENSION_TABLE' out main.h_extension_table);                    /* Zork Zero beta and Macintosh versions don't have the graphics flag set */                    if (main.story_id == Story.ZORK_ZERO)                  {                      if (main.h_release == 96 || main.h_release == 153 ||                          main.h_release == 242 || main.h_release == 296)                      {                          main.h_flags |= ZMachine.GRAPHICS_FLAG;                      }                  }                    /* Adjust opcode tables */                    if (main.h_version <= ZMachine.V4)                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Variable.z_pop);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Math.z_not);                  }                  else                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Process.z_catch);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Process.z_call_n);                  }                    /* Allocate memory for story data */                    byte[] temp = new byte[ZMData.Length];                  Frotz.Other.ZMath.clearArray(temp);                    System.Array.Copy(ZMData' temp' ZMData.Length);                    ZMData = new byte[main.story_size];                  Frotz.Other.ZMath.clearArray(ZMData);                  System.Array.Copy(temp' ZMData' temp.Length);                    /* Load story file in chunks of 32KB */                    n = 0x8000;                    for (size = 64; size < main.story_size; size += n)                  {                      if (main.story_size - size < 0x8000) n = (ushort)(main.story_size - size);                      SET_PC(size);                        int read = story_fp.Read(ZMData' (int)pcp' n);                        if (read != n) os_.fatal("Story file read error");                  }                    // Take a moment to calculate the checksum of the story file in case verify is called                  ZMData_checksum = 0;                  for (int k = 64; k < ZMData.Length; k++)                  {                      ZMData_checksum += ZMData[k];                  }              }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,The following statement contains a magic number: if (main.h_file_size != 0)              {                  main.story_size = 2 * main.h_file_size;                    if (main.h_version >= ZMachine.V4)                  {                      main.story_size *= 2;                  }                    if (main.h_version >= ZMachine.V6)                  {                      main.story_size *= 2;                  }                    if (main.story_id == Story.AMFV && main.h_release == 47)                  {                      main.story_size = 2 * main.h_file_size;                  }                  else if (main.story_size > 0)                  {/* os_path_open() set the size */                  }                  else                  {/* some old games lack the file size entry */                      main.story_size = story_fp.Length - init_fp_pos;                      story_fp.Position = init_fp_pos + 64;                  }                    LOW_WORD(ZMachine.H_CHECKSUM' out main.h_checksum);                  LOW_WORD(ZMachine.H_ALPHABET' out main.h_alphabet);                  LOW_WORD(ZMachine.H_FUNCTIONS_OFFSET' out main.h_functions_offset);                  LOW_WORD(ZMachine.H_STRINGS_OFFSET' out main.h_strings_offset);                  LOW_WORD(ZMachine.H_TERMINATING_KEYS' out main.h_terminating_keys);                  LOW_WORD(ZMachine.H_EXTENSION_TABLE' out main.h_extension_table);                    /* Zork Zero beta and Macintosh versions don't have the graphics flag set */                    if (main.story_id == Story.ZORK_ZERO)                  {                      if (main.h_release == 96 || main.h_release == 153 ||                          main.h_release == 242 || main.h_release == 296)                      {                          main.h_flags |= ZMachine.GRAPHICS_FLAG;                      }                  }                    /* Adjust opcode tables */                    if (main.h_version <= ZMachine.V4)                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Variable.z_pop);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Math.z_not);                  }                  else                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Process.z_catch);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Process.z_call_n);                  }                    /* Allocate memory for story data */                    byte[] temp = new byte[ZMData.Length];                  Frotz.Other.ZMath.clearArray(temp);                    System.Array.Copy(ZMData' temp' ZMData.Length);                    ZMData = new byte[main.story_size];                  Frotz.Other.ZMath.clearArray(ZMData);                  System.Array.Copy(temp' ZMData' temp.Length);                    /* Load story file in chunks of 32KB */                    n = 0x8000;                    for (size = 64; size < main.story_size; size += n)                  {                      if (main.story_size - size < 0x8000) n = (ushort)(main.story_size - size);                      SET_PC(size);                        int read = story_fp.Read(ZMData' (int)pcp' n);                        if (read != n) os_.fatal("Story file read error");                  }                    // Take a moment to calculate the checksum of the story file in case verify is called                  ZMData_checksum = 0;                  for (int k = 64; k < ZMData.Length; k++)                  {                      ZMData_checksum += ZMData[k];                  }              }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,The following statement contains a magic number: if (main.h_file_size != 0)              {                  main.story_size = 2 * main.h_file_size;                    if (main.h_version >= ZMachine.V4)                  {                      main.story_size *= 2;                  }                    if (main.h_version >= ZMachine.V6)                  {                      main.story_size *= 2;                  }                    if (main.story_id == Story.AMFV && main.h_release == 47)                  {                      main.story_size = 2 * main.h_file_size;                  }                  else if (main.story_size > 0)                  {/* os_path_open() set the size */                  }                  else                  {/* some old games lack the file size entry */                      main.story_size = story_fp.Length - init_fp_pos;                      story_fp.Position = init_fp_pos + 64;                  }                    LOW_WORD(ZMachine.H_CHECKSUM' out main.h_checksum);                  LOW_WORD(ZMachine.H_ALPHABET' out main.h_alphabet);                  LOW_WORD(ZMachine.H_FUNCTIONS_OFFSET' out main.h_functions_offset);                  LOW_WORD(ZMachine.H_STRINGS_OFFSET' out main.h_strings_offset);                  LOW_WORD(ZMachine.H_TERMINATING_KEYS' out main.h_terminating_keys);                  LOW_WORD(ZMachine.H_EXTENSION_TABLE' out main.h_extension_table);                    /* Zork Zero beta and Macintosh versions don't have the graphics flag set */                    if (main.story_id == Story.ZORK_ZERO)                  {                      if (main.h_release == 96 || main.h_release == 153 ||                          main.h_release == 242 || main.h_release == 296)                      {                          main.h_flags |= ZMachine.GRAPHICS_FLAG;                      }                  }                    /* Adjust opcode tables */                    if (main.h_version <= ZMachine.V4)                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Variable.z_pop);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Math.z_not);                  }                  else                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Process.z_catch);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Process.z_call_n);                  }                    /* Allocate memory for story data */                    byte[] temp = new byte[ZMData.Length];                  Frotz.Other.ZMath.clearArray(temp);                    System.Array.Copy(ZMData' temp' ZMData.Length);                    ZMData = new byte[main.story_size];                  Frotz.Other.ZMath.clearArray(ZMData);                  System.Array.Copy(temp' ZMData' temp.Length);                    /* Load story file in chunks of 32KB */                    n = 0x8000;                    for (size = 64; size < main.story_size; size += n)                  {                      if (main.story_size - size < 0x8000) n = (ushort)(main.story_size - size);                      SET_PC(size);                        int read = story_fp.Read(ZMData' (int)pcp' n);                        if (read != n) os_.fatal("Story file read error");                  }                    // Take a moment to calculate the checksum of the story file in case verify is called                  ZMData_checksum = 0;                  for (int k = 64; k < ZMData.Length; k++)                  {                      ZMData_checksum += ZMData[k];                  }              }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,The following statement contains a magic number: if (main.h_file_size != 0)              {                  main.story_size = 2 * main.h_file_size;                    if (main.h_version >= ZMachine.V4)                  {                      main.story_size *= 2;                  }                    if (main.h_version >= ZMachine.V6)                  {                      main.story_size *= 2;                  }                    if (main.story_id == Story.AMFV && main.h_release == 47)                  {                      main.story_size = 2 * main.h_file_size;                  }                  else if (main.story_size > 0)                  {/* os_path_open() set the size */                  }                  else                  {/* some old games lack the file size entry */                      main.story_size = story_fp.Length - init_fp_pos;                      story_fp.Position = init_fp_pos + 64;                  }                    LOW_WORD(ZMachine.H_CHECKSUM' out main.h_checksum);                  LOW_WORD(ZMachine.H_ALPHABET' out main.h_alphabet);                  LOW_WORD(ZMachine.H_FUNCTIONS_OFFSET' out main.h_functions_offset);                  LOW_WORD(ZMachine.H_STRINGS_OFFSET' out main.h_strings_offset);                  LOW_WORD(ZMachine.H_TERMINATING_KEYS' out main.h_terminating_keys);                  LOW_WORD(ZMachine.H_EXTENSION_TABLE' out main.h_extension_table);                    /* Zork Zero beta and Macintosh versions don't have the graphics flag set */                    if (main.story_id == Story.ZORK_ZERO)                  {                      if (main.h_release == 96 || main.h_release == 153 ||                          main.h_release == 242 || main.h_release == 296)                      {                          main.h_flags |= ZMachine.GRAPHICS_FLAG;                      }                  }                    /* Adjust opcode tables */                    if (main.h_version <= ZMachine.V4)                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Variable.z_pop);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Math.z_not);                  }                  else                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Process.z_catch);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Process.z_call_n);                  }                    /* Allocate memory for story data */                    byte[] temp = new byte[ZMData.Length];                  Frotz.Other.ZMath.clearArray(temp);                    System.Array.Copy(ZMData' temp' ZMData.Length);                    ZMData = new byte[main.story_size];                  Frotz.Other.ZMath.clearArray(ZMData);                  System.Array.Copy(temp' ZMData' temp.Length);                    /* Load story file in chunks of 32KB */                    n = 0x8000;                    for (size = 64; size < main.story_size; size += n)                  {                      if (main.story_size - size < 0x8000) n = (ushort)(main.story_size - size);                      SET_PC(size);                        int read = story_fp.Read(ZMData' (int)pcp' n);                        if (read != n) os_.fatal("Story file read error");                  }                    // Take a moment to calculate the checksum of the story file in case verify is called                  ZMData_checksum = 0;                  for (int k = 64; k < ZMData.Length; k++)                  {                      ZMData_checksum += ZMData[k];                  }              }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,The following statement contains a magic number: if (main.h_file_size != 0)              {                  main.story_size = 2 * main.h_file_size;                    if (main.h_version >= ZMachine.V4)                  {                      main.story_size *= 2;                  }                    if (main.h_version >= ZMachine.V6)                  {                      main.story_size *= 2;                  }                    if (main.story_id == Story.AMFV && main.h_release == 47)                  {                      main.story_size = 2 * main.h_file_size;                  }                  else if (main.story_size > 0)                  {/* os_path_open() set the size */                  }                  else                  {/* some old games lack the file size entry */                      main.story_size = story_fp.Length - init_fp_pos;                      story_fp.Position = init_fp_pos + 64;                  }                    LOW_WORD(ZMachine.H_CHECKSUM' out main.h_checksum);                  LOW_WORD(ZMachine.H_ALPHABET' out main.h_alphabet);                  LOW_WORD(ZMachine.H_FUNCTIONS_OFFSET' out main.h_functions_offset);                  LOW_WORD(ZMachine.H_STRINGS_OFFSET' out main.h_strings_offset);                  LOW_WORD(ZMachine.H_TERMINATING_KEYS' out main.h_terminating_keys);                  LOW_WORD(ZMachine.H_EXTENSION_TABLE' out main.h_extension_table);                    /* Zork Zero beta and Macintosh versions don't have the graphics flag set */                    if (main.story_id == Story.ZORK_ZERO)                  {                      if (main.h_release == 96 || main.h_release == 153 ||                          main.h_release == 242 || main.h_release == 296)                      {                          main.h_flags |= ZMachine.GRAPHICS_FLAG;                      }                  }                    /* Adjust opcode tables */                    if (main.h_version <= ZMachine.V4)                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Variable.z_pop);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Math.z_not);                  }                  else                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Process.z_catch);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Process.z_call_n);                  }                    /* Allocate memory for story data */                    byte[] temp = new byte[ZMData.Length];                  Frotz.Other.ZMath.clearArray(temp);                    System.Array.Copy(ZMData' temp' ZMData.Length);                    ZMData = new byte[main.story_size];                  Frotz.Other.ZMath.clearArray(ZMData);                  System.Array.Copy(temp' ZMData' temp.Length);                    /* Load story file in chunks of 32KB */                    n = 0x8000;                    for (size = 64; size < main.story_size; size += n)                  {                      if (main.story_size - size < 0x8000) n = (ushort)(main.story_size - size);                      SET_PC(size);                        int read = story_fp.Read(ZMData' (int)pcp' n);                        if (read != n) os_.fatal("Story file read error");                  }                    // Take a moment to calculate the checksum of the story file in case verify is called                  ZMData_checksum = 0;                  for (int k = 64; k < ZMData.Length; k++)                  {                      ZMData_checksum += ZMData[k];                  }              }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,The following statement contains a magic number: if (main.h_file_size != 0)              {                  main.story_size = 2 * main.h_file_size;                    if (main.h_version >= ZMachine.V4)                  {                      main.story_size *= 2;                  }                    if (main.h_version >= ZMachine.V6)                  {                      main.story_size *= 2;                  }                    if (main.story_id == Story.AMFV && main.h_release == 47)                  {                      main.story_size = 2 * main.h_file_size;                  }                  else if (main.story_size > 0)                  {/* os_path_open() set the size */                  }                  else                  {/* some old games lack the file size entry */                      main.story_size = story_fp.Length - init_fp_pos;                      story_fp.Position = init_fp_pos + 64;                  }                    LOW_WORD(ZMachine.H_CHECKSUM' out main.h_checksum);                  LOW_WORD(ZMachine.H_ALPHABET' out main.h_alphabet);                  LOW_WORD(ZMachine.H_FUNCTIONS_OFFSET' out main.h_functions_offset);                  LOW_WORD(ZMachine.H_STRINGS_OFFSET' out main.h_strings_offset);                  LOW_WORD(ZMachine.H_TERMINATING_KEYS' out main.h_terminating_keys);                  LOW_WORD(ZMachine.H_EXTENSION_TABLE' out main.h_extension_table);                    /* Zork Zero beta and Macintosh versions don't have the graphics flag set */                    if (main.story_id == Story.ZORK_ZERO)                  {                      if (main.h_release == 96 || main.h_release == 153 ||                          main.h_release == 242 || main.h_release == 296)                      {                          main.h_flags |= ZMachine.GRAPHICS_FLAG;                      }                  }                    /* Adjust opcode tables */                    if (main.h_version <= ZMachine.V4)                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Variable.z_pop);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Math.z_not);                  }                  else                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Process.z_catch);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Process.z_call_n);                  }                    /* Allocate memory for story data */                    byte[] temp = new byte[ZMData.Length];                  Frotz.Other.ZMath.clearArray(temp);                    System.Array.Copy(ZMData' temp' ZMData.Length);                    ZMData = new byte[main.story_size];                  Frotz.Other.ZMath.clearArray(ZMData);                  System.Array.Copy(temp' ZMData' temp.Length);                    /* Load story file in chunks of 32KB */                    n = 0x8000;                    for (size = 64; size < main.story_size; size += n)                  {                      if (main.story_size - size < 0x8000) n = (ushort)(main.story_size - size);                      SET_PC(size);                        int read = story_fp.Read(ZMData' (int)pcp' n);                        if (read != n) os_.fatal("Story file read error");                  }                    // Take a moment to calculate the checksum of the story file in case verify is called                  ZMData_checksum = 0;                  for (int k = 64; k < ZMData.Length; k++)                  {                      ZMData_checksum += ZMData[k];                  }              }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,The following statement contains a magic number: if (main.h_file_size != 0)              {                  main.story_size = 2 * main.h_file_size;                    if (main.h_version >= ZMachine.V4)                  {                      main.story_size *= 2;                  }                    if (main.h_version >= ZMachine.V6)                  {                      main.story_size *= 2;                  }                    if (main.story_id == Story.AMFV && main.h_release == 47)                  {                      main.story_size = 2 * main.h_file_size;                  }                  else if (main.story_size > 0)                  {/* os_path_open() set the size */                  }                  else                  {/* some old games lack the file size entry */                      main.story_size = story_fp.Length - init_fp_pos;                      story_fp.Position = init_fp_pos + 64;                  }                    LOW_WORD(ZMachine.H_CHECKSUM' out main.h_checksum);                  LOW_WORD(ZMachine.H_ALPHABET' out main.h_alphabet);                  LOW_WORD(ZMachine.H_FUNCTIONS_OFFSET' out main.h_functions_offset);                  LOW_WORD(ZMachine.H_STRINGS_OFFSET' out main.h_strings_offset);                  LOW_WORD(ZMachine.H_TERMINATING_KEYS' out main.h_terminating_keys);                  LOW_WORD(ZMachine.H_EXTENSION_TABLE' out main.h_extension_table);                    /* Zork Zero beta and Macintosh versions don't have the graphics flag set */                    if (main.story_id == Story.ZORK_ZERO)                  {                      if (main.h_release == 96 || main.h_release == 153 ||                          main.h_release == 242 || main.h_release == 296)                      {                          main.h_flags |= ZMachine.GRAPHICS_FLAG;                      }                  }                    /* Adjust opcode tables */                    if (main.h_version <= ZMachine.V4)                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Variable.z_pop);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Math.z_not);                  }                  else                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Process.z_catch);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Process.z_call_n);                  }                    /* Allocate memory for story data */                    byte[] temp = new byte[ZMData.Length];                  Frotz.Other.ZMath.clearArray(temp);                    System.Array.Copy(ZMData' temp' ZMData.Length);                    ZMData = new byte[main.story_size];                  Frotz.Other.ZMath.clearArray(ZMData);                  System.Array.Copy(temp' ZMData' temp.Length);                    /* Load story file in chunks of 32KB */                    n = 0x8000;                    for (size = 64; size < main.story_size; size += n)                  {                      if (main.story_size - size < 0x8000) n = (ushort)(main.story_size - size);                      SET_PC(size);                        int read = story_fp.Read(ZMData' (int)pcp' n);                        if (read != n) os_.fatal("Story file read error");                  }                    // Take a moment to calculate the checksum of the story file in case verify is called                  ZMData_checksum = 0;                  for (int k = 64; k < ZMData.Length; k++)                  {                      ZMData_checksum += ZMData[k];                  }              }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,The following statement contains a magic number: if (main.h_file_size != 0)              {                  main.story_size = 2 * main.h_file_size;                    if (main.h_version >= ZMachine.V4)                  {                      main.story_size *= 2;                  }                    if (main.h_version >= ZMachine.V6)                  {                      main.story_size *= 2;                  }                    if (main.story_id == Story.AMFV && main.h_release == 47)                  {                      main.story_size = 2 * main.h_file_size;                  }                  else if (main.story_size > 0)                  {/* os_path_open() set the size */                  }                  else                  {/* some old games lack the file size entry */                      main.story_size = story_fp.Length - init_fp_pos;                      story_fp.Position = init_fp_pos + 64;                  }                    LOW_WORD(ZMachine.H_CHECKSUM' out main.h_checksum);                  LOW_WORD(ZMachine.H_ALPHABET' out main.h_alphabet);                  LOW_WORD(ZMachine.H_FUNCTIONS_OFFSET' out main.h_functions_offset);                  LOW_WORD(ZMachine.H_STRINGS_OFFSET' out main.h_strings_offset);                  LOW_WORD(ZMachine.H_TERMINATING_KEYS' out main.h_terminating_keys);                  LOW_WORD(ZMachine.H_EXTENSION_TABLE' out main.h_extension_table);                    /* Zork Zero beta and Macintosh versions don't have the graphics flag set */                    if (main.story_id == Story.ZORK_ZERO)                  {                      if (main.h_release == 96 || main.h_release == 153 ||                          main.h_release == 242 || main.h_release == 296)                      {                          main.h_flags |= ZMachine.GRAPHICS_FLAG;                      }                  }                    /* Adjust opcode tables */                    if (main.h_version <= ZMachine.V4)                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Variable.z_pop);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Math.z_not);                  }                  else                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Process.z_catch);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Process.z_call_n);                  }                    /* Allocate memory for story data */                    byte[] temp = new byte[ZMData.Length];                  Frotz.Other.ZMath.clearArray(temp);                    System.Array.Copy(ZMData' temp' ZMData.Length);                    ZMData = new byte[main.story_size];                  Frotz.Other.ZMath.clearArray(ZMData);                  System.Array.Copy(temp' ZMData' temp.Length);                    /* Load story file in chunks of 32KB */                    n = 0x8000;                    for (size = 64; size < main.story_size; size += n)                  {                      if (main.story_size - size < 0x8000) n = (ushort)(main.story_size - size);                      SET_PC(size);                        int read = story_fp.Read(ZMData' (int)pcp' n);                        if (read != n) os_.fatal("Story file read error");                  }                    // Take a moment to calculate the checksum of the story file in case verify is called                  ZMData_checksum = 0;                  for (int k = 64; k < ZMData.Length; k++)                  {                      ZMData_checksum += ZMData[k];                  }              }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,The following statement contains a magic number: if (main.h_file_size != 0)              {                  main.story_size = 2 * main.h_file_size;                    if (main.h_version >= ZMachine.V4)                  {                      main.story_size *= 2;                  }                    if (main.h_version >= ZMachine.V6)                  {                      main.story_size *= 2;                  }                    if (main.story_id == Story.AMFV && main.h_release == 47)                  {                      main.story_size = 2 * main.h_file_size;                  }                  else if (main.story_size > 0)                  {/* os_path_open() set the size */                  }                  else                  {/* some old games lack the file size entry */                      main.story_size = story_fp.Length - init_fp_pos;                      story_fp.Position = init_fp_pos + 64;                  }                    LOW_WORD(ZMachine.H_CHECKSUM' out main.h_checksum);                  LOW_WORD(ZMachine.H_ALPHABET' out main.h_alphabet);                  LOW_WORD(ZMachine.H_FUNCTIONS_OFFSET' out main.h_functions_offset);                  LOW_WORD(ZMachine.H_STRINGS_OFFSET' out main.h_strings_offset);                  LOW_WORD(ZMachine.H_TERMINATING_KEYS' out main.h_terminating_keys);                  LOW_WORD(ZMachine.H_EXTENSION_TABLE' out main.h_extension_table);                    /* Zork Zero beta and Macintosh versions don't have the graphics flag set */                    if (main.story_id == Story.ZORK_ZERO)                  {                      if (main.h_release == 96 || main.h_release == 153 ||                          main.h_release == 242 || main.h_release == 296)                      {                          main.h_flags |= ZMachine.GRAPHICS_FLAG;                      }                  }                    /* Adjust opcode tables */                    if (main.h_version <= ZMachine.V4)                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Variable.z_pop);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Math.z_not);                  }                  else                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Process.z_catch);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Process.z_call_n);                  }                    /* Allocate memory for story data */                    byte[] temp = new byte[ZMData.Length];                  Frotz.Other.ZMath.clearArray(temp);                    System.Array.Copy(ZMData' temp' ZMData.Length);                    ZMData = new byte[main.story_size];                  Frotz.Other.ZMath.clearArray(ZMData);                  System.Array.Copy(temp' ZMData' temp.Length);                    /* Load story file in chunks of 32KB */                    n = 0x8000;                    for (size = 64; size < main.story_size; size += n)                  {                      if (main.story_size - size < 0x8000) n = (ushort)(main.story_size - size);                      SET_PC(size);                        int read = story_fp.Read(ZMData' (int)pcp' n);                        if (read != n) os_.fatal("Story file read error");                  }                    // Take a moment to calculate the checksum of the story file in case verify is called                  ZMData_checksum = 0;                  for (int k = 64; k < ZMData.Length; k++)                  {                      ZMData_checksum += ZMData[k];                  }              }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,The following statement contains a magic number: if (main.h_file_size != 0)              {                  main.story_size = 2 * main.h_file_size;                    if (main.h_version >= ZMachine.V4)                  {                      main.story_size *= 2;                  }                    if (main.h_version >= ZMachine.V6)                  {                      main.story_size *= 2;                  }                    if (main.story_id == Story.AMFV && main.h_release == 47)                  {                      main.story_size = 2 * main.h_file_size;                  }                  else if (main.story_size > 0)                  {/* os_path_open() set the size */                  }                  else                  {/* some old games lack the file size entry */                      main.story_size = story_fp.Length - init_fp_pos;                      story_fp.Position = init_fp_pos + 64;                  }                    LOW_WORD(ZMachine.H_CHECKSUM' out main.h_checksum);                  LOW_WORD(ZMachine.H_ALPHABET' out main.h_alphabet);                  LOW_WORD(ZMachine.H_FUNCTIONS_OFFSET' out main.h_functions_offset);                  LOW_WORD(ZMachine.H_STRINGS_OFFSET' out main.h_strings_offset);                  LOW_WORD(ZMachine.H_TERMINATING_KEYS' out main.h_terminating_keys);                  LOW_WORD(ZMachine.H_EXTENSION_TABLE' out main.h_extension_table);                    /* Zork Zero beta and Macintosh versions don't have the graphics flag set */                    if (main.story_id == Story.ZORK_ZERO)                  {                      if (main.h_release == 96 || main.h_release == 153 ||                          main.h_release == 242 || main.h_release == 296)                      {                          main.h_flags |= ZMachine.GRAPHICS_FLAG;                      }                  }                    /* Adjust opcode tables */                    if (main.h_version <= ZMachine.V4)                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Variable.z_pop);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Math.z_not);                  }                  else                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Process.z_catch);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Process.z_call_n);                  }                    /* Allocate memory for story data */                    byte[] temp = new byte[ZMData.Length];                  Frotz.Other.ZMath.clearArray(temp);                    System.Array.Copy(ZMData' temp' ZMData.Length);                    ZMData = new byte[main.story_size];                  Frotz.Other.ZMath.clearArray(ZMData);                  System.Array.Copy(temp' ZMData' temp.Length);                    /* Load story file in chunks of 32KB */                    n = 0x8000;                    for (size = 64; size < main.story_size; size += n)                  {                      if (main.story_size - size < 0x8000) n = (ushort)(main.story_size - size);                      SET_PC(size);                        int read = story_fp.Read(ZMData' (int)pcp' n);                        if (read != n) os_.fatal("Story file read error");                  }                    // Take a moment to calculate the checksum of the story file in case verify is called                  ZMData_checksum = 0;                  for (int k = 64; k < ZMData.Length; k++)                  {                      ZMData_checksum += ZMData[k];                  }              }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,The following statement contains a magic number: if (main.h_file_size != 0)              {                  main.story_size = 2 * main.h_file_size;                    if (main.h_version >= ZMachine.V4)                  {                      main.story_size *= 2;                  }                    if (main.h_version >= ZMachine.V6)                  {                      main.story_size *= 2;                  }                    if (main.story_id == Story.AMFV && main.h_release == 47)                  {                      main.story_size = 2 * main.h_file_size;                  }                  else if (main.story_size > 0)                  {/* os_path_open() set the size */                  }                  else                  {/* some old games lack the file size entry */                      main.story_size = story_fp.Length - init_fp_pos;                      story_fp.Position = init_fp_pos + 64;                  }                    LOW_WORD(ZMachine.H_CHECKSUM' out main.h_checksum);                  LOW_WORD(ZMachine.H_ALPHABET' out main.h_alphabet);                  LOW_WORD(ZMachine.H_FUNCTIONS_OFFSET' out main.h_functions_offset);                  LOW_WORD(ZMachine.H_STRINGS_OFFSET' out main.h_strings_offset);                  LOW_WORD(ZMachine.H_TERMINATING_KEYS' out main.h_terminating_keys);                  LOW_WORD(ZMachine.H_EXTENSION_TABLE' out main.h_extension_table);                    /* Zork Zero beta and Macintosh versions don't have the graphics flag set */                    if (main.story_id == Story.ZORK_ZERO)                  {                      if (main.h_release == 96 || main.h_release == 153 ||                          main.h_release == 242 || main.h_release == 296)                      {                          main.h_flags |= ZMachine.GRAPHICS_FLAG;                      }                  }                    /* Adjust opcode tables */                    if (main.h_version <= ZMachine.V4)                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Variable.z_pop);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Math.z_not);                  }                  else                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Process.z_catch);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Process.z_call_n);                  }                    /* Allocate memory for story data */                    byte[] temp = new byte[ZMData.Length];                  Frotz.Other.ZMath.clearArray(temp);                    System.Array.Copy(ZMData' temp' ZMData.Length);                    ZMData = new byte[main.story_size];                  Frotz.Other.ZMath.clearArray(ZMData);                  System.Array.Copy(temp' ZMData' temp.Length);                    /* Load story file in chunks of 32KB */                    n = 0x8000;                    for (size = 64; size < main.story_size; size += n)                  {                      if (main.story_size - size < 0x8000) n = (ushort)(main.story_size - size);                      SET_PC(size);                        int read = story_fp.Read(ZMData' (int)pcp' n);                        if (read != n) os_.fatal("Story file read error");                  }                    // Take a moment to calculate the checksum of the story file in case verify is called                  ZMData_checksum = 0;                  for (int k = 64; k < ZMData.Length; k++)                  {                      ZMData_checksum += ZMData[k];                  }              }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,init_memory,The following statement contains a magic number: if (main.h_file_size != 0)              {                  main.story_size = 2 * main.h_file_size;                    if (main.h_version >= ZMachine.V4)                  {                      main.story_size *= 2;                  }                    if (main.h_version >= ZMachine.V6)                  {                      main.story_size *= 2;                  }                    if (main.story_id == Story.AMFV && main.h_release == 47)                  {                      main.story_size = 2 * main.h_file_size;                  }                  else if (main.story_size > 0)                  {/* os_path_open() set the size */                  }                  else                  {/* some old games lack the file size entry */                      main.story_size = story_fp.Length - init_fp_pos;                      story_fp.Position = init_fp_pos + 64;                  }                    LOW_WORD(ZMachine.H_CHECKSUM' out main.h_checksum);                  LOW_WORD(ZMachine.H_ALPHABET' out main.h_alphabet);                  LOW_WORD(ZMachine.H_FUNCTIONS_OFFSET' out main.h_functions_offset);                  LOW_WORD(ZMachine.H_STRINGS_OFFSET' out main.h_strings_offset);                  LOW_WORD(ZMachine.H_TERMINATING_KEYS' out main.h_terminating_keys);                  LOW_WORD(ZMachine.H_EXTENSION_TABLE' out main.h_extension_table);                    /* Zork Zero beta and Macintosh versions don't have the graphics flag set */                    if (main.story_id == Story.ZORK_ZERO)                  {                      if (main.h_release == 96 || main.h_release == 153 ||                          main.h_release == 242 || main.h_release == 296)                      {                          main.h_flags |= ZMachine.GRAPHICS_FLAG;                      }                  }                    /* Adjust opcode tables */                    if (main.h_version <= ZMachine.V4)                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Variable.z_pop);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Math.z_not);                  }                  else                  {                      Process.op0_opcodes[0x09] = new Process.zinstruction(Process.z_catch);                      Process.op0_opcodes[0x0f] = new Process.zinstruction(Process.z_call_n);                  }                    /* Allocate memory for story data */                    byte[] temp = new byte[ZMData.Length];                  Frotz.Other.ZMath.clearArray(temp);                    System.Array.Copy(ZMData' temp' ZMData.Length);                    ZMData = new byte[main.story_size];                  Frotz.Other.ZMath.clearArray(ZMData);                  System.Array.Copy(temp' ZMData' temp.Length);                    /* Load story file in chunks of 32KB */                    n = 0x8000;                    for (size = 64; size < main.story_size; size += n)                  {                      if (main.story_size - size < 0x8000) n = (ushort)(main.story_size - size);                      SET_PC(size);                        int read = story_fp.Read(ZMData' (int)pcp' n);                        if (read != n) os_.fatal("Story file read error");                  }                    // Take a moment to calculate the checksum of the story file in case verify is called                  ZMData_checksum = 0;                  for (int k = 64; k < ZMData.Length; k++)                  {                      ZMData_checksum += ZMData[k];                  }              }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,mem_diff,The following statement contains a magic number: for (; ; )              {                  for (j = 0; size > 0 && (c = (zbyte)(a[aPtr++] ^ b[bPtr++])) == 0; j++)                      size--;                  if (size == 0) break;                    size--;                    if (j > 0x8000)                  {                      diff[dPtr++] = 0;                      diff[dPtr++] = 0xff;                      diff[dPtr++] = 0xff;                      j -= 0x8000;                  }                    if (j > 0)                  {                      diff[dPtr++] = 0;                      j--;                        if (j <= 0x7f)                      {                          diff[dPtr++] = (byte)j;                      }                      else                      {                          diff[dPtr++] = (byte)((j & 0x7f) | 0x80);                          diff[dPtr++] = (byte)((j & 0x7f80) >> 7);                      }                  }                  diff[dPtr++] = c;                  b[bPtr - 1] ^= c;              }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,mem_undiff,The following statement contains a magic number: while (diff_length > 0)              {                  c = diff[diffPtr++];                  diff_length--;                  if (c == 0)                  {                      uint runlen;                        if (diff_length == 0) // TODO I'm not sure about this logic                          return;  /* Incomplete run */                      runlen = diff[diffPtr++];                      diff_length--;                      if ((runlen & 0x80) > 0)                      {                          if (diff_length == 0)                              return; /* Incomplete extended run */                          c = diff[diffPtr++];                          diff_length--;                          runlen = (runlen & 0x7f) | (((uint)c) << 7);                      }                        destPtr += runlen + 1;                  }                  else                  {                      dest[destPtr++] ^= c;                  }              }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,restore_undo,The following statement contains a magic number: return 2;
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,z_save,The following statement contains a magic number: if (Process.zargc != 0)              {                    /* Get the file name */                    default_name = get_default_name((zword)((Process.zargc >= 3) ? Process.zargs[2] : 0));                    //    if ((zargc >= 4) ? zargs[3] : 1) {                    //        if (os_read_file_name (new_name' default_name' FILE_SAVE_AUX) == 0)                  //        goto finished;                    //        strcpy (auxilary_name' new_name);                    //    } else strcpy (new_name' default_name);                    //    /* Open auxilary file */                    //    if ((gfp = fopen (new_name' "wb")) == NULL)                  //        goto finished;                    //    /* Write auxilary file */                    //    success = fwrite (zmp + zargs[0]' zargs[1]' 1' gfp);                    //    /* Close auxilary file */                    //    fclose (gfp);                  os_.fail("need to implement option save arguments");              }              else              {                  if (!os_.read_file_name(out new_name' save_name' FileTypes.FILE_SAVE))                      goto finished;                    save_name = new_name;                    /* Open game file */                    if ((gfp = new System.IO.FileStream(new_name' System.IO.FileMode.OpenOrCreate)) == null)                      goto finished;                    if (main.option_save_quetzal == true)                  {                      //success = Quetzal.save_quetzal(gfp' story_fp);                    }                  else                  {                      os_.fail("Need to implement old style save");                        //        /* Write game file */                        //        fputc ((int) hi (h_release)' gfp);                      //        fputc ((int) lo (h_release)' gfp);                      //        fputc ((int) hi (h_checksum)' gfp);                      //        fputc ((int) lo (h_checksum)' gfp);                        //        GET_PC (pc)                        //        fputc ((int) (pc >> 16) & 0xff' gfp);                      //        fputc ((int) (pc >> 8) & 0xff' gfp);                      //        fputc ((int) (pc) & 0xff' gfp);                        //        nsp = (int) (sp - stack);                      //        nfp = (int) (fp - stack);                        //        fputc ((int) hi (nsp)' gfp);                      //        fputc ((int) lo (nsp)' gfp);                      //        fputc ((int) hi (nfp)' gfp);                      //        fputc ((int) lo (nfp)' gfp);                        //        for (i = nsp; i < STACK_SIZE; i++) {                      //        fputc ((int) hi (stack[i])' gfp);                      //        fputc ((int) lo (stack[i])' gfp);                      //        }                        //        fseek (story_fp' init_fp_pos' SEEK_SET);                        //        for (addr = 0' skip = 0; addr < h_dynamic_size; addr++)                      //        if (zmp[addr] != fgetc (story_fp) || skip == 255 || addr + 1 == h_dynamic_size) {                      //            fputc (skip' gfp);                      //            fputc (zmp[addr]' gfp);                      //            skip = 0;                      //        } else skip++;                  }                    /* Close game file and check for errors */                    gfp.Close();                  // TODO Not sure what to do with these                  //    if (gfp.Close() ) { // || ferror(story_fp)) {                  //    Text.print_string("Error writing save file\n");                  //    goto finished;                  //}                    /* Success */                    success = 1;                }
Magic Number,Frotz.Generic,FastMem,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\fastmem.cs,z_save,The following statement contains a magic number: if (Process.zargc != 0)              {                    /* Get the file name */                    default_name = get_default_name((zword)((Process.zargc >= 3) ? Process.zargs[2] : 0));                    //    if ((zargc >= 4) ? zargs[3] : 1) {                    //        if (os_read_file_name (new_name' default_name' FILE_SAVE_AUX) == 0)                  //        goto finished;                    //        strcpy (auxilary_name' new_name);                    //    } else strcpy (new_name' default_name);                    //    /* Open auxilary file */                    //    if ((gfp = fopen (new_name' "wb")) == NULL)                  //        goto finished;                    //    /* Write auxilary file */                    //    success = fwrite (zmp + zargs[0]' zargs[1]' 1' gfp);                    //    /* Close auxilary file */                    //    fclose (gfp);                  os_.fail("need to implement option save arguments");              }              else              {                  if (!os_.read_file_name(out new_name' save_name' FileTypes.FILE_SAVE))                      goto finished;                    save_name = new_name;                    /* Open game file */                    if ((gfp = new System.IO.FileStream(new_name' System.IO.FileMode.OpenOrCreate)) == null)                      goto finished;                    if (main.option_save_quetzal == true)                  {                      //success = Quetzal.save_quetzal(gfp' story_fp);                    }                  else                  {                      os_.fail("Need to implement old style save");                        //        /* Write game file */                        //        fputc ((int) hi (h_release)' gfp);                      //        fputc ((int) lo (h_release)' gfp);                      //        fputc ((int) hi (h_checksum)' gfp);                      //        fputc ((int) lo (h_checksum)' gfp);                        //        GET_PC (pc)                        //        fputc ((int) (pc >> 16) & 0xff' gfp);                      //        fputc ((int) (pc >> 8) & 0xff' gfp);                      //        fputc ((int) (pc) & 0xff' gfp);                        //        nsp = (int) (sp - stack);                      //        nfp = (int) (fp - stack);                        //        fputc ((int) hi (nsp)' gfp);                      //        fputc ((int) lo (nsp)' gfp);                      //        fputc ((int) hi (nfp)' gfp);                      //        fputc ((int) lo (nfp)' gfp);                        //        for (i = nsp; i < STACK_SIZE; i++) {                      //        fputc ((int) hi (stack[i])' gfp);                      //        fputc ((int) lo (stack[i])' gfp);                      //        }                        //        fseek (story_fp' init_fp_pos' SEEK_SET);                        //        for (addr = 0' skip = 0; addr < h_dynamic_size; addr++)                      //        if (zmp[addr] != fgetc (story_fp) || skip == 255 || addr + 1 == h_dynamic_size) {                      //            fputc (skip' gfp);                      //            fputc (zmp[addr]' gfp);                      //            skip = 0;                      //        } else skip++;                  }                    /* Close game file and check for errors */                    gfp.Close();                  // TODO Not sure what to do with these                  //    if (gfp.Close() ) { // || ferror(story_fp)) {                  //    Text.print_string("Error writing save file\n");                  //    goto finished;                  //}                    /* Success */                    success = 1;                }
Magic Number,Frotz.Generic,Files,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\files.cs,script_word,The following statement contains a magic number: for (i = pos' width = 0; i < s.Length && s[i] != 0; i++)              {                  if (s[i] == CharCodes.ZC_NEW_STYLE || s[i] == CharCodes.ZC_NEW_FONT)                      i++;                  else if (s[i] == CharCodes.ZC_GAP)                      width += 3;                  else if (s[i] == CharCodes.ZC_INDENT)                      width += 2;                  else                      width += 1;              }
Magic Number,Frotz.Generic,Files,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\files.cs,script_word,The following statement contains a magic number: for (i = pos' width = 0; i < s.Length && s[i] != 0; i++)              {                  if (s[i] == CharCodes.ZC_NEW_STYLE || s[i] == CharCodes.ZC_NEW_FONT)                      i++;                  else if (s[i] == CharCodes.ZC_GAP)                      width += 3;                  else if (s[i] == CharCodes.ZC_INDENT)                      width += 2;                  else                      width += 1;              }
Magic Number,Frotz.Generic,Files,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\files.cs,record_code,The following statement contains a magic number: if (force_encoding || c == '[' || c < 0x20 || c > 0x7e)              {                  int i;                    rfp.Write('[');                    for (i = 10000; i != 0; i /= 10)                      if (c >= i || i == 1)                          rfp.Write((char)('0' + (c / i) % 10));                    rfp.Write(']');                }              else rfp.Write((char)c);
Magic Number,Frotz.Generic,Files,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\files.cs,record_code,The following statement contains a magic number: if (force_encoding || c == '[' || c < 0x20 || c > 0x7e)              {                  int i;                    rfp.Write('[');                    for (i = 10000; i != 0; i /= 10)                      if (c >= i || i == 1)                          rfp.Write((char)('0' + (c / i) % 10));                    rfp.Write(']');                }              else rfp.Write((char)c);
Magic Number,Frotz.Generic,Files,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\files.cs,record_code,The following statement contains a magic number: if (force_encoding || c == '[' || c < 0x20 || c > 0x7e)              {                  int i;                    rfp.Write('[');                    for (i = 10000; i != 0; i /= 10)                      if (c >= i || i == 1)                          rfp.Write((char)('0' + (c / i) % 10));                    rfp.Write(']');                }              else rfp.Write((char)c);
Magic Number,Frotz.Generic,Files,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\files.cs,record_char,The following statement contains a magic number: if (c != CharCodes.ZC_RETURN)              {                  if (c < CharCodes.ZC_HKEY_MIN || c > CharCodes.ZC_HKEY_MAX)                  {                      record_code(Text.translate_to_zscii(c)' false);                        if (c == CharCodes.ZC_SINGLE_CLICK || c == CharCodes.ZC_DOUBLE_CLICK)                      {                          record_code(main.mouse_x' true);                          record_code(main.mouse_y' true);                      }                  }                  else record_code(1000 + c - CharCodes.ZC_HKEY_MIN' true);              }
Magic Number,Frotz.Generic,Files,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\files.cs,replay_code,The following statement contains a magic number: if ( (c = pfp.ReadByte()) == '[') {                int c2;                c = 0;                while ((c2 = pfp.ReadByte()) != -1 && c2 >= '0' && c2 <= '9')                  c = 10 * c + c2 - '0';                return (c2 == ']') ? c : -1;                } else return c;
Magic Number,Frotz.Generic,Files,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\files.cs,replay_char,The following statement contains a magic number: if ((c = replay_code ()) != -1) {                if (c != '\n') {                    if (c < 1000)                  {                        c = Text.translate_from_zscii((byte)c);                        if (c == CharCodes.ZC_SINGLE_CLICK || c == CharCodes.ZC_DOUBLE_CLICK)                      {                          main.mouse_x = (zword)replay_code();                          main.mouse_y = (zword)replay_code();                      }                        return (zword)c;                    }                  else return (zword)(CharCodes.ZC_HKEY_MIN + c - 1000);              }                pfp.Position--;              pfp.WriteByte((byte)'\n');                return CharCodes.ZC_RETURN;                } else return CharCodes.ZC_BAD;
Magic Number,Frotz.Generic,Files,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\files.cs,replay_char,The following statement contains a magic number: if ((c = replay_code ()) != -1) {                if (c != '\n') {                    if (c < 1000)                  {                        c = Text.translate_from_zscii((byte)c);                        if (c == CharCodes.ZC_SINGLE_CLICK || c == CharCodes.ZC_DOUBLE_CLICK)                      {                          main.mouse_x = (zword)replay_code();                          main.mouse_y = (zword)replay_code();                      }                        return (zword)c;                    }                  else return (zword)(CharCodes.ZC_HKEY_MIN + c - 1000);              }                pfp.Position--;              pfp.WriteByte((byte)'\n');                return CharCodes.ZC_RETURN;                } else return CharCodes.ZC_BAD;
Magic Number,Frotz.Generic,Hotkey,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\hotkey.cs,hot_key_undo,The following statement contains a magic number: if (FastMem.restore_undo () > 0) {                if (main.h_version >= ZMachine.V5) {		/* for V5+ games we must */                  Process.store (2);			/* store 2 (for success) */                  return true;		/* and abort the input   */              }                if (main.h_version <= ZMachine.V3) {		/* for V3- games we must */                  Screen.z_show_status ();		/* draw the status line  */                  return false;		/* and continue input    */              }                } else Text.print_string ("No more undo information available.\n");
Magic Number,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,is_terminator,The following statement contains a magic number: if (main.h_terminating_keys != 0)                if (key >= CharCodes.ZC_ARROW_MIN && key <= CharCodes.ZC_MENU_CLICK) {                    zword addr = main.h_terminating_keys;                  zbyte c;                    do {                      FastMem.LOW_BYTE(addr' out c);                  if (c == 255 || key == Text.translate_from_zscii (c))                      return true;                  addr++;                  } while (c != 0);                }
Magic Number,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,z_make_menu,The following statement contains a magic number: if (Process.zargs[0] < 3) {              Process.branch (false);              return;              }
Magic Number,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,z_make_menu,The following statement contains a magic number: if (Process.zargs[1] != 0) {                zword items;              int i;                FastMem.LOW_WORD (Process.zargs[1]' out items);                for (i = 0; i < items; i++) {                    zword item;                  zbyte length;                  zbyte c;                  int j;                    FastMem.LOW_WORD (Process.zargs[1]+2+(2*i)' out item);                 FastMem. LOW_BYTE (item' out length);                    if (length > 31)                  length = 31;                  menu[length] = 0;                    for (j = 0; j < length; j++) {                        FastMem.LOW_BYTE(item + j + 1' out c);                  menu[j] = Text.translate_from_zscii (c);                  }                    if (i == 0)                  os_.menu(ZMachine.MENU_NEW' Process.zargs[0]' menu);                  else                      os_.menu(ZMachine.MENU_ADD' Process.zargs[0]' menu);              }              }              else os_.menu(ZMachine.MENU_REMOVE' Process.zargs[0]' new zword[0]);
Magic Number,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,z_make_menu,The following statement contains a magic number: if (Process.zargs[1] != 0) {                zword items;              int i;                FastMem.LOW_WORD (Process.zargs[1]' out items);                for (i = 0; i < items; i++) {                    zword item;                  zbyte length;                  zbyte c;                  int j;                    FastMem.LOW_WORD (Process.zargs[1]+2+(2*i)' out item);                 FastMem. LOW_BYTE (item' out length);                    if (length > 31)                  length = 31;                  menu[length] = 0;                    for (j = 0; j < length; j++) {                        FastMem.LOW_BYTE(item + j + 1' out c);                  menu[j] = Text.translate_from_zscii (c);                  }                    if (i == 0)                  os_.menu(ZMachine.MENU_NEW' Process.zargs[0]' menu);                  else                      os_.menu(ZMachine.MENU_ADD' Process.zargs[0]' menu);              }              }              else os_.menu(ZMachine.MENU_REMOVE' Process.zargs[0]' new zword[0]);
Magic Number,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,z_make_menu,The following statement contains a magic number: if (Process.zargs[1] != 0) {                zword items;              int i;                FastMem.LOW_WORD (Process.zargs[1]' out items);                for (i = 0; i < items; i++) {                    zword item;                  zbyte length;                  zbyte c;                  int j;                    FastMem.LOW_WORD (Process.zargs[1]+2+(2*i)' out item);                 FastMem. LOW_BYTE (item' out length);                    if (length > 31)                  length = 31;                  menu[length] = 0;                    for (j = 0; j < length; j++) {                        FastMem.LOW_BYTE(item + j + 1' out c);                  menu[j] = Text.translate_from_zscii (c);                  }                    if (i == 0)                  os_.menu(ZMachine.MENU_NEW' Process.zargs[0]' menu);                  else                      os_.menu(ZMachine.MENU_ADD' Process.zargs[0]' menu);              }              }              else os_.menu(ZMachine.MENU_REMOVE' Process.zargs[0]' new zword[0]);
Magic Number,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,z_make_menu,The following statement contains a magic number: if (Process.zargs[1] != 0) {                zword items;              int i;                FastMem.LOW_WORD (Process.zargs[1]' out items);                for (i = 0; i < items; i++) {                    zword item;                  zbyte length;                  zbyte c;                  int j;                    FastMem.LOW_WORD (Process.zargs[1]+2+(2*i)' out item);                 FastMem. LOW_BYTE (item' out length);                    if (length > 31)                  length = 31;                  menu[length] = 0;                    for (j = 0; j < length; j++) {                        FastMem.LOW_BYTE(item + j + 1' out c);                  menu[j] = Text.translate_from_zscii (c);                  }                    if (i == 0)                  os_.menu(ZMachine.MENU_NEW' Process.zargs[0]' menu);                  else                      os_.menu(ZMachine.MENU_ADD' Process.zargs[0]' menu);              }              }              else os_.menu(ZMachine.MENU_REMOVE' Process.zargs[0]' new zword[0]);
Magic Number,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,read_number,The following statement contains a magic number: zword[] buffer = new zword[6];
Magic Number,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,read_number,The following statement contains a magic number: Input.read_string (5' buffer);
Magic Number,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,read_number,The following statement contains a magic number: for (i = 0; buffer[i] != 0; i++)              if (buffer[i] >= '0' && buffer[i] <= '9')                  value = 10 * value + buffer[i] - '0';
Magic Number,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,z_read,The following statement contains a magic number: if (Process.zargc < 3)                  Process.zargs[2] = 0;
Magic Number,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,z_read,The following statement contains a magic number: if (Process.zargc < 3)                  Process.zargs[2] = 0;
Magic Number,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,z_read,The following statement contains a magic number: key = Stream.stream_read_input(              max' buffer'		/* buffer and size */              Process.zargs[2]'		/* timeout value   */              Process.zargs[3]'		/* timeout routine */              true'	     	   	/* enable hot keys */              main.h_version == ZMachine.V6);
Magic Number,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,z_read,The following statement contains a magic number: key = Stream.stream_read_input(              max' buffer'		/* buffer and size */              Process.zargs[2]'		/* timeout value   */              Process.zargs[3]'		/* timeout routine */              true'	     	   	/* enable hot keys */              main.h_version == ZMachine.V6);
Magic Number,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,z_read,The following statement contains a magic number: for (i = 0; buffer[i] != 0; i++) {                    if (key == CharCodes.ZC_RETURN) {                        buffer[i] = Text.unicode_tolower(buffer[i]);                    }                    FastMem.storeb((zword)(Process.zargs[0] + ((main.h_version <= ZMachine.V4) ? 1 : 2) + i)' Text.translate_to_zscii(buffer[i]));                }
Magic Number,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,z_read_char,The following statement contains a magic number: if (Process.zargc < 2)              Process.zargs[1] = 0;
Magic Number,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,z_read_char,The following statement contains a magic number: key = Stream.stream_read_key (              Process.zargs[1]'	/* timeout value   */              Process.zargs[2]'	/* timeout routine */              true);
Magic Number,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,z_read_mouse,The following statement contains a magic number: FastMem.storew((zword)(Process.zargs[0] + 2)' main.hx_mouse_x);
Magic Number,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,z_read_mouse,The following statement contains a magic number: FastMem.storew((zword)(Process.zargs[0] + 4)' btn);
Magic Number,Frotz.Generic,Input,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\input.cs,z_read_mouse,The following statement contains a magic number: FastMem.storew((zword)(Process.zargs[0] + 6)' main.menu_selected);
Magic Number,Frotz.Generic,Math,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\math.cs,z_je,The following statement contains a magic number: Process.branch(              Process.zargc > 1 && (Process.zargs[0] == Process.zargs[1] || (              Process.zargc > 2 && (Process.zargs[0] == Process.zargs[2] || (              Process.zargc > 3 && (Process.zargs[0] == Process.zargs[3]))))));
Magic Number,Frotz.Generic,Math,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\math.cs,z_je,The following statement contains a magic number: Process.branch(              Process.zargc > 1 && (Process.zargs[0] == Process.zargs[1] || (              Process.zargc > 2 && (Process.zargs[0] == Process.zargs[2] || (              Process.zargc > 3 && (Process.zargs[0] == Process.zargs[3]))))));
Magic Number,Frotz.Generic,Math,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\math.cs,z_je,The following statement contains a magic number: Process.branch(              Process.zargc > 1 && (Process.zargs[0] == Process.zargs[1] || (              Process.zargc > 2 && (Process.zargs[0] == Process.zargs[2] || (              Process.zargc > 3 && (Process.zargs[0] == Process.zargs[3]))))));
Magic Number,Frotz.Generic,Math,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\math.cs,z_je,The following statement contains a magic number: Process.branch(              Process.zargc > 1 && (Process.zargs[0] == Process.zargs[1] || (              Process.zargc > 2 && (Process.zargs[0] == Process.zargs[2] || (              Process.zargc > 3 && (Process.zargs[0] == Process.zargs[3]))))));
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,object_address,The following statement contains a magic number: if (obj > ((main.h_version <= ZMachine.V3) ? 255 : MAX_OBJECT)) {                  Text.print_string("@Attempt to address illegal object ");                  Text.print_num(obj);                  Text.print_string(".  This is normally fatal.");                  Buffer.new_line();                  Err.runtime_error(ErrorCodes.ERR_ILL_OBJ);              }
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,object_address,The following statement contains a magic number: if (main.h_version <= ZMachine.V3)                  return (zword)(main.h_objects + ((obj - 1) * O1_SIZE + 62));              else                  return (zword)(main.h_objects + ((obj - 1) * O4_SIZE + 126));
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,object_address,The following statement contains a magic number: if (main.h_version <= ZMachine.V3)                  return (zword)(main.h_objects + ((obj - 1) * O1_SIZE + 62));              else                  return (zword)(main.h_objects + ((obj - 1) * O4_SIZE + 126));
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,first_property,The following statement contains a magic number: return (zword)(prop_addr + 1 + 2 * size);
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,next_property,The following statement contains a magic number: if (main.h_version <= ZMachine.V3)                  value >>= 5;              else if (!((value & 0x80) > 0))                  value >>= 6;              else {                    FastMem.LOW_BYTE(prop_addr' out value);                  value &= 0x3f;                    if (value == 0) value = 64;	/* demanded by Spec 1.0 */                }
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,next_property,The following statement contains a magic number: if (main.h_version <= ZMachine.V3)                  value >>= 5;              else if (!((value & 0x80) > 0))                  value >>= 6;              else {                    FastMem.LOW_BYTE(prop_addr' out value);                  value &= 0x3f;                    if (value == 0) value = 64;	/* demanded by Spec 1.0 */                }
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,next_property,The following statement contains a magic number: if (main.h_version <= ZMachine.V3)                  value >>= 5;              else if (!((value & 0x80) > 0))                  value >>= 6;              else {                    FastMem.LOW_BYTE(prop_addr' out value);                  value &= 0x3f;                    if (value == 0) value = 64;	/* demanded by Spec 1.0 */                }
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_clear_attr,The following statement contains a magic number: if (main.story_id == Story.SHERLOCK)                  if (Process.zargs[1] == 48)                      return;
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_clear_attr,The following statement contains a magic number: if (Process.zargs[1] > ((main.h_version <= ZMachine.V3) ? 31 : 47))                  Err.runtime_error(ErrorCodes.ERR_ILL_ATTR);
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_clear_attr,The following statement contains a magic number: if (Process.zargs[1] > ((main.h_version <= ZMachine.V3) ? 31 : 47))                  Err.runtime_error(ErrorCodes.ERR_ILL_ATTR);
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_clear_attr,The following statement contains a magic number: obj_addr = (zword)(object_address(Process.zargs[0]) + Process.zargs[1] / 8);
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_clear_attr,The following statement contains a magic number: value &= (zbyte)(~(0x80 >> (Process.zargs[1] & 7)));
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_get_prop,The following statement contains a magic number: if ((value & mask) == Process.zargs[1]) {	/* property found */                    /* Load property (byte or word sized) */                    prop_addr++;                    if ((main.h_version <= ZMachine.V3 && !((value & 0xe0) > 0)) || (main.h_version >= ZMachine.V4 && !((value & 0xc0) > 0))) {                        FastMem.LOW_BYTE(prop_addr' out bprop_val);                      wprop_val = bprop_val;                    } else FastMem.LOW_WORD(prop_addr' out wprop_val);                } else {	/* property not found */                    /* Load default value */                    prop_addr = (zword)(main.h_objects + 2 * (Process.zargs[1] - 1));                  FastMem.LOW_WORD(prop_addr' out wprop_val);                }
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_get_prop_len,The following statement contains a magic number: if (main.h_version <= ZMachine.V3)                  value = (zbyte)((value >> 5) + 1);              else if (!((value & 0x80) > 0))                  value = (zbyte)((value >> 6) + 1);              else {                    value &= 0x3f;                    if (value == 0) value = 64;	/* demanded by Spec 1.0 */                }
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_get_prop_len,The following statement contains a magic number: if (main.h_version <= ZMachine.V3)                  value = (zbyte)((value >> 5) + 1);              else if (!((value & 0x80) > 0))                  value = (zbyte)((value >> 6) + 1);              else {                    value &= 0x3f;                    if (value == 0) value = 64;	/* demanded by Spec 1.0 */                }
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_get_prop_len,The following statement contains a magic number: if (main.h_version <= ZMachine.V3)                  value = (zbyte)((value >> 5) + 1);              else if (!((value & 0x80) > 0))                  value = (zbyte)((value >> 6) + 1);              else {                    value &= 0x3f;                    if (value == 0) value = 64;	/* demanded by Spec 1.0 */                }
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_put_prop,The following statement contains a magic number: if ((main.h_version <= ZMachine.V3 && !((value & 0xe0) > 0)) || (main.h_version >= ZMachine.V4 && !((value & 0xc0) > 0))) {                  zbyte v = (zbyte)Process.zargs[2];                  FastMem.SET_BYTE(prop_addr' v);              } else {                  zword v = Process.zargs[2];                  FastMem.SET_WORD(prop_addr' v);              }
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_put_prop,The following statement contains a magic number: if ((main.h_version <= ZMachine.V3 && !((value & 0xe0) > 0)) || (main.h_version >= ZMachine.V4 && !((value & 0xc0) > 0))) {                  zbyte v = (zbyte)Process.zargs[2];                  FastMem.SET_BYTE(prop_addr' v);              } else {                  zword v = Process.zargs[2];                  FastMem.SET_WORD(prop_addr' v);              }
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_set_attr,The following statement contains a magic number: if (main.story_id == Story.SHERLOCK)                  if (Process.zargs[1] == 48)                      return;
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_set_attr,The following statement contains a magic number: if (Process.zargs[1] > ((main.h_version <= ZMachine.V3) ? 31 : 47))                  Err.runtime_error(ErrorCodes.ERR_ILL_ATTR);
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_set_attr,The following statement contains a magic number: if (Process.zargs[1] > ((main.h_version <= ZMachine.V3) ? 31 : 47))                  Err.runtime_error(ErrorCodes.ERR_ILL_ATTR);
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_set_attr,The following statement contains a magic number: obj_addr = (zword)(object_address(Process.zargs[0]) + Process.zargs[1] / 8);
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_set_attr,The following statement contains a magic number: value |= (zbyte)(0x80 >> (Process.zargs[1] & 7));
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_test_attr,The following statement contains a magic number: if (Process.zargs[1] > ((main.h_version <= ZMachine.V3) ? 31 : 47))                  Err.runtime_error(ErrorCodes.ERR_ILL_ATTR);
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_test_attr,The following statement contains a magic number: if (Process.zargs[1] > ((main.h_version <= ZMachine.V3) ? 31 : 47))                  Err.runtime_error(ErrorCodes.ERR_ILL_ATTR);
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_test_attr,The following statement contains a magic number: obj_addr = (zword)(object_address(Process.zargs[0]) + Process.zargs[1] / 8);
Magic Number,Frotz.Generic,CObject,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\object.cs,z_test_attr,The following statement contains a magic number: Process.branch((value & (0x80 >> (Process.zargs[1] & 7))) > 0);
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,load_operand,The following statement contains a magic number: if ((type & 2) > 0)              { 			/* variable */                    zbyte variable;                    FastMem.CODE_BYTE(out variable);                    if (variable == 0)                      value = main.stack[main.sp++];                  else if (variable < 16)                      value = main.stack[main.fp - variable];                  else                  {                      zword addr = (zword)(main.h_globals + 2 * (variable - 16)); // TODO Make sure this logic                      FastMem.LOW_WORD(addr' out value);                  }                }              else if ((type & 1) > 0)              { 		/* small constant */                    zbyte bvalue;                    FastMem.CODE_BYTE(out bvalue);                  value = bvalue;                }              else FastMem.CODE_WORD(out value);
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,load_operand,The following statement contains a magic number: if ((type & 2) > 0)              { 			/* variable */                    zbyte variable;                    FastMem.CODE_BYTE(out variable);                    if (variable == 0)                      value = main.stack[main.sp++];                  else if (variable < 16)                      value = main.stack[main.fp - variable];                  else                  {                      zword addr = (zword)(main.h_globals + 2 * (variable - 16)); // TODO Make sure this logic                      FastMem.LOW_WORD(addr' out value);                  }                }              else if ((type & 1) > 0)              { 		/* small constant */                    zbyte bvalue;                    FastMem.CODE_BYTE(out bvalue);                  value = bvalue;                }              else FastMem.CODE_WORD(out value);
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,load_operand,The following statement contains a magic number: if ((type & 2) > 0)              { 			/* variable */                    zbyte variable;                    FastMem.CODE_BYTE(out variable);                    if (variable == 0)                      value = main.stack[main.sp++];                  else if (variable < 16)                      value = main.stack[main.fp - variable];                  else                  {                      zword addr = (zword)(main.h_globals + 2 * (variable - 16)); // TODO Make sure this logic                      FastMem.LOW_WORD(addr' out value);                  }                }              else if ((type & 1) > 0)              { 		/* small constant */                    zbyte bvalue;                    FastMem.CODE_BYTE(out bvalue);                  value = bvalue;                }              else FastMem.CODE_WORD(out value);
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,load_operand,The following statement contains a magic number: if ((type & 2) > 0)              { 			/* variable */                    zbyte variable;                    FastMem.CODE_BYTE(out variable);                    if (variable == 0)                      value = main.stack[main.sp++];                  else if (variable < 16)                      value = main.stack[main.fp - variable];                  else                  {                      zword addr = (zword)(main.h_globals + 2 * (variable - 16)); // TODO Make sure this logic                      FastMem.LOW_WORD(addr' out value);                  }                }              else if ((type & 1) > 0)              { 		/* small constant */                    zbyte bvalue;                    FastMem.CODE_BYTE(out bvalue);                  value = bvalue;                }              else FastMem.CODE_WORD(out value);
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,load_all_operands,The following statement contains a magic number: for (i = 6; i >= 0; i -= 2)              {                    zbyte type = (zbyte)((specifier >> i) & 0x03); // TODO Check this conversion                    if (type == 3)                      break;                    load_operand(type);                }
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,load_all_operands,The following statement contains a magic number: for (i = 6; i >= 0; i -= 2)              {                    zbyte type = (zbyte)((specifier >> i) & 0x03); // TODO Check this conversion                    if (type == 3)                      break;                    load_operand(type);                }
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,load_all_operands,The following statement contains a magic number: for (i = 6; i >= 0; i -= 2)              {                    zbyte type = (zbyte)((specifier >> i) & 0x03); // TODO Check this conversion                    if (type == 3)                      break;                    load_operand(type);                }
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,interpret,The following statement contains a magic number: do              {                  zbyte opcode;                    FastMem.CODE_BYTE(out opcode);                    DebugState.Output("CODE: {0} -> {1:X}"' FastMem.pcp - 1' opcode);                    if (main.abort_game_loop == true)                  {                      main.abort_game_loop = false;                      return;                  }                    zargc = 0;                  if (opcode < 0x80)                  {			/* 2OP opcodes */                        load_operand((zbyte)((opcode & 0x40) > 0 ? 2 : 1));                      load_operand((zbyte)((opcode & 0x20) > 0 ? 2 : 1));                        private_invoke(var_opcodes[opcode & 0x1f]' "2OP"' (opcode & 0x1f)' opcode);                  }                  else if (opcode < 0xb0)                  {		/* 1OP opcodes */                        load_operand((zbyte)(opcode >> 4));                        private_invoke(op1_opcodes[opcode & 0x0f]' "1OP"' (opcode & 0x0f)' opcode);                  }                  else if (opcode < 0xc0)                  {		/* 0OP opcodes */                      private_invoke(op0_opcodes[opcode - 0xb0]' "0OP"' (opcode - 0xb0)' opcode);                  }                  else                  {				/* VAR opcodes */                        zbyte specifier1;                      zbyte specifier2;                        if (opcode == 0xec || opcode == 0xfa)                      {	/* opcodes 0xec */                          FastMem.CODE_BYTE(out specifier1);                  /* and 0xfa are */                          FastMem.CODE_BYTE(out specifier2);                  /* call opcodes */                          load_all_operands(specifier1);		/* with up to 8 */                          load_all_operands(specifier2);         /* arguments    */                      }                      else                      {                          FastMem.CODE_BYTE(out specifier1);                          load_all_operands(specifier1);                      }                        private_invoke(var_opcodes[opcode - 0xc0]' "VAR"' (opcode - 0xc0)' opcode);                  }                    os_.tick();              } while (finished == 0);
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,interpret,The following statement contains a magic number: do              {                  zbyte opcode;                    FastMem.CODE_BYTE(out opcode);                    DebugState.Output("CODE: {0} -> {1:X}"' FastMem.pcp - 1' opcode);                    if (main.abort_game_loop == true)                  {                      main.abort_game_loop = false;                      return;                  }                    zargc = 0;                  if (opcode < 0x80)                  {			/* 2OP opcodes */                        load_operand((zbyte)((opcode & 0x40) > 0 ? 2 : 1));                      load_operand((zbyte)((opcode & 0x20) > 0 ? 2 : 1));                        private_invoke(var_opcodes[opcode & 0x1f]' "2OP"' (opcode & 0x1f)' opcode);                  }                  else if (opcode < 0xb0)                  {		/* 1OP opcodes */                        load_operand((zbyte)(opcode >> 4));                        private_invoke(op1_opcodes[opcode & 0x0f]' "1OP"' (opcode & 0x0f)' opcode);                  }                  else if (opcode < 0xc0)                  {		/* 0OP opcodes */                      private_invoke(op0_opcodes[opcode - 0xb0]' "0OP"' (opcode - 0xb0)' opcode);                  }                  else                  {				/* VAR opcodes */                        zbyte specifier1;                      zbyte specifier2;                        if (opcode == 0xec || opcode == 0xfa)                      {	/* opcodes 0xec */                          FastMem.CODE_BYTE(out specifier1);                  /* and 0xfa are */                          FastMem.CODE_BYTE(out specifier2);                  /* call opcodes */                          load_all_operands(specifier1);		/* with up to 8 */                          load_all_operands(specifier2);         /* arguments    */                      }                      else                      {                          FastMem.CODE_BYTE(out specifier1);                          load_all_operands(specifier1);                      }                        private_invoke(var_opcodes[opcode - 0xc0]' "VAR"' (opcode - 0xc0)' opcode);                  }                    os_.tick();              } while (finished == 0);
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,interpret,The following statement contains a magic number: do              {                  zbyte opcode;                    FastMem.CODE_BYTE(out opcode);                    DebugState.Output("CODE: {0} -> {1:X}"' FastMem.pcp - 1' opcode);                    if (main.abort_game_loop == true)                  {                      main.abort_game_loop = false;                      return;                  }                    zargc = 0;                  if (opcode < 0x80)                  {			/* 2OP opcodes */                        load_operand((zbyte)((opcode & 0x40) > 0 ? 2 : 1));                      load_operand((zbyte)((opcode & 0x20) > 0 ? 2 : 1));                        private_invoke(var_opcodes[opcode & 0x1f]' "2OP"' (opcode & 0x1f)' opcode);                  }                  else if (opcode < 0xb0)                  {		/* 1OP opcodes */                        load_operand((zbyte)(opcode >> 4));                        private_invoke(op1_opcodes[opcode & 0x0f]' "1OP"' (opcode & 0x0f)' opcode);                  }                  else if (opcode < 0xc0)                  {		/* 0OP opcodes */                      private_invoke(op0_opcodes[opcode - 0xb0]' "0OP"' (opcode - 0xb0)' opcode);                  }                  else                  {				/* VAR opcodes */                        zbyte specifier1;                      zbyte specifier2;                        if (opcode == 0xec || opcode == 0xfa)                      {	/* opcodes 0xec */                          FastMem.CODE_BYTE(out specifier1);                  /* and 0xfa are */                          FastMem.CODE_BYTE(out specifier2);                  /* call opcodes */                          load_all_operands(specifier1);		/* with up to 8 */                          load_all_operands(specifier2);         /* arguments    */                      }                      else                      {                          FastMem.CODE_BYTE(out specifier1);                          load_all_operands(specifier1);                      }                        private_invoke(var_opcodes[opcode - 0xc0]' "VAR"' (opcode - 0xc0)' opcode);                  }                    os_.tick();              } while (finished == 0);
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,call,The following statement contains a magic number: if (main.sp < 4)//if (sp - stack < 4)                  Err.runtime_error(ErrorCodes.ERR_STK_OVF);
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,call,The following statement contains a magic number: main.stack[--main.sp] = (zword)(pc >> 9);
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,call,The following statement contains a magic number: main.stack[--main.sp] = (zword)(argc | (ct << (main.option_save_quetzal == true ? 12 : 8)));
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,call,The following statement contains a magic number: main.stack[--main.sp] = (zword)(argc | (ct << (main.option_save_quetzal == true ? 12 : 8)));
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,call,The following statement contains a magic number: DebugState.Output("Added Frame: {0} -> {1}:{2}:{3}:{4}"'                  main.frame_count'                  main.stack[main.sp + 0]'                  main.stack[main.sp + 1]'                  main.stack[main.sp + 2]'                  main.stack[main.sp + 3]);
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,call,The following statement contains a magic number: DebugState.Output("Added Frame: {0} -> {1}:{2}:{3}:{4}"'                  main.frame_count'                  main.stack[main.sp + 0]'                  main.stack[main.sp + 1]'                  main.stack[main.sp + 2]'                  main.stack[main.sp + 3]);
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,call,The following statement contains a magic number: if (main.h_version <= ZMachine.V3)                  pc = (long)routine << 1;              else if (main.h_version <= ZMachine.V5)                  pc = (long)routine << 2;              else if (main.h_version <= ZMachine.V7)                  pc = ((long)routine << 2) + ((long)main.h_functions_offset << 3);              else /* (h_version <= V8) */                  pc = (long)routine << 3;
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,call,The following statement contains a magic number: if (main.h_version <= ZMachine.V3)                  pc = (long)routine << 1;              else if (main.h_version <= ZMachine.V5)                  pc = (long)routine << 2;              else if (main.h_version <= ZMachine.V7)                  pc = ((long)routine << 2) + ((long)main.h_functions_offset << 3);              else /* (h_version <= V8) */                  pc = (long)routine << 3;
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,call,The following statement contains a magic number: if (main.h_version <= ZMachine.V3)                  pc = (long)routine << 1;              else if (main.h_version <= ZMachine.V5)                  pc = (long)routine << 2;              else if (main.h_version <= ZMachine.V7)                  pc = ((long)routine << 2) + ((long)main.h_functions_offset << 3);              else /* (h_version <= V8) */                  pc = (long)routine << 3;
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,call,The following statement contains a magic number: if (main.h_version <= ZMachine.V3)                  pc = (long)routine << 1;              else if (main.h_version <= ZMachine.V5)                  pc = (long)routine << 2;              else if (main.h_version <= ZMachine.V7)                  pc = ((long)routine << 2) + ((long)main.h_functions_offset << 3);              else /* (h_version <= V8) */                  pc = (long)routine << 3;
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,call,The following statement contains a magic number: if (count > 15)                  Err.runtime_error(ErrorCodes.ERR_CALL_NON_RTN);
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,call,The following statement contains a magic number: if (main.option_save_quetzal == true)                  main.stack[main.fp] |= (zword)(count << 8);
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,call,The following statement contains a magic number: if (ct == 2)                  interpret();
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,ret,The following statement contains a magic number: ct = main.stack[main.sp++] >> (main.option_save_quetzal == true ? 12 : 8);
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,ret,The following statement contains a magic number: ct = main.stack[main.sp++] >> (main.option_save_quetzal == true ? 12 : 8);
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,ret,The following statement contains a magic number: pc = (main.stack[main.sp++] << 9) | (int)pc;
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,ret,The following statement contains a magic number: if (ct == 2)                  main.stack[--main.sp] = value;
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,ret,The following statement contains a magic number: if (ct == 2)                  finished++;
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,branch,The following statement contains a magic number: if ((specifier & 0x40) == 0)              { // if (!(specifier & 0x40)) {		/* it's a long branch */                    if ((off1 & 0x20) > 0)		/* propagate sign bit */                      off1 |= 0xc0;                    FastMem.CODE_BYTE(out off2);                    offset = (zword)((off1 << 8) | off2);                }              else offset = off1;
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,branch,The following statement contains a magic number: if ((specifier & 0x80) > 0)              {                    if (offset > 1)                  {		/* normal branch */                        FastMem.GET_PC(out pc);                      pc += (short)offset - 2;                      FastMem.SET_PC(pc);                    }                  else ret(offset);		/* special case' return 0 or 1 */              }
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,store,The following statement contains a magic number: if (variable == 0)              {                  main.stack[--main.sp] = value; // *--sp = value;                  DebugState.Output("  Storing {0} on stack at {1}"' value' main.sp);              }              else if (variable < 16)              {                  main.stack[main.fp - variable] = value;  // *(fp - variable) = value;                  DebugState.Output("  Storing {0} on stack as Variable {1} at {2}"' value' variable' main.sp);              }              else              {                  zword addr = (zword)(main.h_globals + 2 * (variable - 16));                  FastMem.SET_WORD(addr' value);                  DebugState.Output("  Storing {0} at {1}"' value' addr);              }
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,store,The following statement contains a magic number: if (variable == 0)              {                  main.stack[--main.sp] = value; // *--sp = value;                  DebugState.Output("  Storing {0} on stack at {1}"' value' main.sp);              }              else if (variable < 16)              {                  main.stack[main.fp - variable] = value;  // *(fp - variable) = value;                  DebugState.Output("  Storing {0} on stack as Variable {1} at {2}"' value' variable' main.sp);              }              else              {                  zword addr = (zword)(main.h_globals + 2 * (variable - 16));                  FastMem.SET_WORD(addr' value);                  DebugState.Output("  Storing {0} at {1}"' value' addr);              }
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,store,The following statement contains a magic number: if (variable == 0)              {                  main.stack[--main.sp] = value; // *--sp = value;                  DebugState.Output("  Storing {0} on stack at {1}"' value' main.sp);              }              else if (variable < 16)              {                  main.stack[main.fp - variable] = value;  // *(fp - variable) = value;                  DebugState.Output("  Storing {0} on stack as Variable {1} at {2}"' value' variable' main.sp);              }              else              {                  zword addr = (zword)(main.h_globals + 2 * (variable - 16));                  FastMem.SET_WORD(addr' value);                  DebugState.Output("  Storing {0} at {1}"' value' addr);              }
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,direct_call,The following statement contains a magic number: zword[] saved_zargs = new zword[8];
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,direct_call,The following statement contains a magic number: for (i = 0; i < 8; i++)                  saved_zargs[i] = zargs[i];
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,direct_call,The following statement contains a magic number: call(addr' 0' 0' 2);
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,direct_call,The following statement contains a magic number: for (i = 0; i < 8; i++)                  zargs[i] = saved_zargs[i];
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,z_jump,The following statement contains a magic number: pc += (short)zargs[0] - 2;
Magic Number,Frotz.Generic,Process,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\process.cs,z_quit,The following statement contains a magic number: finished = 9999;
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,makeid,The following statement contains a magic number: return ((zlong)(((a) << 24) | ((b) << 16) | ((c) << 8) | (d)));
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,makeid,The following statement contains a magic number: return ((zlong)(((a) << 24) | ((b) << 16) | ((c) << 8) | (d)));
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,makeid,The following statement contains a magic number: return ((zlong)(((a) << 24) | ((b) << 16) | ((c) << 8) | (d)));
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,write_word,The following statement contains a magic number: write_bytx(fp' (w) >> 8);
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,write_long,The following statement contains a magic number: write_bytx(fp' (l) >> 24);
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,write_long,The following statement contains a magic number: write_bytx(fp' (l) >> 16);
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,write_long,The following statement contains a magic number: write_bytx(fp' (l) >> 8);
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,read_word,The following statement contains a magic number: result = (zword)(((zword)a << 8) | (zword)b);
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,read_long,The following statement contains a magic number: byte[] buffer = new byte[4];
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,read_long,The following statement contains a magic number: result = ((zlong)a << 24) | ((zlong)b << 16) |                    ((zlong)c << 8) | (zlong)d;
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,read_long,The following statement contains a magic number: result = ((zlong)a << 24) | ((zlong)b << 16) |                    ((zlong)c << 8) | (zlong)d;
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,read_long,The following statement contains a magic number: result = ((zlong)a << 24) | ((zlong)b << 16) |                    ((zlong)c << 8) | (zlong)d;
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: if (((ifzslen & 1) > 0) || ifzslen < 4) /* Sanity checks. */	return 0;
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: ifzslen -= 4;
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: while (ifzslen > 0) {                  /* Read chunk header. */                  if (ifzslen < 8) /* Couldn't contain a chunk. */	return 0;                  if (!read_long(svf' out tmpl)                      || !read_long(svf' out currlen)) return 0;                  ifzslen -= 8;	/* Reduce remaining by size of header. */                    /* Handle chunk body. */                  if (ifzslen < currlen) /* Chunk goes past EOF?! */	return 0;                  skip = (byte)(currlen & 1);                  ifzslen -= currlen + (zlong)skip;                    switch (tmpl) {                      /* `IFhd' header chunk; must be first in file. */                      case 1229351012: // IFhd                          if ((progress & GOT_HEADER) > 0) {                              Text.print_string("Save file has two IFZS chunks!\n");                              return fatal;                          }                          progress |= GOT_HEADER;                          if (currlen < 13                              || !read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_release)                              progress = GOT_ERROR;                            for (i = ZMachine.H_SERIAL; i < ZMachine.H_SERIAL + 6; ++i) {                              if ((x = svf.ReadByte()) == -1) return fatal;                              if (x != FastMem.ZMData[FastMem.zmp + i])                                  progress = GOT_ERROR;                          }                            if (!read_word(svf' out tmpw)) return fatal;                          if (tmpw != main.h_checksum)                              progress = GOT_ERROR;                            if ((progress & GOT_ERROR) > 0) {                              Text.print_string("File was not saved from this story!\n");                              return fatal;                          }                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc = (zlong)x << 16;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x << 8;                          if ((x = svf.ReadByte()) == -1) return fatal;                          pc |= (zlong)x;                          fatal = zword.MaxValue;	/* Setting PC means errors must be fatal. */ // TODO make sure this works                          FastMem.SET_PC(pc);                            for (i = 13; i < currlen; ++i)                              svf.ReadByte();	/* Skip rest of chunk. */                          break;                      /* `Stks' stacks chunk; restoring this is quite complex. ;) */                      case 1400138611: // ID_Stks:                          if ((progress & GOT_STACK) > 0) {                              Text.print_string("File contains two stack chunks!\n");                              break;                          }                          progress |= GOT_STACK;                            fatal = zword.MaxValue; ;	/* Setting SP means errors must be fatal. */                          // sp = stack + General.STACK_SIZE;                          main.sp = main.stack.Length;                            /*                           * All versions other than V6 may use evaluation stack outside                           * any function context. As a result a faked function context                           * will be present in the file here. We skip this context' but                           * load the associated stack onto the stack proper...                           */                          if (main.h_version != ZMachine.V6) {                              if (currlen < 8) return fatal;                              for (i = 0; i < 6; ++i)                                  if (svf.ReadByte() != 0) return fatal;                              if (!read_word(svf' out tmpw)) return fatal;                              if (tmpw > General.STACK_SIZE) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              currlen -= 8;                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  // if (!read_word(svf' --sp)) return fatal;                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                            /* We now proceed to load the main block of stack frames. */                          for (main.fp = main.stack.Length' main.frame_count = 0;                               currlen > 0;                               currlen -= 8' ++main.frame_count) {                              if (currlen < 8) return fatal;                              if (main.sp < 4)	/* No space for frame. */ {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                                /* Read PC' procedure flag and formal param count. */                              if (!read_long(svf' out tmpl)) return fatal;                              y = (int)(tmpl & 0x0F);	/* Number of formals. */                              tmpw = (zword)(y << 8);                                /* Read result variable. */                              if ((x = svf.ReadByte()) == -1) return fatal;                                /* Check the procedure flag... */                              if ((tmpl & 0x10) > 0) {                                  tmpw |= 0x1000;	/* It's a procedure. */                                  tmpl >>= 8;	/* Shift to get PC value. */                              } else {                                  /* Functions have type 0' so no need to or anything. */                                  tmpl >>= 8;	/* Shift to get PC value. */                                  --tmpl;		/* Point at result byte. */                                  /* Sanity check on result variable... */                                  if (FastMem.ZMData[FastMem.zmp + tmpl] != (zbyte)x) {                                      Text.print_string("Save-file has wrong variable number on stack (possibly wrong game version?)\n");                                      return fatal;                                  }                              }                                main.stack[--main.sp] = (zword)(tmpl >> 9);	/* High part of PC */                              main.stack[--main.sp] = (zword)(tmpl & 0x1FF);	/* Low part of PC */                              main.stack[--main.sp] = (zword)(main.fp - 1);	/* FP */                                /* Read and process argument mask. */                              if ((x = svf.ReadByte()) == -1) return fatal;                              ++x;	/* Should now be a power of 2 */                              for (i = 0; i < 8; ++i)                                  if ((x & (1 << i)) > 0)                                      break;                              if ((x ^ (1 << i)) > 0)	/* Not a power of 2 */ {                                  Text.print_string("Save-file uses incomplete argument lists (which I can't handle)\n");                                  return fatal;                              }                              // *--sp = tmpw | i;                              main.stack[--main.sp] = (zword)(tmpw | i);                              main.fp = main.sp;	/* FP for next frame. */                                /* Read amount of eval stack used. */                              if (!read_word(svf' out tmpw)) return fatal;                                tmpw += (zword)y;	/* Amount of stack + number of locals. */                              // if (sp - stack <= tmpw) {                              if (main.sp <= tmpw) {                                  Text.print_string("Save-file has too much stack (and I can't cope).\n");                                  return fatal;                              }                              if (currlen < tmpw * 2) return fatal;                              for (i = 0; i < tmpw; ++i)                                  if (!read_word(svf' out main.stack[--main.sp])) return fatal;                              currlen -= (zword)(tmpw * 2);                          }                          /* End of `Stks' processing... */                          break;                      /* Any more special chunk types must go in HERE or ABOVE. */                      /* `CMem' compressed memory chunk; uncompress it. */                      case 1129145709: // CMem                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              stf.Position = 0; // (void) fseek (stf' 0' SEEK_SET);                              i = 0;	/* Bytes written to data area. */                              for (; currlen > 0; --currlen) {                                  if ((x = svf.ReadByte()) == -1) return fatal;                                  if (x == 0)	/* Start run. */ {                                      /* Check for bogus run. */                                      if (currlen < 2) {                                          Text.print_string("File contains bogus `CMem' chunk.\n");                                          for (; currlen > 0; --currlen)                                              svf.ReadByte();	/* Skip rest. */                                          currlen = 1;                                          i = 0xFFFF;                                          break; /* Keep going; may be a `UMem' too. */                                      }                                      /* Copy story file to memory during the run. */                                      --currlen;                                      if ((x = svf.ReadByte()) == -1) return fatal;                                      for (; x >= 0 && i < main.h_dynamic_size; --x' ++i)                                          if ((y = stf.ReadByte()) == -1) return fatal;                                          else                                              FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                                  } else	/* Not a run. */ {                                      if ((y = stf.ReadByte()) == -1) return fatal;                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)(x ^ y);                                      ++i;                                  }                                  /* Make sure we don't load too much. */                                  if (i > main.h_dynamic_size) {                                      Text.print_string("warning: `CMem' chunk too long!\n");                                      for (; currlen > 1; --currlen)                                          svf.ReadByte();	/* Skip rest. */                                      break;	/* Keep going; there may be a `UMem' too. */                                  }                              }                              /* If chunk is short' assume a run. */                              for (; i < main.h_dynamic_size; ++i)                                  if ((y = stf.ReadByte()) == -1) return fatal;                                  else                                      FastMem.ZMData[FastMem.zmp + i] = (zbyte)y;                              if (currlen == 0)                                  progress |= GOT_MEMORY;	/* Only if succeeded. */                              break;                          }                          goto default;                      /* Fall right thru (to default) if already GOT_MEMORY */                      /* `UMem' uncompressed memory chunk; load it. */                      case 1431135597: // ID_UMem:                          if ((progress & GOT_MEMORY) == 0)	/* Don't complain if two. */ {                              /* Must be exactly the right size. */                              if (currlen == main.h_dynamic_size) {                                  byte[] buffer = new byte[currlen];                                  int read = svf.Read(FastMem.ZMData' (int)FastMem.zmp' (int)currlen);                                  if (read == currlen) {                                      progress |= GOT_MEMORY;	/* Only on success. */                                      break;                                  }                                  //if (fread(zmp' currlen' 1' svf) == 1) {                                  //}                              } else                                  Text.print_string("`UMem' chunk wrong size!\n");                              /* Fall into default action (skip chunk) on errors. */                          }                          goto default;                      /* Fall thru (to default) if already GOT_MEMORY */                      /* Unrecognised chunk type; skip it. */                      default:                          // (void) fseek (svf' currlen' SEEK_CUR);	/* Skip chunk. */                          svf.Position += currlen;                          break;                  }                  if (skip > 0)                      svf.ReadByte();	/* Skip pad byte. */              }
Magic Number,Frotz.Generic,Quetzal,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\quetzal.cs,restore_quetzal,The following statement contains a magic number: return (ushort)(progress == GOT_ALL ? 2 : fatal);
Magic Number,Frotz.Generic,Random,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\random.cs,seed_random,The following statement contains a magic number: if (value == 0) {		/* ask interface for seed value */              A = os_.random_seed ();              interval = 0;              } else if (value < 1000) {	/* special seed value */              counter = 0;              interval = value;              } else {			/* standard seed value */              A = value;              interval = 0;              }
Magic Number,Frotz.Generic,Random,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\random.cs,z_random,The following statement contains a magic number: if ((short)Process.zargs[0] <= 0) {	/* set random seed */                    seed_random(-(short)Process.zargs[0]);                  Process.store(0);                } else {				/* generate random number */                    zword result;                    if (interval != 0) {		/* ...in special mode */                      result = (zword)counter++;                      if (counter == interval) counter = 0;                  } else {			/* ...in standard mode */                      A = 0x015a4e35 * A + 1;                      result = (zword)((A >> 16) & 0x7fff);                  }                    Process.store((zword)(result % Process.zargs[0] + 1));                }
Magic Number,Frotz.Generic,Redirect,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\redirect.cs,memory_new_line,The following statement contains a magic number: addr += 2;
Magic Number,Frotz.Generic,Redirect,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\redirect.cs,memory_new_line,The following statement contains a magic number: if (redirect[depth].xsize != 0xffff) {                    redirect[depth].table = (zword)(addr + size);              size = 0;                } else FastMem.storeb ((zword) (addr + (size++))' 13);
Magic Number,Frotz.Generic,Redirect,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\redirect.cs,memory_word,The following statement contains a magic number: addr += 2;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,winarg0,The following statement contains a magic number: if (main.h_version == ZMachine.V6 && (short)Process.zargs[0] == -3)                  return (zword)main.cwin;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,winarg0,The following statement contains a magic number: if (Process.zargs[0] >= ((main.h_version == ZMachine.V6) ? 8 : 2))                  Err.runtime_error(ErrorCodes.ERR_ILL_WIN);
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,winarg0,The following statement contains a magic number: if (Process.zargs[0] >= ((main.h_version == ZMachine.V6) ? 8 : 2))                  Err.runtime_error(ErrorCodes.ERR_ILL_WIN);
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,winarg2,The following statement contains a magic number: if (Process.zargc < 3 || (short)Process.zargs[2] == -3)                  return main.cwin;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,winarg2,The following statement contains a magic number: if (Process.zargc < 3 || (short)Process.zargs[2] == -3)                  return main.cwin;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,winarg2,The following statement contains a magic number: if (Process.zargc < 3 || (short)Process.zargs[2] == -3)                  return main.cwin;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,winarg2,The following statement contains a magic number: if (Process.zargs[2] >= 8)                  Err.runtime_error(ErrorCodes.ERR_ILL_WIN);
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,winarg2,The following statement contains a magic number: if (Process.zargs[2] >= 8)                  Err.runtime_error(ErrorCodes.ERR_ILL_WIN);
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,winarg2,The following statement contains a magic number: return Process.zargs[2];
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,units_left,The following statement contains a magic number: if (os_.wrap_window(cwp_index()) == 0) return 999;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,get_max_width,The following statement contains a magic number: if (main.h_version == ZMachine.V6)              {                    if (win >= 8)                      Err.runtime_error(ErrorCodes.ERR_ILL_WIN);                    return (zword)(wp[win].x_size - wp[win].left - wp[win].right);                }              else return 0xffff;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,screen_new_line,The following statement contains a magic number: if (main.h_interpreter_number != ZMachine.INTERP_MSDOS || main.story_id != Story.ZORK_ZERO || main.h_release != 393)                  countdown();
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,screen_new_line,The following statement contains a magic number: if (cwp.y_cursor + 2 * font_height - 1 > cwp.y_size)                    if (main.enable_scrolling)                  {                        zword y = cwp.y_pos;                      zword x = cwp.x_pos;                        os_.scroll_area(y'                              x'                              y + cwp.y_size - 1'                              x + cwp.x_size - 1'                              font_height);                    }                  else cwp.y_cursor = 1;                else cwp.y_cursor += font_height;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,screen_new_line,The following statement contains a magic number: if (main.enable_scrolling && (short)cwp.line_count != -999)              {                    zword above = (zword)((cwp.y_cursor - 1) / font_height);                  zword below = (zword)((cwp.y_size - cwp.y_cursor + 1) / font_height);                    cwp.line_count++;                    if ((short)cwp.line_count >= (short)above + below - 1)                  {                        if (more_prompts)                          os_.more_prompt();                        cwp.line_count = main.option_context_lines;                    }                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,screen_new_line,The following statement contains a magic number: if (main.h_interpreter_number == ZMachine.INTERP_MSDOS && main.story_id == Story.ZORK_ZERO && main.h_release == 393)                  countdown();
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,console_read_input,The following statement contains a magic number: if (main.cwin == 0 && units_left() + os_.string_width(buf) < 10 * font_width)                  screen_new_line();
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,console_read_input,The following statement contains a magic number: if (key != CharCodes.ZC_TIME_OUT)                  for (i = 0; i < 8; i++)                      wp[i].line_count = 0;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,console_read_key,The following statement contains a magic number: if (key != CharCodes.ZC_TIME_OUT)                  for (i = 0; i < 8; i++)                      wp[i].line_count = 0;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,update_attributes,The following statement contains a magic number: main.enable_scrolling = (attr & 2) > 0;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,update_attributes,The following statement contains a magic number: main.enable_scripting = (attr & 4) > 0;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,update_attributes,The following statement contains a magic number: main.enable_buffering = (attr & 8) > 0;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,update_attributes,The following statement contains a magic number: if (main.story_id == Story.ZORK_ZERO && main.h_release == 366)                  if (main.cwin == 0)                      main.enable_wrapping = true;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,update_attributes,The following statement contains a magic number: if (main.story_id == Story.SHOGUN && main.h_release <= 295)                  if (main.cwin == 0)                      main.enable_wrapping = true;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,split_window,The following statement contains a magic number: if (main.h_version <= ZMachine.V3)              {                  stat_height = FastMem.HI(wp[7].font_size);                  wp[7].y_size = stat_height;                  os_.set_window_size(7' wp[7]);              }              else              {                  wp[7].y_size = 0;              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,split_window,The following statement contains a magic number: if (main.h_version <= ZMachine.V3)              {                  stat_height = FastMem.HI(wp[7].font_size);                  wp[7].y_size = stat_height;                  os_.set_window_size(7' wp[7]);              }              else              {                  wp[7].y_size = 0;              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,split_window,The following statement contains a magic number: if (main.h_version <= ZMachine.V3)              {                  stat_height = FastMem.HI(wp[7].font_size);                  wp[7].y_size = stat_height;                  os_.set_window_size(7' wp[7]);              }              else              {                  wp[7].y_size = 0;              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,split_window,The following statement contains a magic number: if (main.h_version <= ZMachine.V3)              {                  stat_height = FastMem.HI(wp[7].font_size);                  wp[7].y_size = stat_height;                  os_.set_window_size(7' wp[7]);              }              else              {                  wp[7].y_size = 0;              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,split_window,The following statement contains a magic number: if (main.h_version <= ZMachine.V3)              {                  stat_height = FastMem.HI(wp[7].font_size);                  wp[7].y_size = stat_height;                  os_.set_window_size(7' wp[7]);              }              else              {                  wp[7].y_size = 0;              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,erase_screen,The following statement contains a magic number: if (FastMem.HI(cwp.colour) != ZColor.TRANSPARENT_COLOUR)                  os_.erase_area(1' 1' main.h_screen_height' main.h_screen_width' -2);
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,erase_screen,The following statement contains a magic number: for (i = 0; i < 8; i++)                  wp[i].line_count = 0;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,restart_screen,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  wp[i] = new ZWindow();                  wp[i].y_pos = 1;                  wp[i].x_pos = 1;                  wp[i].y_size = 0;                  wp[i].x_size = 0;                  wp[i].y_cursor = 1;                  wp[i].x_cursor = 1;                  wp[i].left = 0;                  wp[i].right = 0;                  wp[i].nl_routine = 0;                  wp[i].nl_countdown = 0;                  wp[i].style = 0;                  wp[i].colour = (ushort)((main.h_default_background << 8) | main.h_default_foreground);                  wp[i].font = ZFont.TEXT_FONT;                  wp[i].font_size = (ushort)((font_height << 8) | font_width);                  wp[i].attribute = 8;                  wp[i].true_fore = main.hx_fore_colour;                  wp[i].true_back = main.hx_back_colour;                    wp[i].index = i;              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,restart_screen,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  wp[i] = new ZWindow();                  wp[i].y_pos = 1;                  wp[i].x_pos = 1;                  wp[i].y_size = 0;                  wp[i].x_size = 0;                  wp[i].y_cursor = 1;                  wp[i].x_cursor = 1;                  wp[i].left = 0;                  wp[i].right = 0;                  wp[i].nl_routine = 0;                  wp[i].nl_countdown = 0;                  wp[i].style = 0;                  wp[i].colour = (ushort)((main.h_default_background << 8) | main.h_default_foreground);                  wp[i].font = ZFont.TEXT_FONT;                  wp[i].font_size = (ushort)((font_height << 8) | font_width);                  wp[i].attribute = 8;                  wp[i].true_fore = main.hx_fore_colour;                  wp[i].true_back = main.hx_back_colour;                    wp[i].index = i;              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,restart_screen,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  wp[i] = new ZWindow();                  wp[i].y_pos = 1;                  wp[i].x_pos = 1;                  wp[i].y_size = 0;                  wp[i].x_size = 0;                  wp[i].y_cursor = 1;                  wp[i].x_cursor = 1;                  wp[i].left = 0;                  wp[i].right = 0;                  wp[i].nl_routine = 0;                  wp[i].nl_countdown = 0;                  wp[i].style = 0;                  wp[i].colour = (ushort)((main.h_default_background << 8) | main.h_default_foreground);                  wp[i].font = ZFont.TEXT_FONT;                  wp[i].font_size = (ushort)((font_height << 8) | font_width);                  wp[i].attribute = 8;                  wp[i].true_fore = main.hx_fore_colour;                  wp[i].true_back = main.hx_back_colour;                    wp[i].index = i;              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,restart_screen,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  wp[i] = new ZWindow();                  wp[i].y_pos = 1;                  wp[i].x_pos = 1;                  wp[i].y_size = 0;                  wp[i].x_size = 0;                  wp[i].y_cursor = 1;                  wp[i].x_cursor = 1;                  wp[i].left = 0;                  wp[i].right = 0;                  wp[i].nl_routine = 0;                  wp[i].nl_countdown = 0;                  wp[i].style = 0;                  wp[i].colour = (ushort)((main.h_default_background << 8) | main.h_default_foreground);                  wp[i].font = ZFont.TEXT_FONT;                  wp[i].font_size = (ushort)((font_height << 8) | font_width);                  wp[i].attribute = 8;                  wp[i].true_fore = main.hx_fore_colour;                  wp[i].true_back = main.hx_back_colour;                    wp[i].index = i;              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,restart_screen,The following statement contains a magic number: wp[0].attribute = 15;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,restart_screen,The following statement contains a magic number: if (main.h_version <= ZMachine.V3)                  wp[7].x_size = main.h_screen_width;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_buffer_mode,The following statement contains a magic number: if (main.h_version != ZMachine.V6)              {                    Buffer.flush_buffer();                    zword temp = 8; // TODO No idea what this math will be like //'                    wp[0].attribute &= (zword)(~temp);                    if (Process.zargs[0] != 0)                      wp[0].attribute |= 8;                    update_attributes();                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_buffer_mode,The following statement contains a magic number: if (main.h_version != ZMachine.V6)              {                    Buffer.flush_buffer();                    zword temp = 8; // TODO No idea what this math will be like //'                    wp[0].attribute &= (zword)(~temp);                    if (Process.zargs[0] != 0)                      wp[0].attribute |= 8;                    update_attributes();                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_draw_picture,The following statement contains a magic number: zword x = Process.zargs[2];
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_draw_picture,The following statement contains a magic number: for (i = 0; mapper[i].story_id != Story.UNKNOWN; i++)              {                  if (main.story_id == mapper[i].story_id && pic == mapper[i].pic)                  {                        int height1' width1;                      int height2' width2;                        int delta = 0;                        os_.picture_data(pic' out height1' out width1);                      os_.picture_data(mapper[i].pic2' out height2' out width2);                        if (main.story_id == Story.ARTHUR && pic == 54)                          delta = main.h_screen_width / 160;                        os_.draw_picture(mapper[i].pic1' y + height1' x + delta);                      os_.draw_picture(mapper[i].pic2' y + height1' x + width1 - width2 - delta);                  }              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_draw_picture,The following statement contains a magic number: for (i = 0; mapper[i].story_id != Story.UNKNOWN; i++)              {                  if (main.story_id == mapper[i].story_id && pic == mapper[i].pic)                  {                        int height1' width1;                      int height2' width2;                        int delta = 0;                        os_.picture_data(pic' out height1' out width1);                      os_.picture_data(mapper[i].pic2' out height2' out width2);                        if (main.story_id == Story.ARTHUR && pic == 54)                          delta = main.h_screen_width / 160;                        os_.draw_picture(mapper[i].pic1' y + height1' x + delta);                      os_.draw_picture(mapper[i].pic2' y + height1' x + width1 - width2 - delta);                  }              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_draw_picture,The following statement contains a magic number: if (main.story_id == Story.SHOGUN)                    if (pic == 3)                  {                        int height' width;                        os_.picture_data(59' out height' out width);                  }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_draw_picture,The following statement contains a magic number: if (main.story_id == Story.SHOGUN)                    if (pic == 3)                  {                        int height' width;                        os_.picture_data(59' out height' out width);                  }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_erase_picture,The following statement contains a magic number: zword x = Process.zargs[2];
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_erase_window,The following statement contains a magic number: if ((short)Process.zargs[0] == -1 || (short)Process.zargs[0] == -2)                  erase_screen(Process.zargs[0]);              else                  erase_window(winarg0());
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_get_cursor,The following statement contains a magic number: FastMem.storew((zword)(Process.zargs[0] + 2)' x);
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_get_wind_prop,The following statement contains a magic number: if (Process.zargs[1] < 16)              {                  // Process.store(((zword*)(wp + winarg0()))[Process.zargs[1]]);                  // This is a nasty' nasty piece of code                  Process.store(wp[winarg0()][Process.zargs[1]]);                  // Process.store((wp[winarg0()].union[Process.zargs[1]]                }              else if (Process.zargs[1] == 16)                  Process.store(os_.to_true_colour(FastMem.LO(wp[winarg0()].colour)));                else if (Process.zargs[1] == 17)              {                    zword bg = FastMem.HI(wp[winarg0()].colour);                    if (bg == ZColor.TRANSPARENT_COLOUR)                  {                      unchecked                      {                          Process.store((zword)(-4));                      }                  }                  else                      Process.store(os_.to_true_colour(bg));                }              else                  Err.runtime_error(ErrorCodes.ERR_ILL_WIN_PROP);
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_get_wind_prop,The following statement contains a magic number: if (Process.zargs[1] < 16)              {                  // Process.store(((zword*)(wp + winarg0()))[Process.zargs[1]]);                  // This is a nasty' nasty piece of code                  Process.store(wp[winarg0()][Process.zargs[1]]);                  // Process.store((wp[winarg0()].union[Process.zargs[1]]                }              else if (Process.zargs[1] == 16)                  Process.store(os_.to_true_colour(FastMem.LO(wp[winarg0()].colour)));                else if (Process.zargs[1] == 17)              {                    zword bg = FastMem.HI(wp[winarg0()].colour);                    if (bg == ZColor.TRANSPARENT_COLOUR)                  {                      unchecked                      {                          Process.store((zword)(-4));                      }                  }                  else                      Process.store(os_.to_true_colour(bg));                }              else                  Err.runtime_error(ErrorCodes.ERR_ILL_WIN_PROP);
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_get_wind_prop,The following statement contains a magic number: if (Process.zargs[1] < 16)              {                  // Process.store(((zword*)(wp + winarg0()))[Process.zargs[1]]);                  // This is a nasty' nasty piece of code                  Process.store(wp[winarg0()][Process.zargs[1]]);                  // Process.store((wp[winarg0()].union[Process.zargs[1]]                }              else if (Process.zargs[1] == 16)                  Process.store(os_.to_true_colour(FastMem.LO(wp[winarg0()].colour)));                else if (Process.zargs[1] == 17)              {                    zword bg = FastMem.HI(wp[winarg0()].colour);                    if (bg == ZColor.TRANSPARENT_COLOUR)                  {                      unchecked                      {                          Process.store((zword)(-4));                      }                  }                  else                      Process.store(os_.to_true_colour(bg));                }              else                  Err.runtime_error(ErrorCodes.ERR_ILL_WIN_PROP);
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_get_wind_prop,The following statement contains a magic number: if (Process.zargs[1] < 16)              {                  // Process.store(((zword*)(wp + winarg0()))[Process.zargs[1]]);                  // This is a nasty' nasty piece of code                  Process.store(wp[winarg0()][Process.zargs[1]]);                  // Process.store((wp[winarg0()].union[Process.zargs[1]]                }              else if (Process.zargs[1] == 16)                  Process.store(os_.to_true_colour(FastMem.LO(wp[winarg0()].colour)));                else if (Process.zargs[1] == 17)              {                    zword bg = FastMem.HI(wp[winarg0()].colour);                    if (bg == ZColor.TRANSPARENT_COLOUR)                  {                      unchecked                      {                          Process.store((zword)(-4));                      }                  }                  else                      Process.store(os_.to_true_colour(bg));                }              else                  Err.runtime_error(ErrorCodes.ERR_ILL_WIN_PROP);
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_move_window,The following statement contains a magic number: wp[win].x_pos = Process.zargs[2];
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_picture_data,The following statement contains a magic number: FastMem.storew((zword)(table + 2)' (zword)(width));
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_print_table,The following statement contains a magic number: if (Process.zargc < 3)                  Process.zargs[2] = 1;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_print_table,The following statement contains a magic number: if (Process.zargc < 3)                  Process.zargs[2] = 1;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_print_table,The following statement contains a magic number: if (Process.zargc < 4)                  Process.zargs[3] = 0;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_print_table,The following statement contains a magic number: if (Process.zargc < 4)                  Process.zargs[3] = 0;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_print_table,The following statement contains a magic number: for (i = 0; i < Process.zargs[2]; i++)              {                    if (i != 0)                  {                        Buffer.flush_buffer();                        cwp.y_cursor += font_height;                      cwp.x_cursor = x;                        update_cursor();                    }                    for (j = 0; j < Process.zargs[1]; j++)                  {                        zbyte c;                        FastMem.LOW_BYTE(addr' out c);                      addr++;                        Buffer.print_char(c);                    }                    addr += Process.zargs[3];                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_print_table,The following statement contains a magic number: for (i = 0; i < Process.zargs[2]; i++)              {                    if (i != 0)                  {                        Buffer.flush_buffer();                        cwp.y_cursor += font_height;                      cwp.x_cursor = x;                        update_cursor();                    }                    for (j = 0; j < Process.zargs[1]; j++)                  {                        zbyte c;                        FastMem.LOW_BYTE(addr' out c);                      addr++;                        Buffer.print_char(c);                    }                    addr += Process.zargs[3];                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_put_wind_prop,The following statement contains a magic number: if (Process.zargs[1] >= 16)                  Err.runtime_error(ErrorCodes.ERR_ILL_WIN_PROP);
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_put_wind_prop,The following statement contains a magic number: wp[winarg0()][Process.zargs[1]] = Process.zargs[2];
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_colour,The following statement contains a magic number: if (main.h_version == ZMachine.V6 && amiga_screen_model())                    /* Changing colours of window 0 affects the entire screen */                    if (win == 0)                  {                        int i;                        for (i = 1; i < 8; i++)                      {                            zword bg2 = FastMem.HI(wp[i].colour);                          zword fg2 = FastMem.LO(wp[i].colour);                            if (bg2 < 16)                              bg2 = (bg2 == FastMem.LO(wp[0].colour)) ? fg : bg;                          if (fg2 < 16)                              fg2 = (fg2 == FastMem.LO(wp[0].colour)) ? fg : bg;                            wp[i].colour = (zword)((bg2 << 8) | fg2);                        }                    }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_colour,The following statement contains a magic number: if (main.h_version == ZMachine.V6 && amiga_screen_model())                    /* Changing colours of window 0 affects the entire screen */                    if (win == 0)                  {                        int i;                        for (i = 1; i < 8; i++)                      {                            zword bg2 = FastMem.HI(wp[i].colour);                          zword fg2 = FastMem.LO(wp[i].colour);                            if (bg2 < 16)                              bg2 = (bg2 == FastMem.LO(wp[0].colour)) ? fg : bg;                          if (fg2 < 16)                              fg2 = (fg2 == FastMem.LO(wp[0].colour)) ? fg : bg;                            wp[i].colour = (zword)((bg2 << 8) | fg2);                        }                    }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_colour,The following statement contains a magic number: if (main.h_version == ZMachine.V6 && amiga_screen_model())                    /* Changing colours of window 0 affects the entire screen */                    if (win == 0)                  {                        int i;                        for (i = 1; i < 8; i++)                      {                            zword bg2 = FastMem.HI(wp[i].colour);                          zword fg2 = FastMem.LO(wp[i].colour);                            if (bg2 < 16)                              bg2 = (bg2 == FastMem.LO(wp[0].colour)) ? fg : bg;                          if (fg2 < 16)                              fg2 = (fg2 == FastMem.LO(wp[0].colour)) ? fg : bg;                            wp[i].colour = (zword)((bg2 << 8) | fg2);                        }                    }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_colour,The following statement contains a magic number: if (main.h_version == ZMachine.V6 && amiga_screen_model())                    /* Changing colours of window 0 affects the entire screen */                    if (win == 0)                  {                        int i;                        for (i = 1; i < 8; i++)                      {                            zword bg2 = FastMem.HI(wp[i].colour);                          zword fg2 = FastMem.LO(wp[i].colour);                            if (bg2 < 16)                              bg2 = (bg2 == FastMem.LO(wp[0].colour)) ? fg : bg;                          if (fg2 < 16)                              fg2 = (fg2 == FastMem.LO(wp[0].colour)) ? fg : bg;                            wp[i].colour = (zword)((bg2 << 8) | fg2);                        }                    }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_colour,The following statement contains a magic number: wp[win].colour = (zword)((bg << 8) | fg);
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_true_colour,The following statement contains a magic number: switch ((short)true_fg)              {                    case -1:	/* colour -1 is the system default colour */                      fg = main.h_default_foreground;                      break;                    case -2:	/* colour -2 means keep current colour */                      fg = FastMem.LO(wp[win].colour);                      break;                    case -3:	/* colour -3 is the colour at the cursor */                      fg = os_.peek_colour();                      break;                    case -4:                      fg = FastMem.LO(wp[win].colour);                      break;                    default:                      fg = os_.from_true_colour(true_fg);                      break;              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_true_colour,The following statement contains a magic number: switch ((short)true_fg)              {                    case -1:	/* colour -1 is the system default colour */                      fg = main.h_default_foreground;                      break;                    case -2:	/* colour -2 means keep current colour */                      fg = FastMem.LO(wp[win].colour);                      break;                    case -3:	/* colour -3 is the colour at the cursor */                      fg = os_.peek_colour();                      break;                    case -4:                      fg = FastMem.LO(wp[win].colour);                      break;                    default:                      fg = os_.from_true_colour(true_fg);                      break;              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_true_colour,The following statement contains a magic number: switch ((short)true_fg)              {                    case -1:	/* colour -1 is the system default colour */                      fg = main.h_default_foreground;                      break;                    case -2:	/* colour -2 means keep current colour */                      fg = FastMem.LO(wp[win].colour);                      break;                    case -3:	/* colour -3 is the colour at the cursor */                      fg = os_.peek_colour();                      break;                    case -4:                      fg = FastMem.LO(wp[win].colour);                      break;                    default:                      fg = os_.from_true_colour(true_fg);                      break;              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_true_colour,The following statement contains a magic number: switch ((short)true_bg)              {                    case -1:	/* colour -1 is the system default colour */                      bg = main.h_default_background;                      break;                    case -2:	/* colour -2 means keep current colour */                      bg = FastMem.HI(wp[win].colour);                      break;                    case -3:	/* colour -3 is the colour at the cursor */                      bg = os_.peek_colour();                      break;                    case -4:	/* colour -4 means transparent */                      if ((main.hx_flags & ZMachine.TRANSPARENT_FLAG) > 0)                          bg = ZColor.TRANSPARENT_COLOUR;                      else                          bg = FastMem.HI(wp[win].colour);                      break;                    default:                      bg = os_.from_true_colour(true_bg);                      break;              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_true_colour,The following statement contains a magic number: switch ((short)true_bg)              {                    case -1:	/* colour -1 is the system default colour */                      bg = main.h_default_background;                      break;                    case -2:	/* colour -2 means keep current colour */                      bg = FastMem.HI(wp[win].colour);                      break;                    case -3:	/* colour -3 is the colour at the cursor */                      bg = os_.peek_colour();                      break;                    case -4:	/* colour -4 means transparent */                      if ((main.hx_flags & ZMachine.TRANSPARENT_FLAG) > 0)                          bg = ZColor.TRANSPARENT_COLOUR;                      else                          bg = FastMem.HI(wp[win].colour);                      break;                    default:                      bg = os_.from_true_colour(true_bg);                      break;              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_true_colour,The following statement contains a magic number: switch ((short)true_bg)              {                    case -1:	/* colour -1 is the system default colour */                      bg = main.h_default_background;                      break;                    case -2:	/* colour -2 means keep current colour */                      bg = FastMem.HI(wp[win].colour);                      break;                    case -3:	/* colour -3 is the colour at the cursor */                      bg = os_.peek_colour();                      break;                    case -4:	/* colour -4 means transparent */                      if ((main.hx_flags & ZMachine.TRANSPARENT_FLAG) > 0)                          bg = ZColor.TRANSPARENT_COLOUR;                      else                          bg = FastMem.HI(wp[win].colour);                      break;                    default:                      bg = os_.from_true_colour(true_bg);                      break;              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_true_colour,The following statement contains a magic number: wp[win].colour = (zword)((bg << 8) | fg);
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_font,The following statement contains a magic number: if (main.h_version == ZMachine.V6)              {                    if (Process.zargc < 2 || (short)Process.zargs[1] == -3)                      win = main.cwin;                  else if (Process.zargs[1] >= 8)                      Err.runtime_error(ErrorCodes.ERR_ILL_WIN);                  else                      win = Process.zargs[1];                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_font,The following statement contains a magic number: if (main.h_version == ZMachine.V6)              {                    if (Process.zargc < 2 || (short)Process.zargs[1] == -3)                      win = main.cwin;                  else if (Process.zargs[1] >= 8)                      Err.runtime_error(ErrorCodes.ERR_ILL_WIN);                  else                      win = Process.zargs[1];                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_font,The following statement contains a magic number: if (main.h_version == ZMachine.V6)              {                    if (Process.zargc < 2 || (short)Process.zargs[1] == -3)                      win = main.cwin;                  else if (Process.zargs[1] >= 8)                      Err.runtime_error(ErrorCodes.ERR_ILL_WIN);                  else                      win = Process.zargs[1];                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_font,The following statement contains a magic number: if (font != 0)              {                    if (os_.font_data(font' ref font_height' ref font_width))                  {                        Process.store(wp[win].font);                        wp[win].font = font;                      wp[win].font_size = (zword)((font_height << 8) | font_width);                        if ((main.h_version != ZMachine.V6) || (win == main.cwin))                      {                            if (!main.ostream_memory && main.ostream_screen && main.enable_buffering)                          {                                Buffer.print_char(CharCodes.ZC_NEW_FONT);                              Buffer.print_char(font);                            }                          else os_.set_font(font);                        }                    }                  else Process.store(0);                }              else Process.store(wp[win].font);
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_cursor,The following statement contains a magic number: if (Process.zargc < 3)                  Process.zargs[2] = current_window;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_cursor,The following statement contains a magic number: if (Process.zargc < 3)                  Process.zargs[2] = current_window;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_set_cursor,The following statement contains a magic number: if ((short)y < 0)              {                    if ((short)y == -2)                      cursor = true;                  if ((short)y == -1)                      cursor = false;                    return;                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_show_status,The following statement contains a magic number: addr += 2;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_show_status,The following statement contains a magic number: addr += 2;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_show_status,The following statement contains a magic number: set_window(7);
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_show_status,The following statement contains a magic number: if (main.h_screen_cols < 55)                  brief = true;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_show_status,The following statement contains a magic number: if ((main.h_config & ZMachine.CONFIG_TIME) > 0)              {	/* print hours and minutes */                    zword hours = (zword)((global1 + 11) % 12 + 1);                    pad_status_line(brief ? 15 : 20);                    Text.print_string("Time: ");                    if (hours < 10)                      Buffer.print_char(' ');                  Text.print_num(hours);                    Buffer.print_char(':');                    if (global2 < 10)                      Buffer.print_char('0');                  Text.print_num(global2);                    Buffer.print_char(' ');                    Buffer.print_char((global1 >= 12) ? 'p' : 'a');                  Buffer.print_char('m');                }              else              {				/* print score and moves */                    pad_status_line(brief ? 15 : 30);                    Text.print_string(brief ? "S: " : "Score: ");                  Text.print_num(global1);                    pad_status_line(brief ? 8 : 14);                    Text.print_string(brief ? "M: " : "Moves: ");                  Text.print_num(global2);                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_show_status,The following statement contains a magic number: if ((main.h_config & ZMachine.CONFIG_TIME) > 0)              {	/* print hours and minutes */                    zword hours = (zword)((global1 + 11) % 12 + 1);                    pad_status_line(brief ? 15 : 20);                    Text.print_string("Time: ");                    if (hours < 10)                      Buffer.print_char(' ');                  Text.print_num(hours);                    Buffer.print_char(':');                    if (global2 < 10)                      Buffer.print_char('0');                  Text.print_num(global2);                    Buffer.print_char(' ');                    Buffer.print_char((global1 >= 12) ? 'p' : 'a');                  Buffer.print_char('m');                }              else              {				/* print score and moves */                    pad_status_line(brief ? 15 : 30);                    Text.print_string(brief ? "S: " : "Score: ");                  Text.print_num(global1);                    pad_status_line(brief ? 8 : 14);                    Text.print_string(brief ? "M: " : "Moves: ");                  Text.print_num(global2);                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_show_status,The following statement contains a magic number: if ((main.h_config & ZMachine.CONFIG_TIME) > 0)              {	/* print hours and minutes */                    zword hours = (zword)((global1 + 11) % 12 + 1);                    pad_status_line(brief ? 15 : 20);                    Text.print_string("Time: ");                    if (hours < 10)                      Buffer.print_char(' ');                  Text.print_num(hours);                    Buffer.print_char(':');                    if (global2 < 10)                      Buffer.print_char('0');                  Text.print_num(global2);                    Buffer.print_char(' ');                    Buffer.print_char((global1 >= 12) ? 'p' : 'a');                  Buffer.print_char('m');                }              else              {				/* print score and moves */                    pad_status_line(brief ? 15 : 30);                    Text.print_string(brief ? "S: " : "Score: ");                  Text.print_num(global1);                    pad_status_line(brief ? 8 : 14);                    Text.print_string(brief ? "M: " : "Moves: ");                  Text.print_num(global2);                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_show_status,The following statement contains a magic number: if ((main.h_config & ZMachine.CONFIG_TIME) > 0)              {	/* print hours and minutes */                    zword hours = (zword)((global1 + 11) % 12 + 1);                    pad_status_line(brief ? 15 : 20);                    Text.print_string("Time: ");                    if (hours < 10)                      Buffer.print_char(' ');                  Text.print_num(hours);                    Buffer.print_char(':');                    if (global2 < 10)                      Buffer.print_char('0');                  Text.print_num(global2);                    Buffer.print_char(' ');                    Buffer.print_char((global1 >= 12) ? 'p' : 'a');                  Buffer.print_char('m');                }              else              {				/* print score and moves */                    pad_status_line(brief ? 15 : 30);                    Text.print_string(brief ? "S: " : "Score: ");                  Text.print_num(global1);                    pad_status_line(brief ? 8 : 14);                    Text.print_string(brief ? "M: " : "Moves: ");                  Text.print_num(global2);                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_show_status,The following statement contains a magic number: if ((main.h_config & ZMachine.CONFIG_TIME) > 0)              {	/* print hours and minutes */                    zword hours = (zword)((global1 + 11) % 12 + 1);                    pad_status_line(brief ? 15 : 20);                    Text.print_string("Time: ");                    if (hours < 10)                      Buffer.print_char(' ');                  Text.print_num(hours);                    Buffer.print_char(':');                    if (global2 < 10)                      Buffer.print_char('0');                  Text.print_num(global2);                    Buffer.print_char(' ');                    Buffer.print_char((global1 >= 12) ? 'p' : 'a');                  Buffer.print_char('m');                }              else              {				/* print score and moves */                    pad_status_line(brief ? 15 : 30);                    Text.print_string(brief ? "S: " : "Score: ");                  Text.print_num(global1);                    pad_status_line(brief ? 8 : 14);                    Text.print_string(brief ? "M: " : "Moves: ");                  Text.print_num(global2);                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_show_status,The following statement contains a magic number: if ((main.h_config & ZMachine.CONFIG_TIME) > 0)              {	/* print hours and minutes */                    zword hours = (zword)((global1 + 11) % 12 + 1);                    pad_status_line(brief ? 15 : 20);                    Text.print_string("Time: ");                    if (hours < 10)                      Buffer.print_char(' ');                  Text.print_num(hours);                    Buffer.print_char(':');                    if (global2 < 10)                      Buffer.print_char('0');                  Text.print_num(global2);                    Buffer.print_char(' ');                    Buffer.print_char((global1 >= 12) ? 'p' : 'a');                  Buffer.print_char('m');                }              else              {				/* print score and moves */                    pad_status_line(brief ? 15 : 30);                    Text.print_string(brief ? "S: " : "Score: ");                  Text.print_num(global1);                    pad_status_line(brief ? 8 : 14);                    Text.print_string(brief ? "M: " : "Moves: ");                  Text.print_num(global2);                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_show_status,The following statement contains a magic number: if ((main.h_config & ZMachine.CONFIG_TIME) > 0)              {	/* print hours and minutes */                    zword hours = (zword)((global1 + 11) % 12 + 1);                    pad_status_line(brief ? 15 : 20);                    Text.print_string("Time: ");                    if (hours < 10)                      Buffer.print_char(' ');                  Text.print_num(hours);                    Buffer.print_char(':');                    if (global2 < 10)                      Buffer.print_char('0');                  Text.print_num(global2);                    Buffer.print_char(' ');                    Buffer.print_char((global1 >= 12) ? 'p' : 'a');                  Buffer.print_char('m');                }              else              {				/* print score and moves */                    pad_status_line(brief ? 15 : 30);                    Text.print_string(brief ? "S: " : "Score: ");                  Text.print_num(global1);                    pad_status_line(brief ? 8 : 14);                    Text.print_string(brief ? "M: " : "Moves: ");                  Text.print_num(global2);                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_show_status,The following statement contains a magic number: if ((main.h_config & ZMachine.CONFIG_TIME) > 0)              {	/* print hours and minutes */                    zword hours = (zword)((global1 + 11) % 12 + 1);                    pad_status_line(brief ? 15 : 20);                    Text.print_string("Time: ");                    if (hours < 10)                      Buffer.print_char(' ');                  Text.print_num(hours);                    Buffer.print_char(':');                    if (global2 < 10)                      Buffer.print_char('0');                  Text.print_num(global2);                    Buffer.print_char(' ');                    Buffer.print_char((global1 >= 12) ? 'p' : 'a');                  Buffer.print_char('m');                }              else              {				/* print score and moves */                    pad_status_line(brief ? 15 : 30);                    Text.print_string(brief ? "S: " : "Score: ");                  Text.print_num(global1);                    pad_status_line(brief ? 8 : 14);                    Text.print_string(brief ? "M: " : "Moves: ");                  Text.print_num(global2);                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_show_status,The following statement contains a magic number: if ((main.h_config & ZMachine.CONFIG_TIME) > 0)              {	/* print hours and minutes */                    zword hours = (zword)((global1 + 11) % 12 + 1);                    pad_status_line(brief ? 15 : 20);                    Text.print_string("Time: ");                    if (hours < 10)                      Buffer.print_char(' ');                  Text.print_num(hours);                    Buffer.print_char(':');                    if (global2 < 10)                      Buffer.print_char('0');                  Text.print_num(global2);                    Buffer.print_char(' ');                    Buffer.print_char((global1 >= 12) ? 'p' : 'a');                  Buffer.print_char('m');                }              else              {				/* print score and moves */                    pad_status_line(brief ? 15 : 30);                    Text.print_string(brief ? "S: " : "Score: ");                  Text.print_num(global1);                    pad_status_line(brief ? 8 : 14);                    Text.print_string(brief ? "M: " : "Moves: ");                  Text.print_num(global2);                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_show_status,The following statement contains a magic number: if ((main.h_config & ZMachine.CONFIG_TIME) > 0)              {	/* print hours and minutes */                    zword hours = (zword)((global1 + 11) % 12 + 1);                    pad_status_line(brief ? 15 : 20);                    Text.print_string("Time: ");                    if (hours < 10)                      Buffer.print_char(' ');                  Text.print_num(hours);                    Buffer.print_char(':');                    if (global2 < 10)                      Buffer.print_char('0');                  Text.print_num(global2);                    Buffer.print_char(' ');                    Buffer.print_char((global1 >= 12) ? 'p' : 'a');                  Buffer.print_char('m');                }              else              {				/* print score and moves */                    pad_status_line(brief ? 15 : 30);                    Text.print_string(brief ? "S: " : "Score: ");                  Text.print_num(global1);                    pad_status_line(brief ? 8 : 14);                    Text.print_string(brief ? "M: " : "Moves: ");                  Text.print_num(global2);                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_show_status,The following statement contains a magic number: if ((main.h_config & ZMachine.CONFIG_TIME) > 0)              {	/* print hours and minutes */                    zword hours = (zword)((global1 + 11) % 12 + 1);                    pad_status_line(brief ? 15 : 20);                    Text.print_string("Time: ");                    if (hours < 10)                      Buffer.print_char(' ');                  Text.print_num(hours);                    Buffer.print_char(':');                    if (global2 < 10)                      Buffer.print_char('0');                  Text.print_num(global2);                    Buffer.print_char(' ');                    Buffer.print_char((global1 >= 12) ? 'p' : 'a');                  Buffer.print_char('m');                }              else              {				/* print score and moves */                    pad_status_line(brief ? 15 : 30);                    Text.print_string(brief ? "S: " : "Score: ");                  Text.print_num(global1);                    pad_status_line(brief ? 8 : 14);                    Text.print_string(brief ? "M: " : "Moves: ");                  Text.print_num(global2);                }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_window_size,The following statement contains a magic number: wp[win].x_size = Process.zargs[2];
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_window_size,The following statement contains a magic number: if (wp[win].y_cursor > Process.zargs[1] || wp[win].x_cursor > Process.zargs[2])                  reset_cursor(win);
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_window_style,The following statement contains a magic number: if (Process.zargc < 3)                  Process.zargs[2] = 0;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_window_style,The following statement contains a magic number: if (Process.zargc < 3)                  Process.zargs[2] = 0;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_window_style,The following statement contains a magic number: switch (Process.zargs[2])              {                  case 0: wp[win].attribute = flags; break;                  case 1: wp[win].attribute |= flags; break;                  case 2: wp[win].attribute &= (zword)(~flags); break;                  case 3: wp[win].attribute ^= flags; break;              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_window_style,The following statement contains a magic number: switch (Process.zargs[2])              {                  case 0: wp[win].attribute = flags; break;                  case 1: wp[win].attribute |= flags; break;                  case 2: wp[win].attribute &= (zword)(~flags); break;                  case 3: wp[win].attribute ^= flags; break;              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_window_style,The following statement contains a magic number: switch (Process.zargs[2])              {                  case 0: wp[win].attribute = flags; break;                  case 1: wp[win].attribute |= flags; break;                  case 2: wp[win].attribute &= (zword)(~flags); break;                  case 3: wp[win].attribute ^= flags; break;              }
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,colour_in_use,The following statement contains a magic number: int max = (main.h_version == ZMachine.V6) ? 8 : 2;
Magic Number,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,colour_in_use,The following statement contains a magic number: int max = (main.h_version == ZMachine.V6) ? 8 : 2;
Magic Number,Frotz.Generic,Sound,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\sound.cs,z_sound_effect,The following statement contains a magic number: zword volume = Process.zargs[2];
Magic Number,Frotz.Generic,Sound,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\sound.cs,z_sound_effect,The following statement contains a magic number: if (Process.zargc < 2)                  effect = EFFECT_PLAY;
Magic Number,Frotz.Generic,Sound,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\sound.cs,z_sound_effect,The following statement contains a magic number: if (Process.zargc < 3)                  volume = 8;
Magic Number,Frotz.Generic,Sound,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\sound.cs,z_sound_effect,The following statement contains a magic number: if (Process.zargc < 3)                  volume = 8;
Magic Number,Frotz.Generic,Sound,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\sound.cs,z_sound_effect,The following statement contains a magic number: if (number >= 3 || number == 0)              {                    locked = true;                    if (main.story_id == Story.LURKING_HORROR && (number == 9 || number == 16))                  {                        if (effect == EFFECT_PLAY)                      {                            next_sample = number;                          next_volume = volume;                            locked = false;                            if (!playing)                              start_next_sample();                        }                      else locked = false;                        return;                    }                    playing = false;                    switch (effect)                  {                        case EFFECT_PREPARE:                          os_.prepare_sample(number);                          break;                      case EFFECT_PLAY:                          start_sample(number' FastMem.LO(volume)' FastMem.HI(volume)'                              (zword)((Process.zargc == 4) ? Process.zargs[3] : 0));                          break;                      case EFFECT_STOP:                          os_.stop_sample(number);                          break;                      case EFFECT_FINISH_WITH:                          os_.finish_with_sample(number);                          break;                    }                    locked = false;                }              else os_.beep(number);
Magic Number,Frotz.Generic,Sound,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\sound.cs,z_sound_effect,The following statement contains a magic number: if (number >= 3 || number == 0)              {                    locked = true;                    if (main.story_id == Story.LURKING_HORROR && (number == 9 || number == 16))                  {                        if (effect == EFFECT_PLAY)                      {                            next_sample = number;                          next_volume = volume;                            locked = false;                            if (!playing)                              start_next_sample();                        }                      else locked = false;                        return;                    }                    playing = false;                    switch (effect)                  {                        case EFFECT_PREPARE:                          os_.prepare_sample(number);                          break;                      case EFFECT_PLAY:                          start_sample(number' FastMem.LO(volume)' FastMem.HI(volume)'                              (zword)((Process.zargc == 4) ? Process.zargs[3] : 0));                          break;                      case EFFECT_STOP:                          os_.stop_sample(number);                          break;                      case EFFECT_FINISH_WITH:                          os_.finish_with_sample(number);                          break;                    }                    locked = false;                }              else os_.beep(number);
Magic Number,Frotz.Generic,Sound,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\sound.cs,z_sound_effect,The following statement contains a magic number: if (number >= 3 || number == 0)              {                    locked = true;                    if (main.story_id == Story.LURKING_HORROR && (number == 9 || number == 16))                  {                        if (effect == EFFECT_PLAY)                      {                            next_sample = number;                          next_volume = volume;                            locked = false;                            if (!playing)                              start_next_sample();                        }                      else locked = false;                        return;                    }                    playing = false;                    switch (effect)                  {                        case EFFECT_PREPARE:                          os_.prepare_sample(number);                          break;                      case EFFECT_PLAY:                          start_sample(number' FastMem.LO(volume)' FastMem.HI(volume)'                              (zword)((Process.zargc == 4) ? Process.zargs[3] : 0));                          break;                      case EFFECT_STOP:                          os_.stop_sample(number);                          break;                      case EFFECT_FINISH_WITH:                          os_.finish_with_sample(number);                          break;                    }                    locked = false;                }              else os_.beep(number);
Magic Number,Frotz.Generic,Sound,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\sound.cs,z_sound_effect,The following statement contains a magic number: if (number >= 3 || number == 0)              {                    locked = true;                    if (main.story_id == Story.LURKING_HORROR && (number == 9 || number == 16))                  {                        if (effect == EFFECT_PLAY)                      {                            next_sample = number;                          next_volume = volume;                            locked = false;                            if (!playing)                              start_next_sample();                        }                      else locked = false;                        return;                    }                    playing = false;                    switch (effect)                  {                        case EFFECT_PREPARE:                          os_.prepare_sample(number);                          break;                      case EFFECT_PLAY:                          start_sample(number' FastMem.LO(volume)' FastMem.HI(volume)'                              (zword)((Process.zargc == 4) ? Process.zargs[3] : 0));                          break;                      case EFFECT_STOP:                          os_.stop_sample(number);                          break;                      case EFFECT_FINISH_WITH:                          os_.finish_with_sample(number);                          break;                    }                    locked = false;                }              else os_.beep(number);
Magic Number,Frotz.Generic,Sound,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\sound.cs,z_sound_effect,The following statement contains a magic number: if (number >= 3 || number == 0)              {                    locked = true;                    if (main.story_id == Story.LURKING_HORROR && (number == 9 || number == 16))                  {                        if (effect == EFFECT_PLAY)                      {                            next_sample = number;                          next_volume = volume;                            locked = false;                            if (!playing)                              start_next_sample();                        }                      else locked = false;                        return;                    }                    playing = false;                    switch (effect)                  {                        case EFFECT_PREPARE:                          os_.prepare_sample(number);                          break;                      case EFFECT_PLAY:                          start_sample(number' FastMem.LO(volume)' FastMem.HI(volume)'                              (zword)((Process.zargc == 4) ? Process.zargs[3] : 0));                          break;                      case EFFECT_STOP:                          os_.stop_sample(number);                          break;                      case EFFECT_FINISH_WITH:                          os_.finish_with_sample(number);                          break;                    }                    locked = false;                }              else os_.beep(number);
Magic Number,Frotz.Generic,Stream,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\stream.cs,z_output_stream,The following statement contains a magic number: switch ((short)Process.zargs[0]) {                    case 1: main.ostream_screen = true;                      break;                  case -1: main.ostream_screen = false;                      break;                  case 2: if (!main.ostream_script) Files.script_open();                      break;                  case -2: if (main.ostream_script) Files.script_close();                      break;                  case 3: Redirect.memory_open(Process.zargs[1]' Process.zargs[2]' Process.zargc >= 3);                      break;                  case -3: Redirect.memory_close();                      break;                  case 4: if (!main.ostream_record) Files.record_open();                      break;                  case -4: if (main.ostream_record) Files.record_close();                      break;                }
Magic Number,Frotz.Generic,Stream,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\stream.cs,z_output_stream,The following statement contains a magic number: switch ((short)Process.zargs[0]) {                    case 1: main.ostream_screen = true;                      break;                  case -1: main.ostream_screen = false;                      break;                  case 2: if (!main.ostream_script) Files.script_open();                      break;                  case -2: if (main.ostream_script) Files.script_close();                      break;                  case 3: Redirect.memory_open(Process.zargs[1]' Process.zargs[2]' Process.zargc >= 3);                      break;                  case -3: Redirect.memory_close();                      break;                  case 4: if (!main.ostream_record) Files.record_open();                      break;                  case -4: if (main.ostream_record) Files.record_close();                      break;                }
Magic Number,Frotz.Generic,Stream,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\stream.cs,z_output_stream,The following statement contains a magic number: switch ((short)Process.zargs[0]) {                    case 1: main.ostream_screen = true;                      break;                  case -1: main.ostream_screen = false;                      break;                  case 2: if (!main.ostream_script) Files.script_open();                      break;                  case -2: if (main.ostream_script) Files.script_close();                      break;                  case 3: Redirect.memory_open(Process.zargs[1]' Process.zargs[2]' Process.zargc >= 3);                      break;                  case -3: Redirect.memory_close();                      break;                  case 4: if (!main.ostream_record) Files.record_open();                      break;                  case -4: if (main.ostream_record) Files.record_close();                      break;                }
Magic Number,Frotz.Generic,Stream,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\stream.cs,z_output_stream,The following statement contains a magic number: switch ((short)Process.zargs[0]) {                    case 1: main.ostream_screen = true;                      break;                  case -1: main.ostream_screen = false;                      break;                  case 2: if (!main.ostream_script) Files.script_open();                      break;                  case -2: if (main.ostream_script) Files.script_close();                      break;                  case 3: Redirect.memory_open(Process.zargs[1]' Process.zargs[2]' Process.zargc >= 3);                      break;                  case -3: Redirect.memory_close();                      break;                  case 4: if (!main.ostream_record) Files.record_open();                      break;                  case -4: if (main.ostream_record) Files.record_close();                      break;                }
Magic Number,Frotz.Generic,Stream,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\stream.cs,z_output_stream,The following statement contains a magic number: switch ((short)Process.zargs[0]) {                    case 1: main.ostream_screen = true;                      break;                  case -1: main.ostream_screen = false;                      break;                  case 2: if (!main.ostream_script) Files.script_open();                      break;                  case -2: if (main.ostream_script) Files.script_close();                      break;                  case 3: Redirect.memory_open(Process.zargs[1]' Process.zargs[2]' Process.zargc >= 3);                      break;                  case -3: Redirect.memory_close();                      break;                  case 4: if (!main.ostream_record) Files.record_open();                      break;                  case -4: if (main.ostream_record) Files.record_close();                      break;                }
Magic Number,Frotz.Generic,Stream,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\stream.cs,z_output_stream,The following statement contains a magic number: switch ((short)Process.zargs[0]) {                    case 1: main.ostream_screen = true;                      break;                  case -1: main.ostream_screen = false;                      break;                  case 2: if (!main.ostream_script) Files.script_open();                      break;                  case -2: if (main.ostream_script) Files.script_close();                      break;                  case 3: Redirect.memory_open(Process.zargs[1]' Process.zargs[2]' Process.zargc >= 3);                      break;                  case -3: Redirect.memory_close();                      break;                  case 4: if (!main.ostream_record) Files.record_open();                      break;                  case -4: if (main.ostream_record) Files.record_close();                      break;                }
Magic Number,Frotz.Generic,Stream,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\stream.cs,z_output_stream,The following statement contains a magic number: switch ((short)Process.zargs[0]) {                    case 1: main.ostream_screen = true;                      break;                  case -1: main.ostream_screen = false;                      break;                  case 2: if (!main.ostream_script) Files.script_open();                      break;                  case -2: if (main.ostream_script) Files.script_close();                      break;                  case 3: Redirect.memory_open(Process.zargs[1]' Process.zargs[2]' Process.zargc >= 3);                      break;                  case -3: Redirect.memory_close();                      break;                  case 4: if (!main.ostream_record) Files.record_open();                      break;                  case -4: if (main.ostream_record) Files.record_close();                      break;                }
Magic Number,Frotz.Generic,Stream,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\stream.cs,z_output_stream,The following statement contains a magic number: switch ((short)Process.zargs[0]) {                    case 1: main.ostream_screen = true;                      break;                  case -1: main.ostream_screen = false;                      break;                  case 2: if (!main.ostream_script) Files.script_open();                      break;                  case -2: if (main.ostream_script) Files.script_close();                      break;                  case 3: Redirect.memory_open(Process.zargs[1]' Process.zargs[2]' Process.zargc >= 3);                      break;                  case -3: Redirect.memory_close();                      break;                  case 4: if (!main.ostream_record) Files.record_open();                      break;                  case -4: if (main.ostream_record) Files.record_close();                      break;                }
Magic Number,Frotz.Generic,Table,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\table.cs,z_copy_table,The following statement contains a magic number: zword size = Process.zargs[2];
Magic Number,Frotz.Generic,Table,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\table.cs,z_loadw,The following statement contains a magic number: zword addr = (zword)(Process.zargs[0] + 2 * Process.zargs[1]);
Magic Number,Frotz.Generic,Table,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\table.cs,z_scan_table,The following statement contains a magic number: if (Process.zargc < 4)              Process.zargs[3] = 0x82;
Magic Number,Frotz.Generic,Table,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\table.cs,z_scan_table,The following statement contains a magic number: if (Process.zargc < 4)              Process.zargs[3] = 0x82;
Magic Number,Frotz.Generic,Table,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\table.cs,z_scan_table,The following statement contains a magic number: for (i = 0; i < Process.zargs[2]; i++) {                if ( (Process.zargs[3] & 0x80) > 0) {	/* scan word array */                    zword wvalue;                    FastMem.LOW_WORD(addr' out wvalue);                    if (wvalue == Process.zargs[0])                  goto finished;                } else {		/* scan byte array */                    zbyte bvalue;                    FastMem.LOW_BYTE (addr' out bvalue);                    if (bvalue == Process.zargs[0])                  goto finished;                }                addr += (zword)(Process.zargs[3] & 0x7f);                }
Magic Number,Frotz.Generic,Table,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\table.cs,z_scan_table,The following statement contains a magic number: for (i = 0; i < Process.zargs[2]; i++) {                if ( (Process.zargs[3] & 0x80) > 0) {	/* scan word array */                    zword wvalue;                    FastMem.LOW_WORD(addr' out wvalue);                    if (wvalue == Process.zargs[0])                  goto finished;                } else {		/* scan byte array */                    zbyte bvalue;                    FastMem.LOW_BYTE (addr' out bvalue);                    if (bvalue == Process.zargs[0])                  goto finished;                }                addr += (zword)(Process.zargs[3] & 0x7f);                }
Magic Number,Frotz.Generic,Table,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\table.cs,z_scan_table,The following statement contains a magic number: for (i = 0; i < Process.zargs[2]; i++) {                if ( (Process.zargs[3] & 0x80) > 0) {	/* scan word array */                    zword wvalue;                    FastMem.LOW_WORD(addr' out wvalue);                    if (wvalue == Process.zargs[0])                  goto finished;                } else {		/* scan byte array */                    zbyte bvalue;                    FastMem.LOW_BYTE (addr' out bvalue);                    if (bvalue == Process.zargs[0])                  goto finished;                }                addr += (zword)(Process.zargs[3] & 0x7f);                }
Magic Number,Frotz.Generic,Table,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\table.cs,z_storeb,The following statement contains a magic number: FastMem.storeb((zword)(Process.zargs[0] + Process.zargs[1])' (byte)Process.zargs[2]);
Magic Number,Frotz.Generic,Table,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\table.cs,z_storew,The following statement contains a magic number: FastMem.storew((zword)(Process.zargs[0] + 2 * Process.zargs[1])' Process.zargs[2]);
Magic Number,Frotz.Generic,Table,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\table.cs,z_storew,The following statement contains a magic number: FastMem.storew((zword)(Process.zargs[0] + 2 * Process.zargs[1])' Process.zargs[2]);
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,translate_from_zscii,The following statement contains a magic number: if (c >= 0x9b && main.story_id != Story.BEYOND_ZORK) {                    if (main.hx_unicode_table != 0) {	/* game has its own Unicode table */                        zbyte N;                        FastMem.LOW_BYTE(main.hx_unicode_table' out N);                        if (c - 0x9b < N) {                            zword addr = (zword)(main.hx_unicode_table + 1 + 2 * (c - 0x9b));                          zword unicode;                            FastMem.LOW_WORD(addr' out unicode);                            if (unicode < 0x20)                              return '?';                            return unicode;                        } else return '?';                    } else				/* game uses standard set */                        if (c <= 0xdf) {                            return zscii_to_latin1[c - 0x9b];                        } else return '?';              }
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,unicode_to_zscii,The following statement contains a magic number: if (c >= CharCodes.ZC_LATIN1_MIN) {                    if (main.hx_unicode_table != 0) {	/* game has its own Unicode table */                        zbyte N;                        FastMem.LOW_BYTE(main.hx_unicode_table' out N);                        for (i = 0x9b; i < 0x9b + N; i++) {                            zword addr = (zword)(main.hx_unicode_table + 1 + 2 * (i - 0x9b));                          zword unicode;                            FastMem.LOW_WORD(addr' out unicode);                            if (c == unicode)                              return (zbyte)i;                        }                        return 0;                    } else {			/* game uses standard set */                        for (i = 0x9b; i <= 0xdf; i++)                          if (c == zscii_to_latin1[i - 0x9b])                              return (zbyte)i;                        return 0;                    }              }
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,alphabet,The following statement contains a magic number: if (main.h_version > ZMachine.V1 && set == 2 && index == 1)                  return 0x0D;
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,alphabet,The following statement contains a magic number: if (main.h_alphabet != 0) {	/* game uses its own alphabet */                    zbyte c;                    zword addr = (zword)(main.h_alphabet + 26 * set + index);                  FastMem.LOW_BYTE(addr' out c);                    return translate_from_zscii(c);                } else			/* game uses default alphabet */                    if (set == 0)                      return (zword)('a' + index);                  else if (set == 1)                      return (zword)('A' + index);                  else if (main.h_version == ZMachine.V1)                      return " 0123456789.'!?_#'\"/\\<-:()"[index];                  else                      return " ^0123456789.'!?_#'\"/\\-:()"[index];
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,find_resolution,The following statement contains a magic number: resolution = (main.h_version <= ZMachine.V3) ? 2 : 3;
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,find_resolution,The following statement contains a magic number: resolution = (main.h_version <= ZMachine.V3) ? 2 : 3;
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,find_resolution,The following statement contains a magic number: if (2 * resolution > entry_len) {                    Err.runtime_error(ErrorCodes.ERR_DICT_LEN);                }
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,find_resolution,The following statement contains a magic number: decoded = new zword[3 * resolution + 1];
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,load_string,The following statement contains a magic number: while (i < 3 * resolution)                    if (i < length) {                        zbyte c;                        FastMem.LOW_BYTE(addr' out c);                      addr++;                        decoded[i++] = Text.translate_from_zscii(c);                    } else decoded[i++] = 0;
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,encode_text,The following statement contains a magic number: zchars = new zbyte[3 * (resolution + 1)];
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,encode_text,The following statement contains a magic number: while (i < 3 * resolution)                    if ( (ptr < decoded.Length) && (c = decoded[ptr++]) != 0) {                        int index' set;                      zbyte c2;                        if (c == 32) {                            zchars[i++] = 0;                            continue;                        }                        /* Search character in the alphabet */                        for (set = 0; set < 3; set++)                          for (index = 0; index < 26; index++)                              if (c == alphabet(set' index))                                  goto letter_found;                        /* Character not found' store its ZSCII value */                        c2 = translate_to_zscii(c);                        zchars[i++] = 5;                      zchars[i++] = 6;                      zchars[i++] = (zbyte)(c2 >> 5);                      zchars[i++] = (zbyte)(c2 & 0x1f);                        continue;                    letter_found:                        /* Character found' store its index */                        if (set != 0)                          zchars[i++] = (zbyte)(((main.h_version <= ZMachine.V2) ? 1 : 3) + set);                        zchars[i++] = (zbyte)(index + 6);                    } else zchars[i++] = (zbyte)padding;
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,encode_text,The following statement contains a magic number: while (i < 3 * resolution)                    if ( (ptr < decoded.Length) && (c = decoded[ptr++]) != 0) {                        int index' set;                      zbyte c2;                        if (c == 32) {                            zchars[i++] = 0;                            continue;                        }                        /* Search character in the alphabet */                        for (set = 0; set < 3; set++)                          for (index = 0; index < 26; index++)                              if (c == alphabet(set' index))                                  goto letter_found;                        /* Character not found' store its ZSCII value */                        c2 = translate_to_zscii(c);                        zchars[i++] = 5;                      zchars[i++] = 6;                      zchars[i++] = (zbyte)(c2 >> 5);                      zchars[i++] = (zbyte)(c2 & 0x1f);                        continue;                    letter_found:                        /* Character found' store its index */                        if (set != 0)                          zchars[i++] = (zbyte)(((main.h_version <= ZMachine.V2) ? 1 : 3) + set);                        zchars[i++] = (zbyte)(index + 6);                    } else zchars[i++] = (zbyte)padding;
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,encode_text,The following statement contains a magic number: while (i < 3 * resolution)                    if ( (ptr < decoded.Length) && (c = decoded[ptr++]) != 0) {                        int index' set;                      zbyte c2;                        if (c == 32) {                            zchars[i++] = 0;                            continue;                        }                        /* Search character in the alphabet */                        for (set = 0; set < 3; set++)                          for (index = 0; index < 26; index++)                              if (c == alphabet(set' index))                                  goto letter_found;                        /* Character not found' store its ZSCII value */                        c2 = translate_to_zscii(c);                        zchars[i++] = 5;                      zchars[i++] = 6;                      zchars[i++] = (zbyte)(c2 >> 5);                      zchars[i++] = (zbyte)(c2 & 0x1f);                        continue;                    letter_found:                        /* Character found' store its index */                        if (set != 0)                          zchars[i++] = (zbyte)(((main.h_version <= ZMachine.V2) ? 1 : 3) + set);                        zchars[i++] = (zbyte)(index + 6);                    } else zchars[i++] = (zbyte)padding;
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,encode_text,The following statement contains a magic number: while (i < 3 * resolution)                    if ( (ptr < decoded.Length) && (c = decoded[ptr++]) != 0) {                        int index' set;                      zbyte c2;                        if (c == 32) {                            zchars[i++] = 0;                            continue;                        }                        /* Search character in the alphabet */                        for (set = 0; set < 3; set++)                          for (index = 0; index < 26; index++)                              if (c == alphabet(set' index))                                  goto letter_found;                        /* Character not found' store its ZSCII value */                        c2 = translate_to_zscii(c);                        zchars[i++] = 5;                      zchars[i++] = 6;                      zchars[i++] = (zbyte)(c2 >> 5);                      zchars[i++] = (zbyte)(c2 & 0x1f);                        continue;                    letter_found:                        /* Character found' store its index */                        if (set != 0)                          zchars[i++] = (zbyte)(((main.h_version <= ZMachine.V2) ? 1 : 3) + set);                        zchars[i++] = (zbyte)(index + 6);                    } else zchars[i++] = (zbyte)padding;
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,encode_text,The following statement contains a magic number: while (i < 3 * resolution)                    if ( (ptr < decoded.Length) && (c = decoded[ptr++]) != 0) {                        int index' set;                      zbyte c2;                        if (c == 32) {                            zchars[i++] = 0;                            continue;                        }                        /* Search character in the alphabet */                        for (set = 0; set < 3; set++)                          for (index = 0; index < 26; index++)                              if (c == alphabet(set' index))                                  goto letter_found;                        /* Character not found' store its ZSCII value */                        c2 = translate_to_zscii(c);                        zchars[i++] = 5;                      zchars[i++] = 6;                      zchars[i++] = (zbyte)(c2 >> 5);                      zchars[i++] = (zbyte)(c2 & 0x1f);                        continue;                    letter_found:                        /* Character found' store its index */                        if (set != 0)                          zchars[i++] = (zbyte)(((main.h_version <= ZMachine.V2) ? 1 : 3) + set);                        zchars[i++] = (zbyte)(index + 6);                    } else zchars[i++] = (zbyte)padding;
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,encode_text,The following statement contains a magic number: while (i < 3 * resolution)                    if ( (ptr < decoded.Length) && (c = decoded[ptr++]) != 0) {                        int index' set;                      zbyte c2;                        if (c == 32) {                            zchars[i++] = 0;                            continue;                        }                        /* Search character in the alphabet */                        for (set = 0; set < 3; set++)                          for (index = 0; index < 26; index++)                              if (c == alphabet(set' index))                                  goto letter_found;                        /* Character not found' store its ZSCII value */                        c2 = translate_to_zscii(c);                        zchars[i++] = 5;                      zchars[i++] = 6;                      zchars[i++] = (zbyte)(c2 >> 5);                      zchars[i++] = (zbyte)(c2 & 0x1f);                        continue;                    letter_found:                        /* Character found' store its index */                        if (set != 0)                          zchars[i++] = (zbyte)(((main.h_version <= ZMachine.V2) ? 1 : 3) + set);                        zchars[i++] = (zbyte)(index + 6);                    } else zchars[i++] = (zbyte)padding;
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,encode_text,The following statement contains a magic number: while (i < 3 * resolution)                    if ( (ptr < decoded.Length) && (c = decoded[ptr++]) != 0) {                        int index' set;                      zbyte c2;                        if (c == 32) {                            zchars[i++] = 0;                            continue;                        }                        /* Search character in the alphabet */                        for (set = 0; set < 3; set++)                          for (index = 0; index < 26; index++)                              if (c == alphabet(set' index))                                  goto letter_found;                        /* Character not found' store its ZSCII value */                        c2 = translate_to_zscii(c);                        zchars[i++] = 5;                      zchars[i++] = 6;                      zchars[i++] = (zbyte)(c2 >> 5);                      zchars[i++] = (zbyte)(c2 & 0x1f);                        continue;                    letter_found:                        /* Character found' store its index */                        if (set != 0)                          zchars[i++] = (zbyte)(((main.h_version <= ZMachine.V2) ? 1 : 3) + set);                        zchars[i++] = (zbyte)(index + 6);                    } else zchars[i++] = (zbyte)padding;
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,encode_text,The following statement contains a magic number: while (i < 3 * resolution)                    if ( (ptr < decoded.Length) && (c = decoded[ptr++]) != 0) {                        int index' set;                      zbyte c2;                        if (c == 32) {                            zchars[i++] = 0;                            continue;                        }                        /* Search character in the alphabet */                        for (set = 0; set < 3; set++)                          for (index = 0; index < 26; index++)                              if (c == alphabet(set' index))                                  goto letter_found;                        /* Character not found' store its ZSCII value */                        c2 = translate_to_zscii(c);                        zchars[i++] = 5;                      zchars[i++] = 6;                      zchars[i++] = (zbyte)(c2 >> 5);                      zchars[i++] = (zbyte)(c2 & 0x1f);                        continue;                    letter_found:                        /* Character found' store its index */                        if (set != 0)                          zchars[i++] = (zbyte)(((main.h_version <= ZMachine.V2) ? 1 : 3) + set);                        zchars[i++] = (zbyte)(index + 6);                    } else zchars[i++] = (zbyte)padding;
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,encode_text,The following statement contains a magic number: while (i < 3 * resolution)                    if ( (ptr < decoded.Length) && (c = decoded[ptr++]) != 0) {                        int index' set;                      zbyte c2;                        if (c == 32) {                            zchars[i++] = 0;                            continue;                        }                        /* Search character in the alphabet */                        for (set = 0; set < 3; set++)                          for (index = 0; index < 26; index++)                              if (c == alphabet(set' index))                                  goto letter_found;                        /* Character not found' store its ZSCII value */                        c2 = translate_to_zscii(c);                        zchars[i++] = 5;                      zchars[i++] = 6;                      zchars[i++] = (zbyte)(c2 >> 5);                      zchars[i++] = (zbyte)(c2 & 0x1f);                        continue;                    letter_found:                        /* Character found' store its index */                        if (set != 0)                          zchars[i++] = (zbyte)(((main.h_version <= ZMachine.V2) ? 1 : 3) + set);                        zchars[i++] = (zbyte)(index + 6);                    } else zchars[i++] = (zbyte)padding;
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,encode_text,The following statement contains a magic number: for (i = 0; i < resolution; i++)                    encoded[i] = (zword)(                      (zchars[3 * i + 0] << 10) |                      (zchars[3 * i + 1] << 5) |                      (zchars[3 * i + 2]));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,encode_text,The following statement contains a magic number: for (i = 0; i < resolution; i++)                    encoded[i] = (zword)(                      (zchars[3 * i + 0] << 10) |                      (zchars[3 * i + 1] << 5) |                      (zchars[3 * i + 2]));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,encode_text,The following statement contains a magic number: for (i = 0; i < resolution; i++)                    encoded[i] = (zword)(                      (zchars[3 * i + 0] << 10) |                      (zchars[3 * i + 1] << 5) |                      (zchars[3 * i + 2]));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,encode_text,The following statement contains a magic number: for (i = 0; i < resolution; i++)                    encoded[i] = (zword)(                      (zchars[3 * i + 0] << 10) |                      (zchars[3 * i + 1] << 5) |                      (zchars[3 * i + 2]));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,encode_text,The following statement contains a magic number: for (i = 0; i < resolution; i++)                    encoded[i] = (zword)(                      (zchars[3 * i + 0] << 10) |                      (zchars[3 * i + 1] << 5) |                      (zchars[3 * i + 2]));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,encode_text,The following statement contains a magic number: for (i = 0; i < resolution; i++)                    encoded[i] = (zword)(                      (zchars[3 * i + 0] << 10) |                      (zchars[3 * i + 1] << 5) |                      (zchars[3 * i + 2]));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,z_check_unicode,The following statement contains a magic number: if (c <= 0x1f)              {              if ((c == 0x08) || (c == 0x0d) || (c == 0x1b))                  result = 2;              }              else if (c <= 0x7e)              result = 3;              else              result = os_.check_unicode (Screen.get_window_font(main.cwin)' c);
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,z_check_unicode,The following statement contains a magic number: if (c <= 0x1f)              {              if ((c == 0x08) || (c == 0x0d) || (c == 0x1b))                  result = 2;              }              else if (c <= 0x7e)              result = 3;              else              result = os_.check_unicode (Screen.get_window_font(main.cwin)' c);
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,z_encode_text,The following statement contains a magic number: load_string ((zword) (Process.zargs[0] + Process.zargs[2])' Process.zargs[1]);
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,z_encode_text,The following statement contains a magic number: for (i = 0; i < resolution; i++)              FastMem.storew ((zword) (Process.zargs[3] + 2 * i)' encoded[i]);
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,z_encode_text,The following statement contains a magic number: for (i = 0; i < resolution; i++)              FastMem.storew ((zword) (Process.zargs[3] + 2 * i)' encoded[i]);
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: if (st == string_type.ABBREVIATION)                  byte_addr = (long)addr << 1;                else if (st == string_type.HIGH_STRING) {                    if (main.h_version <= ZMachine.V3)                      byte_addr = (long)addr << 1;                  else if (main.h_version <= ZMachine.V5)                      byte_addr = (long)addr << 2;                  else if (main.h_version <= ZMachine.V7)                      byte_addr = ((long)addr << 2) + ((long)main.h_strings_offset << 3);                  else /* (h_version <= V8) */                      byte_addr = (long)addr << 3;                    if (byte_addr >= main.story_size)                      Err.runtime_error(ErrorCodes.ERR_ILL_PRINT_ADDR);                }
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: if (st == string_type.ABBREVIATION)                  byte_addr = (long)addr << 1;                else if (st == string_type.HIGH_STRING) {                    if (main.h_version <= ZMachine.V3)                      byte_addr = (long)addr << 1;                  else if (main.h_version <= ZMachine.V5)                      byte_addr = (long)addr << 2;                  else if (main.h_version <= ZMachine.V7)                      byte_addr = ((long)addr << 2) + ((long)main.h_strings_offset << 3);                  else /* (h_version <= V8) */                      byte_addr = (long)addr << 3;                    if (byte_addr >= main.story_size)                      Err.runtime_error(ErrorCodes.ERR_ILL_PRINT_ADDR);                }
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: if (st == string_type.ABBREVIATION)                  byte_addr = (long)addr << 1;                else if (st == string_type.HIGH_STRING) {                    if (main.h_version <= ZMachine.V3)                      byte_addr = (long)addr << 1;                  else if (main.h_version <= ZMachine.V5)                      byte_addr = (long)addr << 2;                  else if (main.h_version <= ZMachine.V7)                      byte_addr = ((long)addr << 2) + ((long)main.h_strings_offset << 3);                  else /* (h_version <= V8) */                      byte_addr = (long)addr << 3;                    if (byte_addr >= main.story_size)                      Err.runtime_error(ErrorCodes.ERR_ILL_PRINT_ADDR);                }
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: if (st == string_type.ABBREVIATION)                  byte_addr = (long)addr << 1;                else if (st == string_type.HIGH_STRING) {                    if (main.h_version <= ZMachine.V3)                      byte_addr = (long)addr << 1;                  else if (main.h_version <= ZMachine.V5)                      byte_addr = (long)addr << 2;                  else if (main.h_version <= ZMachine.V7)                      byte_addr = ((long)addr << 2) + ((long)main.h_strings_offset << 3);                  else /* (h_version <= V8) */                      byte_addr = (long)addr << 3;                    if (byte_addr >= main.story_size)                      Err.runtime_error(ErrorCodes.ERR_ILL_PRINT_ADDR);                }
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following statement contains a magic number: do {                    int i;                    /* Fetch the next 16bit word */                    if (st == string_type.LOW_STRING || st == string_type.VOCABULARY) {                      FastMem.LOW_WORD(addr' out code);                      addr += 2;                  } else if (st == string_type.HIGH_STRING || st == string_type.ABBREVIATION) {                      FastMem.HIGH_WORD(byte_addr' out code);                      byte_addr += 2;                  } else                      FastMem.CODE_WORD(out code);                    /* Read its three Z-characters */                    for (i = 10; i >= 0; i -= 5) {                        zword abbr_addr;                      zword ptr_addr;                      zword zc;                        c = (zbyte)((code >> i) & 0x1f);                        switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }                        prev_c = c;                    }                } while (!((code & 0x8000) > 0));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,z_print_form,The following statement contains a magic number: for (;;) {                FastMem.LOW_WORD (addr' out count);              addr += 2;                if (count == 0)                  break;                if (!first)                  Buffer.new_line ();                while (count-- > 0) {                    zbyte c;                    FastMem.LOW_BYTE(addr' out c);                  addr++;                    Buffer.print_char (translate_from_zscii (c));                }                first = false ;                }
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,print_num,The following statement contains a magic number: for (i = 10000; i != 0; i /= 10)                  if (value >= i || i == 1)                      Buffer.print_char((zword)('0' + (value / i) % 10));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,print_num,The following statement contains a magic number: for (i = 10000; i != 0; i /= 10)                  if (value >= i || i == 1)                      Buffer.print_char((zword)('0' + (value / i) % 10));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,print_num,The following statement contains a magic number: for (i = 10000; i != 0; i /= 10)                  if (value >= i || i == 1)                      Buffer.print_char((zword)('0' + (value / i) % 10));
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,lookup_text,The following statement contains a magic number: dct += 2;
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,lookup_text,The following statement contains a magic number: while (lower <= upper) {                    if (sorted)                             /* binary search */                      entry_number = (lower + upper) / 2;                  else                                    /* linear search */                      entry_number = lower;                    entry_addr = (zword)(dct + entry_number * entry_len);                    /* Compare word to dictionary entry */                    addr = entry_addr;                    for (i = 0; i < resolution; i++) {                      FastMem.LOW_WORD(addr' out entry);                      if (encoded[i] != entry)                          goto continuing;                      addr += 2;                  }                    return entry_addr;		/* exact match found' return now */                continuing:                    if (sorted)				/* binary search */                        if (encoded[i] > entry)                          lower = entry_number + 1;                      else                          upper = entry_number - 1;                    else lower++;                           /* linear search */                }
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,lookup_text,The following statement contains a magic number: while (lower <= upper) {                    if (sorted)                             /* binary search */                      entry_number = (lower + upper) / 2;                  else                                    /* linear search */                      entry_number = lower;                    entry_addr = (zword)(dct + entry_number * entry_len);                    /* Compare word to dictionary entry */                    addr = entry_addr;                    for (i = 0; i < resolution; i++) {                      FastMem.LOW_WORD(addr' out entry);                      if (encoded[i] != entry)                          goto continuing;                      addr += 2;                  }                    return entry_addr;		/* exact match found' return now */                continuing:                    if (sorted)				/* binary search */                        if (encoded[i] > entry)                          lower = entry_number + 1;                      else                          upper = entry_number - 1;                    else lower++;                           /* linear search */                }
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,tokenise_text,The following statement contains a magic number: if (token_count < token_max) {	/* sufficient space left for token? */                    FastMem.storeb(parse++' (zbyte)(token_count + 1));                    load_string((zword)(text + from)' length);                    addr = lookup_text(0x05' dct);                    if (addr != 0 || !flag) {                        parse += (zword)(4 * token_count); // Will parse get updated properly?                        FastMem.storew((zword)(parse + 0)' addr);                      FastMem.storeb((zword)(parse + 2)' (zbyte)length);                      FastMem.storeb((zword)(parse + 3)' (zbyte)from);                    }                }
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,tokenise_text,The following statement contains a magic number: if (token_count < token_max) {	/* sufficient space left for token? */                    FastMem.storeb(parse++' (zbyte)(token_count + 1));                    load_string((zword)(text + from)' length);                    addr = lookup_text(0x05' dct);                    if (addr != 0 || !flag) {                        parse += (zword)(4 * token_count); // Will parse get updated properly?                        FastMem.storew((zword)(parse + 0)' addr);                      FastMem.storeb((zword)(parse + 2)' (zbyte)length);                      FastMem.storeb((zword)(parse + 3)' (zbyte)from);                    }                }
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,tokenise_text,The following statement contains a magic number: if (token_count < token_max) {	/* sufficient space left for token? */                    FastMem.storeb(parse++' (zbyte)(token_count + 1));                    load_string((zword)(text + from)' length);                    addr = lookup_text(0x05' dct);                    if (addr != 0 || !flag) {                        parse += (zword)(4 * token_count); // Will parse get updated properly?                        FastMem.storew((zword)(parse + 0)' addr);                      FastMem.storeb((zword)(parse + 2)' (zbyte)length);                      FastMem.storeb((zword)(parse + 3)' (zbyte)from);                    }                }
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,tokenise_line,The following statement contains a magic number: do {                    zword sep_addr;                  zbyte sep_count;                  zbyte separator;                    /* Fetch next ZSCII character */                    addr1++;                    if (main.h_version >= ZMachine.V5 && addr1 == text + 2 + length)                      c = 0;                  else                      FastMem.LOW_BYTE(addr1' out c);                    /* Check for separator */                    sep_addr = dct;                    FastMem.LOW_BYTE(sep_addr' out sep_count);                  sep_addr++;                    do {                        FastMem.LOW_BYTE(sep_addr' out separator);                      sep_addr++;                    } while (c != separator && --sep_count != 0);                    /* This could be the start or the end of a word */                    if (sep_count == 0 && c != ' ' && c != 0) {                        if (addr2 == 0)                          addr2 = addr1;                    } else if (addr2 != 0) {                        tokenise_text(                      text'                      (zword)(addr1 - addr2)'                      (zword)(addr2 - text)'                      token' dct' flag);                        addr2 = 0;                    }                    /* Translate separator (which is a word in its own right) */                    if (sep_count != 0)                        tokenise_text(                      text'                      (zword)(1)'                      (zword)(addr1 - text)'                      token' dct' flag);                } while (c != 0);
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,z_tokenise,The following statement contains a magic number: if (Process.zargc < 3)                  Process.zargs[2] = 0;
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,z_tokenise,The following statement contains a magic number: if (Process.zargc < 3)                  Process.zargs[2] = 0;
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,z_tokenise,The following statement contains a magic number: if (Process.zargc < 4)                  Process.zargs[3] = 0;
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,z_tokenise,The following statement contains a magic number: if (Process.zargc < 4)                  Process.zargs[3] = 0;
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,z_tokenise,The following statement contains a magic number: tokenise_line(Process.zargs[0]' Process.zargs[1]' Process.zargs[2]' Process.zargs[3] != 0);
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,z_tokenise,The following statement contains a magic number: tokenise_line(Process.zargs[0]' Process.zargs[1]' Process.zargs[2]' Process.zargs[3] != 0);
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,completion,The following statement contains a magic number: while ((pos < buffer.Length && (c = buffer[pos++]) != 0))              {                    if (c != ' ')                  {                        if (len < 3 * resolution)                          decoded[len++] = c;                    }                  else len = 0;              }
Magic Number,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,completion,The following statement contains a magic number: if (minaddr == 0 || maxaddr == 0 || minaddr > maxaddr)              return 2;
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_dec,The following statement contains a magic number: if (Process.zargs[0] == 0)                  (main.stack[main.sp])--;              else if (Process.zargs[0] < 16)                  (main.stack[main.fp - Process.zargs[0]])--;              else {                  zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));                  FastMem.LOW_WORD(addr' out value);                  value--;                  FastMem.SET_WORD(addr' value);              }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_dec,The following statement contains a magic number: if (Process.zargs[0] == 0)                  (main.stack[main.sp])--;              else if (Process.zargs[0] < 16)                  (main.stack[main.fp - Process.zargs[0]])--;              else {                  zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));                  FastMem.LOW_WORD(addr' out value);                  value--;                  FastMem.SET_WORD(addr' value);              }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_dec,The following statement contains a magic number: if (Process.zargs[0] == 0)                  (main.stack[main.sp])--;              else if (Process.zargs[0] < 16)                  (main.stack[main.fp - Process.zargs[0]])--;              else {                  zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));                  FastMem.LOW_WORD(addr' out value);                  value--;                  FastMem.SET_WORD(addr' value);              }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_dec_chk,The following statement contains a magic number: if (Process.zargs[0] == 0)                  value = --(main.stack[main.sp]);              else if (Process.zargs[0] < 16)                  value = --(main.stack[main.fp - Process.zargs[0]]);              else {                  zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));                  FastMem.LOW_WORD(addr' out value);                  value--;                  FastMem.SET_WORD(addr' value);              }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_dec_chk,The following statement contains a magic number: if (Process.zargs[0] == 0)                  value = --(main.stack[main.sp]);              else if (Process.zargs[0] < 16)                  value = --(main.stack[main.fp - Process.zargs[0]]);              else {                  zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));                  FastMem.LOW_WORD(addr' out value);                  value--;                  FastMem.SET_WORD(addr' value);              }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_dec_chk,The following statement contains a magic number: if (Process.zargs[0] == 0)                  value = --(main.stack[main.sp]);              else if (Process.zargs[0] < 16)                  value = --(main.stack[main.fp - Process.zargs[0]]);              else {                  zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));                  FastMem.LOW_WORD(addr' out value);                  value--;                  FastMem.SET_WORD(addr' value);              }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_inc,The following statement contains a magic number: if (Process.zargs[0] == 0)                  main.stack[main.sp]++; // (*sp)++;              else if (Process.zargs[0] < 16)                  (main.stack[main.fp - Process.zargs[0]])++;              else {                  zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));                  FastMem.LOW_WORD(addr' out value);                  value++;                  FastMem.SET_WORD(addr' value);              }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_inc,The following statement contains a magic number: if (Process.zargs[0] == 0)                  main.stack[main.sp]++; // (*sp)++;              else if (Process.zargs[0] < 16)                  (main.stack[main.fp - Process.zargs[0]])++;              else {                  zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));                  FastMem.LOW_WORD(addr' out value);                  value++;                  FastMem.SET_WORD(addr' value);              }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_inc,The following statement contains a magic number: if (Process.zargs[0] == 0)                  main.stack[main.sp]++; // (*sp)++;              else if (Process.zargs[0] < 16)                  (main.stack[main.fp - Process.zargs[0]])++;              else {                  zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));                  FastMem.LOW_WORD(addr' out value);                  value++;                  FastMem.SET_WORD(addr' value);              }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_inc_chk,The following statement contains a magic number: if (Process.zargs[0] == 0)                  value = ++(main.stack[main.sp]);              else if (Process.zargs[0] < 16)                  value = ++(main.stack[main.fp - Process.zargs[0]]);              else {                  zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));                  FastMem.LOW_WORD(addr' out value);                  value++;                  FastMem.SET_WORD(addr' value);              }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_inc_chk,The following statement contains a magic number: if (Process.zargs[0] == 0)                  value = ++(main.stack[main.sp]);              else if (Process.zargs[0] < 16)                  value = ++(main.stack[main.fp - Process.zargs[0]]);              else {                  zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));                  FastMem.LOW_WORD(addr' out value);                  value++;                  FastMem.SET_WORD(addr' value);              }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_inc_chk,The following statement contains a magic number: if (Process.zargs[0] == 0)                  value = ++(main.stack[main.sp]);              else if (Process.zargs[0] < 16)                  value = ++(main.stack[main.fp - Process.zargs[0]]);              else {                  zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));                  FastMem.LOW_WORD(addr' out value);                  value++;                  FastMem.SET_WORD(addr' value);              }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_load,The following statement contains a magic number: if (Process.zargs[0] == 0)              value = main.stack[main.sp];              else if (Process.zargs[0] < 16)              value = main.stack[main.fp - Process.zargs[0]];              else {                  zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));              FastMem.LOW_WORD(addr' out value);              }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_load,The following statement contains a magic number: if (Process.zargs[0] == 0)              value = main.stack[main.sp];              else if (Process.zargs[0] < 16)              value = main.stack[main.fp - Process.zargs[0]];              else {                  zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));              FastMem.LOW_WORD(addr' out value);              }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_load,The following statement contains a magic number: if (Process.zargs[0] == 0)              value = main.stack[main.sp];              else if (Process.zargs[0] < 16)              value = main.stack[main.fp - Process.zargs[0]];              else {                  zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));              FastMem.LOW_WORD(addr' out value);              }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_pop_stack,The following statement contains a magic number: if (Process.zargc == 2) {		/* it's a user stack */                zword size;              zword addr = Process.zargs[1];                FastMem.LOW_WORD(addr' out size);                size += Process.zargs[0];              FastMem.storew (addr' size);                } else main.sp += Process.zargs[0];
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_pull,The following statement contains a magic number: if (main.h_version != ZMachine.V6) {	/* not a V6 game' pop stack and write */                    value = main.stack[main.sp++];                    if (Process.zargs[0] == 0)                      main.stack[main.sp] = value;                  else if (Process.zargs[0] < 16)                      // *(fp - Process.zargs[0]) = value;                      main.stack[main.fp - Process.zargs[0]] = value;                  else {                      zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));                      FastMem.SET_WORD(addr' value);                  }                } else {			/* it's V6' but is there a user stack? */                    if (Process.zargc == 1) {	/* it's a user stack */                        zword size;                      zword addr = Process.zargs[0];                        FastMem.LOW_WORD(addr' out size);                        size++;                      FastMem.storew(addr' size);                        addr += (zword)(2 * size);                      FastMem.LOW_WORD(addr' out value);                    } else value = main.stack[main.sp++];// value = *sp++;	/* it's the game stack */                    Process.store(value);                }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_pull,The following statement contains a magic number: if (main.h_version != ZMachine.V6) {	/* not a V6 game' pop stack and write */                    value = main.stack[main.sp++];                    if (Process.zargs[0] == 0)                      main.stack[main.sp] = value;                  else if (Process.zargs[0] < 16)                      // *(fp - Process.zargs[0]) = value;                      main.stack[main.fp - Process.zargs[0]] = value;                  else {                      zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));                      FastMem.SET_WORD(addr' value);                  }                } else {			/* it's V6' but is there a user stack? */                    if (Process.zargc == 1) {	/* it's a user stack */                        zword size;                      zword addr = Process.zargs[0];                        FastMem.LOW_WORD(addr' out size);                        size++;                      FastMem.storew(addr' size);                        addr += (zword)(2 * size);                      FastMem.LOW_WORD(addr' out value);                    } else value = main.stack[main.sp++];// value = *sp++;	/* it's the game stack */                    Process.store(value);                }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_pull,The following statement contains a magic number: if (main.h_version != ZMachine.V6) {	/* not a V6 game' pop stack and write */                    value = main.stack[main.sp++];                    if (Process.zargs[0] == 0)                      main.stack[main.sp] = value;                  else if (Process.zargs[0] < 16)                      // *(fp - Process.zargs[0]) = value;                      main.stack[main.fp - Process.zargs[0]] = value;                  else {                      zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));                      FastMem.SET_WORD(addr' value);                  }                } else {			/* it's V6' but is there a user stack? */                    if (Process.zargc == 1) {	/* it's a user stack */                        zword size;                      zword addr = Process.zargs[0];                        FastMem.LOW_WORD(addr' out size);                        size++;                      FastMem.storew(addr' size);                        addr += (zword)(2 * size);                      FastMem.LOW_WORD(addr' out value);                    } else value = main.stack[main.sp++];// value = *sp++;	/* it's the game stack */                    Process.store(value);                }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_pull,The following statement contains a magic number: if (main.h_version != ZMachine.V6) {	/* not a V6 game' pop stack and write */                    value = main.stack[main.sp++];                    if (Process.zargs[0] == 0)                      main.stack[main.sp] = value;                  else if (Process.zargs[0] < 16)                      // *(fp - Process.zargs[0]) = value;                      main.stack[main.fp - Process.zargs[0]] = value;                  else {                      zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));                      FastMem.SET_WORD(addr' value);                  }                } else {			/* it's V6' but is there a user stack? */                    if (Process.zargc == 1) {	/* it's a user stack */                        zword size;                      zword addr = Process.zargs[0];                        FastMem.LOW_WORD(addr' out size);                        size++;                      FastMem.storew(addr' size);                        addr += (zword)(2 * size);                      FastMem.LOW_WORD(addr' out value);                    } else value = main.stack[main.sp++];// value = *sp++;	/* it's the game stack */                    Process.store(value);                }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_push_stack,The following statement contains a magic number: if (size != 0) {                FastMem.storew ((zword) (addr + 2 * size)' Process.zargs[0]);                size--;              FastMem.storew (addr' size);                }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_store,The following statement contains a magic number: if (Process.zargs[0] == 0)                  main.stack[main.sp] = value;              else if (Process.zargs[0] < 16)                  main.stack[main.fp - Process.zargs[0]] = value;              else {                  zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));                  FastMem.SET_WORD(addr' value);              }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_store,The following statement contains a magic number: if (Process.zargs[0] == 0)                  main.stack[main.sp] = value;              else if (Process.zargs[0] < 16)                  main.stack[main.fp - Process.zargs[0]] = value;              else {                  zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));                  FastMem.SET_WORD(addr' value);              }
Magic Number,Frotz.Generic,Variable,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\variable.cs,z_store,The following statement contains a magic number: if (Process.zargs[0] == 0)                  main.stack[main.sp] = value;              else if (Process.zargs[0] < 16)                  main.stack[main.fp - Process.zargs[0]] = value;              else {                  zword addr = (zword)(main.h_globals + 2 * (Process.zargs[0] - 16));                  FastMem.SET_WORD(addr' value);              }
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,ParsePng,The following statement contains a magic number: byte[] buffer = new byte[8];
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,ParsePng,The following statement contains a magic number: _stream.Read(buffer' 0' 8);
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,ParsePng,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  if (buffer[i] != _header[i])                  {                      throw new ArgumentException("Not a valid PNG file");                  }              }
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,CalcCRC,The following statement contains a magic number: byte[] temp = new byte[buffer.Length + 4];
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,CalcCRC,The following statement contains a magic number: Array.Copy(tempType' temp' 4);
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,CalcCRC,The following statement contains a magic number: Array.Copy(buffer' 0' temp' 4' buffer.Length);
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,readType,The following statement contains a magic number: byte[] buffer = new byte[4];
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,readType,The following statement contains a magic number: _stream.Read(buffer' 0' 4);
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,readInt,The following statement contains a magic number: byte[] buffer = new byte[4];
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,readInt,The following statement contains a magic number: _stream.Read(buffer' 0' 4);
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,readInt,The following statement contains a magic number: ulong c = buffer[2];
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,readInt,The following statement contains a magic number: ulong d = buffer[3];
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,readInt,The following statement contains a magic number: return ((ulong)(a << 24 | ((b) << 16) | ((c) << 8) | (d)));
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,readInt,The following statement contains a magic number: return ((ulong)(a << 24 | ((b) << 16) | ((c) << 8) | (d)));
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,readInt,The following statement contains a magic number: return ((ulong)(a << 24 | ((b) << 16) | ((c) << 8) | (d)));
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,Save,The following statement contains a magic number: Stream.Write(_header' 0' 8);
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,Save,The following statement contains a magic number: foreach (String type in _chunkOrder)              {                  PNGChunk chunk = _chunks[type];                    WriteLong(Stream' (ulong)chunk.Data.Length);                  Stream.WriteByte((byte)type[0]);                  Stream.WriteByte((byte)type[1]);                  Stream.WriteByte((byte)type[2]);                  Stream.WriteByte((byte)type[3]);                    Stream.Write(chunk.Data' 0' chunk.Data.Length);                    WriteLong(Stream' chunk.CRC);              }
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,Save,The following statement contains a magic number: foreach (String type in _chunkOrder)              {                  PNGChunk chunk = _chunks[type];                    WriteLong(Stream' (ulong)chunk.Data.Length);                  Stream.WriteByte((byte)type[0]);                  Stream.WriteByte((byte)type[1]);                  Stream.WriteByte((byte)type[2]);                  Stream.WriteByte((byte)type[3]);                    Stream.Write(chunk.Data' 0' chunk.Data.Length);                    WriteLong(Stream' chunk.CRC);              }
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,WriteLong,The following statement contains a magic number: s.WriteByte((byte)(l >> 24));
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,WriteLong,The following statement contains a magic number: s.WriteByte((byte)(l >> 16));
Magic Number,FrotzNetDLL.Frotz.Other,PNG,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\PNG.cs,WriteLong,The following statement contains a magic number: s.WriteByte((byte)(l >> 8));
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,TrueColorStuff,The following statement contains a magic number: m_colours = new long[11];
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,TrueColorStuff,The following statement contains a magic number: m_colours[2] = RGB5ToTrue(0x0340);
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,TrueColorStuff,The following statement contains a magic number: m_colours[3] = RGB5ToTrue(0x03BD);
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,TrueColorStuff,The following statement contains a magic number: m_colours[4] = RGB5ToTrue(0x59A0);
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,TrueColorStuff,The following statement contains a magic number: m_colours[5] = RGB5ToTrue(0x7C1F);
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,TrueColorStuff,The following statement contains a magic number: m_colours[6] = RGB5ToTrue(0x77A0);
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,TrueColorStuff,The following statement contains a magic number: m_colours[7] = RGB5ToTrue(0x7FFF);
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,TrueColorStuff,The following statement contains a magic number: m_colours[8] = RGB5ToTrue(0x5AD6);
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,TrueColorStuff,The following statement contains a magic number: m_colours[9] = RGB5ToTrue(0x4631);
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,TrueColorStuff,The following statement contains a magic number: m_colours[10] = RGB5ToTrue(0x2D6B);
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,RGB5ToTrue,The following statement contains a magic number: byte g = (byte)((five & 0x03E0) >> 5);
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,RGB5ToTrue,The following statement contains a magic number: byte b = (byte)((five & 0x7C00) >> 10);
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,RGB5ToTrue,The following statement contains a magic number: return RGB(                  (byte)((r << 3) | (r >> 2))'                  (byte)((g << 3) | (g >> 2))'                  (byte)((b << 3) | (b >> 2)));
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,RGB5ToTrue,The following statement contains a magic number: return RGB(                  (byte)((r << 3) | (r >> 2))'                  (byte)((g << 3) | (g >> 2))'                  (byte)((b << 3) | (b >> 2)));
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,RGB5ToTrue,The following statement contains a magic number: return RGB(                  (byte)((r << 3) | (r >> 2))'                  (byte)((g << 3) | (g >> 2))'                  (byte)((b << 3) | (b >> 2)));
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,RGB5ToTrue,The following statement contains a magic number: return RGB(                  (byte)((r << 3) | (r >> 2))'                  (byte)((g << 3) | (g >> 2))'                  (byte)((b << 3) | (b >> 2)));
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,RGB5ToTrue,The following statement contains a magic number: return RGB(                  (byte)((r << 3) | (r >> 2))'                  (byte)((g << 3) | (g >> 2))'                  (byte)((b << 3) | (b >> 2)));
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,RGB5ToTrue,The following statement contains a magic number: return RGB(                  (byte)((r << 3) | (r >> 2))'                  (byte)((g << 3) | (g >> 2))'                  (byte)((b << 3) | (b >> 2)));
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,RGB,The following statement contains a magic number: return r | g << 8 | b << 16;
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,RGB,The following statement contains a magic number: return r | g << 8 | b << 16;
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,TrueToRGB5,The following statement contains a magic number: int r = GetRValue(colour) >> 3;
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,TrueToRGB5,The following statement contains a magic number: int g = GetGValue(colour) >> 3;
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,TrueToRGB5,The following statement contains a magic number: int b = GetBValue(colour) >> 3;
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,TrueToRGB5,The following statement contains a magic number: return (zword)(r | (g << 5) | (b << 10));
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,TrueToRGB5,The following statement contains a magic number: return (zword)(r | (g << 5) | (b << 10));
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,GetGValue,The following statement contains a magic number: return LOBYTE(rgb >> 8);
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,GetBValue,The following statement contains a magic number: return LOBYTE(rgb >> 16);
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,GetColourIndex,The following statement contains a magic number: for (int i = 0; i < 11; i++)              {                  if (m_colours[i] == colour)                      return (zword)(i + ZColor.BLACK_COLOUR);              }
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,GetColourIndex,The following statement contains a magic number: if (m_defaultFore == colour)                  return 16;
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,GetColourIndex,The following statement contains a magic number: if (m_defaultBack == colour)                  return 17;
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,GetColourIndex,The following statement contains a magic number: for (int i = 0; i < NON_STD_COLS; i++)              {                  if (m_nonStdColours[i] == colour)                      return (zword)(i + 18);              }
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,GetColourIndex,The following statement contains a magic number: while (index == -1)              {                  if (Screen.colour_in_use(                      (zword)( m_nonStdIndex + 18 )) == 0)                  {                      m_nonStdColours[m_nonStdIndex] = colour;                      index = m_nonStdIndex + 18;                  }                    m_nonStdIndex++;                  if (m_nonStdIndex >= NON_STD_COLS)                      m_nonStdIndex = 0;              }
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,GetColourIndex,The following statement contains a magic number: while (index == -1)              {                  if (Screen.colour_in_use(                      (zword)( m_nonStdIndex + 18 )) == 0)                  {                      m_nonStdColours[m_nonStdIndex] = colour;                      index = m_nonStdIndex + 18;                  }                    m_nonStdIndex++;                  if (m_nonStdIndex >= NON_STD_COLS)                      m_nonStdIndex = 0;              }
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,GetColour,The following statement contains a magic number: if (colour == 16)                  return m_defaultFore;
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,GetColour,The following statement contains a magic number: if (colour == 17)                  return m_defaultBack;
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,GetColour,The following statement contains a magic number: if ((colour >= 18) && (colour < 256))              {                  if (m_nonStdColours[colour - 18] != 0xFFFFFFFF)                      return m_nonStdColours[colour - 18];              }
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,GetColour,The following statement contains a magic number: if ((colour >= 18) && (colour < 256))              {                  if (m_nonStdColours[colour - 18] != 0xFFFFFFFF)                      return m_nonStdColours[colour - 18];              }
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,GetColour,The following statement contains a magic number: if ((colour >= 18) && (colour < 256))              {                  if (m_nonStdColours[colour - 18] != 0xFFFFFFFF)                      return m_nonStdColours[colour - 18];              }
Magic Number,FrotzNet.Frotz.Other,TrueColorStuff,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Other\TrueColorStuff.cs,GetColour,The following statement contains a magic number: if ((colour >= 18) && (colour < 256))              {                  if (m_nonStdColours[colour - 18] != 0xFFFFFFFF)                      return m_nonStdColours[colour - 18];              }
Magic Number,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,makeid,The following statement contains a magic number: return ((long)(((a) << 24) | ((b) << 16) | ((c) << 8) | (d)));
Magic Number,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,makeid,The following statement contains a magic number: return ((long)(((a) << 24) | ((b) << 16) | ((c) << 8) | (d)));
Magic Number,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,makeid,The following statement contains a magic number: return ((long)(((a) << 24) | ((b) << 16) | ((c) << 8) | (d)));
Magic Number,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,makeid,The following statement contains a magic number: return makeid(buffer[offset]' buffer[offset + 1]' buffer[offset + 2]' buffer[offset + 3]);
Magic Number,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,makeid,The following statement contains a magic number: return makeid(buffer[offset]' buffer[offset + 1]' buffer[offset + 2]' buffer[offset + 3]);
Magic Number,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,beep,The following statement contains a magic number: if (number == 1)              {                  Console.Beep(800' 200);              }              else              {                  Console.Beep(392' 200);              }
Magic Number,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,beep,The following statement contains a magic number: if (number == 1)              {                  Console.Beep(800' 200);              }              else              {                  Console.Beep(392' 200);              }
Magic Number,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,beep,The following statement contains a magic number: if (number == 1)              {                  Console.Beep(800' 200);              }              else              {                  Console.Beep(392' 200);              }
Magic Number,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,beep,The following statement contains a magic number: if (number == 1)              {                  Console.Beep(800' 200);              }              else              {                  Console.Beep(392' 200);              }
Magic Number,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,erase_area,The following statement contains a magic number: if (win == -2)              {                  _screen.Clear();              }              else if (win == 1)              {                  _screen.ClearArea(top' left' bottom' right);              }              else              {                  _screen.ClearArea(top' left' bottom' right);              }
Magic Number,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,init_screen,The following statement contains a magic number: main.h_interpreter_number = 4;
Magic Number,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,more_prompt,The following statement contains a magic number: _screen.RemoveChars(6);
Magic Number,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,picture_data,The following statement contains a magic number: if (_blorbFile != null)              {                  if (picture == 0)                  {                      height = -1;                      width = -_blorbFile.ReleaseNumber;                      foreach (var p in _blorbFile.Pictures.Keys)                      {                          if (p > height)                          {                              height = p;                              width = _blorbFile.ReleaseNumber;                          }                      }                        return true;                  }                  else                  {                      byte[] buffer = _blorbFile.Pictures[picture].Image;                      if (buffer.Length == 8)                      { // TODO This is a bit of a hack' it would be better to handle this upfront so there is no guess work                          width = (int)makeid(buffer' 0) * _metrics.Scale;                          height = (int)makeid(buffer' 4) * _metrics.Scale;                      }                      else                      {                          ZSize size = _screen.GetImageInfo(buffer);                          height = size.Height;                          width = size.Width;                      }                        return true;                  }              }
Magic Number,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,picture_data,The following statement contains a magic number: if (_blorbFile != null)              {                  if (picture == 0)                  {                      height = -1;                      width = -_blorbFile.ReleaseNumber;                      foreach (var p in _blorbFile.Pictures.Keys)                      {                          if (p > height)                          {                              height = p;                              width = _blorbFile.ReleaseNumber;                          }                      }                        return true;                  }                  else                  {                      byte[] buffer = _blorbFile.Pictures[picture].Image;                      if (buffer.Length == 8)                      { // TODO This is a bit of a hack' it would be better to handle this upfront so there is no guess work                          width = (int)makeid(buffer' 0) * _metrics.Scale;                          height = (int)makeid(buffer' 4) * _metrics.Scale;                      }                      else                      {                          ZSize size = _screen.GetImageInfo(buffer);                          height = size.Height;                          width = size.Width;                      }                        return true;                  }              }
Magic Number,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,random_seed,The following statement contains a magic number: if (DebugState.IsActive)              {                  return DebugState.RandomSeed();              }              else              {                  System.Random r = new System.Random();                  return r.Next() & 32767;              }
Magic Number,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,path_open,The following statement contains a magic number: if (story_data.Length < 4)              {                  throw new ArgumentException("story_data isn't long enough");              }              else              {                  if (story_data[0] == (char)'F' && story_data[1] == (byte)'O' &&                      story_data[2] == (byte)'R' && story_data[3] == (byte)'M') {                      _blorbFile = Blorb.BlorbReader.ReadBlorbFile(story_data);                        return new System.IO.MemoryStream(_blorbFile.ZCode);                  }                  else                  {                      //FileStream fs = new FileStream(FileName' FileMode.Open' FileAccess.Read);                      //byte[] buffer = new byte[fs.Length];                      //fs.Read(buffer' 0' buffer.Length);                      //fs.Close();    #if !SILVERLIGHT                      String temp = Path.ChangeExtension(main.story_name' "blb");                      _blorbFile = null;                        if (File.Exists(temp))                      {                          var s = File.OpenRead(temp);                          byte[] buffer = new zbyte[s.Length];                          s.Read(buffer' 0' buffer.Length);                          s.Close();                          var tempB = Blorb.BlorbReader.ReadBlorbFile(buffer);                          _blorbFile = tempB;                      }  #endif                      return new MemoryStream(story_data);                  }              }
Magic Number,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,path_open,The following statement contains a magic number: if (story_data.Length < 4)              {                  throw new ArgumentException("story_data isn't long enough");              }              else              {                  if (story_data[0] == (char)'F' && story_data[1] == (byte)'O' &&                      story_data[2] == (byte)'R' && story_data[3] == (byte)'M') {                      _blorbFile = Blorb.BlorbReader.ReadBlorbFile(story_data);                        return new System.IO.MemoryStream(_blorbFile.ZCode);                  }                  else                  {                      //FileStream fs = new FileStream(FileName' FileMode.Open' FileAccess.Read);                      //byte[] buffer = new byte[fs.Length];                      //fs.Read(buffer' 0' buffer.Length);                      //fs.Close();    #if !SILVERLIGHT                      String temp = Path.ChangeExtension(main.story_name' "blb");                      _blorbFile = null;                        if (File.Exists(temp))                      {                          var s = File.OpenRead(temp);                          byte[] buffer = new zbyte[s.Length];                          s.Read(buffer' 0' buffer.Length);                          s.Close();                          var tempB = Blorb.BlorbReader.ReadBlorbFile(buffer);                          _blorbFile = tempB;                      }  #endif                      return new MemoryStream(story_data);                  }              }
Magic Number,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,path_open,The following statement contains a magic number: if (story_data.Length < 4)              {                  throw new ArgumentException("story_data isn't long enough");              }              else              {                  if (story_data[0] == (char)'F' && story_data[1] == (byte)'O' &&                      story_data[2] == (byte)'R' && story_data[3] == (byte)'M') {                      _blorbFile = Blorb.BlorbReader.ReadBlorbFile(story_data);                        return new System.IO.MemoryStream(_blorbFile.ZCode);                  }                  else                  {                      //FileStream fs = new FileStream(FileName' FileMode.Open' FileAccess.Read);                      //byte[] buffer = new byte[fs.Length];                      //fs.Read(buffer' 0' buffer.Length);                      //fs.Close();    #if !SILVERLIGHT                      String temp = Path.ChangeExtension(main.story_name' "blb");                      _blorbFile = null;                        if (File.Exists(temp))                      {                          var s = File.OpenRead(temp);                          byte[] buffer = new zbyte[s.Length];                          s.Read(buffer' 0' buffer.Length);                          s.Close();                          var tempB = Blorb.BlorbReader.ReadBlorbFile(buffer);                          _blorbFile = tempB;                      }  #endif                      return new MemoryStream(story_data);                  }              }
Magic Number,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,tick,The following statement contains a magic number: if (++os_tick_count > 1000)              {                  os_tick_count = 0;                  // TODO Implement sound at some point :)              }
Magic Number,Frotz.Screen,ScreenLines,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Screen\ScreenLines.cs,ScreenLines,The following statement contains a magic number: for (int i = 0; i < Rows; i++) {                  _lines.Add(new LineInfo(Columns * 3));              }
Magic Number,Frotz.Screen,ScreenLines,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Screen\ScreenLines.cs,Clear,The following statement contains a magic number: ClearArea(0' 0' Rows' Columns * 3);
Magic Number,Frotz.Screen,ScreenLines,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Screen\ScreenLines.cs,addLines,The following statement contains a magic number: while (_lines.Count <= Rows * 2) {                  lock (_lines) {                      _lines.Add(new LineInfo(Columns * 3));                  }              }
Magic Number,Frotz.Screen,ScreenLines,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Screen\ScreenLines.cs,addLines,The following statement contains a magic number: while (_lines.Count <= Rows * 2) {                  lock (_lines) {                      _lines.Add(new LineInfo(Columns * 3));                  }              }
Magic Number,ZTools,infinfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infinfo.cs,configure_inform_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  if (header.name[4] >= '6')                  {                      inform_version = (ushort)((header.name[4] - '0') * 100 + (header.name[6] - '0') * 10 + (header.name[7] - '0'));                      address = class_numbers_base = obj_data_end + 1;                      while (txio.read_data_word(ref address) > 0) /* do nothing */;                      class_numbers_end = address - 1;                      property_names_base = address;                      num_properties = (zword_t)(txio.read_data_word(ref address) - 1);                      address += (ulong)(num_properties * sizeof(zword_t));                      property_names_end = address - 1;                      if (inform_version >= tx_h.INFORM_610)                      {                          attr_names_base = address;                          address += (48 * sizeof(zword_t));                          attr_names_end = address - 1;                          /* then come the action names' the individual property values' the dynamic arrays' etc */                      }                  }              }              else                  inform_version = 0;
Magic Number,ZTools,infinfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infinfo.cs,configure_inform_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  if (header.name[4] >= '6')                  {                      inform_version = (ushort)((header.name[4] - '0') * 100 + (header.name[6] - '0') * 10 + (header.name[7] - '0'));                      address = class_numbers_base = obj_data_end + 1;                      while (txio.read_data_word(ref address) > 0) /* do nothing */;                      class_numbers_end = address - 1;                      property_names_base = address;                      num_properties = (zword_t)(txio.read_data_word(ref address) - 1);                      address += (ulong)(num_properties * sizeof(zword_t));                      property_names_end = address - 1;                      if (inform_version >= tx_h.INFORM_610)                      {                          attr_names_base = address;                          address += (48 * sizeof(zword_t));                          attr_names_end = address - 1;                          /* then come the action names' the individual property values' the dynamic arrays' etc */                      }                  }              }              else                  inform_version = 0;
Magic Number,ZTools,infinfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infinfo.cs,configure_inform_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  if (header.name[4] >= '6')                  {                      inform_version = (ushort)((header.name[4] - '0') * 100 + (header.name[6] - '0') * 10 + (header.name[7] - '0'));                      address = class_numbers_base = obj_data_end + 1;                      while (txio.read_data_word(ref address) > 0) /* do nothing */;                      class_numbers_end = address - 1;                      property_names_base = address;                      num_properties = (zword_t)(txio.read_data_word(ref address) - 1);                      address += (ulong)(num_properties * sizeof(zword_t));                      property_names_end = address - 1;                      if (inform_version >= tx_h.INFORM_610)                      {                          attr_names_base = address;                          address += (48 * sizeof(zword_t));                          attr_names_end = address - 1;                          /* then come the action names' the individual property values' the dynamic arrays' etc */                      }                  }              }              else                  inform_version = 0;
Magic Number,ZTools,infinfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infinfo.cs,configure_inform_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  if (header.name[4] >= '6')                  {                      inform_version = (ushort)((header.name[4] - '0') * 100 + (header.name[6] - '0') * 10 + (header.name[7] - '0'));                      address = class_numbers_base = obj_data_end + 1;                      while (txio.read_data_word(ref address) > 0) /* do nothing */;                      class_numbers_end = address - 1;                      property_names_base = address;                      num_properties = (zword_t)(txio.read_data_word(ref address) - 1);                      address += (ulong)(num_properties * sizeof(zword_t));                      property_names_end = address - 1;                      if (inform_version >= tx_h.INFORM_610)                      {                          attr_names_base = address;                          address += (48 * sizeof(zword_t));                          attr_names_end = address - 1;                          /* then come the action names' the individual property values' the dynamic arrays' etc */                      }                  }              }              else                  inform_version = 0;
Magic Number,ZTools,infinfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infinfo.cs,configure_inform_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  if (header.name[4] >= '6')                  {                      inform_version = (ushort)((header.name[4] - '0') * 100 + (header.name[6] - '0') * 10 + (header.name[7] - '0'));                      address = class_numbers_base = obj_data_end + 1;                      while (txio.read_data_word(ref address) > 0) /* do nothing */;                      class_numbers_end = address - 1;                      property_names_base = address;                      num_properties = (zword_t)(txio.read_data_word(ref address) - 1);                      address += (ulong)(num_properties * sizeof(zword_t));                      property_names_end = address - 1;                      if (inform_version >= tx_h.INFORM_610)                      {                          attr_names_base = address;                          address += (48 * sizeof(zword_t));                          attr_names_end = address - 1;                          /* then come the action names' the individual property values' the dynamic arrays' etc */                      }                  }              }              else                  inform_version = 0;
Magic Number,ZTools,infinfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infinfo.cs,configure_inform_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  if (header.name[4] >= '6')                  {                      inform_version = (ushort)((header.name[4] - '0') * 100 + (header.name[6] - '0') * 10 + (header.name[7] - '0'));                      address = class_numbers_base = obj_data_end + 1;                      while (txio.read_data_word(ref address) > 0) /* do nothing */;                      class_numbers_end = address - 1;                      property_names_base = address;                      num_properties = (zword_t)(txio.read_data_word(ref address) - 1);                      address += (ulong)(num_properties * sizeof(zword_t));                      property_names_end = address - 1;                      if (inform_version >= tx_h.INFORM_610)                      {                          attr_names_base = address;                          address += (48 * sizeof(zword_t));                          attr_names_end = address - 1;                          /* then come the action names' the individual property values' the dynamic arrays' etc */                      }                  }              }              else                  inform_version = 0;
Magic Number,ZTools,infinfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infinfo.cs,configure_inform_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  if (header.name[4] >= '6')                  {                      inform_version = (ushort)((header.name[4] - '0') * 100 + (header.name[6] - '0') * 10 + (header.name[7] - '0'));                      address = class_numbers_base = obj_data_end + 1;                      while (txio.read_data_word(ref address) > 0) /* do nothing */;                      class_numbers_end = address - 1;                      property_names_base = address;                      num_properties = (zword_t)(txio.read_data_word(ref address) - 1);                      address += (ulong)(num_properties * sizeof(zword_t));                      property_names_end = address - 1;                      if (inform_version >= tx_h.INFORM_610)                      {                          attr_names_base = address;                          address += (48 * sizeof(zword_t));                          attr_names_end = address - 1;                          /* then come the action names' the individual property values' the dynamic arrays' etc */                      }                  }              }              else                  inform_version = 0;
Magic Number,ZTools,infinfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infinfo.cs,configure_inform_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  if (header.name[4] >= '6')                  {                      inform_version = (ushort)((header.name[4] - '0') * 100 + (header.name[6] - '0') * 10 + (header.name[7] - '0'));                      address = class_numbers_base = obj_data_end + 1;                      while (txio.read_data_word(ref address) > 0) /* do nothing */;                      class_numbers_end = address - 1;                      property_names_base = address;                      num_properties = (zword_t)(txio.read_data_word(ref address) - 1);                      address += (ulong)(num_properties * sizeof(zword_t));                      property_names_end = address - 1;                      if (inform_version >= tx_h.INFORM_610)                      {                          attr_names_base = address;                          address += (48 * sizeof(zword_t));                          attr_names_end = address - 1;                          /* then come the action names' the individual property values' the dynamic arrays' etc */                      }                  }              }              else                  inform_version = 0;
Magic Number,ZTools,infinfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infinfo.cs,configure_inform_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  if (header.name[4] >= '6')                  {                      inform_version = (ushort)((header.name[4] - '0') * 100 + (header.name[6] - '0') * 10 + (header.name[7] - '0'));                      address = class_numbers_base = obj_data_end + 1;                      while (txio.read_data_word(ref address) > 0) /* do nothing */;                      class_numbers_end = address - 1;                      property_names_base = address;                      num_properties = (zword_t)(txio.read_data_word(ref address) - 1);                      address += (ulong)(num_properties * sizeof(zword_t));                      property_names_end = address - 1;                      if (inform_version >= tx_h.INFORM_610)                      {                          attr_names_base = address;                          address += (48 * sizeof(zword_t));                          attr_names_end = address - 1;                          /* then come the action names' the individual property values' the dynamic arrays' etc */                      }                  }              }              else                  inform_version = 0;
Magic Number,ZTools,infinfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infinfo.cs,configure_inform_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  if (header.name[4] >= '6')                  {                      inform_version = (ushort)((header.name[4] - '0') * 100 + (header.name[6] - '0') * 10 + (header.name[7] - '0'));                      address = class_numbers_base = obj_data_end + 1;                      while (txio.read_data_word(ref address) > 0) /* do nothing */;                      class_numbers_end = address - 1;                      property_names_base = address;                      num_properties = (zword_t)(txio.read_data_word(ref address) - 1);                      address += (ulong)(num_properties * sizeof(zword_t));                      property_names_end = address - 1;                      if (inform_version >= tx_h.INFORM_610)                      {                          attr_names_base = address;                          address += (48 * sizeof(zword_t));                          attr_names_end = address - 1;                          /* then come the action names' the individual property values' the dynamic arrays' etc */                      }                  }              }              else                  inform_version = 0;
Magic Number,ZTools,infinfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infinfo.cs,configure_inform_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  if (header.name[4] >= '6')                  {                      inform_version = (ushort)((header.name[4] - '0') * 100 + (header.name[6] - '0') * 10 + (header.name[7] - '0'));                      address = class_numbers_base = obj_data_end + 1;                      while (txio.read_data_word(ref address) > 0) /* do nothing */;                      class_numbers_end = address - 1;                      property_names_base = address;                      num_properties = (zword_t)(txio.read_data_word(ref address) - 1);                      address += (ulong)(num_properties * sizeof(zword_t));                      property_names_end = address - 1;                      if (inform_version >= tx_h.INFORM_610)                      {                          attr_names_base = address;                          address += (48 * sizeof(zword_t));                          attr_names_end = address - 1;                          /* then come the action names' the individual property values' the dynamic arrays' etc */                      }                  }              }              else                  inform_version = 0;
Magic Number,ZTools,infinfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infinfo.cs,configure_inform_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  if (header.name[4] >= '6')                  {                      inform_version = (ushort)((header.name[4] - '0') * 100 + (header.name[6] - '0') * 10 + (header.name[7] - '0'));                      address = class_numbers_base = obj_data_end + 1;                      while (txio.read_data_word(ref address) > 0) /* do nothing */;                      class_numbers_end = address - 1;                      property_names_base = address;                      num_properties = (zword_t)(txio.read_data_word(ref address) - 1);                      address += (ulong)(num_properties * sizeof(zword_t));                      property_names_end = address - 1;                      if (inform_version >= tx_h.INFORM_610)                      {                          attr_names_base = address;                          address += (48 * sizeof(zword_t));                          attr_names_end = address - 1;                          /* then come the action names' the individual property values' the dynamic arrays' etc */                      }                  }              }              else                  inform_version = 0;
Magic Number,ZTools,infinfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infinfo.cs,configure_inform_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  if (header.name[4] >= '6')                  {                      inform_version = (ushort)((header.name[4] - '0') * 100 + (header.name[6] - '0') * 10 + (header.name[7] - '0'));                      address = class_numbers_base = obj_data_end + 1;                      while (txio.read_data_word(ref address) > 0) /* do nothing */;                      class_numbers_end = address - 1;                      property_names_base = address;                      num_properties = (zword_t)(txio.read_data_word(ref address) - 1);                      address += (ulong)(num_properties * sizeof(zword_t));                      property_names_end = address - 1;                      if (inform_version >= tx_h.INFORM_610)                      {                          attr_names_base = address;                          address += (48 * sizeof(zword_t));                          attr_names_end = address - 1;                          /* then come the action names' the individual property values' the dynamic arrays' etc */                      }                  }              }              else                  inform_version = 0;
Magic Number,ZTools,infinfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infinfo.cs,configure_inform_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  if (header.name[4] >= '6')                  {                      inform_version = (ushort)((header.name[4] - '0') * 100 + (header.name[6] - '0') * 10 + (header.name[7] - '0'));                      address = class_numbers_base = obj_data_end + 1;                      while (txio.read_data_word(ref address) > 0) /* do nothing */;                      class_numbers_end = address - 1;                      property_names_base = address;                      num_properties = (zword_t)(txio.read_data_word(ref address) - 1);                      address += (ulong)(num_properties * sizeof(zword_t));                      property_names_end = address - 1;                      if (inform_version >= tx_h.INFORM_610)                      {                          attr_names_base = address;                          address += (48 * sizeof(zword_t));                          attr_names_end = address - 1;                          /* then come the action names' the individual property values' the dynamic arrays' etc */                      }                  }              }              else                  inform_version = 0;
Magic Number,ZTools,infinfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infinfo.cs,configure_inform_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  if (header.name[4] >= '6')                  {                      inform_version = (ushort)((header.name[4] - '0') * 100 + (header.name[6] - '0') * 10 + (header.name[7] - '0'));                      address = class_numbers_base = obj_data_end + 1;                      while (txio.read_data_word(ref address) > 0) /* do nothing */;                      class_numbers_end = address - 1;                      property_names_base = address;                      num_properties = (zword_t)(txio.read_data_word(ref address) - 1);                      address += (ulong)(num_properties * sizeof(zword_t));                      property_names_end = address - 1;                      if (inform_version >= tx_h.INFORM_610)                      {                          attr_names_base = address;                          address += (48 * sizeof(zword_t));                          attr_names_end = address - 1;                          /* then come the action names' the individual property values' the dynamic arrays' etc */                      }                  }              }              else                  inform_version = 0;
Magic Number,ZTools,infinfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infinfo.cs,print_inform_attribute_name,The following statement contains a magic number: address = (ulong)(attr_names_base + (ulong)attr_no * 2);
Magic Number,ZTools,infinfo,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infinfo.cs,print_inform_action_name,The following statement contains a magic number: address = (ulong)action_names_base + (ulong)action_no * 2;
Magic Number,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,fix_dictionary,The following statement contains a magic number: for (i = 1; i <= word_count; i++)              {                    /* Check that the word is in non-paged memory before writing */                    if ((address + 4) < (ulong)txio.header.resident_size)                      if ((uint)txio.header.version <= tx_h.V3)                          tx_h.set_byte(address + 2' (uint)tx_h.get_byte(address + 2) | 0x80);                      else                          tx_h.set_byte(address + 4' (uint)tx_h.get_byte(address + 4) | 0x80);                    address += word_size;              }
Magic Number,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,fix_dictionary,The following statement contains a magic number: for (i = 1; i <= word_count; i++)              {                    /* Check that the word is in non-paged memory before writing */                    if ((address + 4) < (ulong)txio.header.resident_size)                      if ((uint)txio.header.version <= tx_h.V3)                          tx_h.set_byte(address + 2' (uint)tx_h.get_byte(address + 2) | 0x80);                      else                          tx_h.set_byte(address + 4' (uint)tx_h.get_byte(address + 4) | 0x80);                    address += word_size;              }
Magic Number,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,fix_dictionary,The following statement contains a magic number: for (i = 1; i <= word_count; i++)              {                    /* Check that the word is in non-paged memory before writing */                    if ((address + 4) < (ulong)txio.header.resident_size)                      if ((uint)txio.header.version <= tx_h.V3)                          tx_h.set_byte(address + 2' (uint)tx_h.get_byte(address + 2) | 0x80);                      else                          tx_h.set_byte(address + 4' (uint)tx_h.get_byte(address + 4) | 0x80);                    address += word_size;              }
Magic Number,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,fix_dictionary,The following statement contains a magic number: for (i = 1; i <= word_count; i++)              {                    /* Check that the word is in non-paged memory before writing */                    if ((address + 4) < (ulong)txio.header.resident_size)                      if ((uint)txio.header.version <= tx_h.V3)                          tx_h.set_byte(address + 2' (uint)tx_h.get_byte(address + 2) | 0x80);                      else                          tx_h.set_byte(address + 4' (uint)tx_h.get_byte(address + 4) | 0x80);                    address += word_size;              }
Magic Number,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,fix_dictionary,The following statement contains a magic number: for (i = 1; i <= word_count; i++)              {                    /* Check that the word is in non-paged memory before writing */                    if ((address + 4) < (ulong)txio.header.resident_size)                      if ((uint)txio.header.version <= tx_h.V3)                          tx_h.set_byte(address + 2' (uint)tx_h.get_byte(address + 2) | 0x80);                      else                          tx_h.set_byte(address + 4' (uint)tx_h.get_byte(address + 4) | 0x80);                    address += word_size;              }
Magic Number,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,show_map,The following statement contains a magic number: set_area(0' 63' "Story file header");
Magic Number,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,show_map,The following statement contains a magic number: if (ext_table_base > 0)              {                  ext_table_size = tx_h.get_word((int)ext_table_base);                  ext_table_end = ext_table_base + 2 + ext_table_size * 2 - 1;                  set_area(ext_table_base' ext_table_end' "Header extension table");                  if (ext_table_size > 2)                  {                      unicode_table_base = tx_h.get_word((int)ext_table_base + 6);                      if (unicode_table_base > 0)                      {                          unicode_table_end = unicode_table_base + (ulong)tx_h.get_byte((int)unicode_table_base) * 2;                          set_area(unicode_table_base' unicode_table_end' "Unicode table");                      }                  }              }
Magic Number,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,show_map,The following statement contains a magic number: if (ext_table_base > 0)              {                  ext_table_size = tx_h.get_word((int)ext_table_base);                  ext_table_end = ext_table_base + 2 + ext_table_size * 2 - 1;                  set_area(ext_table_base' ext_table_end' "Header extension table");                  if (ext_table_size > 2)                  {                      unicode_table_base = tx_h.get_word((int)ext_table_base + 6);                      if (unicode_table_base > 0)                      {                          unicode_table_end = unicode_table_base + (ulong)tx_h.get_byte((int)unicode_table_base) * 2;                          set_area(unicode_table_base' unicode_table_end' "Unicode table");                      }                  }              }
Magic Number,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,show_map,The following statement contains a magic number: if (ext_table_base > 0)              {                  ext_table_size = tx_h.get_word((int)ext_table_base);                  ext_table_end = ext_table_base + 2 + ext_table_size * 2 - 1;                  set_area(ext_table_base' ext_table_end' "Header extension table");                  if (ext_table_size > 2)                  {                      unicode_table_base = tx_h.get_word((int)ext_table_base + 6);                      if (unicode_table_base > 0)                      {                          unicode_table_end = unicode_table_base + (ulong)tx_h.get_byte((int)unicode_table_base) * 2;                          set_area(unicode_table_base' unicode_table_end' "Unicode table");                      }                  }              }
Magic Number,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,show_map,The following statement contains a magic number: if (ext_table_base > 0)              {                  ext_table_size = tx_h.get_word((int)ext_table_base);                  ext_table_end = ext_table_base + 2 + ext_table_size * 2 - 1;                  set_area(ext_table_base' ext_table_end' "Header extension table");                  if (ext_table_size > 2)                  {                      unicode_table_base = tx_h.get_word((int)ext_table_base + 6);                      if (unicode_table_base > 0)                      {                          unicode_table_end = unicode_table_base + (ulong)tx_h.get_byte((int)unicode_table_base) * 2;                          set_area(unicode_table_base' unicode_table_end' "Unicode table");                      }                  }              }
Magic Number,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,show_map,The following statement contains a magic number: if (ext_table_base > 0)              {                  ext_table_size = tx_h.get_word((int)ext_table_base);                  ext_table_end = ext_table_base + 2 + ext_table_size * 2 - 1;                  set_area(ext_table_base' ext_table_end' "Header extension table");                  if (ext_table_size > 2)                  {                      unicode_table_base = tx_h.get_word((int)ext_table_base + 6);                      if (unicode_table_base > 0)                      {                          unicode_table_end = unicode_table_base + (ulong)tx_h.get_byte((int)unicode_table_base) * 2;                          set_area(unicode_table_base' unicode_table_end' "Unicode table");                      }                  }              }
Magic Number,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,show_map,The following statement contains a magic number: if ((verb_count > 0) && (verb_type != (int)tx_h.parser_types.infocom6_grammar))              {                  set_area(verb_table_base' verb_data_base - 1' "Grammar pointer table");                  set_area(verb_data_base' action_table_base - 1' "Grammar data");                  set_area(action_table_base' preact_table_base - 1' "Action routine table");                  if (verb_type < (int)tx_h.parser_types.inform_gv2)                  {                      set_area(preact_table_base' prep_table_base - 1' (verb_type >= (int)tx_h.parser_types.inform5_grammar) ? "Parsing routine table" : "Pre-action routine table");                      set_area(prep_table_base' prep_table_end' "Preposition table");                  }              }              else if (verb_count > 0)              {                  set_area(verb_table_base' verb_table_base + 8 * verb_count - 1' "Verb grammar table");                  set_area(verb_data_base' prep_table_base - 1' "Grammar entries");                  set_area(action_table_base' preact_table_base - 1' "Action routine table");                  set_area(preact_table_base' preact_table_base + action_count * 2 - 1' "Pre-action routine table");              }
Magic Number,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,show_map,The following statement contains a magic number: if ((verb_count > 0) && (verb_type != (int)tx_h.parser_types.infocom6_grammar))              {                  set_area(verb_table_base' verb_data_base - 1' "Grammar pointer table");                  set_area(verb_data_base' action_table_base - 1' "Grammar data");                  set_area(action_table_base' preact_table_base - 1' "Action routine table");                  if (verb_type < (int)tx_h.parser_types.inform_gv2)                  {                      set_area(preact_table_base' prep_table_base - 1' (verb_type >= (int)tx_h.parser_types.inform5_grammar) ? "Parsing routine table" : "Pre-action routine table");                      set_area(prep_table_base' prep_table_end' "Preposition table");                  }              }              else if (verb_count > 0)              {                  set_area(verb_table_base' verb_table_base + 8 * verb_count - 1' "Verb grammar table");                  set_area(verb_data_base' prep_table_base - 1' "Grammar entries");                  set_area(action_table_base' preact_table_base - 1' "Action routine table");                  set_area(preact_table_base' preact_table_base + action_count * 2 - 1' "Pre-action routine table");              }
Magic Number,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,show_map,The following statement contains a magic number: set_area((ulong)header.globals'                    (ulong)header.globals + (240 * 2) - 1'                    "Global variables");
Magic Number,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,show_map,The following statement contains a magic number: set_area((ulong)header.globals'                    (ulong)header.globals + (240 * 2) - 1'                    "Global variables");
Magic Number,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,show_map,The following statement contains a magic number: if (header.alphabet > 0)                  set_area((ulong)header.alphabet'                        (ulong)header.alphabet + (26 * 3) - 1'                        "Alphabet");
Magic Number,ZTools,InfoDump,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\infodump.cs,show_map,The following statement contains a magic number: if (header.alphabet > 0)                  set_area((ulong)header.alphabet'                        (ulong)header.alphabet + (26 * 3) - 1'                        "Alphabet");
Magic Number,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,show_dictionary,The following statement contains a magic number: if (columns == 0)                  columns = ((uint)header.version < tx_h.V4) ? 5 : 4;
Magic Number,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,show_dictionary,The following statement contains a magic number: if (columns == 0)                  columns = ((uint)header.version < tx_h.V4) ? 5 : 4;
Magic Number,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,show_dictionary,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  inform_flags = true;              }
Magic Number,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,show_dictionary,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  inform_flags = true;              }
Magic Number,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,show_dictionary,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  inform_flags = true;              }
Magic Number,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,show_dictionary,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  inform_flags = true;              }
Magic Number,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,show_dictionary,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  inform_flags = true;              }
Magic Number,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,show_dictionary,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  inform_flags = true;              }
Magic Number,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,show_dictionary,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  inform_flags = true;              }
Magic Number,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,show_dictionary,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  inform_flags = true;              }
Magic Number,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,show_abbreviations,The following statement contains a magic number: if (abbr_count == 0)              {                  txio.tx_printf("No abbreviation information.\n");              }              else              {                    /* Display each abbreviation */                    table_address = abbr_table_base;                    for (i = 0; (uint)i < abbr_count; i++)                  {                        /* Get address of abbreviation text from table */                        abbreviation_address = (ulong)txio.read_data_word(ref table_address) * 2;                      txio.tx_printf("[{0:d2}] \""' (int)i);                      txio.decode_text(ref abbreviation_address);                      txio.tx_printf("\"\n");                  }              }
Magic Number,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,configure_abbreviations,The following statement contains a magic number: if (abbr_table_base > 0)              {                    /* Calculate the number of abbreviation tables (V2 = 1' V3+ = 3) */                    tables = ((uint)txio.header.version < tx_h.V3) ? 1 : 3;                    /* Calculate abbreviation count and table end address */                    abbr_count = (uint)(tables * 32);                  abbr_table_end = abbr_table_base + (abbr_count * 2) - 1;                    /* Calculate the high and low address for the abbreviation strings */                    table_address = abbr_table_base;                  for (i = 0; (uint)i < abbr_count; i++)                  {                      address = (ulong)txio.read_data_word(ref table_address) * 2;                      if (abbr_data_base == 0 || address < abbr_data_base)                          abbr_data_base = address;                      if (abbr_data_end == 0 || address > abbr_data_end)                          abbr_data_end = address;                  }                    /* Scan last string to get the actual end of the string */                    while (((uint)txio.read_data_word(ref abbr_data_end) & 0x8000) == 0)                      ;                    (abbr_data_end)--;              }
Magic Number,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,configure_abbreviations,The following statement contains a magic number: if (abbr_table_base > 0)              {                    /* Calculate the number of abbreviation tables (V2 = 1' V3+ = 3) */                    tables = ((uint)txio.header.version < tx_h.V3) ? 1 : 3;                    /* Calculate abbreviation count and table end address */                    abbr_count = (uint)(tables * 32);                  abbr_table_end = abbr_table_base + (abbr_count * 2) - 1;                    /* Calculate the high and low address for the abbreviation strings */                    table_address = abbr_table_base;                  for (i = 0; (uint)i < abbr_count; i++)                  {                      address = (ulong)txio.read_data_word(ref table_address) * 2;                      if (abbr_data_base == 0 || address < abbr_data_base)                          abbr_data_base = address;                      if (abbr_data_end == 0 || address > abbr_data_end)                          abbr_data_end = address;                  }                    /* Scan last string to get the actual end of the string */                    while (((uint)txio.read_data_word(ref abbr_data_end) & 0x8000) == 0)                      ;                    (abbr_data_end)--;              }
Magic Number,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,configure_abbreviations,The following statement contains a magic number: if (abbr_table_base > 0)              {                    /* Calculate the number of abbreviation tables (V2 = 1' V3+ = 3) */                    tables = ((uint)txio.header.version < tx_h.V3) ? 1 : 3;                    /* Calculate abbreviation count and table end address */                    abbr_count = (uint)(tables * 32);                  abbr_table_end = abbr_table_base + (abbr_count * 2) - 1;                    /* Calculate the high and low address for the abbreviation strings */                    table_address = abbr_table_base;                  for (i = 0; (uint)i < abbr_count; i++)                  {                      address = (ulong)txio.read_data_word(ref table_address) * 2;                      if (abbr_data_base == 0 || address < abbr_data_base)                          abbr_data_base = address;                      if (abbr_data_end == 0 || address > abbr_data_end)                          abbr_data_end = address;                  }                    /* Scan last string to get the actual end of the string */                    while (((uint)txio.read_data_word(ref abbr_data_end) & 0x8000) == 0)                      ;                    (abbr_data_end)--;              }
Magic Number,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,configure_abbreviations,The following statement contains a magic number: if (abbr_table_base > 0)              {                    /* Calculate the number of abbreviation tables (V2 = 1' V3+ = 3) */                    tables = ((uint)txio.header.version < tx_h.V3) ? 1 : 3;                    /* Calculate abbreviation count and table end address */                    abbr_count = (uint)(tables * 32);                  abbr_table_end = abbr_table_base + (abbr_count * 2) - 1;                    /* Calculate the high and low address for the abbreviation strings */                    table_address = abbr_table_base;                  for (i = 0; (uint)i < abbr_count; i++)                  {                      address = (ulong)txio.read_data_word(ref table_address) * 2;                      if (abbr_data_base == 0 || address < abbr_data_base)                          abbr_data_base = address;                      if (abbr_data_end == 0 || address > abbr_data_end)                          abbr_data_end = address;                  }                    /* Scan last string to get the actual end of the string */                    while (((uint)txio.read_data_word(ref abbr_data_end) & 0x8000) == 0)                      ;                    (abbr_data_end)--;              }
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  inform = 5;                    if (header.name[4] >= '6')                      inform = header.name[4] - '0';              }
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  inform = 5;                    if (header.name[4] >= '6')                      inform = header.name[4] - '0';              }
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  inform = 5;                    if (header.name[4] >= '6')                      inform = header.name[4] - '0';              }
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  inform = 5;                    if (header.name[4] >= '6')                      inform = header.name[4] - '0';              }
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  inform = 5;                    if (header.name[4] >= '6')                      inform = header.name[4] - '0';              }
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  inform = 5;                    if (header.name[4] >= '6')                      inform = header.name[4] - '0';              }
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  inform = 5;                    if (header.name[4] >= '6')                      inform = header.name[4] - '0';              }
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  inform = 5;                    if (header.name[4] >= '6')                      inform = header.name[4] - '0';              }
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  inform = 5;                    if (header.name[4] >= '6')                      inform = header.name[4] - '0';              }
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  inform = 5;                    if (header.name[4] >= '6')                      inform = header.name[4] - '0';              }
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  inform = 5;                    if (header.name[4] >= '6')                      inform = header.name[4] - '0';              }
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: for (i = 0; i < 8; i++)              {                  if (((uint)header.config & (1 << i)) > 0)                  {                      txio.tx_printf("{0}{1}"' (list++) > 0 ? "' " : ""'                             ((uint)header.version < tx_h.V4) ? interpreter_flags1[i] : interpreter_flags2[i]);                  }                  else                  {                      if ((uint)header.version < tx_h.V4 && i == 1)                          txio.tx_printf("{0}Display score/moves"' (list++) > 0 ? "' " : "");                  }              }
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: for (i = 0; i < 16; i++)              {                  if (((uint)header.flags & (1 << i)) > 0)                  {                      txio.tx_printf("{0}{1}"' (list++) > 0 ? "' " : ""'                             ((uint)header.version < tx_h.V4) ? game_flags1[i] : game_flags2[i]);                  }              }
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: txio.tx_printf("Serial number:            {0}{1}{2}{3}{4}{5}\n"'                  (char)header.serial[0]' (char)header.serial[1]'                  (char)header.serial[2]' (char)header.serial[3]'                  (char)header.serial[4]' (char)header.serial[5]);
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: txio.tx_printf("Serial number:            {0}{1}{2}{3}{4}{5}\n"'                  (char)header.serial[0]' (char)header.serial[1]'                  (char)header.serial[2]' (char)header.serial[3]'                  (char)header.serial[4]' (char)header.serial[5]);
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: txio.tx_printf("Serial number:            {0}{1}{2}{3}{4}{5}\n"'                  (char)header.serial[0]' (char)header.serial[1]'                  (char)header.serial[2]' (char)header.serial[3]'                  (char)header.serial[4]' (char)header.serial[5]);
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: txio.tx_printf("Serial number:            {0}{1}{2}{3}{4}{5}\n"'                  (char)header.serial[0]' (char)header.serial[1]'                  (char)header.serial[2]' (char)header.serial[3]'                  (char)header.serial[4]' (char)header.serial[5]);
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: if ((uint)header.alphabet > 0)              {                  txio.tx_printf("Alphabet address:         {0:4X}\n"' (uint)header.alphabet);                  txio.tx_printf("    ");                  txio.tx_fix_margin(1);                  for (i = 0; i < 3; i++)                  {                      txio.tx_printf("\"");                      for (j = 0; j < 26; j++)                          txio.tx_printf("{0}"' (char)tx_h.get_byte((ulong)((uint)header.alphabet + (i * 26) + j)));                      txio.tx_printf("\"\n");                  }                  txio.tx_fix_margin(0);              }
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: if ((uint)header.alphabet > 0)              {                  txio.tx_printf("Alphabet address:         {0:4X}\n"' (uint)header.alphabet);                  txio.tx_printf("    ");                  txio.tx_fix_margin(1);                  for (i = 0; i < 3; i++)                  {                      txio.tx_printf("\"");                      for (j = 0; j < 26; j++)                          txio.tx_printf("{0}"' (char)tx_h.get_byte((ulong)((uint)header.alphabet + (i * 26) + j)));                      txio.tx_printf("\"\n");                  }                  txio.tx_fix_margin(0);              }
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: if ((uint)header.alphabet > 0)              {                  txio.tx_printf("Alphabet address:         {0:4X}\n"' (uint)header.alphabet);                  txio.tx_printf("    ");                  txio.tx_fix_margin(1);                  for (i = 0; i < 3; i++)                  {                      txio.tx_printf("\"");                      for (j = 0; j < 26; j++)                          txio.tx_printf("{0}"' (char)tx_h.get_byte((ulong)((uint)header.alphabet + (i * 26) + j)));                      txio.tx_printf("\"\n");                  }                  txio.tx_fix_margin(0);              }
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: if (inform >= 6)              {                  txio.tx_printf("Inform Version:           ");                  for (i = 4; i < header.name.Length; i++)                      txio.tx_printf("{0}"' (char)header.name[i]);                  txio.tx_printf("\n");              }
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header,The following statement contains a magic number: if (inform >= 6)              {                  txio.tx_printf("Inform Version:           ");                  for (i = 4; i < header.name.Length; i++)                      txio.tx_printf("{0}"' (char)header.name[i]);                  txio.tx_printf("\n");              }
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header_extension,The following statement contains a magic number: if (tlen > 2)                  txio.tx_printf("Unicode table address:    {0:X4}\n"' (ulong)tx_h.get_word(txio.header.mouse_table + 6));
Magic Number,ZTools,showhead,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showhead.cs,show_header_extension,The following statement contains a magic number: if (tlen > 2)                  txio.tx_printf("Unicode table address:    {0:X4}\n"' (ulong)tx_h.get_word(txio.header.mouse_table + 6));
Magic Number,ZTools,showobj,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showobj.cs,configure_object_tables,The following statement contains a magic number: while ((data = txio.read_data_byte(ref obj_data_end)) != 0)              {                  if ((uint)txio.header.version < tx_h.V4)                      data_count = (uint)(((data & txio.property_size_mask) >> 5) + 1);                  else if ((data & 0x80) > 0)                      data_count = (uint)(txio.read_data_byte(ref obj_data_end) & txio.property_size_mask);                  else if ((data & 0x40) > 0)                      data_count = 2;                  else                      data_count = 1;                  obj_data_end += data_count;              }
Magic Number,ZTools,showobj,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showobj.cs,configure_object_tables,The following statement contains a magic number: while ((data = txio.read_data_byte(ref obj_data_end)) != 0)              {                  if ((uint)txio.header.version < tx_h.V4)                      data_count = (uint)(((data & txio.property_size_mask) >> 5) + 1);                  else if ((data & 0x80) > 0)                      data_count = (uint)(txio.read_data_byte(ref obj_data_end) & txio.property_size_mask);                  else if ((data & 0x40) > 0)                      data_count = 2;                  else                      data_count = 1;                  obj_data_end += data_count;              }
Magic Number,ZTools,showobj,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showobj.cs,show_objects,The following statement contains a magic number: for (i = 1; (uint)i <= obj_count; i++)              {                  txio.tx_printf("\n");                    /* Get address of object */                    object_address = (ulong)get_object_address(i);                    /* Display attributes */                    txio.tx_printf("{0:d3}. Attributes: "' (int)i);                  list = 0;                  for (j = 0; j < (((uint)txio.header.version < tx_h.V4) ? 4 : 6); j++)                  {                      data = (uint)txio.read_data_byte(ref object_address);                      for (k = 7; k >= 0; k--)                      {                          if (((data >> k) & 1) > 0)                          {                              txio.tx_printf("{0}"' (list++) > 0 ? "' " : "");                              if (symbols.print_attribute_name(attr_names_base' (int)((j * 8) + (7 - k))) > 0)                                  txio.tx_printf("({0:d})"' (int)((j * 8) + (7 - k)));                              else                                  txio.tx_printf("{0:d}"' (int)((j * 8) + (7 - k)));                          }                      }                  }                  if (list == 0)                      txio.tx_printf("None");                  txio.tx_printf("\n");                    /* Get object linkage information */                    if ((uint)txio.header.version < tx_h.V4)                  {                      pobj = (uint)txio.read_data_byte(ref object_address);                      nobj = (uint)txio.read_data_byte(ref object_address);                      cobj = (uint)txio.read_data_byte(ref object_address);                  }                  else                  {                      pobj = (uint)txio.read_data_word(ref object_address);                      nobj = (uint)txio.read_data_word(ref object_address);                      cobj = (uint)txio.read_data_word(ref object_address);                  }                  address = txio.read_data_word(ref object_address);                  txio.tx_printf("     Parent object: {0:d3}  "' (int)pobj);                  txio.tx_printf("Sibling object: {0:d3}  "' (int)nobj);                  txio.tx_printf("Child object: {0:d3}\n"' (int)cobj);                  txio.tx_printf("     Property address: {0:X4}\n"' (ulong)address);                  txio.tx_printf("         Description: \"");                    /* If object has a description then display it */                    if ((uint)txio.read_data_byte(ref address) > 0)                      txio.decode_text(ref address);                  txio.tx_printf("\"\n");                    /* Print property list */                    txio.tx_printf("          Properties:\n");                  print_property_list(ref address' property_names_base);              }
Magic Number,ZTools,showobj,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showobj.cs,show_objects,The following statement contains a magic number: for (i = 1; (uint)i <= obj_count; i++)              {                  txio.tx_printf("\n");                    /* Get address of object */                    object_address = (ulong)get_object_address(i);                    /* Display attributes */                    txio.tx_printf("{0:d3}. Attributes: "' (int)i);                  list = 0;                  for (j = 0; j < (((uint)txio.header.version < tx_h.V4) ? 4 : 6); j++)                  {                      data = (uint)txio.read_data_byte(ref object_address);                      for (k = 7; k >= 0; k--)                      {                          if (((data >> k) & 1) > 0)                          {                              txio.tx_printf("{0}"' (list++) > 0 ? "' " : "");                              if (symbols.print_attribute_name(attr_names_base' (int)((j * 8) + (7 - k))) > 0)                                  txio.tx_printf("({0:d})"' (int)((j * 8) + (7 - k)));                              else                                  txio.tx_printf("{0:d}"' (int)((j * 8) + (7 - k)));                          }                      }                  }                  if (list == 0)                      txio.tx_printf("None");                  txio.tx_printf("\n");                    /* Get object linkage information */                    if ((uint)txio.header.version < tx_h.V4)                  {                      pobj = (uint)txio.read_data_byte(ref object_address);                      nobj = (uint)txio.read_data_byte(ref object_address);                      cobj = (uint)txio.read_data_byte(ref object_address);                  }                  else                  {                      pobj = (uint)txio.read_data_word(ref object_address);                      nobj = (uint)txio.read_data_word(ref object_address);                      cobj = (uint)txio.read_data_word(ref object_address);                  }                  address = txio.read_data_word(ref object_address);                  txio.tx_printf("     Parent object: {0:d3}  "' (int)pobj);                  txio.tx_printf("Sibling object: {0:d3}  "' (int)nobj);                  txio.tx_printf("Child object: {0:d3}\n"' (int)cobj);                  txio.tx_printf("     Property address: {0:X4}\n"' (ulong)address);                  txio.tx_printf("         Description: \"");                    /* If object has a description then display it */                    if ((uint)txio.read_data_byte(ref address) > 0)                      txio.decode_text(ref address);                  txio.tx_printf("\"\n");                    /* Print property list */                    txio.tx_printf("          Properties:\n");                  print_property_list(ref address' property_names_base);              }
Magic Number,ZTools,showobj,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showobj.cs,show_objects,The following statement contains a magic number: for (i = 1; (uint)i <= obj_count; i++)              {                  txio.tx_printf("\n");                    /* Get address of object */                    object_address = (ulong)get_object_address(i);                    /* Display attributes */                    txio.tx_printf("{0:d3}. Attributes: "' (int)i);                  list = 0;                  for (j = 0; j < (((uint)txio.header.version < tx_h.V4) ? 4 : 6); j++)                  {                      data = (uint)txio.read_data_byte(ref object_address);                      for (k = 7; k >= 0; k--)                      {                          if (((data >> k) & 1) > 0)                          {                              txio.tx_printf("{0}"' (list++) > 0 ? "' " : "");                              if (symbols.print_attribute_name(attr_names_base' (int)((j * 8) + (7 - k))) > 0)                                  txio.tx_printf("({0:d})"' (int)((j * 8) + (7 - k)));                              else                                  txio.tx_printf("{0:d}"' (int)((j * 8) + (7 - k)));                          }                      }                  }                  if (list == 0)                      txio.tx_printf("None");                  txio.tx_printf("\n");                    /* Get object linkage information */                    if ((uint)txio.header.version < tx_h.V4)                  {                      pobj = (uint)txio.read_data_byte(ref object_address);                      nobj = (uint)txio.read_data_byte(ref object_address);                      cobj = (uint)txio.read_data_byte(ref object_address);                  }                  else                  {                      pobj = (uint)txio.read_data_word(ref object_address);                      nobj = (uint)txio.read_data_word(ref object_address);                      cobj = (uint)txio.read_data_word(ref object_address);                  }                  address = txio.read_data_word(ref object_address);                  txio.tx_printf("     Parent object: {0:d3}  "' (int)pobj);                  txio.tx_printf("Sibling object: {0:d3}  "' (int)nobj);                  txio.tx_printf("Child object: {0:d3}\n"' (int)cobj);                  txio.tx_printf("     Property address: {0:X4}\n"' (ulong)address);                  txio.tx_printf("         Description: \"");                    /* If object has a description then display it */                    if ((uint)txio.read_data_byte(ref address) > 0)                      txio.decode_text(ref address);                  txio.tx_printf("\"\n");                    /* Print property list */                    txio.tx_printf("          Properties:\n");                  print_property_list(ref address' property_names_base);              }
Magic Number,ZTools,showobj,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showobj.cs,show_objects,The following statement contains a magic number: for (i = 1; (uint)i <= obj_count; i++)              {                  txio.tx_printf("\n");                    /* Get address of object */                    object_address = (ulong)get_object_address(i);                    /* Display attributes */                    txio.tx_printf("{0:d3}. Attributes: "' (int)i);                  list = 0;                  for (j = 0; j < (((uint)txio.header.version < tx_h.V4) ? 4 : 6); j++)                  {                      data = (uint)txio.read_data_byte(ref object_address);                      for (k = 7; k >= 0; k--)                      {                          if (((data >> k) & 1) > 0)                          {                              txio.tx_printf("{0}"' (list++) > 0 ? "' " : "");                              if (symbols.print_attribute_name(attr_names_base' (int)((j * 8) + (7 - k))) > 0)                                  txio.tx_printf("({0:d})"' (int)((j * 8) + (7 - k)));                              else                                  txio.tx_printf("{0:d}"' (int)((j * 8) + (7 - k)));                          }                      }                  }                  if (list == 0)                      txio.tx_printf("None");                  txio.tx_printf("\n");                    /* Get object linkage information */                    if ((uint)txio.header.version < tx_h.V4)                  {                      pobj = (uint)txio.read_data_byte(ref object_address);                      nobj = (uint)txio.read_data_byte(ref object_address);                      cobj = (uint)txio.read_data_byte(ref object_address);                  }                  else                  {                      pobj = (uint)txio.read_data_word(ref object_address);                      nobj = (uint)txio.read_data_word(ref object_address);                      cobj = (uint)txio.read_data_word(ref object_address);                  }                  address = txio.read_data_word(ref object_address);                  txio.tx_printf("     Parent object: {0:d3}  "' (int)pobj);                  txio.tx_printf("Sibling object: {0:d3}  "' (int)nobj);                  txio.tx_printf("Child object: {0:d3}\n"' (int)cobj);                  txio.tx_printf("     Property address: {0:X4}\n"' (ulong)address);                  txio.tx_printf("         Description: \"");                    /* If object has a description then display it */                    if ((uint)txio.read_data_byte(ref address) > 0)                      txio.decode_text(ref address);                  txio.tx_printf("\"\n");                    /* Print property list */                    txio.tx_printf("          Properties:\n");                  print_property_list(ref address' property_names_base);              }
Magic Number,ZTools,showobj,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showobj.cs,show_objects,The following statement contains a magic number: for (i = 1; (uint)i <= obj_count; i++)              {                  txio.tx_printf("\n");                    /* Get address of object */                    object_address = (ulong)get_object_address(i);                    /* Display attributes */                    txio.tx_printf("{0:d3}. Attributes: "' (int)i);                  list = 0;                  for (j = 0; j < (((uint)txio.header.version < tx_h.V4) ? 4 : 6); j++)                  {                      data = (uint)txio.read_data_byte(ref object_address);                      for (k = 7; k >= 0; k--)                      {                          if (((data >> k) & 1) > 0)                          {                              txio.tx_printf("{0}"' (list++) > 0 ? "' " : "");                              if (symbols.print_attribute_name(attr_names_base' (int)((j * 8) + (7 - k))) > 0)                                  txio.tx_printf("({0:d})"' (int)((j * 8) + (7 - k)));                              else                                  txio.tx_printf("{0:d}"' (int)((j * 8) + (7 - k)));                          }                      }                  }                  if (list == 0)                      txio.tx_printf("None");                  txio.tx_printf("\n");                    /* Get object linkage information */                    if ((uint)txio.header.version < tx_h.V4)                  {                      pobj = (uint)txio.read_data_byte(ref object_address);                      nobj = (uint)txio.read_data_byte(ref object_address);                      cobj = (uint)txio.read_data_byte(ref object_address);                  }                  else                  {                      pobj = (uint)txio.read_data_word(ref object_address);                      nobj = (uint)txio.read_data_word(ref object_address);                      cobj = (uint)txio.read_data_word(ref object_address);                  }                  address = txio.read_data_word(ref object_address);                  txio.tx_printf("     Parent object: {0:d3}  "' (int)pobj);                  txio.tx_printf("Sibling object: {0:d3}  "' (int)nobj);                  txio.tx_printf("Child object: {0:d3}\n"' (int)cobj);                  txio.tx_printf("     Property address: {0:X4}\n"' (ulong)address);                  txio.tx_printf("         Description: \"");                    /* If object has a description then display it */                    if ((uint)txio.read_data_byte(ref address) > 0)                      txio.decode_text(ref address);                  txio.tx_printf("\"\n");                    /* Print property list */                    txio.tx_printf("          Properties:\n");                  print_property_list(ref address' property_names_base);              }
Magic Number,ZTools,showobj,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showobj.cs,show_objects,The following statement contains a magic number: for (i = 1; (uint)i <= obj_count; i++)              {                  txio.tx_printf("\n");                    /* Get address of object */                    object_address = (ulong)get_object_address(i);                    /* Display attributes */                    txio.tx_printf("{0:d3}. Attributes: "' (int)i);                  list = 0;                  for (j = 0; j < (((uint)txio.header.version < tx_h.V4) ? 4 : 6); j++)                  {                      data = (uint)txio.read_data_byte(ref object_address);                      for (k = 7; k >= 0; k--)                      {                          if (((data >> k) & 1) > 0)                          {                              txio.tx_printf("{0}"' (list++) > 0 ? "' " : "");                              if (symbols.print_attribute_name(attr_names_base' (int)((j * 8) + (7 - k))) > 0)                                  txio.tx_printf("({0:d})"' (int)((j * 8) + (7 - k)));                              else                                  txio.tx_printf("{0:d}"' (int)((j * 8) + (7 - k)));                          }                      }                  }                  if (list == 0)                      txio.tx_printf("None");                  txio.tx_printf("\n");                    /* Get object linkage information */                    if ((uint)txio.header.version < tx_h.V4)                  {                      pobj = (uint)txio.read_data_byte(ref object_address);                      nobj = (uint)txio.read_data_byte(ref object_address);                      cobj = (uint)txio.read_data_byte(ref object_address);                  }                  else                  {                      pobj = (uint)txio.read_data_word(ref object_address);                      nobj = (uint)txio.read_data_word(ref object_address);                      cobj = (uint)txio.read_data_word(ref object_address);                  }                  address = txio.read_data_word(ref object_address);                  txio.tx_printf("     Parent object: {0:d3}  "' (int)pobj);                  txio.tx_printf("Sibling object: {0:d3}  "' (int)nobj);                  txio.tx_printf("Child object: {0:d3}\n"' (int)cobj);                  txio.tx_printf("     Property address: {0:X4}\n"' (ulong)address);                  txio.tx_printf("         Description: \"");                    /* If object has a description then display it */                    if ((uint)txio.read_data_byte(ref address) > 0)                      txio.decode_text(ref address);                  txio.tx_printf("\"\n");                    /* Print property list */                    txio.tx_printf("          Properties:\n");                  print_property_list(ref address' property_names_base);              }
Magic Number,ZTools,showobj,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showobj.cs,show_objects,The following statement contains a magic number: for (i = 1; (uint)i <= obj_count; i++)              {                  txio.tx_printf("\n");                    /* Get address of object */                    object_address = (ulong)get_object_address(i);                    /* Display attributes */                    txio.tx_printf("{0:d3}. Attributes: "' (int)i);                  list = 0;                  for (j = 0; j < (((uint)txio.header.version < tx_h.V4) ? 4 : 6); j++)                  {                      data = (uint)txio.read_data_byte(ref object_address);                      for (k = 7; k >= 0; k--)                      {                          if (((data >> k) & 1) > 0)                          {                              txio.tx_printf("{0}"' (list++) > 0 ? "' " : "");                              if (symbols.print_attribute_name(attr_names_base' (int)((j * 8) + (7 - k))) > 0)                                  txio.tx_printf("({0:d})"' (int)((j * 8) + (7 - k)));                              else                                  txio.tx_printf("{0:d}"' (int)((j * 8) + (7 - k)));                          }                      }                  }                  if (list == 0)                      txio.tx_printf("None");                  txio.tx_printf("\n");                    /* Get object linkage information */                    if ((uint)txio.header.version < tx_h.V4)                  {                      pobj = (uint)txio.read_data_byte(ref object_address);                      nobj = (uint)txio.read_data_byte(ref object_address);                      cobj = (uint)txio.read_data_byte(ref object_address);                  }                  else                  {                      pobj = (uint)txio.read_data_word(ref object_address);                      nobj = (uint)txio.read_data_word(ref object_address);                      cobj = (uint)txio.read_data_word(ref object_address);                  }                  address = txio.read_data_word(ref object_address);                  txio.tx_printf("     Parent object: {0:d3}  "' (int)pobj);                  txio.tx_printf("Sibling object: {0:d3}  "' (int)nobj);                  txio.tx_printf("Child object: {0:d3}\n"' (int)cobj);                  txio.tx_printf("     Property address: {0:X4}\n"' (ulong)address);                  txio.tx_printf("         Description: \"");                    /* If object has a description then display it */                    if ((uint)txio.read_data_byte(ref address) > 0)                      txio.decode_text(ref address);                  txio.tx_printf("\"\n");                    /* Print property list */                    txio.tx_printf("          Properties:\n");                  print_property_list(ref address' property_names_base);              }
Magic Number,ZTools,showobj,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showobj.cs,show_objects,The following statement contains a magic number: for (i = 1; (uint)i <= obj_count; i++)              {                  txio.tx_printf("\n");                    /* Get address of object */                    object_address = (ulong)get_object_address(i);                    /* Display attributes */                    txio.tx_printf("{0:d3}. Attributes: "' (int)i);                  list = 0;                  for (j = 0; j < (((uint)txio.header.version < tx_h.V4) ? 4 : 6); j++)                  {                      data = (uint)txio.read_data_byte(ref object_address);                      for (k = 7; k >= 0; k--)                      {                          if (((data >> k) & 1) > 0)                          {                              txio.tx_printf("{0}"' (list++) > 0 ? "' " : "");                              if (symbols.print_attribute_name(attr_names_base' (int)((j * 8) + (7 - k))) > 0)                                  txio.tx_printf("({0:d})"' (int)((j * 8) + (7 - k)));                              else                                  txio.tx_printf("{0:d}"' (int)((j * 8) + (7 - k)));                          }                      }                  }                  if (list == 0)                      txio.tx_printf("None");                  txio.tx_printf("\n");                    /* Get object linkage information */                    if ((uint)txio.header.version < tx_h.V4)                  {                      pobj = (uint)txio.read_data_byte(ref object_address);                      nobj = (uint)txio.read_data_byte(ref object_address);                      cobj = (uint)txio.read_data_byte(ref object_address);                  }                  else                  {                      pobj = (uint)txio.read_data_word(ref object_address);                      nobj = (uint)txio.read_data_word(ref object_address);                      cobj = (uint)txio.read_data_word(ref object_address);                  }                  address = txio.read_data_word(ref object_address);                  txio.tx_printf("     Parent object: {0:d3}  "' (int)pobj);                  txio.tx_printf("Sibling object: {0:d3}  "' (int)nobj);                  txio.tx_printf("Child object: {0:d3}\n"' (int)cobj);                  txio.tx_printf("     Property address: {0:X4}\n"' (ulong)address);                  txio.tx_printf("         Description: \"");                    /* If object has a description then display it */                    if ((uint)txio.read_data_byte(ref address) > 0)                      txio.decode_text(ref address);                  txio.tx_printf("\"\n");                    /* Print property list */                    txio.tx_printf("          Properties:\n");                  print_property_list(ref address' property_names_base);              }
Magic Number,ZTools,showobj,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showobj.cs,show_objects,The following statement contains a magic number: for (i = 1; (uint)i <= obj_count; i++)              {                  txio.tx_printf("\n");                    /* Get address of object */                    object_address = (ulong)get_object_address(i);                    /* Display attributes */                    txio.tx_printf("{0:d3}. Attributes: "' (int)i);                  list = 0;                  for (j = 0; j < (((uint)txio.header.version < tx_h.V4) ? 4 : 6); j++)                  {                      data = (uint)txio.read_data_byte(ref object_address);                      for (k = 7; k >= 0; k--)                      {                          if (((data >> k) & 1) > 0)                          {                              txio.tx_printf("{0}"' (list++) > 0 ? "' " : "");                              if (symbols.print_attribute_name(attr_names_base' (int)((j * 8) + (7 - k))) > 0)                                  txio.tx_printf("({0:d})"' (int)((j * 8) + (7 - k)));                              else                                  txio.tx_printf("{0:d}"' (int)((j * 8) + (7 - k)));                          }                      }                  }                  if (list == 0)                      txio.tx_printf("None");                  txio.tx_printf("\n");                    /* Get object linkage information */                    if ((uint)txio.header.version < tx_h.V4)                  {                      pobj = (uint)txio.read_data_byte(ref object_address);                      nobj = (uint)txio.read_data_byte(ref object_address);                      cobj = (uint)txio.read_data_byte(ref object_address);                  }                  else                  {                      pobj = (uint)txio.read_data_word(ref object_address);                      nobj = (uint)txio.read_data_word(ref object_address);                      cobj = (uint)txio.read_data_word(ref object_address);                  }                  address = txio.read_data_word(ref object_address);                  txio.tx_printf("     Parent object: {0:d3}  "' (int)pobj);                  txio.tx_printf("Sibling object: {0:d3}  "' (int)nobj);                  txio.tx_printf("Child object: {0:d3}\n"' (int)cobj);                  txio.tx_printf("     Property address: {0:X4}\n"' (ulong)address);                  txio.tx_printf("         Description: \"");                    /* If object has a description then display it */                    if ((uint)txio.read_data_byte(ref address) > 0)                      txio.decode_text(ref address);                  txio.tx_printf("\"\n");                    /* Print property list */                    txio.tx_printf("          Properties:\n");                  print_property_list(ref address' property_names_base);              }
Magic Number,ZTools,showobj,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showobj.cs,get_object_address,The following statement contains a magic number: if ((uint)txio.header.version <= tx_h.V3)                  offset += ((tx_h.P3_MAX_PROPERTIES - 1) * 2) + ((obj - 1) * tx_h.O3_SIZE);              else                  offset += ((tx_h.P4_MAX_PROPERTIES - 1) * 2) + ((obj - 1) * tx_h.O4_SIZE);
Magic Number,ZTools,showobj,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showobj.cs,get_object_address,The following statement contains a magic number: if ((uint)txio.header.version <= tx_h.V3)                  offset += ((tx_h.P3_MAX_PROPERTIES - 1) * 2) + ((obj - 1) * tx_h.O3_SIZE);              else                  offset += ((tx_h.P4_MAX_PROPERTIES - 1) * 2) + ((obj - 1) * tx_h.O4_SIZE);
Magic Number,ZTools,showobj,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showobj.cs,print_property_list,The following statement contains a magic number: for (data = txio.read_data_byte(ref address); data > 0; data = txio.read_data_byte(ref address))              {                  txio.tx_printf("            ");                  if (symbols.print_property_name(property_names_base' (int)(data & txio.property_mask)) > 0)                      txio.tx_printf("\n              ");                  else                      txio.tx_printf("  ");                  txio.tx_printf("[%2d] "' (int)(data & txio.property_mask));                  if ((uint)txio.header.version <= tx_h.V3)                      count = ((data & txio.property_size_mask) >> 5) + 1;                  else if ((data & 0x80) > 0)                      count = (int)((uint)txio.read_data_byte(ref address) & txio.property_size_mask);                  else if ((data & 0x40) > 0)                      count = 2;                  else                      count = 1;                  while (count-- > 0)                      txio.tx_printf("{0:X2} "' (uint)txio.read_data_byte(ref address));                  txio.tx_printf("\n");              }
Magic Number,ZTools,showobj,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showobj.cs,print_property_list,The following statement contains a magic number: for (data = txio.read_data_byte(ref address); data > 0; data = txio.read_data_byte(ref address))              {                  txio.tx_printf("            ");                  if (symbols.print_property_name(property_names_base' (int)(data & txio.property_mask)) > 0)                      txio.tx_printf("\n              ");                  else                      txio.tx_printf("  ");                  txio.tx_printf("[%2d] "' (int)(data & txio.property_mask));                  if ((uint)txio.header.version <= tx_h.V3)                      count = ((data & txio.property_size_mask) >> 5) + 1;                  else if ((data & 0x80) > 0)                      count = (int)((uint)txio.read_data_byte(ref address) & txio.property_size_mask);                  else if ((data & 0x40) > 0)                      count = 2;                  else                      count = 1;                  while (count-- > 0)                      txio.tx_printf("{0:X2} "' (uint)txio.read_data_byte(ref address));                  txio.tx_printf("\n");              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,showverb,The following statement contains a magic number: verb_sizes = new int[] { 2' 4' 7' 0 };
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,showverb,The following statement contains a magic number: verb_sizes = new int[] { 2' 4' 7' 0 };
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,showverb,The following statement contains a magic number: verb_sizes = new int[] { 2' 4' 7' 0 };
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  parser_type = (uint)tx_h.parser_types.inform5_grammar;                    if (header.name[4] >= '6')                      parser_type = (uint)tx_h.parser_types.inform_gv1;              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  parser_type = (uint)tx_h.parser_types.inform5_grammar;                    if (header.name[4] >= '6')                      parser_type = (uint)tx_h.parser_types.inform_gv1;              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  parser_type = (uint)tx_h.parser_types.inform5_grammar;                    if (header.name[4] >= '6')                      parser_type = (uint)tx_h.parser_types.inform_gv1;              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  parser_type = (uint)tx_h.parser_types.inform5_grammar;                    if (header.name[4] >= '6')                      parser_type = (uint)tx_h.parser_types.inform_gv1;              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  parser_type = (uint)tx_h.parser_types.inform5_grammar;                    if (header.name[4] >= '6')                      parser_type = (uint)tx_h.parser_types.inform_gv1;              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  parser_type = (uint)tx_h.parser_types.inform5_grammar;                    if (header.name[4] >= '6')                      parser_type = (uint)tx_h.parser_types.inform_gv1;              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  parser_type = (uint)tx_h.parser_types.inform5_grammar;                    if (header.name[4] >= '6')                      parser_type = (uint)tx_h.parser_types.inform_gv1;              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  parser_type = (uint)tx_h.parser_types.inform5_grammar;                    if (header.name[4] >= '6')                      parser_type = (uint)tx_h.parser_types.inform_gv1;              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (header.serial[0] >= '0' && header.serial[0] <= '9' &&                  header.serial[1] >= '0' && header.serial[1] <= '9' &&                  header.serial[2] >= '0' && header.serial[2] <= '1' &&                  header.serial[3] >= '0' && header.serial[3] <= '9' &&                  header.serial[4] >= '0' && header.serial[4] <= '3' &&                  header.serial[5] >= '0' && header.serial[5] <= '9' &&                  header.serial[0] != '8')              {                  parser_type = (uint)tx_h.parser_types.inform5_grammar;                    if (header.name[4] >= '6')                      parser_type = (uint)tx_h.parser_types.inform_gv1;              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if ((parser_type < (uint)tx_h.parser_types.inform5_grammar) && (uint)header.version == tx_h.V6)              {                  // TODO This code does not work!                  ulong word_address' first_word' last_word;                  ushort word_size' word_count;                  ulong vbase' vend;                  ulong area2base' area2end;                  ulong parse_address;                    parser_type = (uint)tx_h.parser_types.infocom6_grammar;                  address = (ulong)(header.objects - 4);                  action_table_base = (ushort)txio.read_data_word(ref address);                  preact_table_base = (ushort)txio.read_data_word(ref address);                    /* Calculate dictionary bounds and entry size */                    address = (ulong)header.dictionary;                  ulong temp = (ulong)txio.read_data_byte(ref address);                  address += temp;                  word_size = txio.read_data_byte(ref address);                  word_count = txio.read_data_word(ref address);                  first_word = address;                  last_word = (address + ((ulong)(word_count - 1) * word_size));                    vbase = area2base = 0xFFFF;                  vend = area2end = 0;                    for (word_address = first_word; word_address <= last_word; word_address += word_size)                  {                      address = word_address + 6;                      parse_index = (ushort)txio.read_data_word(ref address);                      address = word_address + word_size - 1;                      val = txio.read_data_byte(ref address); /* flags */                      if ((val & 1) != 0 && (val & 0x80) == 0 && (parse_index != 0) && (parse_index < action_table_base))                      { /* dictionary verb */                          if (vbase > parse_index)                              vbase = parse_index;                          if (vend <= parse_index)                              vend = parse_index + 8;                          address = parse_index + 4;                            /* retrieve direct-object only parse entries */                          parse_address = (ushort)txio.read_data_word(ref address);                          if (parse_address > 0 && (area2base > parse_address))                              area2base = parse_address;                            if (parse_address > 0 && (area2end <= parse_address))                          {                              val = (ushort)txio.read_data_word(ref parse_address);                              area2end = (parse_address + 6 * val);                          }                            /* retrieve indrect-object parse entries */                          parse_address = (ushort)txio.read_data_word(ref address);                          if (parse_address > 0 && (area2base > parse_address))                              area2base = parse_address;                            if (parse_address > 0 && (area2end <= parse_address))                          {                              val = (ushort)txio.read_data_word(ref parse_address);                              area2end = (parse_address + 10 * val);                          }                      }                  }                  if (vend == 0) /* no verbs */                      return;                  verb_count = (uint)((vend - vbase) / 8);                  verb_table_base = vbase;                  verb_data_base = area2base;                  /* there is no preposition table' but *prep_table_base bounds the verb data area */                  prep_table_base = area2end;                  prep_table_end = area2end;                  action_count = (uint)(preact_table_base - action_table_base) / 2;                  return;              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if ((parser_type < (uint)tx_h.parser_types.inform5_grammar) && (uint)header.version == tx_h.V6)              {                  // TODO This code does not work!                  ulong word_address' first_word' last_word;                  ushort word_size' word_count;                  ulong vbase' vend;                  ulong area2base' area2end;                  ulong parse_address;                    parser_type = (uint)tx_h.parser_types.infocom6_grammar;                  address = (ulong)(header.objects - 4);                  action_table_base = (ushort)txio.read_data_word(ref address);                  preact_table_base = (ushort)txio.read_data_word(ref address);                    /* Calculate dictionary bounds and entry size */                    address = (ulong)header.dictionary;                  ulong temp = (ulong)txio.read_data_byte(ref address);                  address += temp;                  word_size = txio.read_data_byte(ref address);                  word_count = txio.read_data_word(ref address);                  first_word = address;                  last_word = (address + ((ulong)(word_count - 1) * word_size));                    vbase = area2base = 0xFFFF;                  vend = area2end = 0;                    for (word_address = first_word; word_address <= last_word; word_address += word_size)                  {                      address = word_address + 6;                      parse_index = (ushort)txio.read_data_word(ref address);                      address = word_address + word_size - 1;                      val = txio.read_data_byte(ref address); /* flags */                      if ((val & 1) != 0 && (val & 0x80) == 0 && (parse_index != 0) && (parse_index < action_table_base))                      { /* dictionary verb */                          if (vbase > parse_index)                              vbase = parse_index;                          if (vend <= parse_index)                              vend = parse_index + 8;                          address = parse_index + 4;                            /* retrieve direct-object only parse entries */                          parse_address = (ushort)txio.read_data_word(ref address);                          if (parse_address > 0 && (area2base > parse_address))                              area2base = parse_address;                            if (parse_address > 0 && (area2end <= parse_address))                          {                              val = (ushort)txio.read_data_word(ref parse_address);                              area2end = (parse_address + 6 * val);                          }                            /* retrieve indrect-object parse entries */                          parse_address = (ushort)txio.read_data_word(ref address);                          if (parse_address > 0 && (area2base > parse_address))                              area2base = parse_address;                            if (parse_address > 0 && (area2end <= parse_address))                          {                              val = (ushort)txio.read_data_word(ref parse_address);                              area2end = (parse_address + 10 * val);                          }                      }                  }                  if (vend == 0) /* no verbs */                      return;                  verb_count = (uint)((vend - vbase) / 8);                  verb_table_base = vbase;                  verb_data_base = area2base;                  /* there is no preposition table' but *prep_table_base bounds the verb data area */                  prep_table_base = area2end;                  prep_table_end = area2end;                  action_count = (uint)(preact_table_base - action_table_base) / 2;                  return;              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if ((parser_type < (uint)tx_h.parser_types.inform5_grammar) && (uint)header.version == tx_h.V6)              {                  // TODO This code does not work!                  ulong word_address' first_word' last_word;                  ushort word_size' word_count;                  ulong vbase' vend;                  ulong area2base' area2end;                  ulong parse_address;                    parser_type = (uint)tx_h.parser_types.infocom6_grammar;                  address = (ulong)(header.objects - 4);                  action_table_base = (ushort)txio.read_data_word(ref address);                  preact_table_base = (ushort)txio.read_data_word(ref address);                    /* Calculate dictionary bounds and entry size */                    address = (ulong)header.dictionary;                  ulong temp = (ulong)txio.read_data_byte(ref address);                  address += temp;                  word_size = txio.read_data_byte(ref address);                  word_count = txio.read_data_word(ref address);                  first_word = address;                  last_word = (address + ((ulong)(word_count - 1) * word_size));                    vbase = area2base = 0xFFFF;                  vend = area2end = 0;                    for (word_address = first_word; word_address <= last_word; word_address += word_size)                  {                      address = word_address + 6;                      parse_index = (ushort)txio.read_data_word(ref address);                      address = word_address + word_size - 1;                      val = txio.read_data_byte(ref address); /* flags */                      if ((val & 1) != 0 && (val & 0x80) == 0 && (parse_index != 0) && (parse_index < action_table_base))                      { /* dictionary verb */                          if (vbase > parse_index)                              vbase = parse_index;                          if (vend <= parse_index)                              vend = parse_index + 8;                          address = parse_index + 4;                            /* retrieve direct-object only parse entries */                          parse_address = (ushort)txio.read_data_word(ref address);                          if (parse_address > 0 && (area2base > parse_address))                              area2base = parse_address;                            if (parse_address > 0 && (area2end <= parse_address))                          {                              val = (ushort)txio.read_data_word(ref parse_address);                              area2end = (parse_address + 6 * val);                          }                            /* retrieve indrect-object parse entries */                          parse_address = (ushort)txio.read_data_word(ref address);                          if (parse_address > 0 && (area2base > parse_address))                              area2base = parse_address;                            if (parse_address > 0 && (area2end <= parse_address))                          {                              val = (ushort)txio.read_data_word(ref parse_address);                              area2end = (parse_address + 10 * val);                          }                      }                  }                  if (vend == 0) /* no verbs */                      return;                  verb_count = (uint)((vend - vbase) / 8);                  verb_table_base = vbase;                  verb_data_base = area2base;                  /* there is no preposition table' but *prep_table_base bounds the verb data area */                  prep_table_base = area2end;                  prep_table_end = area2end;                  action_count = (uint)(preact_table_base - action_table_base) / 2;                  return;              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if ((parser_type < (uint)tx_h.parser_types.inform5_grammar) && (uint)header.version == tx_h.V6)              {                  // TODO This code does not work!                  ulong word_address' first_word' last_word;                  ushort word_size' word_count;                  ulong vbase' vend;                  ulong area2base' area2end;                  ulong parse_address;                    parser_type = (uint)tx_h.parser_types.infocom6_grammar;                  address = (ulong)(header.objects - 4);                  action_table_base = (ushort)txio.read_data_word(ref address);                  preact_table_base = (ushort)txio.read_data_word(ref address);                    /* Calculate dictionary bounds and entry size */                    address = (ulong)header.dictionary;                  ulong temp = (ulong)txio.read_data_byte(ref address);                  address += temp;                  word_size = txio.read_data_byte(ref address);                  word_count = txio.read_data_word(ref address);                  first_word = address;                  last_word = (address + ((ulong)(word_count - 1) * word_size));                    vbase = area2base = 0xFFFF;                  vend = area2end = 0;                    for (word_address = first_word; word_address <= last_word; word_address += word_size)                  {                      address = word_address + 6;                      parse_index = (ushort)txio.read_data_word(ref address);                      address = word_address + word_size - 1;                      val = txio.read_data_byte(ref address); /* flags */                      if ((val & 1) != 0 && (val & 0x80) == 0 && (parse_index != 0) && (parse_index < action_table_base))                      { /* dictionary verb */                          if (vbase > parse_index)                              vbase = parse_index;                          if (vend <= parse_index)                              vend = parse_index + 8;                          address = parse_index + 4;                            /* retrieve direct-object only parse entries */                          parse_address = (ushort)txio.read_data_word(ref address);                          if (parse_address > 0 && (area2base > parse_address))                              area2base = parse_address;                            if (parse_address > 0 && (area2end <= parse_address))                          {                              val = (ushort)txio.read_data_word(ref parse_address);                              area2end = (parse_address + 6 * val);                          }                            /* retrieve indrect-object parse entries */                          parse_address = (ushort)txio.read_data_word(ref address);                          if (parse_address > 0 && (area2base > parse_address))                              area2base = parse_address;                            if (parse_address > 0 && (area2end <= parse_address))                          {                              val = (ushort)txio.read_data_word(ref parse_address);                              area2end = (parse_address + 10 * val);                          }                      }                  }                  if (vend == 0) /* no verbs */                      return;                  verb_count = (uint)((vend - vbase) / 8);                  verb_table_base = vbase;                  verb_data_base = area2base;                  /* there is no preposition table' but *prep_table_base bounds the verb data area */                  prep_table_base = area2end;                  prep_table_end = area2end;                  action_count = (uint)(preact_table_base - action_table_base) / 2;                  return;              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if ((parser_type < (uint)tx_h.parser_types.inform5_grammar) && (uint)header.version == tx_h.V6)              {                  // TODO This code does not work!                  ulong word_address' first_word' last_word;                  ushort word_size' word_count;                  ulong vbase' vend;                  ulong area2base' area2end;                  ulong parse_address;                    parser_type = (uint)tx_h.parser_types.infocom6_grammar;                  address = (ulong)(header.objects - 4);                  action_table_base = (ushort)txio.read_data_word(ref address);                  preact_table_base = (ushort)txio.read_data_word(ref address);                    /* Calculate dictionary bounds and entry size */                    address = (ulong)header.dictionary;                  ulong temp = (ulong)txio.read_data_byte(ref address);                  address += temp;                  word_size = txio.read_data_byte(ref address);                  word_count = txio.read_data_word(ref address);                  first_word = address;                  last_word = (address + ((ulong)(word_count - 1) * word_size));                    vbase = area2base = 0xFFFF;                  vend = area2end = 0;                    for (word_address = first_word; word_address <= last_word; word_address += word_size)                  {                      address = word_address + 6;                      parse_index = (ushort)txio.read_data_word(ref address);                      address = word_address + word_size - 1;                      val = txio.read_data_byte(ref address); /* flags */                      if ((val & 1) != 0 && (val & 0x80) == 0 && (parse_index != 0) && (parse_index < action_table_base))                      { /* dictionary verb */                          if (vbase > parse_index)                              vbase = parse_index;                          if (vend <= parse_index)                              vend = parse_index + 8;                          address = parse_index + 4;                            /* retrieve direct-object only parse entries */                          parse_address = (ushort)txio.read_data_word(ref address);                          if (parse_address > 0 && (area2base > parse_address))                              area2base = parse_address;                            if (parse_address > 0 && (area2end <= parse_address))                          {                              val = (ushort)txio.read_data_word(ref parse_address);                              area2end = (parse_address + 6 * val);                          }                            /* retrieve indrect-object parse entries */                          parse_address = (ushort)txio.read_data_word(ref address);                          if (parse_address > 0 && (area2base > parse_address))                              area2base = parse_address;                            if (parse_address > 0 && (area2end <= parse_address))                          {                              val = (ushort)txio.read_data_word(ref parse_address);                              area2end = (parse_address + 10 * val);                          }                      }                  }                  if (vend == 0) /* no verbs */                      return;                  verb_count = (uint)((vend - vbase) / 8);                  verb_table_base = vbase;                  verb_data_base = area2base;                  /* there is no preposition table' but *prep_table_base bounds the verb data area */                  prep_table_base = area2end;                  prep_table_end = area2end;                  action_count = (uint)(preact_table_base - action_table_base) / 2;                  return;              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if ((parser_type < (uint)tx_h.parser_types.inform5_grammar) && (uint)header.version == tx_h.V6)              {                  // TODO This code does not work!                  ulong word_address' first_word' last_word;                  ushort word_size' word_count;                  ulong vbase' vend;                  ulong area2base' area2end;                  ulong parse_address;                    parser_type = (uint)tx_h.parser_types.infocom6_grammar;                  address = (ulong)(header.objects - 4);                  action_table_base = (ushort)txio.read_data_word(ref address);                  preact_table_base = (ushort)txio.read_data_word(ref address);                    /* Calculate dictionary bounds and entry size */                    address = (ulong)header.dictionary;                  ulong temp = (ulong)txio.read_data_byte(ref address);                  address += temp;                  word_size = txio.read_data_byte(ref address);                  word_count = txio.read_data_word(ref address);                  first_word = address;                  last_word = (address + ((ulong)(word_count - 1) * word_size));                    vbase = area2base = 0xFFFF;                  vend = area2end = 0;                    for (word_address = first_word; word_address <= last_word; word_address += word_size)                  {                      address = word_address + 6;                      parse_index = (ushort)txio.read_data_word(ref address);                      address = word_address + word_size - 1;                      val = txio.read_data_byte(ref address); /* flags */                      if ((val & 1) != 0 && (val & 0x80) == 0 && (parse_index != 0) && (parse_index < action_table_base))                      { /* dictionary verb */                          if (vbase > parse_index)                              vbase = parse_index;                          if (vend <= parse_index)                              vend = parse_index + 8;                          address = parse_index + 4;                            /* retrieve direct-object only parse entries */                          parse_address = (ushort)txio.read_data_word(ref address);                          if (parse_address > 0 && (area2base > parse_address))                              area2base = parse_address;                            if (parse_address > 0 && (area2end <= parse_address))                          {                              val = (ushort)txio.read_data_word(ref parse_address);                              area2end = (parse_address + 6 * val);                          }                            /* retrieve indrect-object parse entries */                          parse_address = (ushort)txio.read_data_word(ref address);                          if (parse_address > 0 && (area2base > parse_address))                              area2base = parse_address;                            if (parse_address > 0 && (area2end <= parse_address))                          {                              val = (ushort)txio.read_data_word(ref parse_address);                              area2end = (parse_address + 10 * val);                          }                      }                  }                  if (vend == 0) /* no verbs */                      return;                  verb_count = (uint)((vend - vbase) / 8);                  verb_table_base = vbase;                  verb_data_base = area2base;                  /* there is no preposition table' but *prep_table_base bounds the verb data area */                  prep_table_base = area2end;                  prep_table_end = area2end;                  action_count = (uint)(preact_table_base - action_table_base) / 2;                  return;              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if ((parser_type < (uint)tx_h.parser_types.inform5_grammar) && (uint)header.version == tx_h.V6)              {                  // TODO This code does not work!                  ulong word_address' first_word' last_word;                  ushort word_size' word_count;                  ulong vbase' vend;                  ulong area2base' area2end;                  ulong parse_address;                    parser_type = (uint)tx_h.parser_types.infocom6_grammar;                  address = (ulong)(header.objects - 4);                  action_table_base = (ushort)txio.read_data_word(ref address);                  preact_table_base = (ushort)txio.read_data_word(ref address);                    /* Calculate dictionary bounds and entry size */                    address = (ulong)header.dictionary;                  ulong temp = (ulong)txio.read_data_byte(ref address);                  address += temp;                  word_size = txio.read_data_byte(ref address);                  word_count = txio.read_data_word(ref address);                  first_word = address;                  last_word = (address + ((ulong)(word_count - 1) * word_size));                    vbase = area2base = 0xFFFF;                  vend = area2end = 0;                    for (word_address = first_word; word_address <= last_word; word_address += word_size)                  {                      address = word_address + 6;                      parse_index = (ushort)txio.read_data_word(ref address);                      address = word_address + word_size - 1;                      val = txio.read_data_byte(ref address); /* flags */                      if ((val & 1) != 0 && (val & 0x80) == 0 && (parse_index != 0) && (parse_index < action_table_base))                      { /* dictionary verb */                          if (vbase > parse_index)                              vbase = parse_index;                          if (vend <= parse_index)                              vend = parse_index + 8;                          address = parse_index + 4;                            /* retrieve direct-object only parse entries */                          parse_address = (ushort)txio.read_data_word(ref address);                          if (parse_address > 0 && (area2base > parse_address))                              area2base = parse_address;                            if (parse_address > 0 && (area2end <= parse_address))                          {                              val = (ushort)txio.read_data_word(ref parse_address);                              area2end = (parse_address + 6 * val);                          }                            /* retrieve indrect-object parse entries */                          parse_address = (ushort)txio.read_data_word(ref address);                          if (parse_address > 0 && (area2base > parse_address))                              area2base = parse_address;                            if (parse_address > 0 && (area2end <= parse_address))                          {                              val = (ushort)txio.read_data_word(ref parse_address);                              area2end = (parse_address + 10 * val);                          }                      }                  }                  if (vend == 0) /* no verbs */                      return;                  verb_count = (uint)((vend - vbase) / 8);                  verb_table_base = vbase;                  verb_data_base = area2base;                  /* there is no preposition table' but *prep_table_base bounds the verb data area */                  prep_table_base = area2end;                  prep_table_end = area2end;                  action_count = (uint)(preact_table_base - action_table_base) / 2;                  return;              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if ((parser_type < (uint)tx_h.parser_types.inform5_grammar) && (uint)header.version == tx_h.V6)              {                  // TODO This code does not work!                  ulong word_address' first_word' last_word;                  ushort word_size' word_count;                  ulong vbase' vend;                  ulong area2base' area2end;                  ulong parse_address;                    parser_type = (uint)tx_h.parser_types.infocom6_grammar;                  address = (ulong)(header.objects - 4);                  action_table_base = (ushort)txio.read_data_word(ref address);                  preact_table_base = (ushort)txio.read_data_word(ref address);                    /* Calculate dictionary bounds and entry size */                    address = (ulong)header.dictionary;                  ulong temp = (ulong)txio.read_data_byte(ref address);                  address += temp;                  word_size = txio.read_data_byte(ref address);                  word_count = txio.read_data_word(ref address);                  first_word = address;                  last_word = (address + ((ulong)(word_count - 1) * word_size));                    vbase = area2base = 0xFFFF;                  vend = area2end = 0;                    for (word_address = first_word; word_address <= last_word; word_address += word_size)                  {                      address = word_address + 6;                      parse_index = (ushort)txio.read_data_word(ref address);                      address = word_address + word_size - 1;                      val = txio.read_data_byte(ref address); /* flags */                      if ((val & 1) != 0 && (val & 0x80) == 0 && (parse_index != 0) && (parse_index < action_table_base))                      { /* dictionary verb */                          if (vbase > parse_index)                              vbase = parse_index;                          if (vend <= parse_index)                              vend = parse_index + 8;                          address = parse_index + 4;                            /* retrieve direct-object only parse entries */                          parse_address = (ushort)txio.read_data_word(ref address);                          if (parse_address > 0 && (area2base > parse_address))                              area2base = parse_address;                            if (parse_address > 0 && (area2end <= parse_address))                          {                              val = (ushort)txio.read_data_word(ref parse_address);                              area2end = (parse_address + 6 * val);                          }                            /* retrieve indrect-object parse entries */                          parse_address = (ushort)txio.read_data_word(ref address);                          if (parse_address > 0 && (area2base > parse_address))                              area2base = parse_address;                            if (parse_address > 0 && (area2end <= parse_address))                          {                              val = (ushort)txio.read_data_word(ref parse_address);                              area2end = (parse_address + 10 * val);                          }                      }                  }                  if (vend == 0) /* no verbs */                      return;                  verb_count = (uint)((vend - vbase) / 8);                  verb_table_base = vbase;                  verb_data_base = area2base;                  /* there is no preposition table' but *prep_table_base bounds the verb data area */                  prep_table_base = area2end;                  prep_table_end = area2end;                  action_count = (uint)(preact_table_base - action_table_base) / 2;                  return;              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (parser_type < (uint)tx_h.parser_types.inform5_grammar)              {                  parser_type = (uint)tx_h.parser_types.infocom_fixed;                    if (((second_entry - first_entry) / entry_count) <= 7)                      parser_type = (uint)tx_h.parser_types.infocom_variable;              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.inform_gv1)              {                  first_entry = verb_data_base;                  if (((second_entry - first_entry) % 3) == 1)                  {                      entry_count = txio.read_data_byte(ref first_entry);                      if ((entry_count * 8 + 1) == (second_entry - first_entry))                      {                          /* this is the most ambiguous case */                          for (i = 0; i < entry_count && (parser_type == (int)tx_h.parser_types.inform_gv1); i++)                          {                              if (txio.read_data_byte(ref first_entry) > 6)                              {                                  parser_type = (int)tx_h.parser_types.inform_gv2;                                  break;                              }                              for (j = 1; j < 7; j++)                              {                                  val = txio.read_data_byte(ref first_entry);                                  if ((val >= 9) || (val <= 15) || (val >= 112) || (val <= 127))                                  {                                      parser_type = (int)tx_h.parser_types.inform_gv2;                                      break;                                  }                              }                              txio.read_data_byte(ref first_entry); /* action number.  This can be anything */                          }                      }                      else                      {                          parser_type = (int)tx_h.parser_types.inform_gv2;                      }                  }                  else if (((second_entry - first_entry) % 8) != 1)                  {                      Console.Error.WriteLine("Grammar table illegal size!");                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.inform_gv1)              {                  first_entry = verb_data_base;                  if (((second_entry - first_entry) % 3) == 1)                  {                      entry_count = txio.read_data_byte(ref first_entry);                      if ((entry_count * 8 + 1) == (second_entry - first_entry))                      {                          /* this is the most ambiguous case */                          for (i = 0; i < entry_count && (parser_type == (int)tx_h.parser_types.inform_gv1); i++)                          {                              if (txio.read_data_byte(ref first_entry) > 6)                              {                                  parser_type = (int)tx_h.parser_types.inform_gv2;                                  break;                              }                              for (j = 1; j < 7; j++)                              {                                  val = txio.read_data_byte(ref first_entry);                                  if ((val >= 9) || (val <= 15) || (val >= 112) || (val <= 127))                                  {                                      parser_type = (int)tx_h.parser_types.inform_gv2;                                      break;                                  }                              }                              txio.read_data_byte(ref first_entry); /* action number.  This can be anything */                          }                      }                      else                      {                          parser_type = (int)tx_h.parser_types.inform_gv2;                      }                  }                  else if (((second_entry - first_entry) % 8) != 1)                  {                      Console.Error.WriteLine("Grammar table illegal size!");                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.inform_gv1)              {                  first_entry = verb_data_base;                  if (((second_entry - first_entry) % 3) == 1)                  {                      entry_count = txio.read_data_byte(ref first_entry);                      if ((entry_count * 8 + 1) == (second_entry - first_entry))                      {                          /* this is the most ambiguous case */                          for (i = 0; i < entry_count && (parser_type == (int)tx_h.parser_types.inform_gv1); i++)                          {                              if (txio.read_data_byte(ref first_entry) > 6)                              {                                  parser_type = (int)tx_h.parser_types.inform_gv2;                                  break;                              }                              for (j = 1; j < 7; j++)                              {                                  val = txio.read_data_byte(ref first_entry);                                  if ((val >= 9) || (val <= 15) || (val >= 112) || (val <= 127))                                  {                                      parser_type = (int)tx_h.parser_types.inform_gv2;                                      break;                                  }                              }                              txio.read_data_byte(ref first_entry); /* action number.  This can be anything */                          }                      }                      else                      {                          parser_type = (int)tx_h.parser_types.inform_gv2;                      }                  }                  else if (((second_entry - first_entry) % 8) != 1)                  {                      Console.Error.WriteLine("Grammar table illegal size!");                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.inform_gv1)              {                  first_entry = verb_data_base;                  if (((second_entry - first_entry) % 3) == 1)                  {                      entry_count = txio.read_data_byte(ref first_entry);                      if ((entry_count * 8 + 1) == (second_entry - first_entry))                      {                          /* this is the most ambiguous case */                          for (i = 0; i < entry_count && (parser_type == (int)tx_h.parser_types.inform_gv1); i++)                          {                              if (txio.read_data_byte(ref first_entry) > 6)                              {                                  parser_type = (int)tx_h.parser_types.inform_gv2;                                  break;                              }                              for (j = 1; j < 7; j++)                              {                                  val = txio.read_data_byte(ref first_entry);                                  if ((val >= 9) || (val <= 15) || (val >= 112) || (val <= 127))                                  {                                      parser_type = (int)tx_h.parser_types.inform_gv2;                                      break;                                  }                              }                              txio.read_data_byte(ref first_entry); /* action number.  This can be anything */                          }                      }                      else                      {                          parser_type = (int)tx_h.parser_types.inform_gv2;                      }                  }                  else if (((second_entry - first_entry) % 8) != 1)                  {                      Console.Error.WriteLine("Grammar table illegal size!");                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.inform_gv1)              {                  first_entry = verb_data_base;                  if (((second_entry - first_entry) % 3) == 1)                  {                      entry_count = txio.read_data_byte(ref first_entry);                      if ((entry_count * 8 + 1) == (second_entry - first_entry))                      {                          /* this is the most ambiguous case */                          for (i = 0; i < entry_count && (parser_type == (int)tx_h.parser_types.inform_gv1); i++)                          {                              if (txio.read_data_byte(ref first_entry) > 6)                              {                                  parser_type = (int)tx_h.parser_types.inform_gv2;                                  break;                              }                              for (j = 1; j < 7; j++)                              {                                  val = txio.read_data_byte(ref first_entry);                                  if ((val >= 9) || (val <= 15) || (val >= 112) || (val <= 127))                                  {                                      parser_type = (int)tx_h.parser_types.inform_gv2;                                      break;                                  }                              }                              txio.read_data_byte(ref first_entry); /* action number.  This can be anything */                          }                      }                      else                      {                          parser_type = (int)tx_h.parser_types.inform_gv2;                      }                  }                  else if (((second_entry - first_entry) % 8) != 1)                  {                      Console.Error.WriteLine("Grammar table illegal size!");                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.inform_gv1)              {                  first_entry = verb_data_base;                  if (((second_entry - first_entry) % 3) == 1)                  {                      entry_count = txio.read_data_byte(ref first_entry);                      if ((entry_count * 8 + 1) == (second_entry - first_entry))                      {                          /* this is the most ambiguous case */                          for (i = 0; i < entry_count && (parser_type == (int)tx_h.parser_types.inform_gv1); i++)                          {                              if (txio.read_data_byte(ref first_entry) > 6)                              {                                  parser_type = (int)tx_h.parser_types.inform_gv2;                                  break;                              }                              for (j = 1; j < 7; j++)                              {                                  val = txio.read_data_byte(ref first_entry);                                  if ((val >= 9) || (val <= 15) || (val >= 112) || (val <= 127))                                  {                                      parser_type = (int)tx_h.parser_types.inform_gv2;                                      break;                                  }                              }                              txio.read_data_byte(ref first_entry); /* action number.  This can be anything */                          }                      }                      else                      {                          parser_type = (int)tx_h.parser_types.inform_gv2;                      }                  }                  else if (((second_entry - first_entry) % 8) != 1)                  {                      Console.Error.WriteLine("Grammar table illegal size!");                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.inform_gv1)              {                  first_entry = verb_data_base;                  if (((second_entry - first_entry) % 3) == 1)                  {                      entry_count = txio.read_data_byte(ref first_entry);                      if ((entry_count * 8 + 1) == (second_entry - first_entry))                      {                          /* this is the most ambiguous case */                          for (i = 0; i < entry_count && (parser_type == (int)tx_h.parser_types.inform_gv1); i++)                          {                              if (txio.read_data_byte(ref first_entry) > 6)                              {                                  parser_type = (int)tx_h.parser_types.inform_gv2;                                  break;                              }                              for (j = 1; j < 7; j++)                              {                                  val = txio.read_data_byte(ref first_entry);                                  if ((val >= 9) || (val <= 15) || (val >= 112) || (val <= 127))                                  {                                      parser_type = (int)tx_h.parser_types.inform_gv2;                                      break;                                  }                              }                              txio.read_data_byte(ref first_entry); /* action number.  This can be anything */                          }                      }                      else                      {                          parser_type = (int)tx_h.parser_types.inform_gv2;                      }                  }                  else if (((second_entry - first_entry) % 8) != 1)                  {                      Console.Error.WriteLine("Grammar table illegal size!");                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.inform_gv1)              {                  first_entry = verb_data_base;                  if (((second_entry - first_entry) % 3) == 1)                  {                      entry_count = txio.read_data_byte(ref first_entry);                      if ((entry_count * 8 + 1) == (second_entry - first_entry))                      {                          /* this is the most ambiguous case */                          for (i = 0; i < entry_count && (parser_type == (int)tx_h.parser_types.inform_gv1); i++)                          {                              if (txio.read_data_byte(ref first_entry) > 6)                              {                                  parser_type = (int)tx_h.parser_types.inform_gv2;                                  break;                              }                              for (j = 1; j < 7; j++)                              {                                  val = txio.read_data_byte(ref first_entry);                                  if ((val >= 9) || (val <= 15) || (val >= 112) || (val <= 127))                                  {                                      parser_type = (int)tx_h.parser_types.inform_gv2;                                      break;                                  }                              }                              txio.read_data_byte(ref first_entry); /* action number.  This can be anything */                          }                      }                      else                      {                          parser_type = (int)tx_h.parser_types.inform_gv2;                      }                  }                  else if (((second_entry - first_entry) % 8) != 1)                  {                      Console.Error.WriteLine("Grammar table illegal size!");                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.inform_gv1)              {                  first_entry = verb_data_base;                  if (((second_entry - first_entry) % 3) == 1)                  {                      entry_count = txio.read_data_byte(ref first_entry);                      if ((entry_count * 8 + 1) == (second_entry - first_entry))                      {                          /* this is the most ambiguous case */                          for (i = 0; i < entry_count && (parser_type == (int)tx_h.parser_types.inform_gv1); i++)                          {                              if (txio.read_data_byte(ref first_entry) > 6)                              {                                  parser_type = (int)tx_h.parser_types.inform_gv2;                                  break;                              }                              for (j = 1; j < 7; j++)                              {                                  val = txio.read_data_byte(ref first_entry);                                  if ((val >= 9) || (val <= 15) || (val >= 112) || (val <= 127))                                  {                                      parser_type = (int)tx_h.parser_types.inform_gv2;                                      break;                                  }                              }                              txio.read_data_byte(ref first_entry); /* action number.  This can be anything */                          }                      }                      else                      {                          parser_type = (int)tx_h.parser_types.inform_gv2;                      }                  }                  else if (((second_entry - first_entry) % 8) != 1)                  {                      Console.Error.WriteLine("Grammar table illegal size!");                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                  verb_entry = (ulong)txio.read_data_word(ref address);                  entry_count = (uint)txio.read_data_byte(ref verb_entry);                  while (entry_count-- > 0)                  {                      if (parser_type == (int)tx_h.parser_types.infocom_fixed)                      {                          verb_entry += 7;                          action_index = (uint)txio.read_data_byte(ref verb_entry);                      }                      else if (parser_type == (int)tx_h.parser_types.infocom_variable)                      {                          object_count = (uint)txio.read_data_byte(ref verb_entry);                          action_index = (uint)txio.read_data_byte(ref verb_entry);                          verb_entry += (ulong)(verb_sizes[(object_count >> 6) & 0x03] - 2);                      }                      else if ((parser_type == (int)tx_h.parser_types.inform_gv1) || (parser_type == (int)tx_h.parser_types.inform5_grammar))                      {                          /* GV1 */                          object_count = (uint)txio.read_data_byte(ref verb_entry);                          for (j = 0; j < 6; j++)                          {                              val = txio.read_data_byte(ref verb_entry);                              if (val < 16 || val >= 112)                                  continue;                              parse_index = (val - 16) % 32;                              if (parse_index > parse_count)                                  parse_count = (uint)parse_index;                          }                          action_index = (uint)txio.read_data_byte(ref verb_entry);                      }                      else                      {                          /* GV2 */                          action_index = (uint)(txio.read_data_word(ref verb_entry) & 0x3FF);                          val = txio.read_data_byte(ref verb_entry);                          while (val != 15)                          {                              txio.read_data_byte(ref verb_entry);                              txio.read_data_byte(ref verb_entry);                              val = txio.read_data_byte(ref verb_entry);                          }                      }                      if (action_index > action_count)                          action_count = action_index;                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                  verb_entry = (ulong)txio.read_data_word(ref address);                  entry_count = (uint)txio.read_data_byte(ref verb_entry);                  while (entry_count-- > 0)                  {                      if (parser_type == (int)tx_h.parser_types.infocom_fixed)                      {                          verb_entry += 7;                          action_index = (uint)txio.read_data_byte(ref verb_entry);                      }                      else if (parser_type == (int)tx_h.parser_types.infocom_variable)                      {                          object_count = (uint)txio.read_data_byte(ref verb_entry);                          action_index = (uint)txio.read_data_byte(ref verb_entry);                          verb_entry += (ulong)(verb_sizes[(object_count >> 6) & 0x03] - 2);                      }                      else if ((parser_type == (int)tx_h.parser_types.inform_gv1) || (parser_type == (int)tx_h.parser_types.inform5_grammar))                      {                          /* GV1 */                          object_count = (uint)txio.read_data_byte(ref verb_entry);                          for (j = 0; j < 6; j++)                          {                              val = txio.read_data_byte(ref verb_entry);                              if (val < 16 || val >= 112)                                  continue;                              parse_index = (val - 16) % 32;                              if (parse_index > parse_count)                                  parse_count = (uint)parse_index;                          }                          action_index = (uint)txio.read_data_byte(ref verb_entry);                      }                      else                      {                          /* GV2 */                          action_index = (uint)(txio.read_data_word(ref verb_entry) & 0x3FF);                          val = txio.read_data_byte(ref verb_entry);                          while (val != 15)                          {                              txio.read_data_byte(ref verb_entry);                              txio.read_data_byte(ref verb_entry);                              val = txio.read_data_byte(ref verb_entry);                          }                      }                      if (action_index > action_count)                          action_count = action_index;                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                  verb_entry = (ulong)txio.read_data_word(ref address);                  entry_count = (uint)txio.read_data_byte(ref verb_entry);                  while (entry_count-- > 0)                  {                      if (parser_type == (int)tx_h.parser_types.infocom_fixed)                      {                          verb_entry += 7;                          action_index = (uint)txio.read_data_byte(ref verb_entry);                      }                      else if (parser_type == (int)tx_h.parser_types.infocom_variable)                      {                          object_count = (uint)txio.read_data_byte(ref verb_entry);                          action_index = (uint)txio.read_data_byte(ref verb_entry);                          verb_entry += (ulong)(verb_sizes[(object_count >> 6) & 0x03] - 2);                      }                      else if ((parser_type == (int)tx_h.parser_types.inform_gv1) || (parser_type == (int)tx_h.parser_types.inform5_grammar))                      {                          /* GV1 */                          object_count = (uint)txio.read_data_byte(ref verb_entry);                          for (j = 0; j < 6; j++)                          {                              val = txio.read_data_byte(ref verb_entry);                              if (val < 16 || val >= 112)                                  continue;                              parse_index = (val - 16) % 32;                              if (parse_index > parse_count)                                  parse_count = (uint)parse_index;                          }                          action_index = (uint)txio.read_data_byte(ref verb_entry);                      }                      else                      {                          /* GV2 */                          action_index = (uint)(txio.read_data_word(ref verb_entry) & 0x3FF);                          val = txio.read_data_byte(ref verb_entry);                          while (val != 15)                          {                              txio.read_data_byte(ref verb_entry);                              txio.read_data_byte(ref verb_entry);                              val = txio.read_data_byte(ref verb_entry);                          }                      }                      if (action_index > action_count)                          action_count = action_index;                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                  verb_entry = (ulong)txio.read_data_word(ref address);                  entry_count = (uint)txio.read_data_byte(ref verb_entry);                  while (entry_count-- > 0)                  {                      if (parser_type == (int)tx_h.parser_types.infocom_fixed)                      {                          verb_entry += 7;                          action_index = (uint)txio.read_data_byte(ref verb_entry);                      }                      else if (parser_type == (int)tx_h.parser_types.infocom_variable)                      {                          object_count = (uint)txio.read_data_byte(ref verb_entry);                          action_index = (uint)txio.read_data_byte(ref verb_entry);                          verb_entry += (ulong)(verb_sizes[(object_count >> 6) & 0x03] - 2);                      }                      else if ((parser_type == (int)tx_h.parser_types.inform_gv1) || (parser_type == (int)tx_h.parser_types.inform5_grammar))                      {                          /* GV1 */                          object_count = (uint)txio.read_data_byte(ref verb_entry);                          for (j = 0; j < 6; j++)                          {                              val = txio.read_data_byte(ref verb_entry);                              if (val < 16 || val >= 112)                                  continue;                              parse_index = (val - 16) % 32;                              if (parse_index > parse_count)                                  parse_count = (uint)parse_index;                          }                          action_index = (uint)txio.read_data_byte(ref verb_entry);                      }                      else                      {                          /* GV2 */                          action_index = (uint)(txio.read_data_word(ref verb_entry) & 0x3FF);                          val = txio.read_data_byte(ref verb_entry);                          while (val != 15)                          {                              txio.read_data_byte(ref verb_entry);                              txio.read_data_byte(ref verb_entry);                              val = txio.read_data_byte(ref verb_entry);                          }                      }                      if (action_index > action_count)                          action_count = action_index;                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                  verb_entry = (ulong)txio.read_data_word(ref address);                  entry_count = (uint)txio.read_data_byte(ref verb_entry);                  while (entry_count-- > 0)                  {                      if (parser_type == (int)tx_h.parser_types.infocom_fixed)                      {                          verb_entry += 7;                          action_index = (uint)txio.read_data_byte(ref verb_entry);                      }                      else if (parser_type == (int)tx_h.parser_types.infocom_variable)                      {                          object_count = (uint)txio.read_data_byte(ref verb_entry);                          action_index = (uint)txio.read_data_byte(ref verb_entry);                          verb_entry += (ulong)(verb_sizes[(object_count >> 6) & 0x03] - 2);                      }                      else if ((parser_type == (int)tx_h.parser_types.inform_gv1) || (parser_type == (int)tx_h.parser_types.inform5_grammar))                      {                          /* GV1 */                          object_count = (uint)txio.read_data_byte(ref verb_entry);                          for (j = 0; j < 6; j++)                          {                              val = txio.read_data_byte(ref verb_entry);                              if (val < 16 || val >= 112)                                  continue;                              parse_index = (val - 16) % 32;                              if (parse_index > parse_count)                                  parse_count = (uint)parse_index;                          }                          action_index = (uint)txio.read_data_byte(ref verb_entry);                      }                      else                      {                          /* GV2 */                          action_index = (uint)(txio.read_data_word(ref verb_entry) & 0x3FF);                          val = txio.read_data_byte(ref verb_entry);                          while (val != 15)                          {                              txio.read_data_byte(ref verb_entry);                              txio.read_data_byte(ref verb_entry);                              val = txio.read_data_byte(ref verb_entry);                          }                      }                      if (action_index > action_count)                          action_count = action_index;                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                  verb_entry = (ulong)txio.read_data_word(ref address);                  entry_count = (uint)txio.read_data_byte(ref verb_entry);                  while (entry_count-- > 0)                  {                      if (parser_type == (int)tx_h.parser_types.infocom_fixed)                      {                          verb_entry += 7;                          action_index = (uint)txio.read_data_byte(ref verb_entry);                      }                      else if (parser_type == (int)tx_h.parser_types.infocom_variable)                      {                          object_count = (uint)txio.read_data_byte(ref verb_entry);                          action_index = (uint)txio.read_data_byte(ref verb_entry);                          verb_entry += (ulong)(verb_sizes[(object_count >> 6) & 0x03] - 2);                      }                      else if ((parser_type == (int)tx_h.parser_types.inform_gv1) || (parser_type == (int)tx_h.parser_types.inform5_grammar))                      {                          /* GV1 */                          object_count = (uint)txio.read_data_byte(ref verb_entry);                          for (j = 0; j < 6; j++)                          {                              val = txio.read_data_byte(ref verb_entry);                              if (val < 16 || val >= 112)                                  continue;                              parse_index = (val - 16) % 32;                              if (parse_index > parse_count)                                  parse_count = (uint)parse_index;                          }                          action_index = (uint)txio.read_data_byte(ref verb_entry);                      }                      else                      {                          /* GV2 */                          action_index = (uint)(txio.read_data_word(ref verb_entry) & 0x3FF);                          val = txio.read_data_byte(ref verb_entry);                          while (val != 15)                          {                              txio.read_data_byte(ref verb_entry);                              txio.read_data_byte(ref verb_entry);                              val = txio.read_data_byte(ref verb_entry);                          }                      }                      if (action_index > action_count)                          action_count = action_index;                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                  verb_entry = (ulong)txio.read_data_word(ref address);                  entry_count = (uint)txio.read_data_byte(ref verb_entry);                  while (entry_count-- > 0)                  {                      if (parser_type == (int)tx_h.parser_types.infocom_fixed)                      {                          verb_entry += 7;                          action_index = (uint)txio.read_data_byte(ref verb_entry);                      }                      else if (parser_type == (int)tx_h.parser_types.infocom_variable)                      {                          object_count = (uint)txio.read_data_byte(ref verb_entry);                          action_index = (uint)txio.read_data_byte(ref verb_entry);                          verb_entry += (ulong)(verb_sizes[(object_count >> 6) & 0x03] - 2);                      }                      else if ((parser_type == (int)tx_h.parser_types.inform_gv1) || (parser_type == (int)tx_h.parser_types.inform5_grammar))                      {                          /* GV1 */                          object_count = (uint)txio.read_data_byte(ref verb_entry);                          for (j = 0; j < 6; j++)                          {                              val = txio.read_data_byte(ref verb_entry);                              if (val < 16 || val >= 112)                                  continue;                              parse_index = (val - 16) % 32;                              if (parse_index > parse_count)                                  parse_count = (uint)parse_index;                          }                          action_index = (uint)txio.read_data_byte(ref verb_entry);                      }                      else                      {                          /* GV2 */                          action_index = (uint)(txio.read_data_word(ref verb_entry) & 0x3FF);                          val = txio.read_data_byte(ref verb_entry);                          while (val != 15)                          {                              txio.read_data_byte(ref verb_entry);                              txio.read_data_byte(ref verb_entry);                              val = txio.read_data_byte(ref verb_entry);                          }                      }                      if (action_index > action_count)                          action_count = action_index;                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                  verb_entry = (ulong)txio.read_data_word(ref address);                  entry_count = (uint)txio.read_data_byte(ref verb_entry);                  while (entry_count-- > 0)                  {                      if (parser_type == (int)tx_h.parser_types.infocom_fixed)                      {                          verb_entry += 7;                          action_index = (uint)txio.read_data_byte(ref verb_entry);                      }                      else if (parser_type == (int)tx_h.parser_types.infocom_variable)                      {                          object_count = (uint)txio.read_data_byte(ref verb_entry);                          action_index = (uint)txio.read_data_byte(ref verb_entry);                          verb_entry += (ulong)(verb_sizes[(object_count >> 6) & 0x03] - 2);                      }                      else if ((parser_type == (int)tx_h.parser_types.inform_gv1) || (parser_type == (int)tx_h.parser_types.inform5_grammar))                      {                          /* GV1 */                          object_count = (uint)txio.read_data_byte(ref verb_entry);                          for (j = 0; j < 6; j++)                          {                              val = txio.read_data_byte(ref verb_entry);                              if (val < 16 || val >= 112)                                  continue;                              parse_index = (val - 16) % 32;                              if (parse_index > parse_count)                                  parse_count = (uint)parse_index;                          }                          action_index = (uint)txio.read_data_byte(ref verb_entry);                      }                      else                      {                          /* GV2 */                          action_index = (uint)(txio.read_data_word(ref verb_entry) & 0x3FF);                          val = txio.read_data_byte(ref verb_entry);                          while (val != 15)                          {                              txio.read_data_byte(ref verb_entry);                              txio.read_data_byte(ref verb_entry);                              val = txio.read_data_byte(ref verb_entry);                          }                      }                      if (action_index > action_count)                          action_count = action_index;                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                  verb_entry = (ulong)txio.read_data_word(ref address);                  entry_count = (uint)txio.read_data_byte(ref verb_entry);                  while (entry_count-- > 0)                  {                      if (parser_type == (int)tx_h.parser_types.infocom_fixed)                      {                          verb_entry += 7;                          action_index = (uint)txio.read_data_byte(ref verb_entry);                      }                      else if (parser_type == (int)tx_h.parser_types.infocom_variable)                      {                          object_count = (uint)txio.read_data_byte(ref verb_entry);                          action_index = (uint)txio.read_data_byte(ref verb_entry);                          verb_entry += (ulong)(verb_sizes[(object_count >> 6) & 0x03] - 2);                      }                      else if ((parser_type == (int)tx_h.parser_types.inform_gv1) || (parser_type == (int)tx_h.parser_types.inform5_grammar))                      {                          /* GV1 */                          object_count = (uint)txio.read_data_byte(ref verb_entry);                          for (j = 0; j < 6; j++)                          {                              val = txio.read_data_byte(ref verb_entry);                              if (val < 16 || val >= 112)                                  continue;                              parse_index = (val - 16) % 32;                              if (parse_index > parse_count)                                  parse_count = (uint)parse_index;                          }                          action_index = (uint)txio.read_data_byte(ref verb_entry);                      }                      else                      {                          /* GV2 */                          action_index = (uint)(txio.read_data_word(ref verb_entry) & 0x3FF);                          val = txio.read_data_byte(ref verb_entry);                          while (val != 15)                          {                              txio.read_data_byte(ref verb_entry);                              txio.read_data_byte(ref verb_entry);                              val = txio.read_data_byte(ref verb_entry);                          }                      }                      if (action_index > action_count)                          action_count = action_index;                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* GV2 has neither preaction/parse table nor preposition table */                  prep_table_base = preact_table_base;                  prep_table_end = preact_table_base;              }              else              {                  if (parser_type < (int)tx_h.parser_types.inform_gv1)                      prep_table_base = preact_table_base + (action_count * sizeof(zword_t));                  else                      prep_table_base = preact_table_base + (parse_count * sizeof(zword_t));                    /*                   * Set the preposition table type by looking to see if the byte index                   * is stored in a word (an hence the upper 8 bits are zero).                   */                    address = prep_table_base;                  prep_count = (uint)txio.read_data_word(ref address);                  address += 2; /* Skip first address */                  if ((uint)txio.read_data_byte(ref address) == 0)                  {                      prep_type = 0;                      prep_table_end = prep_table_base + 2 + (4 * prep_count) - 1;                  }                  else                  {                      prep_type = 1;                      prep_table_end = prep_table_base + 2 + (3 * prep_count) - 1;                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* GV2 has neither preaction/parse table nor preposition table */                  prep_table_base = preact_table_base;                  prep_table_end = preact_table_base;              }              else              {                  if (parser_type < (int)tx_h.parser_types.inform_gv1)                      prep_table_base = preact_table_base + (action_count * sizeof(zword_t));                  else                      prep_table_base = preact_table_base + (parse_count * sizeof(zword_t));                    /*                   * Set the preposition table type by looking to see if the byte index                   * is stored in a word (an hence the upper 8 bits are zero).                   */                    address = prep_table_base;                  prep_count = (uint)txio.read_data_word(ref address);                  address += 2; /* Skip first address */                  if ((uint)txio.read_data_byte(ref address) == 0)                  {                      prep_type = 0;                      prep_table_end = prep_table_base + 2 + (4 * prep_count) - 1;                  }                  else                  {                      prep_type = 1;                      prep_table_end = prep_table_base + 2 + (3 * prep_count) - 1;                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* GV2 has neither preaction/parse table nor preposition table */                  prep_table_base = preact_table_base;                  prep_table_end = preact_table_base;              }              else              {                  if (parser_type < (int)tx_h.parser_types.inform_gv1)                      prep_table_base = preact_table_base + (action_count * sizeof(zword_t));                  else                      prep_table_base = preact_table_base + (parse_count * sizeof(zword_t));                    /*                   * Set the preposition table type by looking to see if the byte index                   * is stored in a word (an hence the upper 8 bits are zero).                   */                    address = prep_table_base;                  prep_count = (uint)txio.read_data_word(ref address);                  address += 2; /* Skip first address */                  if ((uint)txio.read_data_byte(ref address) == 0)                  {                      prep_type = 0;                      prep_table_end = prep_table_base + 2 + (4 * prep_count) - 1;                  }                  else                  {                      prep_type = 1;                      prep_table_end = prep_table_base + 2 + (3 * prep_count) - 1;                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* GV2 has neither preaction/parse table nor preposition table */                  prep_table_base = preact_table_base;                  prep_table_end = preact_table_base;              }              else              {                  if (parser_type < (int)tx_h.parser_types.inform_gv1)                      prep_table_base = preact_table_base + (action_count * sizeof(zword_t));                  else                      prep_table_base = preact_table_base + (parse_count * sizeof(zword_t));                    /*                   * Set the preposition table type by looking to see if the byte index                   * is stored in a word (an hence the upper 8 bits are zero).                   */                    address = prep_table_base;                  prep_count = (uint)txio.read_data_word(ref address);                  address += 2; /* Skip first address */                  if ((uint)txio.read_data_byte(ref address) == 0)                  {                      prep_type = 0;                      prep_table_end = prep_table_base + 2 + (4 * prep_count) - 1;                  }                  else                  {                      prep_type = 1;                      prep_table_end = prep_table_base + 2 + (3 * prep_count) - 1;                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,configure_parse_tables,The following statement contains a magic number: if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* GV2 has neither preaction/parse table nor preposition table */                  prep_table_base = preact_table_base;                  prep_table_end = preact_table_base;              }              else              {                  if (parser_type < (int)tx_h.parser_types.inform_gv1)                      prep_table_base = preact_table_base + (action_count * sizeof(zword_t));                  else                      prep_table_base = preact_table_base + (parse_count * sizeof(zword_t));                    /*                   * Set the preposition table type by looking to see if the byte index                   * is stored in a word (an hence the upper 8 bits are zero).                   */                    address = prep_table_base;                  prep_count = (uint)txio.read_data_word(ref address);                  address += 2; /* Skip first address */                  if ((uint)txio.read_data_byte(ref address) == 0)                  {                      prep_type = 0;                      prep_table_end = prep_table_base + 2 + (4 * prep_count) - 1;                  }                  else                  {                      prep_type = 1;                      prep_table_end = prep_table_base + 2 + (3 * prep_count) - 1;                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_parse_table,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                    /* Get start of verb entry and number of entries */                    if (parser_type == (uint)tx_h.parser_types.infocom6_grammar)                  {                      ulong do_address' doio_address;                      uint verb_address;                        verb_address = (uint)address; /* cast is guaranteed to work provided uint >= 16 bits */                      txio.tx_printf("\n{0'3:d}. @ ${1:X4}' verb = "' i' address);                      show_words((uint)address' 0L' tx_h.VERB_V6' parser_type);                      txio.tx_printf("\n    Main data");                      txio.tx_printf("\n    [");                      parse_data = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4} "' (uint)parse_data);                      txio.read_data_word(ref address);	/* I don't know what this word does */                      txio.tx_printf("{0:X4} "' (uint)parse_data);                      do_address = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4} "' (uint)do_address);                      doio_address = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4}"' (uint)doio_address);                      txio.tx_printf("] ");                      if (verb_entry != 0xFFFF)                          show_verb_grammar(parse_entry' verb_address' (int)parser_type' 0' 0' 0L' 0L);                        if (do_address > 0)                      {                          txio.tx_printf("\n    One object entries:\n");                          verb_entry = do_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          verb_size = 3; /* words */                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              txio.tx_printf("    [");                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_word(ref verb_entry);                                  txio.tx_printf("{0:X4}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                              txio.tx_printf("] ");                              show_verb_grammar(parse_entry' verb_address' (int)parser_type' 1'                                         0' 0L' 0L);                              txio.tx_printf("\n");                          }                      }                      if (doio_address > 0)                      {                          txio.tx_printf("\n    Two object entries:\n");                          verb_entry = doio_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          verb_size = 5; /* words */                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              txio.tx_printf("    [");                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_word(ref verb_entry);                                  txio.tx_printf("{0:X4}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                              txio.tx_printf("] ");                              show_verb_grammar(parse_entry' verb_address' (int)parser_type' 2'                                         0' 0L' 0L);                              txio.tx_printf("\n");                          }                      }                  }                  else                  { /* everything but Zork Zero' Shogun' and Arthur */                      verb_entry = (ulong)txio.read_data_word(ref address);                      entry_count = (uint)txio.read_data_byte(ref verb_entry);                        /* Show the verb index' entry count' verb and synonyms */                        txio.tx_printf("\n{0:d3}. {1} entr{2}' verb = "' (int)tx_h.VERB_NUM(i' parser_type)'                                 (int)entry_count' (entry_count == 1) ? "y" : "ies");                      show_words(tx_h.VERB_NUM(i' parser_type)' 0L' tx_h.VERB' parser_type);                      txio.tx_printf("\n");                        /* Show parse data and grammar for each verb entry */                        while (entry_count-- > 0)                      {                          parse_entry = verb_entry;                            /* Calculate the amount of verb data */                            if (parser_type != (int)tx_h.parser_types.infocom_variable)                          {                              verb_size = 8;                          }                          else                          {                              object_count = (uint)txio.read_data_byte(ref parse_entry);                              verb_size = verb_sizes[(object_count >> 6) & 0x03];                              parse_entry = verb_entry;                          }                            /* Show parse data for each verb */                            txio.tx_printf("    [");                            if (parser_type < (int)tx_h.parser_types.inform_gv2)                          {                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_byte(ref verb_entry);                                  txio.tx_printf("{0:X2}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                          }                          else                          {                              /* GV2 variable entry format                                 <flags and action high> <action low> n*(<token type> <token data 1> <token data 2>) <ENDIT>*/                              for (j = 0; (j == 0) || (j % 3 != 0) || (parse_data != tx_h.ENDIT); j++)                              {                                  if (j != 0)                                      txio.tx_printf(" ");                                  parse_data = (uint)txio.read_data_byte(ref verb_entry);                                  txio.tx_printf("{0:X2}"' (uint)parse_data);                              }                              verb_size = j;                          }                          txio.tx_printf("] ");                          for (; j < 8; j++)                              txio.tx_printf("   ");                            /* Show the verb grammar for this entry */                            show_verb_grammar(parse_entry' tx_h.VERB_NUM(i' parser_type)' (int)parser_type' 0'                                             (int)prep_type' prep_table_base' attr_names_base);                          txio.tx_printf("\n");                      }                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_parse_table,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                    /* Get start of verb entry and number of entries */                    if (parser_type == (uint)tx_h.parser_types.infocom6_grammar)                  {                      ulong do_address' doio_address;                      uint verb_address;                        verb_address = (uint)address; /* cast is guaranteed to work provided uint >= 16 bits */                      txio.tx_printf("\n{0'3:d}. @ ${1:X4}' verb = "' i' address);                      show_words((uint)address' 0L' tx_h.VERB_V6' parser_type);                      txio.tx_printf("\n    Main data");                      txio.tx_printf("\n    [");                      parse_data = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4} "' (uint)parse_data);                      txio.read_data_word(ref address);	/* I don't know what this word does */                      txio.tx_printf("{0:X4} "' (uint)parse_data);                      do_address = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4} "' (uint)do_address);                      doio_address = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4}"' (uint)doio_address);                      txio.tx_printf("] ");                      if (verb_entry != 0xFFFF)                          show_verb_grammar(parse_entry' verb_address' (int)parser_type' 0' 0' 0L' 0L);                        if (do_address > 0)                      {                          txio.tx_printf("\n    One object entries:\n");                          verb_entry = do_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          verb_size = 3; /* words */                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              txio.tx_printf("    [");                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_word(ref verb_entry);                                  txio.tx_printf("{0:X4}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                              txio.tx_printf("] ");                              show_verb_grammar(parse_entry' verb_address' (int)parser_type' 1'                                         0' 0L' 0L);                              txio.tx_printf("\n");                          }                      }                      if (doio_address > 0)                      {                          txio.tx_printf("\n    Two object entries:\n");                          verb_entry = doio_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          verb_size = 5; /* words */                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              txio.tx_printf("    [");                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_word(ref verb_entry);                                  txio.tx_printf("{0:X4}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                              txio.tx_printf("] ");                              show_verb_grammar(parse_entry' verb_address' (int)parser_type' 2'                                         0' 0L' 0L);                              txio.tx_printf("\n");                          }                      }                  }                  else                  { /* everything but Zork Zero' Shogun' and Arthur */                      verb_entry = (ulong)txio.read_data_word(ref address);                      entry_count = (uint)txio.read_data_byte(ref verb_entry);                        /* Show the verb index' entry count' verb and synonyms */                        txio.tx_printf("\n{0:d3}. {1} entr{2}' verb = "' (int)tx_h.VERB_NUM(i' parser_type)'                                 (int)entry_count' (entry_count == 1) ? "y" : "ies");                      show_words(tx_h.VERB_NUM(i' parser_type)' 0L' tx_h.VERB' parser_type);                      txio.tx_printf("\n");                        /* Show parse data and grammar for each verb entry */                        while (entry_count-- > 0)                      {                          parse_entry = verb_entry;                            /* Calculate the amount of verb data */                            if (parser_type != (int)tx_h.parser_types.infocom_variable)                          {                              verb_size = 8;                          }                          else                          {                              object_count = (uint)txio.read_data_byte(ref parse_entry);                              verb_size = verb_sizes[(object_count >> 6) & 0x03];                              parse_entry = verb_entry;                          }                            /* Show parse data for each verb */                            txio.tx_printf("    [");                            if (parser_type < (int)tx_h.parser_types.inform_gv2)                          {                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_byte(ref verb_entry);                                  txio.tx_printf("{0:X2}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                          }                          else                          {                              /* GV2 variable entry format                                 <flags and action high> <action low> n*(<token type> <token data 1> <token data 2>) <ENDIT>*/                              for (j = 0; (j == 0) || (j % 3 != 0) || (parse_data != tx_h.ENDIT); j++)                              {                                  if (j != 0)                                      txio.tx_printf(" ");                                  parse_data = (uint)txio.read_data_byte(ref verb_entry);                                  txio.tx_printf("{0:X2}"' (uint)parse_data);                              }                              verb_size = j;                          }                          txio.tx_printf("] ");                          for (; j < 8; j++)                              txio.tx_printf("   ");                            /* Show the verb grammar for this entry */                            show_verb_grammar(parse_entry' tx_h.VERB_NUM(i' parser_type)' (int)parser_type' 0'                                             (int)prep_type' prep_table_base' attr_names_base);                          txio.tx_printf("\n");                      }                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_parse_table,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                    /* Get start of verb entry and number of entries */                    if (parser_type == (uint)tx_h.parser_types.infocom6_grammar)                  {                      ulong do_address' doio_address;                      uint verb_address;                        verb_address = (uint)address; /* cast is guaranteed to work provided uint >= 16 bits */                      txio.tx_printf("\n{0'3:d}. @ ${1:X4}' verb = "' i' address);                      show_words((uint)address' 0L' tx_h.VERB_V6' parser_type);                      txio.tx_printf("\n    Main data");                      txio.tx_printf("\n    [");                      parse_data = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4} "' (uint)parse_data);                      txio.read_data_word(ref address);	/* I don't know what this word does */                      txio.tx_printf("{0:X4} "' (uint)parse_data);                      do_address = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4} "' (uint)do_address);                      doio_address = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4}"' (uint)doio_address);                      txio.tx_printf("] ");                      if (verb_entry != 0xFFFF)                          show_verb_grammar(parse_entry' verb_address' (int)parser_type' 0' 0' 0L' 0L);                        if (do_address > 0)                      {                          txio.tx_printf("\n    One object entries:\n");                          verb_entry = do_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          verb_size = 3; /* words */                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              txio.tx_printf("    [");                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_word(ref verb_entry);                                  txio.tx_printf("{0:X4}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                              txio.tx_printf("] ");                              show_verb_grammar(parse_entry' verb_address' (int)parser_type' 1'                                         0' 0L' 0L);                              txio.tx_printf("\n");                          }                      }                      if (doio_address > 0)                      {                          txio.tx_printf("\n    Two object entries:\n");                          verb_entry = doio_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          verb_size = 5; /* words */                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              txio.tx_printf("    [");                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_word(ref verb_entry);                                  txio.tx_printf("{0:X4}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                              txio.tx_printf("] ");                              show_verb_grammar(parse_entry' verb_address' (int)parser_type' 2'                                         0' 0L' 0L);                              txio.tx_printf("\n");                          }                      }                  }                  else                  { /* everything but Zork Zero' Shogun' and Arthur */                      verb_entry = (ulong)txio.read_data_word(ref address);                      entry_count = (uint)txio.read_data_byte(ref verb_entry);                        /* Show the verb index' entry count' verb and synonyms */                        txio.tx_printf("\n{0:d3}. {1} entr{2}' verb = "' (int)tx_h.VERB_NUM(i' parser_type)'                                 (int)entry_count' (entry_count == 1) ? "y" : "ies");                      show_words(tx_h.VERB_NUM(i' parser_type)' 0L' tx_h.VERB' parser_type);                      txio.tx_printf("\n");                        /* Show parse data and grammar for each verb entry */                        while (entry_count-- > 0)                      {                          parse_entry = verb_entry;                            /* Calculate the amount of verb data */                            if (parser_type != (int)tx_h.parser_types.infocom_variable)                          {                              verb_size = 8;                          }                          else                          {                              object_count = (uint)txio.read_data_byte(ref parse_entry);                              verb_size = verb_sizes[(object_count >> 6) & 0x03];                              parse_entry = verb_entry;                          }                            /* Show parse data for each verb */                            txio.tx_printf("    [");                            if (parser_type < (int)tx_h.parser_types.inform_gv2)                          {                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_byte(ref verb_entry);                                  txio.tx_printf("{0:X2}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                          }                          else                          {                              /* GV2 variable entry format                                 <flags and action high> <action low> n*(<token type> <token data 1> <token data 2>) <ENDIT>*/                              for (j = 0; (j == 0) || (j % 3 != 0) || (parse_data != tx_h.ENDIT); j++)                              {                                  if (j != 0)                                      txio.tx_printf(" ");                                  parse_data = (uint)txio.read_data_byte(ref verb_entry);                                  txio.tx_printf("{0:X2}"' (uint)parse_data);                              }                              verb_size = j;                          }                          txio.tx_printf("] ");                          for (; j < 8; j++)                              txio.tx_printf("   ");                            /* Show the verb grammar for this entry */                            show_verb_grammar(parse_entry' tx_h.VERB_NUM(i' parser_type)' (int)parser_type' 0'                                             (int)prep_type' prep_table_base' attr_names_base);                          txio.tx_printf("\n");                      }                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_parse_table,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                    /* Get start of verb entry and number of entries */                    if (parser_type == (uint)tx_h.parser_types.infocom6_grammar)                  {                      ulong do_address' doio_address;                      uint verb_address;                        verb_address = (uint)address; /* cast is guaranteed to work provided uint >= 16 bits */                      txio.tx_printf("\n{0'3:d}. @ ${1:X4}' verb = "' i' address);                      show_words((uint)address' 0L' tx_h.VERB_V6' parser_type);                      txio.tx_printf("\n    Main data");                      txio.tx_printf("\n    [");                      parse_data = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4} "' (uint)parse_data);                      txio.read_data_word(ref address);	/* I don't know what this word does */                      txio.tx_printf("{0:X4} "' (uint)parse_data);                      do_address = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4} "' (uint)do_address);                      doio_address = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4}"' (uint)doio_address);                      txio.tx_printf("] ");                      if (verb_entry != 0xFFFF)                          show_verb_grammar(parse_entry' verb_address' (int)parser_type' 0' 0' 0L' 0L);                        if (do_address > 0)                      {                          txio.tx_printf("\n    One object entries:\n");                          verb_entry = do_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          verb_size = 3; /* words */                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              txio.tx_printf("    [");                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_word(ref verb_entry);                                  txio.tx_printf("{0:X4}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                              txio.tx_printf("] ");                              show_verb_grammar(parse_entry' verb_address' (int)parser_type' 1'                                         0' 0L' 0L);                              txio.tx_printf("\n");                          }                      }                      if (doio_address > 0)                      {                          txio.tx_printf("\n    Two object entries:\n");                          verb_entry = doio_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          verb_size = 5; /* words */                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              txio.tx_printf("    [");                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_word(ref verb_entry);                                  txio.tx_printf("{0:X4}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                              txio.tx_printf("] ");                              show_verb_grammar(parse_entry' verb_address' (int)parser_type' 2'                                         0' 0L' 0L);                              txio.tx_printf("\n");                          }                      }                  }                  else                  { /* everything but Zork Zero' Shogun' and Arthur */                      verb_entry = (ulong)txio.read_data_word(ref address);                      entry_count = (uint)txio.read_data_byte(ref verb_entry);                        /* Show the verb index' entry count' verb and synonyms */                        txio.tx_printf("\n{0:d3}. {1} entr{2}' verb = "' (int)tx_h.VERB_NUM(i' parser_type)'                                 (int)entry_count' (entry_count == 1) ? "y" : "ies");                      show_words(tx_h.VERB_NUM(i' parser_type)' 0L' tx_h.VERB' parser_type);                      txio.tx_printf("\n");                        /* Show parse data and grammar for each verb entry */                        while (entry_count-- > 0)                      {                          parse_entry = verb_entry;                            /* Calculate the amount of verb data */                            if (parser_type != (int)tx_h.parser_types.infocom_variable)                          {                              verb_size = 8;                          }                          else                          {                              object_count = (uint)txio.read_data_byte(ref parse_entry);                              verb_size = verb_sizes[(object_count >> 6) & 0x03];                              parse_entry = verb_entry;                          }                            /* Show parse data for each verb */                            txio.tx_printf("    [");                            if (parser_type < (int)tx_h.parser_types.inform_gv2)                          {                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_byte(ref verb_entry);                                  txio.tx_printf("{0:X2}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                          }                          else                          {                              /* GV2 variable entry format                                 <flags and action high> <action low> n*(<token type> <token data 1> <token data 2>) <ENDIT>*/                              for (j = 0; (j == 0) || (j % 3 != 0) || (parse_data != tx_h.ENDIT); j++)                              {                                  if (j != 0)                                      txio.tx_printf(" ");                                  parse_data = (uint)txio.read_data_byte(ref verb_entry);                                  txio.tx_printf("{0:X2}"' (uint)parse_data);                              }                              verb_size = j;                          }                          txio.tx_printf("] ");                          for (; j < 8; j++)                              txio.tx_printf("   ");                            /* Show the verb grammar for this entry */                            show_verb_grammar(parse_entry' tx_h.VERB_NUM(i' parser_type)' (int)parser_type' 0'                                             (int)prep_type' prep_table_base' attr_names_base);                          txio.tx_printf("\n");                      }                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_parse_table,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                    /* Get start of verb entry and number of entries */                    if (parser_type == (uint)tx_h.parser_types.infocom6_grammar)                  {                      ulong do_address' doio_address;                      uint verb_address;                        verb_address = (uint)address; /* cast is guaranteed to work provided uint >= 16 bits */                      txio.tx_printf("\n{0'3:d}. @ ${1:X4}' verb = "' i' address);                      show_words((uint)address' 0L' tx_h.VERB_V6' parser_type);                      txio.tx_printf("\n    Main data");                      txio.tx_printf("\n    [");                      parse_data = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4} "' (uint)parse_data);                      txio.read_data_word(ref address);	/* I don't know what this word does */                      txio.tx_printf("{0:X4} "' (uint)parse_data);                      do_address = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4} "' (uint)do_address);                      doio_address = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4}"' (uint)doio_address);                      txio.tx_printf("] ");                      if (verb_entry != 0xFFFF)                          show_verb_grammar(parse_entry' verb_address' (int)parser_type' 0' 0' 0L' 0L);                        if (do_address > 0)                      {                          txio.tx_printf("\n    One object entries:\n");                          verb_entry = do_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          verb_size = 3; /* words */                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              txio.tx_printf("    [");                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_word(ref verb_entry);                                  txio.tx_printf("{0:X4}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                              txio.tx_printf("] ");                              show_verb_grammar(parse_entry' verb_address' (int)parser_type' 1'                                         0' 0L' 0L);                              txio.tx_printf("\n");                          }                      }                      if (doio_address > 0)                      {                          txio.tx_printf("\n    Two object entries:\n");                          verb_entry = doio_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          verb_size = 5; /* words */                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              txio.tx_printf("    [");                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_word(ref verb_entry);                                  txio.tx_printf("{0:X4}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                              txio.tx_printf("] ");                              show_verb_grammar(parse_entry' verb_address' (int)parser_type' 2'                                         0' 0L' 0L);                              txio.tx_printf("\n");                          }                      }                  }                  else                  { /* everything but Zork Zero' Shogun' and Arthur */                      verb_entry = (ulong)txio.read_data_word(ref address);                      entry_count = (uint)txio.read_data_byte(ref verb_entry);                        /* Show the verb index' entry count' verb and synonyms */                        txio.tx_printf("\n{0:d3}. {1} entr{2}' verb = "' (int)tx_h.VERB_NUM(i' parser_type)'                                 (int)entry_count' (entry_count == 1) ? "y" : "ies");                      show_words(tx_h.VERB_NUM(i' parser_type)' 0L' tx_h.VERB' parser_type);                      txio.tx_printf("\n");                        /* Show parse data and grammar for each verb entry */                        while (entry_count-- > 0)                      {                          parse_entry = verb_entry;                            /* Calculate the amount of verb data */                            if (parser_type != (int)tx_h.parser_types.infocom_variable)                          {                              verb_size = 8;                          }                          else                          {                              object_count = (uint)txio.read_data_byte(ref parse_entry);                              verb_size = verb_sizes[(object_count >> 6) & 0x03];                              parse_entry = verb_entry;                          }                            /* Show parse data for each verb */                            txio.tx_printf("    [");                            if (parser_type < (int)tx_h.parser_types.inform_gv2)                          {                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_byte(ref verb_entry);                                  txio.tx_printf("{0:X2}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                          }                          else                          {                              /* GV2 variable entry format                                 <flags and action high> <action low> n*(<token type> <token data 1> <token data 2>) <ENDIT>*/                              for (j = 0; (j == 0) || (j % 3 != 0) || (parse_data != tx_h.ENDIT); j++)                              {                                  if (j != 0)                                      txio.tx_printf(" ");                                  parse_data = (uint)txio.read_data_byte(ref verb_entry);                                  txio.tx_printf("{0:X2}"' (uint)parse_data);                              }                              verb_size = j;                          }                          txio.tx_printf("] ");                          for (; j < 8; j++)                              txio.tx_printf("   ");                            /* Show the verb grammar for this entry */                            show_verb_grammar(parse_entry' tx_h.VERB_NUM(i' parser_type)' (int)parser_type' 0'                                             (int)prep_type' prep_table_base' attr_names_base);                          txio.tx_printf("\n");                      }                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_parse_table,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                    /* Get start of verb entry and number of entries */                    if (parser_type == (uint)tx_h.parser_types.infocom6_grammar)                  {                      ulong do_address' doio_address;                      uint verb_address;                        verb_address = (uint)address; /* cast is guaranteed to work provided uint >= 16 bits */                      txio.tx_printf("\n{0'3:d}. @ ${1:X4}' verb = "' i' address);                      show_words((uint)address' 0L' tx_h.VERB_V6' parser_type);                      txio.tx_printf("\n    Main data");                      txio.tx_printf("\n    [");                      parse_data = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4} "' (uint)parse_data);                      txio.read_data_word(ref address);	/* I don't know what this word does */                      txio.tx_printf("{0:X4} "' (uint)parse_data);                      do_address = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4} "' (uint)do_address);                      doio_address = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4}"' (uint)doio_address);                      txio.tx_printf("] ");                      if (verb_entry != 0xFFFF)                          show_verb_grammar(parse_entry' verb_address' (int)parser_type' 0' 0' 0L' 0L);                        if (do_address > 0)                      {                          txio.tx_printf("\n    One object entries:\n");                          verb_entry = do_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          verb_size = 3; /* words */                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              txio.tx_printf("    [");                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_word(ref verb_entry);                                  txio.tx_printf("{0:X4}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                              txio.tx_printf("] ");                              show_verb_grammar(parse_entry' verb_address' (int)parser_type' 1'                                         0' 0L' 0L);                              txio.tx_printf("\n");                          }                      }                      if (doio_address > 0)                      {                          txio.tx_printf("\n    Two object entries:\n");                          verb_entry = doio_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          verb_size = 5; /* words */                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              txio.tx_printf("    [");                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_word(ref verb_entry);                                  txio.tx_printf("{0:X4}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                              txio.tx_printf("] ");                              show_verb_grammar(parse_entry' verb_address' (int)parser_type' 2'                                         0' 0L' 0L);                              txio.tx_printf("\n");                          }                      }                  }                  else                  { /* everything but Zork Zero' Shogun' and Arthur */                      verb_entry = (ulong)txio.read_data_word(ref address);                      entry_count = (uint)txio.read_data_byte(ref verb_entry);                        /* Show the verb index' entry count' verb and synonyms */                        txio.tx_printf("\n{0:d3}. {1} entr{2}' verb = "' (int)tx_h.VERB_NUM(i' parser_type)'                                 (int)entry_count' (entry_count == 1) ? "y" : "ies");                      show_words(tx_h.VERB_NUM(i' parser_type)' 0L' tx_h.VERB' parser_type);                      txio.tx_printf("\n");                        /* Show parse data and grammar for each verb entry */                        while (entry_count-- > 0)                      {                          parse_entry = verb_entry;                            /* Calculate the amount of verb data */                            if (parser_type != (int)tx_h.parser_types.infocom_variable)                          {                              verb_size = 8;                          }                          else                          {                              object_count = (uint)txio.read_data_byte(ref parse_entry);                              verb_size = verb_sizes[(object_count >> 6) & 0x03];                              parse_entry = verb_entry;                          }                            /* Show parse data for each verb */                            txio.tx_printf("    [");                            if (parser_type < (int)tx_h.parser_types.inform_gv2)                          {                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_byte(ref verb_entry);                                  txio.tx_printf("{0:X2}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                          }                          else                          {                              /* GV2 variable entry format                                 <flags and action high> <action low> n*(<token type> <token data 1> <token data 2>) <ENDIT>*/                              for (j = 0; (j == 0) || (j % 3 != 0) || (parse_data != tx_h.ENDIT); j++)                              {                                  if (j != 0)                                      txio.tx_printf(" ");                                  parse_data = (uint)txio.read_data_byte(ref verb_entry);                                  txio.tx_printf("{0:X2}"' (uint)parse_data);                              }                              verb_size = j;                          }                          txio.tx_printf("] ");                          for (; j < 8; j++)                              txio.tx_printf("   ");                            /* Show the verb grammar for this entry */                            show_verb_grammar(parse_entry' tx_h.VERB_NUM(i' parser_type)' (int)parser_type' 0'                                             (int)prep_type' prep_table_base' attr_names_base);                          txio.tx_printf("\n");                      }                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_parse_table,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                    /* Get start of verb entry and number of entries */                    if (parser_type == (uint)tx_h.parser_types.infocom6_grammar)                  {                      ulong do_address' doio_address;                      uint verb_address;                        verb_address = (uint)address; /* cast is guaranteed to work provided uint >= 16 bits */                      txio.tx_printf("\n{0'3:d}. @ ${1:X4}' verb = "' i' address);                      show_words((uint)address' 0L' tx_h.VERB_V6' parser_type);                      txio.tx_printf("\n    Main data");                      txio.tx_printf("\n    [");                      parse_data = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4} "' (uint)parse_data);                      txio.read_data_word(ref address);	/* I don't know what this word does */                      txio.tx_printf("{0:X4} "' (uint)parse_data);                      do_address = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4} "' (uint)do_address);                      doio_address = (uint)txio.read_data_word(ref address);                      txio.tx_printf("{0:X4}"' (uint)doio_address);                      txio.tx_printf("] ");                      if (verb_entry != 0xFFFF)                          show_verb_grammar(parse_entry' verb_address' (int)parser_type' 0' 0' 0L' 0L);                        if (do_address > 0)                      {                          txio.tx_printf("\n    One object entries:\n");                          verb_entry = do_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          verb_size = 3; /* words */                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              txio.tx_printf("    [");                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_word(ref verb_entry);                                  txio.tx_printf("{0:X4}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                              txio.tx_printf("] ");                              show_verb_grammar(parse_entry' verb_address' (int)parser_type' 1'                                         0' 0L' 0L);                              txio.tx_printf("\n");                          }                      }                      if (doio_address > 0)                      {                          txio.tx_printf("\n    Two object entries:\n");                          verb_entry = doio_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          verb_size = 5; /* words */                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              txio.tx_printf("    [");                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_word(ref verb_entry);                                  txio.tx_printf("{0:X4}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                              txio.tx_printf("] ");                              show_verb_grammar(parse_entry' verb_address' (int)parser_type' 2'                                         0' 0L' 0L);                              txio.tx_printf("\n");                          }                      }                  }                  else                  { /* everything but Zork Zero' Shogun' and Arthur */                      verb_entry = (ulong)txio.read_data_word(ref address);                      entry_count = (uint)txio.read_data_byte(ref verb_entry);                        /* Show the verb index' entry count' verb and synonyms */                        txio.tx_printf("\n{0:d3}. {1} entr{2}' verb = "' (int)tx_h.VERB_NUM(i' parser_type)'                                 (int)entry_count' (entry_count == 1) ? "y" : "ies");                      show_words(tx_h.VERB_NUM(i' parser_type)' 0L' tx_h.VERB' parser_type);                      txio.tx_printf("\n");                        /* Show parse data and grammar for each verb entry */                        while (entry_count-- > 0)                      {                          parse_entry = verb_entry;                            /* Calculate the amount of verb data */                            if (parser_type != (int)tx_h.parser_types.infocom_variable)                          {                              verb_size = 8;                          }                          else                          {                              object_count = (uint)txio.read_data_byte(ref parse_entry);                              verb_size = verb_sizes[(object_count >> 6) & 0x03];                              parse_entry = verb_entry;                          }                            /* Show parse data for each verb */                            txio.tx_printf("    [");                            if (parser_type < (int)tx_h.parser_types.inform_gv2)                          {                              for (j = 0; j < verb_size; j++)                              {                                  parse_data = (uint)txio.read_data_byte(ref verb_entry);                                  txio.tx_printf("{0:X2}"' (uint)parse_data);                                  if (j < (verb_size - 1))                                      txio.tx_printf(" ");                              }                          }                          else                          {                              /* GV2 variable entry format                                 <flags and action high> <action low> n*(<token type> <token data 1> <token data 2>) <ENDIT>*/                              for (j = 0; (j == 0) || (j % 3 != 0) || (parse_data != tx_h.ENDIT); j++)                              {                                  if (j != 0)                                      txio.tx_printf(" ");                                  parse_data = (uint)txio.read_data_byte(ref verb_entry);                                  txio.tx_printf("{0:X2}"' (uint)parse_data);                              }                              verb_size = j;                          }                          txio.tx_printf("] ");                          for (; j < 8; j++)                              txio.tx_printf("   ");                            /* Show the verb grammar for this entry */                            show_verb_grammar(parse_entry' tx_h.VERB_NUM(i' parser_type)' (int)parser_type' 0'                                             (int)prep_type' prep_table_base' attr_names_base);                          txio.tx_printf("\n");                      }                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_syntax_of_action,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                    if (parser_type == (uint)tx_h.parser_types.infocom6_grammar)                  {                      ulong do_address' doio_address;                      uint verb_address;                        verb_address = (uint)address;                      parse_entry = address;                      action_index = txio.read_data_word(ref address);                      if (action_index == (uint)action)                      {                          show_verb_grammar(parse_entry' verb_address' (int)parser_type' 0'                                             (int)0' 0L' 0L);                          txio.tx_printf("\n");                          matched = true;                      }                      txio.read_data_word(ref address);                      do_address = txio.read_data_word(ref address);                      doio_address = txio.read_data_word(ref address);                        if (do_address > 0)                      {                          verb_entry = do_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              action_index = txio.read_data_word(ref verb_entry);                              if (action_index == (uint)action)                              {                                  show_verb_grammar(parse_entry' verb_address' (int)parser_type' 1'                                         0' 0L' 0L);                                  txio.tx_printf("\n");                                  matched = true;                              }                              verb_entry += 4; /* skip preposition and object */                          }                      }                        if (doio_address > 0)                      {                          verb_entry = doio_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              action_index = txio.read_data_word(ref verb_entry);                              if (action_index == (uint)action)                              {                                  show_verb_grammar(parse_entry' verb_address' (int)parser_type' 2'                                         0' 0L' 0L);                                  txio.tx_printf("\n");                                  matched = true;                              }                              verb_entry += 8; /* skip preposition and direct object and preposition and indirect object*/                          }                      }                  }                  else                  {                      /* Get the parse data address for this entry */                        verb_entry = (ulong)txio.read_data_word(ref address);                      entry_count = (uint)txio.read_data_byte(ref verb_entry);                        /* Look through the sentence structures looking for a match */                        while (entry_count-- > 0)                      {                          parse_entry = verb_entry;                          if (parser_type >= (uint)tx_h.parser_types.inform_gv2)                          { /* GV2' variable length with terminator */                              action_index = (uint)txio.read_data_word(ref verb_entry) & 0x3FF;                              val = txio.read_data_byte(ref verb_entry);                              while (val != tx_h.ENDIT)                              {                                  txio.read_data_word(ref verb_entry);                                  val = txio.read_data_byte(ref verb_entry);                              }                          }                          else if (parser_type != (uint)tx_h.parser_types.infocom_variable)                          { /* Index is in last (8th) byte */                              verb_entry += 7;                              action_index = (uint)txio.read_data_byte(ref verb_entry);                          }                          else                          { /* Index is in second byte */                              object_count = (uint)txio.read_data_byte(ref verb_entry);                              action_index = (uint)txio.read_data_byte(ref verb_entry);                              verb_entry += (ulong)(verb_sizes[(object_count >> 6) & 0x03] - 2);                          }                            /* Check if this verb/sentence structure uses the action routine */                            if (action_index == (uint)action)                          {                              show_verb_grammar(parse_entry' tx_h.VERB_NUM(i' parser_type)' (int)parser_type' 0'                                                 (int)prep_type' prep_table_base' attr_names_base);                              txio.tx_printf("\n");                              matched = true;                          }                      }                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_syntax_of_action,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                    if (parser_type == (uint)tx_h.parser_types.infocom6_grammar)                  {                      ulong do_address' doio_address;                      uint verb_address;                        verb_address = (uint)address;                      parse_entry = address;                      action_index = txio.read_data_word(ref address);                      if (action_index == (uint)action)                      {                          show_verb_grammar(parse_entry' verb_address' (int)parser_type' 0'                                             (int)0' 0L' 0L);                          txio.tx_printf("\n");                          matched = true;                      }                      txio.read_data_word(ref address);                      do_address = txio.read_data_word(ref address);                      doio_address = txio.read_data_word(ref address);                        if (do_address > 0)                      {                          verb_entry = do_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              action_index = txio.read_data_word(ref verb_entry);                              if (action_index == (uint)action)                              {                                  show_verb_grammar(parse_entry' verb_address' (int)parser_type' 1'                                         0' 0L' 0L);                                  txio.tx_printf("\n");                                  matched = true;                              }                              verb_entry += 4; /* skip preposition and object */                          }                      }                        if (doio_address > 0)                      {                          verb_entry = doio_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              action_index = txio.read_data_word(ref verb_entry);                              if (action_index == (uint)action)                              {                                  show_verb_grammar(parse_entry' verb_address' (int)parser_type' 2'                                         0' 0L' 0L);                                  txio.tx_printf("\n");                                  matched = true;                              }                              verb_entry += 8; /* skip preposition and direct object and preposition and indirect object*/                          }                      }                  }                  else                  {                      /* Get the parse data address for this entry */                        verb_entry = (ulong)txio.read_data_word(ref address);                      entry_count = (uint)txio.read_data_byte(ref verb_entry);                        /* Look through the sentence structures looking for a match */                        while (entry_count-- > 0)                      {                          parse_entry = verb_entry;                          if (parser_type >= (uint)tx_h.parser_types.inform_gv2)                          { /* GV2' variable length with terminator */                              action_index = (uint)txio.read_data_word(ref verb_entry) & 0x3FF;                              val = txio.read_data_byte(ref verb_entry);                              while (val != tx_h.ENDIT)                              {                                  txio.read_data_word(ref verb_entry);                                  val = txio.read_data_byte(ref verb_entry);                              }                          }                          else if (parser_type != (uint)tx_h.parser_types.infocom_variable)                          { /* Index is in last (8th) byte */                              verb_entry += 7;                              action_index = (uint)txio.read_data_byte(ref verb_entry);                          }                          else                          { /* Index is in second byte */                              object_count = (uint)txio.read_data_byte(ref verb_entry);                              action_index = (uint)txio.read_data_byte(ref verb_entry);                              verb_entry += (ulong)(verb_sizes[(object_count >> 6) & 0x03] - 2);                          }                            /* Check if this verb/sentence structure uses the action routine */                            if (action_index == (uint)action)                          {                              show_verb_grammar(parse_entry' tx_h.VERB_NUM(i' parser_type)' (int)parser_type' 0'                                                 (int)prep_type' prep_table_base' attr_names_base);                              txio.tx_printf("\n");                              matched = true;                          }                      }                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_syntax_of_action,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                    if (parser_type == (uint)tx_h.parser_types.infocom6_grammar)                  {                      ulong do_address' doio_address;                      uint verb_address;                        verb_address = (uint)address;                      parse_entry = address;                      action_index = txio.read_data_word(ref address);                      if (action_index == (uint)action)                      {                          show_verb_grammar(parse_entry' verb_address' (int)parser_type' 0'                                             (int)0' 0L' 0L);                          txio.tx_printf("\n");                          matched = true;                      }                      txio.read_data_word(ref address);                      do_address = txio.read_data_word(ref address);                      doio_address = txio.read_data_word(ref address);                        if (do_address > 0)                      {                          verb_entry = do_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              action_index = txio.read_data_word(ref verb_entry);                              if (action_index == (uint)action)                              {                                  show_verb_grammar(parse_entry' verb_address' (int)parser_type' 1'                                         0' 0L' 0L);                                  txio.tx_printf("\n");                                  matched = true;                              }                              verb_entry += 4; /* skip preposition and object */                          }                      }                        if (doio_address > 0)                      {                          verb_entry = doio_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              action_index = txio.read_data_word(ref verb_entry);                              if (action_index == (uint)action)                              {                                  show_verb_grammar(parse_entry' verb_address' (int)parser_type' 2'                                         0' 0L' 0L);                                  txio.tx_printf("\n");                                  matched = true;                              }                              verb_entry += 8; /* skip preposition and direct object and preposition and indirect object*/                          }                      }                  }                  else                  {                      /* Get the parse data address for this entry */                        verb_entry = (ulong)txio.read_data_word(ref address);                      entry_count = (uint)txio.read_data_byte(ref verb_entry);                        /* Look through the sentence structures looking for a match */                        while (entry_count-- > 0)                      {                          parse_entry = verb_entry;                          if (parser_type >= (uint)tx_h.parser_types.inform_gv2)                          { /* GV2' variable length with terminator */                              action_index = (uint)txio.read_data_word(ref verb_entry) & 0x3FF;                              val = txio.read_data_byte(ref verb_entry);                              while (val != tx_h.ENDIT)                              {                                  txio.read_data_word(ref verb_entry);                                  val = txio.read_data_byte(ref verb_entry);                              }                          }                          else if (parser_type != (uint)tx_h.parser_types.infocom_variable)                          { /* Index is in last (8th) byte */                              verb_entry += 7;                              action_index = (uint)txio.read_data_byte(ref verb_entry);                          }                          else                          { /* Index is in second byte */                              object_count = (uint)txio.read_data_byte(ref verb_entry);                              action_index = (uint)txio.read_data_byte(ref verb_entry);                              verb_entry += (ulong)(verb_sizes[(object_count >> 6) & 0x03] - 2);                          }                            /* Check if this verb/sentence structure uses the action routine */                            if (action_index == (uint)action)                          {                              show_verb_grammar(parse_entry' tx_h.VERB_NUM(i' parser_type)' (int)parser_type' 0'                                                 (int)prep_type' prep_table_base' attr_names_base);                              txio.tx_printf("\n");                              matched = true;                          }                      }                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_syntax_of_action,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                    if (parser_type == (uint)tx_h.parser_types.infocom6_grammar)                  {                      ulong do_address' doio_address;                      uint verb_address;                        verb_address = (uint)address;                      parse_entry = address;                      action_index = txio.read_data_word(ref address);                      if (action_index == (uint)action)                      {                          show_verb_grammar(parse_entry' verb_address' (int)parser_type' 0'                                             (int)0' 0L' 0L);                          txio.tx_printf("\n");                          matched = true;                      }                      txio.read_data_word(ref address);                      do_address = txio.read_data_word(ref address);                      doio_address = txio.read_data_word(ref address);                        if (do_address > 0)                      {                          verb_entry = do_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              action_index = txio.read_data_word(ref verb_entry);                              if (action_index == (uint)action)                              {                                  show_verb_grammar(parse_entry' verb_address' (int)parser_type' 1'                                         0' 0L' 0L);                                  txio.tx_printf("\n");                                  matched = true;                              }                              verb_entry += 4; /* skip preposition and object */                          }                      }                        if (doio_address > 0)                      {                          verb_entry = doio_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              action_index = txio.read_data_word(ref verb_entry);                              if (action_index == (uint)action)                              {                                  show_verb_grammar(parse_entry' verb_address' (int)parser_type' 2'                                         0' 0L' 0L);                                  txio.tx_printf("\n");                                  matched = true;                              }                              verb_entry += 8; /* skip preposition and direct object and preposition and indirect object*/                          }                      }                  }                  else                  {                      /* Get the parse data address for this entry */                        verb_entry = (ulong)txio.read_data_word(ref address);                      entry_count = (uint)txio.read_data_byte(ref verb_entry);                        /* Look through the sentence structures looking for a match */                        while (entry_count-- > 0)                      {                          parse_entry = verb_entry;                          if (parser_type >= (uint)tx_h.parser_types.inform_gv2)                          { /* GV2' variable length with terminator */                              action_index = (uint)txio.read_data_word(ref verb_entry) & 0x3FF;                              val = txio.read_data_byte(ref verb_entry);                              while (val != tx_h.ENDIT)                              {                                  txio.read_data_word(ref verb_entry);                                  val = txio.read_data_byte(ref verb_entry);                              }                          }                          else if (parser_type != (uint)tx_h.parser_types.infocom_variable)                          { /* Index is in last (8th) byte */                              verb_entry += 7;                              action_index = (uint)txio.read_data_byte(ref verb_entry);                          }                          else                          { /* Index is in second byte */                              object_count = (uint)txio.read_data_byte(ref verb_entry);                              action_index = (uint)txio.read_data_byte(ref verb_entry);                              verb_entry += (ulong)(verb_sizes[(object_count >> 6) & 0x03] - 2);                          }                            /* Check if this verb/sentence structure uses the action routine */                            if (action_index == (uint)action)                          {                              show_verb_grammar(parse_entry' tx_h.VERB_NUM(i' parser_type)' (int)parser_type' 0'                                                 (int)prep_type' prep_table_base' attr_names_base);                              txio.tx_printf("\n");                              matched = true;                          }                      }                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_syntax_of_action,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                    if (parser_type == (uint)tx_h.parser_types.infocom6_grammar)                  {                      ulong do_address' doio_address;                      uint verb_address;                        verb_address = (uint)address;                      parse_entry = address;                      action_index = txio.read_data_word(ref address);                      if (action_index == (uint)action)                      {                          show_verb_grammar(parse_entry' verb_address' (int)parser_type' 0'                                             (int)0' 0L' 0L);                          txio.tx_printf("\n");                          matched = true;                      }                      txio.read_data_word(ref address);                      do_address = txio.read_data_word(ref address);                      doio_address = txio.read_data_word(ref address);                        if (do_address > 0)                      {                          verb_entry = do_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              action_index = txio.read_data_word(ref verb_entry);                              if (action_index == (uint)action)                              {                                  show_verb_grammar(parse_entry' verb_address' (int)parser_type' 1'                                         0' 0L' 0L);                                  txio.tx_printf("\n");                                  matched = true;                              }                              verb_entry += 4; /* skip preposition and object */                          }                      }                        if (doio_address > 0)                      {                          verb_entry = doio_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              action_index = txio.read_data_word(ref verb_entry);                              if (action_index == (uint)action)                              {                                  show_verb_grammar(parse_entry' verb_address' (int)parser_type' 2'                                         0' 0L' 0L);                                  txio.tx_printf("\n");                                  matched = true;                              }                              verb_entry += 8; /* skip preposition and direct object and preposition and indirect object*/                          }                      }                  }                  else                  {                      /* Get the parse data address for this entry */                        verb_entry = (ulong)txio.read_data_word(ref address);                      entry_count = (uint)txio.read_data_byte(ref verb_entry);                        /* Look through the sentence structures looking for a match */                        while (entry_count-- > 0)                      {                          parse_entry = verb_entry;                          if (parser_type >= (uint)tx_h.parser_types.inform_gv2)                          { /* GV2' variable length with terminator */                              action_index = (uint)txio.read_data_word(ref verb_entry) & 0x3FF;                              val = txio.read_data_byte(ref verb_entry);                              while (val != tx_h.ENDIT)                              {                                  txio.read_data_word(ref verb_entry);                                  val = txio.read_data_byte(ref verb_entry);                              }                          }                          else if (parser_type != (uint)tx_h.parser_types.infocom_variable)                          { /* Index is in last (8th) byte */                              verb_entry += 7;                              action_index = (uint)txio.read_data_byte(ref verb_entry);                          }                          else                          { /* Index is in second byte */                              object_count = (uint)txio.read_data_byte(ref verb_entry);                              action_index = (uint)txio.read_data_byte(ref verb_entry);                              verb_entry += (ulong)(verb_sizes[(object_count >> 6) & 0x03] - 2);                          }                            /* Check if this verb/sentence structure uses the action routine */                            if (action_index == (uint)action)                          {                              show_verb_grammar(parse_entry' tx_h.VERB_NUM(i' parser_type)' (int)parser_type' 0'                                                 (int)prep_type' prep_table_base' attr_names_base);                              txio.tx_printf("\n");                              matched = true;                          }                      }                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_syntax_of_action,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                    if (parser_type == (uint)tx_h.parser_types.infocom6_grammar)                  {                      ulong do_address' doio_address;                      uint verb_address;                        verb_address = (uint)address;                      parse_entry = address;                      action_index = txio.read_data_word(ref address);                      if (action_index == (uint)action)                      {                          show_verb_grammar(parse_entry' verb_address' (int)parser_type' 0'                                             (int)0' 0L' 0L);                          txio.tx_printf("\n");                          matched = true;                      }                      txio.read_data_word(ref address);                      do_address = txio.read_data_word(ref address);                      doio_address = txio.read_data_word(ref address);                        if (do_address > 0)                      {                          verb_entry = do_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              action_index = txio.read_data_word(ref verb_entry);                              if (action_index == (uint)action)                              {                                  show_verb_grammar(parse_entry' verb_address' (int)parser_type' 1'                                         0' 0L' 0L);                                  txio.tx_printf("\n");                                  matched = true;                              }                              verb_entry += 4; /* skip preposition and object */                          }                      }                        if (doio_address > 0)                      {                          verb_entry = doio_address;                          entry_count = (uint)txio.read_data_word(ref verb_entry);                          while (entry_count-- > 0)                          {                              parse_entry = verb_entry;                              action_index = txio.read_data_word(ref verb_entry);                              if (action_index == (uint)action)                              {                                  show_verb_grammar(parse_entry' verb_address' (int)parser_type' 2'                                         0' 0L' 0L);                                  txio.tx_printf("\n");                                  matched = true;                              }                              verb_entry += 8; /* skip preposition and direct object and preposition and indirect object*/                          }                      }                  }                  else                  {                      /* Get the parse data address for this entry */                        verb_entry = (ulong)txio.read_data_word(ref address);                      entry_count = (uint)txio.read_data_byte(ref verb_entry);                        /* Look through the sentence structures looking for a match */                        while (entry_count-- > 0)                      {                          parse_entry = verb_entry;                          if (parser_type >= (uint)tx_h.parser_types.inform_gv2)                          { /* GV2' variable length with terminator */                              action_index = (uint)txio.read_data_word(ref verb_entry) & 0x3FF;                              val = txio.read_data_byte(ref verb_entry);                              while (val != tx_h.ENDIT)                              {                                  txio.read_data_word(ref verb_entry);                                  val = txio.read_data_byte(ref verb_entry);                              }                          }                          else if (parser_type != (uint)tx_h.parser_types.infocom_variable)                          { /* Index is in last (8th) byte */                              verb_entry += 7;                              action_index = (uint)txio.read_data_byte(ref verb_entry);                          }                          else                          { /* Index is in second byte */                              object_count = (uint)txio.read_data_byte(ref verb_entry);                              action_index = (uint)txio.read_data_byte(ref verb_entry);                              verb_entry += (ulong)(verb_sizes[(object_count >> 6) & 0x03] - 2);                          }                            /* Check if this verb/sentence structure uses the action routine */                            if (action_index == (uint)action)                          {                              show_verb_grammar(parse_entry' tx_h.VERB_NUM(i' parser_type)' (int)parser_type' 0'                                                 (int)prep_type' prep_table_base' attr_names_base);                              txio.tx_printf("\n");                              matched = true;                          }                      }                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_syntax_of_parsing_routine,The following statement contains a magic number: for (i = 0; (uint)i < verb_count; i++)              {                    /* Get the parse data address for this entry */                    verb_entry = (ulong)txio.read_data_word(ref address);                  entry_count = (uint)txio.read_data_byte(ref verb_entry);                  while (entry_count-- > 0)                  {                      parse_entry = verb_entry;                      found = false;                      if (parser_type < (int)tx_h.parser_types.inform_gv2)                      {                          object_count = (uint)txio.read_data_byte(ref verb_entry);                          while (object_count > 0)                          {                              val = (uint)txio.read_data_byte(ref verb_entry);                              if (val < 0xb0)                              {                                  object_count--;                                  if (val >= 0x10 && val < 0x70 && ((val - 0x10) & 0x1f) == (uint)parsing_routine)                                      found = true;                              }                          }                          verb_entry = parse_entry + 8;                      }                      else                      {                          txio.read_data_word(ref verb_entry); /* skip action # and flags */                          val = (uint)txio.read_data_byte(ref verb_entry);                          while (val != tx_h.ENDIT)                          {                              token_data = txio.read_data_word(ref verb_entry);                              if (((val & 0xC0) == 0x80) && (token_data == parsing_routine_packed)) /* V7/V6 issue here */                                  found = true;                              val = (uint)txio.read_data_byte(ref verb_entry);                          }                      }                      if (found)                      {                          show_verb_grammar(parse_entry' tx_h.VERB_NUM(i' parser_type)' (int)parser_type' (int)prep_type' 0'                                             prep_table_base' attr_names_base);                          txio.tx_printf("\n");                      }                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: uint[] preps = new uint[2];
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,show_verb_grammar,The following statement contains a magic number: if (parser_type == (int)tx_h.parser_types.infocom6_grammar)              {                  txio.tx_printf("\"");                  verb_address = lookup_word(0L' verb_index' tx_h.VERB_V6' (uint)parser_type);                  if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    if (v6_number_objects > 0)                  {                      txio.tx_printf(" ");                        action = txio.read_data_word(ref address);                      while (v6_number_objects-- > 0)                      {                          token_data = txio.read_data_word(ref address);                          token_type = txio.read_data_word(ref address);                          if (token_data > 0)                          {                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              txio.tx_printf(" ");                          }                          //                            txio.tx_printf("${0:X4}"' token_type);  /* turn this on if you want to see the attribute and flag? info for the object */                            txio.tx_printf("OBJ");                            if (v6_number_objects > 0)                              txio.tx_printf(" ");                      }                  }                  txio.tx_printf("\"");              }              else if (parser_type >= (int)tx_h.parser_types.inform_gv2)              {                  /* Inform 6 GV2 verb entry */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    action = txio.read_data_word(ref address); /* Action # and flags*/                    val = txio.read_data_byte(ref address);                  while (val != tx_h.ENDIT)                  {                      if (((val & 0x30) == 0x10) || ((val & 0x30) == 0x30)) /* 2nd ... nth byte of alternative list */                          txio.tx_printf(" /");                      txio.tx_printf(" ");                      token_type = val & 0xF;                      token_data = txio.read_data_word(ref address);                      switch ((gv2_tokentype)token_type)                      {                          case gv2_tokentype.TT_ELEMENTARY:                              if (token_data < GV2_elementary.Length)                                  txio.tx_printf(GV2_elementary[token_data]);                              else                                  txio.tx_printf("UNKNOWN_ELEMENTARY");                              break;                          case gv2_tokentype.TT_PREPOSITION:                              prep_address = token_data;                              txio.decode_text(ref prep_address);                              break;                          case gv2_tokentype.TT_NOUNR:                              txio.tx_printf("noun = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ATTRIBUTE:                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)token_data) == 0)                              {                                  txio.tx_printf("{0}"' token_data);                              }                              txio.tx_printf(")"' token_data);                              break;                          case gv2_tokentype.TT_SCOPER:                              txio.tx_printf("scope = [parse ${0:X4}]"' token_data);                              break;                          case gv2_tokentype.TT_ROUTINE:                              txio.tx_printf("[parse ${0:X4}]"' token_data);                              break;                          default:                              txio.tx_printf("UNKNOWN");                              break;                      }                      val = txio.read_data_byte(ref address);                  }                  txio.tx_printf("\"");                  if ((action & 0x0400) > 0)                      txio.tx_printf(" REVERSE");              }              else if (parser_type >= (int)tx_h.parser_types.inform5_grammar)              {                  /* Inform 5 and GV1 verb entries are just a series of tokens */                    txio.tx_printf("\"");                    /* Print verb if one is present */                    verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                    if (verb_address > 0)                      txio.decode_text(ref verb_address);                  else                      txio.tx_printf("no-verb");                    objs = txio.read_data_byte(ref address);                    for (i = 0; i < 8; i++)                  {                      val = txio.read_data_byte(ref address);                      if (val < 0xb0)                      {                          if (val == 0 && objs == 0)                              break;                          txio.tx_printf(" ");                          if (val == 0)                              txio.tx_printf("NOUN");                          else if (val == 1)                              txio.tx_printf("HELD");                          else if (val == 2)                              txio.tx_printf("MULTI");                          else if (val == 3)                              txio.tx_printf("MULTIHELD");                          else if (val == 4)                              txio.tx_printf("MULTIEXCEPT");                          else if (val == 5)                              txio.tx_printf("MULTIINSIDE");                          else if (val == 6)                              txio.tx_printf("CREATURE");                          else if (val == 7)                              txio.tx_printf("SPECIAL");                          else if (val == 8)                              txio.tx_printf("NUMBER");                          else if (val >= 16 && val < 48)                              txio.tx_printf("NOUN [parse {0}]"' val - 16);                          else if (val >= 48 && val < 80)                              txio.tx_printf("TEXT [parse {0}]"' val - 48);                          else if (val >= 80 && val < 112)                              txio.tx_printf("SCOPE [parse {0}]"' val - 80);                          else if (val >= 128 && val < 176)                          {                              txio.tx_printf("ATTRIBUTE(");                              if (symbols.print_attribute_name(attr_names_base' (int)(val - 128)) == 0)                              {                                  txio.tx_printf("{0}"' val - 128);                              }                              txio.tx_printf(")");                          }                          else                              txio.tx_printf("UNKNOWN");                          objs--;                      }                      else                      {                          txio.tx_printf(" ");                          show_preposition(val' prep_type' prep_table_base);                      }                  }                    txio.tx_printf("\"");              }              else              {                    address = verb_entry;                  preps[0] = preps[1] = 0;                    /* Calculate noun count and prepositions */                    if (parser_type == (int)tx_h.parser_types.infocom_fixed)                  {                        /* Fixed length parse table format */                        /* Object count in 1st byte' preposition indices in next two bytes */                        objs = (uint)txio.read_data_byte(ref address);                      preps[0] = (uint)txio.read_data_byte(ref address);                      preps[0] = (preps[0] >= 0x80) ? preps[0] : 0;                      preps[1] = (uint)txio.read_data_byte(ref address);                      preps[1] = (preps[1] >= 0x80) ? preps[1] : 0;                  }                  else                  {                        /* Variable length parse table format */                        /* Object count in top two bits of first byte */                        parse_data = (uint)txio.read_data_byte(ref address);                      objs = (parse_data >> 6) & 0x03;                        /* 1st preposition in bottom 6 bits of first byte. Fill in top two bits */                        preps[0] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                      parse_data = (uint)txio.read_data_byte(ref address);                        /* Check for more than one object */                        if (objs > 0)                      {                            /* Skip object data */                            parse_data = (uint)txio.read_data_byte(ref address);                          parse_data = (uint)txio.read_data_byte(ref address);                            /* Check for more than two objects */                            if (objs > 1)                          {                                /* 2nd preposition in bottom 6 bits of byte. Fill in top two bits */                                parse_data = (uint)txio.read_data_byte(ref address);                              preps[1] = (parse_data & 0x3f) > 0 ? parse_data | 0xc0 : 0;                          }                      }                  }                    /* Check that there are 0 - 2 objects only */                    if (objs > 2)                  {                        txio.tx_printf("Bad object count (%d)"' (int)objs);                    }                  else                  {                        txio.tx_printf("\"");                        /* Print verb if one is present */                        verb_address = lookup_word(0L' verb_index' tx_h.VERB' (uint)parser_type);                        if (verb_address > 0)                          txio.decode_text(ref verb_address);                      else                          txio.tx_printf("no-verb");                        /* Display any prepositions and objects if present */                        for (i = 0; i < 2; i++)                      {                          if (preps[i] != 0)                          {                              txio.tx_printf(" ");                              show_preposition(preps[i]' prep_type' prep_table_base);                          }                          if (objs > (uint)i)                              txio.tx_printf(" OBJ");                      }                        txio.tx_printf("\"");                    }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,lookup_word,The following statement contains a magic number: for (word_address = entry; word_address <= last_word; word_address += word_size)              {                    /* Skip to flags byte and read it */                    if (parser_type != (int)tx_h.parser_types.infocom6_grammar)                  {                      address = word_address + (ulong)(((uint)txio.header.version < tx_h.V4) ? 4 : 6);                      flags = txio.read_data_byte(ref address);                  }                  else                  {                      address = word_address + word_size - 1;                      flags = txio.read_data_byte(ref address);                      address = word_address + 6;                  }                    /* Check if this word is the type we are looking for */                    if ((flags & mask) > 0)                  {                        if ((parser_type == (int)tx_h.parser_types.infocom6_grammar) || (parser_type >= (int)tx_h.parser_types.inform_gv2a))                      {                          data = (uint)txio.read_data_word(ref address);                      }                      else if (parser_type <= (int)tx_h.parser_types.inform_gv1)                      {                          /* Infocom' Inform 5' GV1.	Verbs only for Inform */                          /* Read the data for the word */                            data = (uint)txio.read_data_byte(ref  address);                            /* Skip to next byte under some circumstances */                            if (((mask == tx_h.VERB) && (flags & tx_h.DATA_FIRST) != tx_h.VERB_FIRST) ||                              ((mask == tx_h.DESC) && (flags & tx_h.DATA_FIRST) != tx_h.ADJ_FIRST))                              data = (uint)txio.read_data_byte(ref address);                      }                      else                      {                          /* GV2' Inform 6.10 version */                          data = (uint)txio.read_data_byte(ref address);                      }                        /* If this word matches the type and index then return its address */                        if (data == number)                          return (word_address);                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,lookup_word,The following statement contains a magic number: for (word_address = entry; word_address <= last_word; word_address += word_size)              {                    /* Skip to flags byte and read it */                    if (parser_type != (int)tx_h.parser_types.infocom6_grammar)                  {                      address = word_address + (ulong)(((uint)txio.header.version < tx_h.V4) ? 4 : 6);                      flags = txio.read_data_byte(ref address);                  }                  else                  {                      address = word_address + word_size - 1;                      flags = txio.read_data_byte(ref address);                      address = word_address + 6;                  }                    /* Check if this word is the type we are looking for */                    if ((flags & mask) > 0)                  {                        if ((parser_type == (int)tx_h.parser_types.infocom6_grammar) || (parser_type >= (int)tx_h.parser_types.inform_gv2a))                      {                          data = (uint)txio.read_data_word(ref address);                      }                      else if (parser_type <= (int)tx_h.parser_types.inform_gv1)                      {                          /* Infocom' Inform 5' GV1.	Verbs only for Inform */                          /* Read the data for the word */                            data = (uint)txio.read_data_byte(ref  address);                            /* Skip to next byte under some circumstances */                            if (((mask == tx_h.VERB) && (flags & tx_h.DATA_FIRST) != tx_h.VERB_FIRST) ||                              ((mask == tx_h.DESC) && (flags & tx_h.DATA_FIRST) != tx_h.ADJ_FIRST))                              data = (uint)txio.read_data_byte(ref address);                      }                      else                      {                          /* GV2' Inform 6.10 version */                          data = (uint)txio.read_data_byte(ref address);                      }                        /* If this word matches the type and index then return its address */                        if (data == number)                          return (word_address);                  }              }
Magic Number,ZTools,showverb,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showverb.cs,lookup_word,The following statement contains a magic number: for (word_address = entry; word_address <= last_word; word_address += word_size)              {                    /* Skip to flags byte and read it */                    if (parser_type != (int)tx_h.parser_types.infocom6_grammar)                  {                      address = word_address + (ulong)(((uint)txio.header.version < tx_h.V4) ? 4 : 6);                      flags = txio.read_data_byte(ref address);                  }                  else                  {                      address = word_address + word_size - 1;                      flags = txio.read_data_byte(ref address);                      address = word_address + 6;                  }                    /* Check if this word is the type we are looking for */                    if ((flags & mask) > 0)                  {                        if ((parser_type == (int)tx_h.parser_types.infocom6_grammar) || (parser_type >= (int)tx_h.parser_types.inform_gv2a))                      {                          data = (uint)txio.read_data_word(ref address);                      }                      else if (parser_type <= (int)tx_h.parser_types.inform_gv1)                      {                          /* Infocom' Inform 5' GV1.	Verbs only for Inform */                          /* Read the data for the word */                            data = (uint)txio.read_data_byte(ref  address);                            /* Skip to next byte under some circumstances */                            if (((mask == tx_h.VERB) && (flags & tx_h.DATA_FIRST) != tx_h.VERB_FIRST) ||                              ((mask == tx_h.DESC) && (flags & tx_h.DATA_FIRST) != tx_h.ADJ_FIRST))                              data = (uint)txio.read_data_byte(ref address);                      }                      else                      {                          /* GV2' Inform 6.10 version */                          data = (uint)txio.read_data_byte(ref address);                      }                        /* If this word matches the type and index then return its address */                        if (data == number)                          return (word_address);                  }              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,main,The following statement contains a magic number: verb_sizes = new int[4] { 2' 4' 7' 7 };
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,main,The following statement contains a magic number: verb_sizes = new int[4] { 2' 4' 7' 7 };
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,main,The following statement contains a magic number: verb_sizes = new int[4] { 2' 4' 7' 7 };
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,main,The following statement contains a magic number: verb_sizes = new int[4] { 2' 4' 7' 7 };
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,main,The following statement contains a magic number: verb_sizes = new int[4] { 2' 4' 7' 7 };
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_program,The following statement contains a magic number: if (decode.first_pass)              {                  if (decode.pc < decode.initial_pc)                  {                      /* Scan for low routines */                      decode.pc = ROUND_CODE(decode.pc);                      for (pc = decode.pc' flag = false; pc < decode.initial_pc && !flag; pc += txio.code_scaler)                      {                          for (vars = (char)txio.read_data_byte(ref pc); vars < 0 || vars > 15; vars = (char)txio.read_data_byte(ref pc))                              pc = ROUND_CODE(pc);                          decode.pc = pc - 1;                          for (i = 0' flag = true; i < 3 && flag; i++)                          {                              pcindex = 0;                              decode.pc = ROUND_CODE(decode.pc);                              if (decode_routine() != tx_h.END_OF_ROUTINE || pcindex > 0)                                  flag = false;                          }                          decode.pc = pc - 1;                      }                      if (flag && (uint)header.version < tx_h.V5)                      {                          pc = decode.pc;                          vars = (char)txio.read_data_byte(ref pc);                          low_pc = decode.pc;                          for (pc = (ulong)(pc + ((ulong)vars * 2) - 1)' flag = false; pc >= low_pc && !flag; pc -= txio.story_scaler)                          {                              decode.pc = pc;                              for (i = 0' flag = true; i < 3 && flag; i++)                              {                                  pcindex = 0;                                  decode.pc = ROUND_CODE(decode.pc);                                  if (decode_routine() != tx_h.END_OF_ROUTINE || pcindex > 0)                                      flag = false;                              }                              decode.pc = pc;                          }                      }                      if (!flag || decode.pc > decode.initial_pc)                          decode.pc = decode.initial_pc;                  }                  /* Fill in middle routines */                  decode.low_address = decode.pc;                  decode.high_address = decode.pc;                  start_data_pc = 0;                  end_data_pc = 0;                  do                  {                      if (option_labels > 0)                      {                          routines_base = null;                      }                      prev_low_pc = decode.low_address;                      prev_high_pc = decode.high_address;                      flag = false;                      pcindex = 0;                      low_pc = decode.low_address;                      high_pc = decode.high_address;                      pc = decode.pc = decode.low_address;                      while (decode.pc <= high_pc || decode.pc <= decode.initial_pc)                      {                          if (start_data_pc == decode.pc)                              decode.pc = end_data_pc;                          if (decode_routine() != tx_h.END_OF_ROUTINE)                          {                              if (start_data_pc == 0)                                  start_data_pc = decode.pc;                              flag = true;                              end_data_pc = 0;                              pcindex = 0;                              pc = ROUND_CODE(pc);                              do                              {                                  pc += txio.code_scaler;                                  vars = (char)txio.read_data_byte(ref pc);                                  pc--;                              } while (vars < 0 || vars > 15);                              decode.pc = pc;                          }                          else                          {                              if (pc < decode.initial_pc && decode.pc > decode.initial_pc)                              {                                  pc = decode.pc = decode.initial_pc;                                  decode.low_address = low_pc;                                  decode.high_address = high_pc;                              }                              else                              {                                  if (start_data_pc > 0 && end_data_pc == 0)                                      end_data_pc = pc;                                  pc = ROUND_CODE(decode.pc);                                  if (!flag)                                  {                                      low_pc = decode.low_address;                                      high_pc = decode.high_address;                                  }                              }                          }                      }                      decode.low_address = low_pc;                      decode.high_address = high_pc;                      // Console.WriteLine("{0} < {1} : {2} > {3}"' low_pc' prev_low_pc' high_pc' prev_high_pc);                    } while (low_pc < prev_low_pc || high_pc > prev_high_pc);                  /* Scan for high routines */                  pc = decode.pc;                  while (decode_routine() == tx_h.END_OF_ROUTINE)                  {                      decode.high_address = pc;                      pc = decode.pc;                  }              }              else              {                  txio.tx_printf("\n[Start of code");                  if (option_labels == 0)                      txio.tx_printf(" at {0:X}"' (ulong)decode.low_address);                  txio.tx_printf("]\n");                  for (decode.pc = decode.low_address;                       decode.pc <= decode.high_address; )                      decode_routine();                  txio.tx_printf("\n[End of code");                  if (option_labels == 0)                      txio.tx_printf(" at {0:X}"' (ulong)decode.pc);                  txio.tx_printf("]\n");              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_program,The following statement contains a magic number: if (decode.first_pass)              {                  if (decode.pc < decode.initial_pc)                  {                      /* Scan for low routines */                      decode.pc = ROUND_CODE(decode.pc);                      for (pc = decode.pc' flag = false; pc < decode.initial_pc && !flag; pc += txio.code_scaler)                      {                          for (vars = (char)txio.read_data_byte(ref pc); vars < 0 || vars > 15; vars = (char)txio.read_data_byte(ref pc))                              pc = ROUND_CODE(pc);                          decode.pc = pc - 1;                          for (i = 0' flag = true; i < 3 && flag; i++)                          {                              pcindex = 0;                              decode.pc = ROUND_CODE(decode.pc);                              if (decode_routine() != tx_h.END_OF_ROUTINE || pcindex > 0)                                  flag = false;                          }                          decode.pc = pc - 1;                      }                      if (flag && (uint)header.version < tx_h.V5)                      {                          pc = decode.pc;                          vars = (char)txio.read_data_byte(ref pc);                          low_pc = decode.pc;                          for (pc = (ulong)(pc + ((ulong)vars * 2) - 1)' flag = false; pc >= low_pc && !flag; pc -= txio.story_scaler)                          {                              decode.pc = pc;                              for (i = 0' flag = true; i < 3 && flag; i++)                              {                                  pcindex = 0;                                  decode.pc = ROUND_CODE(decode.pc);                                  if (decode_routine() != tx_h.END_OF_ROUTINE || pcindex > 0)                                      flag = false;                              }                              decode.pc = pc;                          }                      }                      if (!flag || decode.pc > decode.initial_pc)                          decode.pc = decode.initial_pc;                  }                  /* Fill in middle routines */                  decode.low_address = decode.pc;                  decode.high_address = decode.pc;                  start_data_pc = 0;                  end_data_pc = 0;                  do                  {                      if (option_labels > 0)                      {                          routines_base = null;                      }                      prev_low_pc = decode.low_address;                      prev_high_pc = decode.high_address;                      flag = false;                      pcindex = 0;                      low_pc = decode.low_address;                      high_pc = decode.high_address;                      pc = decode.pc = decode.low_address;                      while (decode.pc <= high_pc || decode.pc <= decode.initial_pc)                      {                          if (start_data_pc == decode.pc)                              decode.pc = end_data_pc;                          if (decode_routine() != tx_h.END_OF_ROUTINE)                          {                              if (start_data_pc == 0)                                  start_data_pc = decode.pc;                              flag = true;                              end_data_pc = 0;                              pcindex = 0;                              pc = ROUND_CODE(pc);                              do                              {                                  pc += txio.code_scaler;                                  vars = (char)txio.read_data_byte(ref pc);                                  pc--;                              } while (vars < 0 || vars > 15);                              decode.pc = pc;                          }                          else                          {                              if (pc < decode.initial_pc && decode.pc > decode.initial_pc)                              {                                  pc = decode.pc = decode.initial_pc;                                  decode.low_address = low_pc;                                  decode.high_address = high_pc;                              }                              else                              {                                  if (start_data_pc > 0 && end_data_pc == 0)                                      end_data_pc = pc;                                  pc = ROUND_CODE(decode.pc);                                  if (!flag)                                  {                                      low_pc = decode.low_address;                                      high_pc = decode.high_address;                                  }                              }                          }                      }                      decode.low_address = low_pc;                      decode.high_address = high_pc;                      // Console.WriteLine("{0} < {1} : {2} > {3}"' low_pc' prev_low_pc' high_pc' prev_high_pc);                    } while (low_pc < prev_low_pc || high_pc > prev_high_pc);                  /* Scan for high routines */                  pc = decode.pc;                  while (decode_routine() == tx_h.END_OF_ROUTINE)                  {                      decode.high_address = pc;                      pc = decode.pc;                  }              }              else              {                  txio.tx_printf("\n[Start of code");                  if (option_labels == 0)                      txio.tx_printf(" at {0:X}"' (ulong)decode.low_address);                  txio.tx_printf("]\n");                  for (decode.pc = decode.low_address;                       decode.pc <= decode.high_address; )                      decode_routine();                  txio.tx_printf("\n[End of code");                  if (option_labels == 0)                      txio.tx_printf(" at {0:X}"' (ulong)decode.pc);                  txio.tx_printf("]\n");              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_program,The following statement contains a magic number: if (decode.first_pass)              {                  if (decode.pc < decode.initial_pc)                  {                      /* Scan for low routines */                      decode.pc = ROUND_CODE(decode.pc);                      for (pc = decode.pc' flag = false; pc < decode.initial_pc && !flag; pc += txio.code_scaler)                      {                          for (vars = (char)txio.read_data_byte(ref pc); vars < 0 || vars > 15; vars = (char)txio.read_data_byte(ref pc))                              pc = ROUND_CODE(pc);                          decode.pc = pc - 1;                          for (i = 0' flag = true; i < 3 && flag; i++)                          {                              pcindex = 0;                              decode.pc = ROUND_CODE(decode.pc);                              if (decode_routine() != tx_h.END_OF_ROUTINE || pcindex > 0)                                  flag = false;                          }                          decode.pc = pc - 1;                      }                      if (flag && (uint)header.version < tx_h.V5)                      {                          pc = decode.pc;                          vars = (char)txio.read_data_byte(ref pc);                          low_pc = decode.pc;                          for (pc = (ulong)(pc + ((ulong)vars * 2) - 1)' flag = false; pc >= low_pc && !flag; pc -= txio.story_scaler)                          {                              decode.pc = pc;                              for (i = 0' flag = true; i < 3 && flag; i++)                              {                                  pcindex = 0;                                  decode.pc = ROUND_CODE(decode.pc);                                  if (decode_routine() != tx_h.END_OF_ROUTINE || pcindex > 0)                                      flag = false;                              }                              decode.pc = pc;                          }                      }                      if (!flag || decode.pc > decode.initial_pc)                          decode.pc = decode.initial_pc;                  }                  /* Fill in middle routines */                  decode.low_address = decode.pc;                  decode.high_address = decode.pc;                  start_data_pc = 0;                  end_data_pc = 0;                  do                  {                      if (option_labels > 0)                      {                          routines_base = null;                      }                      prev_low_pc = decode.low_address;                      prev_high_pc = decode.high_address;                      flag = false;                      pcindex = 0;                      low_pc = decode.low_address;                      high_pc = decode.high_address;                      pc = decode.pc = decode.low_address;                      while (decode.pc <= high_pc || decode.pc <= decode.initial_pc)                      {                          if (start_data_pc == decode.pc)                              decode.pc = end_data_pc;                          if (decode_routine() != tx_h.END_OF_ROUTINE)                          {                              if (start_data_pc == 0)                                  start_data_pc = decode.pc;                              flag = true;                              end_data_pc = 0;                              pcindex = 0;                              pc = ROUND_CODE(pc);                              do                              {                                  pc += txio.code_scaler;                                  vars = (char)txio.read_data_byte(ref pc);                                  pc--;                              } while (vars < 0 || vars > 15);                              decode.pc = pc;                          }                          else                          {                              if (pc < decode.initial_pc && decode.pc > decode.initial_pc)                              {                                  pc = decode.pc = decode.initial_pc;                                  decode.low_address = low_pc;                                  decode.high_address = high_pc;                              }                              else                              {                                  if (start_data_pc > 0 && end_data_pc == 0)                                      end_data_pc = pc;                                  pc = ROUND_CODE(decode.pc);                                  if (!flag)                                  {                                      low_pc = decode.low_address;                                      high_pc = decode.high_address;                                  }                              }                          }                      }                      decode.low_address = low_pc;                      decode.high_address = high_pc;                      // Console.WriteLine("{0} < {1} : {2} > {3}"' low_pc' prev_low_pc' high_pc' prev_high_pc);                    } while (low_pc < prev_low_pc || high_pc > prev_high_pc);                  /* Scan for high routines */                  pc = decode.pc;                  while (decode_routine() == tx_h.END_OF_ROUTINE)                  {                      decode.high_address = pc;                      pc = decode.pc;                  }              }              else              {                  txio.tx_printf("\n[Start of code");                  if (option_labels == 0)                      txio.tx_printf(" at {0:X}"' (ulong)decode.low_address);                  txio.tx_printf("]\n");                  for (decode.pc = decode.low_address;                       decode.pc <= decode.high_address; )                      decode_routine();                  txio.tx_printf("\n[End of code");                  if (option_labels == 0)                      txio.tx_printf(" at {0:X}"' (ulong)decode.pc);                  txio.tx_printf("]\n");              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_program,The following statement contains a magic number: if (decode.first_pass)              {                  if (decode.pc < decode.initial_pc)                  {                      /* Scan for low routines */                      decode.pc = ROUND_CODE(decode.pc);                      for (pc = decode.pc' flag = false; pc < decode.initial_pc && !flag; pc += txio.code_scaler)                      {                          for (vars = (char)txio.read_data_byte(ref pc); vars < 0 || vars > 15; vars = (char)txio.read_data_byte(ref pc))                              pc = ROUND_CODE(pc);                          decode.pc = pc - 1;                          for (i = 0' flag = true; i < 3 && flag; i++)                          {                              pcindex = 0;                              decode.pc = ROUND_CODE(decode.pc);                              if (decode_routine() != tx_h.END_OF_ROUTINE || pcindex > 0)                                  flag = false;                          }                          decode.pc = pc - 1;                      }                      if (flag && (uint)header.version < tx_h.V5)                      {                          pc = decode.pc;                          vars = (char)txio.read_data_byte(ref pc);                          low_pc = decode.pc;                          for (pc = (ulong)(pc + ((ulong)vars * 2) - 1)' flag = false; pc >= low_pc && !flag; pc -= txio.story_scaler)                          {                              decode.pc = pc;                              for (i = 0' flag = true; i < 3 && flag; i++)                              {                                  pcindex = 0;                                  decode.pc = ROUND_CODE(decode.pc);                                  if (decode_routine() != tx_h.END_OF_ROUTINE || pcindex > 0)                                      flag = false;                              }                              decode.pc = pc;                          }                      }                      if (!flag || decode.pc > decode.initial_pc)                          decode.pc = decode.initial_pc;                  }                  /* Fill in middle routines */                  decode.low_address = decode.pc;                  decode.high_address = decode.pc;                  start_data_pc = 0;                  end_data_pc = 0;                  do                  {                      if (option_labels > 0)                      {                          routines_base = null;                      }                      prev_low_pc = decode.low_address;                      prev_high_pc = decode.high_address;                      flag = false;                      pcindex = 0;                      low_pc = decode.low_address;                      high_pc = decode.high_address;                      pc = decode.pc = decode.low_address;                      while (decode.pc <= high_pc || decode.pc <= decode.initial_pc)                      {                          if (start_data_pc == decode.pc)                              decode.pc = end_data_pc;                          if (decode_routine() != tx_h.END_OF_ROUTINE)                          {                              if (start_data_pc == 0)                                  start_data_pc = decode.pc;                              flag = true;                              end_data_pc = 0;                              pcindex = 0;                              pc = ROUND_CODE(pc);                              do                              {                                  pc += txio.code_scaler;                                  vars = (char)txio.read_data_byte(ref pc);                                  pc--;                              } while (vars < 0 || vars > 15);                              decode.pc = pc;                          }                          else                          {                              if (pc < decode.initial_pc && decode.pc > decode.initial_pc)                              {                                  pc = decode.pc = decode.initial_pc;                                  decode.low_address = low_pc;                                  decode.high_address = high_pc;                              }                              else                              {                                  if (start_data_pc > 0 && end_data_pc == 0)                                      end_data_pc = pc;                                  pc = ROUND_CODE(decode.pc);                                  if (!flag)                                  {                                      low_pc = decode.low_address;                                      high_pc = decode.high_address;                                  }                              }                          }                      }                      decode.low_address = low_pc;                      decode.high_address = high_pc;                      // Console.WriteLine("{0} < {1} : {2} > {3}"' low_pc' prev_low_pc' high_pc' prev_high_pc);                    } while (low_pc < prev_low_pc || high_pc > prev_high_pc);                  /* Scan for high routines */                  pc = decode.pc;                  while (decode_routine() == tx_h.END_OF_ROUTINE)                  {                      decode.high_address = pc;                      pc = decode.pc;                  }              }              else              {                  txio.tx_printf("\n[Start of code");                  if (option_labels == 0)                      txio.tx_printf(" at {0:X}"' (ulong)decode.low_address);                  txio.tx_printf("]\n");                  for (decode.pc = decode.low_address;                       decode.pc <= decode.high_address; )                      decode_routine();                  txio.tx_printf("\n[End of code");                  if (option_labels == 0)                      txio.tx_printf(" at {0:X}"' (ulong)decode.pc);                  txio.tx_printf("]\n");              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_program,The following statement contains a magic number: if (decode.first_pass)              {                  if (decode.pc < decode.initial_pc)                  {                      /* Scan for low routines */                      decode.pc = ROUND_CODE(decode.pc);                      for (pc = decode.pc' flag = false; pc < decode.initial_pc && !flag; pc += txio.code_scaler)                      {                          for (vars = (char)txio.read_data_byte(ref pc); vars < 0 || vars > 15; vars = (char)txio.read_data_byte(ref pc))                              pc = ROUND_CODE(pc);                          decode.pc = pc - 1;                          for (i = 0' flag = true; i < 3 && flag; i++)                          {                              pcindex = 0;                              decode.pc = ROUND_CODE(decode.pc);                              if (decode_routine() != tx_h.END_OF_ROUTINE || pcindex > 0)                                  flag = false;                          }                          decode.pc = pc - 1;                      }                      if (flag && (uint)header.version < tx_h.V5)                      {                          pc = decode.pc;                          vars = (char)txio.read_data_byte(ref pc);                          low_pc = decode.pc;                          for (pc = (ulong)(pc + ((ulong)vars * 2) - 1)' flag = false; pc >= low_pc && !flag; pc -= txio.story_scaler)                          {                              decode.pc = pc;                              for (i = 0' flag = true; i < 3 && flag; i++)                              {                                  pcindex = 0;                                  decode.pc = ROUND_CODE(decode.pc);                                  if (decode_routine() != tx_h.END_OF_ROUTINE || pcindex > 0)                                      flag = false;                              }                              decode.pc = pc;                          }                      }                      if (!flag || decode.pc > decode.initial_pc)                          decode.pc = decode.initial_pc;                  }                  /* Fill in middle routines */                  decode.low_address = decode.pc;                  decode.high_address = decode.pc;                  start_data_pc = 0;                  end_data_pc = 0;                  do                  {                      if (option_labels > 0)                      {                          routines_base = null;                      }                      prev_low_pc = decode.low_address;                      prev_high_pc = decode.high_address;                      flag = false;                      pcindex = 0;                      low_pc = decode.low_address;                      high_pc = decode.high_address;                      pc = decode.pc = decode.low_address;                      while (decode.pc <= high_pc || decode.pc <= decode.initial_pc)                      {                          if (start_data_pc == decode.pc)                              decode.pc = end_data_pc;                          if (decode_routine() != tx_h.END_OF_ROUTINE)                          {                              if (start_data_pc == 0)                                  start_data_pc = decode.pc;                              flag = true;                              end_data_pc = 0;                              pcindex = 0;                              pc = ROUND_CODE(pc);                              do                              {                                  pc += txio.code_scaler;                                  vars = (char)txio.read_data_byte(ref pc);                                  pc--;                              } while (vars < 0 || vars > 15);                              decode.pc = pc;                          }                          else                          {                              if (pc < decode.initial_pc && decode.pc > decode.initial_pc)                              {                                  pc = decode.pc = decode.initial_pc;                                  decode.low_address = low_pc;                                  decode.high_address = high_pc;                              }                              else                              {                                  if (start_data_pc > 0 && end_data_pc == 0)                                      end_data_pc = pc;                                  pc = ROUND_CODE(decode.pc);                                  if (!flag)                                  {                                      low_pc = decode.low_address;                                      high_pc = decode.high_address;                                  }                              }                          }                      }                      decode.low_address = low_pc;                      decode.high_address = high_pc;                      // Console.WriteLine("{0} < {1} : {2} > {3}"' low_pc' prev_low_pc' high_pc' prev_high_pc);                    } while (low_pc < prev_low_pc || high_pc > prev_high_pc);                  /* Scan for high routines */                  pc = decode.pc;                  while (decode_routine() == tx_h.END_OF_ROUTINE)                  {                      decode.high_address = pc;                      pc = decode.pc;                  }              }              else              {                  txio.tx_printf("\n[Start of code");                  if (option_labels == 0)                      txio.tx_printf(" at {0:X}"' (ulong)decode.low_address);                  txio.tx_printf("]\n");                  for (decode.pc = decode.low_address;                       decode.pc <= decode.high_address; )                      decode_routine();                  txio.tx_printf("\n[End of code");                  if (option_labels == 0)                      txio.tx_printf(" at {0:X}"' (ulong)decode.pc);                  txio.tx_printf("]\n");              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_routine,The following statement contains a magic number: if (decode.first_pass)              {                  cref_item = null;                  if (option_labels > 0)                      cref_item = current_routine;                  old_start = start_of_routine;                  locals = locals_count;                  old_pc = decode.pc;                  decode.pc = ROUND_CODE(decode.pc);                  vars = txio.read_data_byte(ref decode.pc);                  if (vars >= 0 && vars <= 15)                  {                      if (option_labels > 0)                          add_routine(decode.pc - 1);                      locals_count = vars;                      if ((uint)header.version < tx_h.V5)                          for (; vars > 0; vars--)                              txio.read_data_word(ref decode.pc);                      start_of_routine = decode.pc;                      if (decode_code() == tx_h.END_OF_ROUTINE)                          return (tx_h.END_OF_ROUTINE);                      if (option_labels > 0)                          current_routine = cref_item;                      start_of_routine = old_start;                      locals_count = locals;                  }                  decode.pc = old_pc;                  if ((status = decode_code()) != tx_h.END_OF_ROUTINE)                  {                      decode.pc = old_pc;                  }                  else                  {                      pctable[pcindex++] = old_pc;                      if (pcindex == MAX_PCS)                      {                          throw new NotImplementedException("\nFatal: too many orphan code fragments\n");                      }                  }              }              else              {                  if (decode.pc == start_data_pc)                  {                      if (option_dump > 0)                      {                          txio.tx_printf("\n[Start of data");                          if (option_labels == 0)                              txio.tx_printf(" at {0:X}"' (ulong)start_data_pc);                          txio.tx_printf("]\n\n");                          dump_data(start_data_pc' end_data_pc - 1);                          txio.tx_printf("\n[End of data");                          if (option_labels == 0)                              txio.tx_printf(" at {0:X}"' (ulong)(end_data_pc - 1));                          txio.tx_printf("]\n");                      }                      decode.pc = end_data_pc;                  }                  for (i = 0; i < pcindex && decode.pc != pctable[i]; i++)                      ;                  if (i == pcindex)                  {                      decode.pc = ROUND_CODE(decode.pc);                      start_of_routine = decode.pc;                      vars = txio.read_data_byte(ref decode.pc);                      if (option_labels > 0)                      {                          txio.tx_printf("{0}outine {1}{2:d4}' {3} local"'                                             (decode.pc - 1 == decode.initial_pc) ? "\nMain r" : "\nR"'                                             (txio.option_inform) ? 'r' : 'R''                                 (int)lookup_routine(decode.pc - 1' 1)'                                             (int)vars);                      }                      else                      {                          txio.tx_printf("{0}outine {1:X}' {2} local"'                                 (decode.pc - 1 == decode.initial_pc) ? "\nMain r" : "\nR"'                                             (ulong)(decode.pc - 1)'                                             (int)vars);                      }                      if (vars != 1)                          txio.tx_printf("s");                      if ((uint)header.version < tx_h.V5)                      {                          txio.tx_printf(" (");                          txio.tx_fix_margin(1);                          for (; vars > 0; vars--)                          {                              txio.tx_printf("{0:X4}"' (uint)txio.read_data_word(ref decode.pc));                              if (vars > 1)                                  txio.tx_printf("' ");                          }                          txio.tx_fix_margin(0);                          txio.tx_printf(")");                      }                      txio.tx_printf("\n");                      lookup_verb(start_of_routine);                      txio.tx_printf("\n");                  }                  else                      txio.tx_printf("\norphan code fragment:\n\n");                  status = decode_code();              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_operands,The following statement contains a magic number: opcode.par[2] = par3;
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_operands,The following statement contains a magic number: opcode.par[3] = par4;
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_operands,The following statement contains a magic number: if (decode.first_pass)              {                  status = decode_parameters(out opers);                  if (status > 0)                      return (tx_h.BAD_OPCODE);                  status = decode_extra();              }              else              {                  if (option_dump > 0)                      dump_opcode(decode.pc' opcode.opcode' opcode.opclass' opcode.par' opcode.extra);                  if (txio.option_inform)                  {                      len = opcode_name.Length;                      for (i = 0; i < len; i++)                          txio.tx_printf("{0}"' Char.ToLower(opcode_name[i]));                  }                  else                  {                      txio.tx_printf(opcode_name);                      // len = strlen (opcode_name);                      len = opcode_name.Length;                  }                  for (; len < 16; len++)                      txio.tx_printf(" ");                  decode_parameters(out opers);                  if (opers > 0 && opcode.extra != tx_h.NONE)                      txio.tx_printf(" ");                  status = decode_extra();                  txio.tx_printf("\n");              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameters,The following statement contains a magic number: switch (opcode.opclass)              {                    case tx_h.ONE_OPERAND:                      status = decode_parameter((opcode.opcode >> 4) & 0x03' 0);                      if (status > 0)                          return (status);                      opers = 1;                      break;                    case tx_h.TWO_OPERAND:                      status = decode_parameter((opcode.opcode & 0x40) > 0 ? tx_h.VARIABLE : tx_h.BYTE_IMMED' 0);                      if (status > 0)                          return (status);                      if (!decode.first_pass)                      {                          if (!txio.option_inform && opcode.type == tx_h.CALL)                              txio.tx_printf(" (");                          else                              txio.tx_printf("{0}"' (txio.option_inform) ? ' ' : ''');                      }                      status = decode_parameter((opcode.opcode & 0x20) > 0 ? tx_h.VARIABLE : tx_h.BYTE_IMMED' 1);                      if (status > 0)                          return (status);                      opers = 2;                      if (!txio.option_inform && !decode.first_pass && opcode.type == tx_h.CALL && opers > 1)                          txio.tx_printf(")");                      break;                    case tx_h.VARIABLE_OPERAND:                  case tx_h.EXTENDED_OPERAND:                      if ((opcode.opcode & 0x3f) == 0x2c ||                      (opcode.opcode & 0x3f) == 0x3a)                      {                          modes = txio.read_data_word(ref decode.pc);                          maxopers = 8;                      }                      else                      {                          modes = txio.read_data_byte(ref decode.pc);                          maxopers = 4;                      }                      for (addr_mode = 0' opers = 0;                       (addr_mode != tx_h.NO_OPERAND) && maxopers > 0; maxopers--)                      {                          addr_mode = (modes >> ((maxopers - 1) * 2)) & 0x03;                          if (addr_mode != tx_h.NO_OPERAND)                          {                              if (!decode.first_pass && opers > 0)                              {                                  if (!txio.option_inform && opcode.type == tx_h.CALL && opers == 1)                                      txio.tx_printf(" (");                                  else                                      txio.tx_printf("{0}"' (txio.option_inform) ? ' ' : ''');                              }                              status = decode_parameter(addr_mode' opers);                              if (status > 0)                                  return (status);                              opers++;                          }                      }                      if (!txio.option_inform && !decode.first_pass && opcode.type == tx_h.CALL && opers > 1)                          txio.tx_printf(")");                      break;                    case tx_h.ZERO_OPERAND:                      break;                    default:                      throw new ArgumentException(String.Format("\nFatal: bad class ({0})\n"' (int)opcode.opclass));              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameters,The following statement contains a magic number: switch (opcode.opclass)              {                    case tx_h.ONE_OPERAND:                      status = decode_parameter((opcode.opcode >> 4) & 0x03' 0);                      if (status > 0)                          return (status);                      opers = 1;                      break;                    case tx_h.TWO_OPERAND:                      status = decode_parameter((opcode.opcode & 0x40) > 0 ? tx_h.VARIABLE : tx_h.BYTE_IMMED' 0);                      if (status > 0)                          return (status);                      if (!decode.first_pass)                      {                          if (!txio.option_inform && opcode.type == tx_h.CALL)                              txio.tx_printf(" (");                          else                              txio.tx_printf("{0}"' (txio.option_inform) ? ' ' : ''');                      }                      status = decode_parameter((opcode.opcode & 0x20) > 0 ? tx_h.VARIABLE : tx_h.BYTE_IMMED' 1);                      if (status > 0)                          return (status);                      opers = 2;                      if (!txio.option_inform && !decode.first_pass && opcode.type == tx_h.CALL && opers > 1)                          txio.tx_printf(")");                      break;                    case tx_h.VARIABLE_OPERAND:                  case tx_h.EXTENDED_OPERAND:                      if ((opcode.opcode & 0x3f) == 0x2c ||                      (opcode.opcode & 0x3f) == 0x3a)                      {                          modes = txio.read_data_word(ref decode.pc);                          maxopers = 8;                      }                      else                      {                          modes = txio.read_data_byte(ref decode.pc);                          maxopers = 4;                      }                      for (addr_mode = 0' opers = 0;                       (addr_mode != tx_h.NO_OPERAND) && maxopers > 0; maxopers--)                      {                          addr_mode = (modes >> ((maxopers - 1) * 2)) & 0x03;                          if (addr_mode != tx_h.NO_OPERAND)                          {                              if (!decode.first_pass && opers > 0)                              {                                  if (!txio.option_inform && opcode.type == tx_h.CALL && opers == 1)                                      txio.tx_printf(" (");                                  else                                      txio.tx_printf("{0}"' (txio.option_inform) ? ' ' : ''');                              }                              status = decode_parameter(addr_mode' opers);                              if (status > 0)                                  return (status);                              opers++;                          }                      }                      if (!txio.option_inform && !decode.first_pass && opcode.type == tx_h.CALL && opers > 1)                          txio.tx_printf(")");                      break;                    case tx_h.ZERO_OPERAND:                      break;                    default:                      throw new ArgumentException(String.Format("\nFatal: bad class ({0})\n"' (int)opcode.opclass));              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameters,The following statement contains a magic number: switch (opcode.opclass)              {                    case tx_h.ONE_OPERAND:                      status = decode_parameter((opcode.opcode >> 4) & 0x03' 0);                      if (status > 0)                          return (status);                      opers = 1;                      break;                    case tx_h.TWO_OPERAND:                      status = decode_parameter((opcode.opcode & 0x40) > 0 ? tx_h.VARIABLE : tx_h.BYTE_IMMED' 0);                      if (status > 0)                          return (status);                      if (!decode.first_pass)                      {                          if (!txio.option_inform && opcode.type == tx_h.CALL)                              txio.tx_printf(" (");                          else                              txio.tx_printf("{0}"' (txio.option_inform) ? ' ' : ''');                      }                      status = decode_parameter((opcode.opcode & 0x20) > 0 ? tx_h.VARIABLE : tx_h.BYTE_IMMED' 1);                      if (status > 0)                          return (status);                      opers = 2;                      if (!txio.option_inform && !decode.first_pass && opcode.type == tx_h.CALL && opers > 1)                          txio.tx_printf(")");                      break;                    case tx_h.VARIABLE_OPERAND:                  case tx_h.EXTENDED_OPERAND:                      if ((opcode.opcode & 0x3f) == 0x2c ||                      (opcode.opcode & 0x3f) == 0x3a)                      {                          modes = txio.read_data_word(ref decode.pc);                          maxopers = 8;                      }                      else                      {                          modes = txio.read_data_byte(ref decode.pc);                          maxopers = 4;                      }                      for (addr_mode = 0' opers = 0;                       (addr_mode != tx_h.NO_OPERAND) && maxopers > 0; maxopers--)                      {                          addr_mode = (modes >> ((maxopers - 1) * 2)) & 0x03;                          if (addr_mode != tx_h.NO_OPERAND)                          {                              if (!decode.first_pass && opers > 0)                              {                                  if (!txio.option_inform && opcode.type == tx_h.CALL && opers == 1)                                      txio.tx_printf(" (");                                  else                                      txio.tx_printf("{0}"' (txio.option_inform) ? ' ' : ''');                              }                              status = decode_parameter(addr_mode' opers);                              if (status > 0)                                  return (status);                              opers++;                          }                      }                      if (!txio.option_inform && !decode.first_pass && opcode.type == tx_h.CALL && opers > 1)                          txio.tx_printf(")");                      break;                    case tx_h.ZERO_OPERAND:                      break;                    default:                      throw new ArgumentException(String.Format("\nFatal: bad class ({0})\n"' (int)opcode.opclass));              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameters,The following statement contains a magic number: switch (opcode.opclass)              {                    case tx_h.ONE_OPERAND:                      status = decode_parameter((opcode.opcode >> 4) & 0x03' 0);                      if (status > 0)                          return (status);                      opers = 1;                      break;                    case tx_h.TWO_OPERAND:                      status = decode_parameter((opcode.opcode & 0x40) > 0 ? tx_h.VARIABLE : tx_h.BYTE_IMMED' 0);                      if (status > 0)                          return (status);                      if (!decode.first_pass)                      {                          if (!txio.option_inform && opcode.type == tx_h.CALL)                              txio.tx_printf(" (");                          else                              txio.tx_printf("{0}"' (txio.option_inform) ? ' ' : ''');                      }                      status = decode_parameter((opcode.opcode & 0x20) > 0 ? tx_h.VARIABLE : tx_h.BYTE_IMMED' 1);                      if (status > 0)                          return (status);                      opers = 2;                      if (!txio.option_inform && !decode.first_pass && opcode.type == tx_h.CALL && opers > 1)                          txio.tx_printf(")");                      break;                    case tx_h.VARIABLE_OPERAND:                  case tx_h.EXTENDED_OPERAND:                      if ((opcode.opcode & 0x3f) == 0x2c ||                      (opcode.opcode & 0x3f) == 0x3a)                      {                          modes = txio.read_data_word(ref decode.pc);                          maxopers = 8;                      }                      else                      {                          modes = txio.read_data_byte(ref decode.pc);                          maxopers = 4;                      }                      for (addr_mode = 0' opers = 0;                       (addr_mode != tx_h.NO_OPERAND) && maxopers > 0; maxopers--)                      {                          addr_mode = (modes >> ((maxopers - 1) * 2)) & 0x03;                          if (addr_mode != tx_h.NO_OPERAND)                          {                              if (!decode.first_pass && opers > 0)                              {                                  if (!txio.option_inform && opcode.type == tx_h.CALL && opers == 1)                                      txio.tx_printf(" (");                                  else                                      txio.tx_printf("{0}"' (txio.option_inform) ? ' ' : ''');                              }                              status = decode_parameter(addr_mode' opers);                              if (status > 0)                                  return (status);                              opers++;                          }                      }                      if (!txio.option_inform && !decode.first_pass && opcode.type == tx_h.CALL && opers > 1)                          txio.tx_printf(")");                      break;                    case tx_h.ZERO_OPERAND:                      break;                    default:                      throw new ArgumentException(String.Format("\nFatal: bad class ({0})\n"' (int)opcode.opclass));              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameters,The following statement contains a magic number: switch (opcode.opclass)              {                    case tx_h.ONE_OPERAND:                      status = decode_parameter((opcode.opcode >> 4) & 0x03' 0);                      if (status > 0)                          return (status);                      opers = 1;                      break;                    case tx_h.TWO_OPERAND:                      status = decode_parameter((opcode.opcode & 0x40) > 0 ? tx_h.VARIABLE : tx_h.BYTE_IMMED' 0);                      if (status > 0)                          return (status);                      if (!decode.first_pass)                      {                          if (!txio.option_inform && opcode.type == tx_h.CALL)                              txio.tx_printf(" (");                          else                              txio.tx_printf("{0}"' (txio.option_inform) ? ' ' : ''');                      }                      status = decode_parameter((opcode.opcode & 0x20) > 0 ? tx_h.VARIABLE : tx_h.BYTE_IMMED' 1);                      if (status > 0)                          return (status);                      opers = 2;                      if (!txio.option_inform && !decode.first_pass && opcode.type == tx_h.CALL && opers > 1)                          txio.tx_printf(")");                      break;                    case tx_h.VARIABLE_OPERAND:                  case tx_h.EXTENDED_OPERAND:                      if ((opcode.opcode & 0x3f) == 0x2c ||                      (opcode.opcode & 0x3f) == 0x3a)                      {                          modes = txio.read_data_word(ref decode.pc);                          maxopers = 8;                      }                      else                      {                          modes = txio.read_data_byte(ref decode.pc);                          maxopers = 4;                      }                      for (addr_mode = 0' opers = 0;                       (addr_mode != tx_h.NO_OPERAND) && maxopers > 0; maxopers--)                      {                          addr_mode = (modes >> ((maxopers - 1) * 2)) & 0x03;                          if (addr_mode != tx_h.NO_OPERAND)                          {                              if (!decode.first_pass && opers > 0)                              {                                  if (!txio.option_inform && opcode.type == tx_h.CALL && opers == 1)                                      txio.tx_printf(" (");                                  else                                      txio.tx_printf("{0}"' (txio.option_inform) ? ' ' : ''');                              }                              status = decode_parameter(addr_mode' opers);                              if (status > 0)                                  return (status);                              opers++;                          }                      }                      if (!txio.option_inform && !decode.first_pass && opcode.type == tx_h.CALL && opers > 1)                          txio.tx_printf(")");                      break;                    case tx_h.ZERO_OPERAND:                      break;                    default:                      throw new ArgumentException(String.Format("\nFatal: bad class ({0})\n"' (int)opcode.opclass));              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameter,The following statement contains a magic number: par = (opers < 4) ? opcode.par[opers] : tx_h.ANYTHING;
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameter,The following statement contains a magic number: if (opers < 4 && opcode.par[opers] == tx_h.VAR)                  par = (addr_mode == tx_h.VARIABLE) ? tx_h.INDIRECT : tx_h.VAR;
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameter,The following statement contains a magic number: switch (par)              {                    case tx_h.NIL:                      if (!decode.first_pass)                      {                          Console.Error.Write("\nWarning: Unexpected Parameter #{0} near {1:X5}\n"' opers' decode.pc);                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ANYTHING:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s > 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' s);                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              if (s > 0)                                  txio.tx_printf(" {0} "' (txio.option_inform) ? "or" : "OR");                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          if (dictionary == 0 && s == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.VAR:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("{0}"' (txio.option_inform) ? "sp" : "(SP)+");                          else                              print_variable(value);                      }                      else                      {                          if ((int)value > 0 && (int)value < 16 && (int)value > locals_count)                              return (1);                      }                      break;                    case tx_h.NUMBER:                      if (!decode.first_pass)                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.PROPNUM:                      if (!decode.first_pass)                          if (symbols.print_property_name(property_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.ATTRNUM:                      if (!decode.first_pass)                          if (symbols.print_attribute_name(attr_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.LOW_ADDR:                      if (!decode.first_pass)                      {                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ROUTINE:                      addr = (ulong)txio.code_scaler * value + (ulong)header.routines_offset * txio.story_scaler;                      if (!decode.first_pass)                      {                          if (option_labels > 0)                              if (value != 0)                              {                                  routine = lookup_routine(addr' 0);                                  if (routine != 0)                                      txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'r' : 'R'' routine);                                  else                                  {                                      Console.Error.Write("\nWarning: found call to nonexistent routine!\n");                                      txio.tx_printf("{0:X}"' addr);                                  }                              }                              else                                  print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          else                              txio.tx_printf("{0:X}"' addr);                      }                      else                      {                          if (addr < decode.low_address &&                              addr >= code_base)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.low_address = addr - 1;                          }                          if (addr > decode.high_address &&                              addr < (ulong)txio.file_size)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.high_address = addr - 1;                          }                      }                      break;                    case tx_h.OBJECT:                      if (!decode.first_pass)                      {                          // if (value == 0 || showobj.print_object_desc ((int)value) == 0) // TODO I don't like this section                          if (value == 0)                          {                              showobj.print_object_desc((int)value);                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          }                      }                      break;                    case tx_h.STATIC:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s != 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' (int)s);                          else                          {  #if !TXD_DEBUG                              Console.Error.WriteLine("\nWarning: printing of nonexistent string\n");  #endif                              txio.tx_printf("{0:X}"' addr);                          }                      }                      break;                    case tx_h.LABEL:                      addr = decode.pc + (ulong)(short)value - 2; // TODO Check this math somehow                      if (decode.first_pass && addr < decode.low_address)                          return (1);                      if (option_labels > 0)                      {                          if (decode.first_pass)                              add_label(addr);                          else                              txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'l' : 'L'' lookup_label(addr' 1));                      }                      else                      {                          if (!decode.first_pass)                              txio.tx_printf("{0:X}"' addr);                      }                      if (addr > decode.high_pc)                          decode.high_pc = addr;                      break;                    case tx_h.PCHAR:                      if (!decode.first_pass)                          if (isprint((char)value))                              txio.tx_printf("\'{0}\'"' (char)value);                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.VATTR:                      if (!decode.first_pass)                      {                          if (value == tx_h.ROMAN)                              txio.tx_printf("{0}"' (txio.option_inform) ? "roman" : "ROMAN");                          else if (value == tx_h.REVERSE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "reverse" : "REVERSE");                          else if (value == tx_h.BOLDFACE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "boldface" : "BOLDFACE");                          else if (value == tx_h.EMPHASIS)                              txio.tx_printf("{0}"' (txio.option_inform) ? "emphasis" : "EMPHASIS");                          else if (value == tx_h.FIXED_FONT)                              txio.tx_printf("{0}"' (txio.option_inform) ? "fixed_font" : "FIXED_FONT");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.PATTR:                      if (!decode.first_pass)                      {                          if ((int)value == 1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_enable" : "OUTPUT_ENABLE");                          else if ((int)value == 2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_enable" : "SCRIPTING_ENABLE");                          else if ((int)value == 3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_enable" : "REDIRECT_ENABLE");                          else if ((int)value == 4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_enable" : "RECORD_ENABLE");                          else if ((int)value == -1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_disable" : "OUTPUT_DISABLE");                          else if ((int)value == -2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_disable" : "SCRIPTING_DISABLE");                          else if ((int)value == -3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_disable" : "REDIRECT_DISABLE");                          else if ((int)value == -4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_disable" : "RECORD_DISABLE");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.INDIRECT:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("[{0}]"' (txio.option_inform) ? "sp" : "(SP)+");                          else                          {                              txio.tx_printf("[");                              print_variable(value);                              txio.tx_printf("]");                          }                      }                      break;                    default:                      throw new ArgumentException(String.Format("\nFatal: bad operand type ({0})\n"' (int)par));              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameter,The following statement contains a magic number: switch (par)              {                    case tx_h.NIL:                      if (!decode.first_pass)                      {                          Console.Error.Write("\nWarning: Unexpected Parameter #{0} near {1:X5}\n"' opers' decode.pc);                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ANYTHING:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s > 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' s);                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              if (s > 0)                                  txio.tx_printf(" {0} "' (txio.option_inform) ? "or" : "OR");                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          if (dictionary == 0 && s == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.VAR:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("{0}"' (txio.option_inform) ? "sp" : "(SP)+");                          else                              print_variable(value);                      }                      else                      {                          if ((int)value > 0 && (int)value < 16 && (int)value > locals_count)                              return (1);                      }                      break;                    case tx_h.NUMBER:                      if (!decode.first_pass)                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.PROPNUM:                      if (!decode.first_pass)                          if (symbols.print_property_name(property_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.ATTRNUM:                      if (!decode.first_pass)                          if (symbols.print_attribute_name(attr_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.LOW_ADDR:                      if (!decode.first_pass)                      {                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ROUTINE:                      addr = (ulong)txio.code_scaler * value + (ulong)header.routines_offset * txio.story_scaler;                      if (!decode.first_pass)                      {                          if (option_labels > 0)                              if (value != 0)                              {                                  routine = lookup_routine(addr' 0);                                  if (routine != 0)                                      txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'r' : 'R'' routine);                                  else                                  {                                      Console.Error.Write("\nWarning: found call to nonexistent routine!\n");                                      txio.tx_printf("{0:X}"' addr);                                  }                              }                              else                                  print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          else                              txio.tx_printf("{0:X}"' addr);                      }                      else                      {                          if (addr < decode.low_address &&                              addr >= code_base)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.low_address = addr - 1;                          }                          if (addr > decode.high_address &&                              addr < (ulong)txio.file_size)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.high_address = addr - 1;                          }                      }                      break;                    case tx_h.OBJECT:                      if (!decode.first_pass)                      {                          // if (value == 0 || showobj.print_object_desc ((int)value) == 0) // TODO I don't like this section                          if (value == 0)                          {                              showobj.print_object_desc((int)value);                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          }                      }                      break;                    case tx_h.STATIC:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s != 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' (int)s);                          else                          {  #if !TXD_DEBUG                              Console.Error.WriteLine("\nWarning: printing of nonexistent string\n");  #endif                              txio.tx_printf("{0:X}"' addr);                          }                      }                      break;                    case tx_h.LABEL:                      addr = decode.pc + (ulong)(short)value - 2; // TODO Check this math somehow                      if (decode.first_pass && addr < decode.low_address)                          return (1);                      if (option_labels > 0)                      {                          if (decode.first_pass)                              add_label(addr);                          else                              txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'l' : 'L'' lookup_label(addr' 1));                      }                      else                      {                          if (!decode.first_pass)                              txio.tx_printf("{0:X}"' addr);                      }                      if (addr > decode.high_pc)                          decode.high_pc = addr;                      break;                    case tx_h.PCHAR:                      if (!decode.first_pass)                          if (isprint((char)value))                              txio.tx_printf("\'{0}\'"' (char)value);                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.VATTR:                      if (!decode.first_pass)                      {                          if (value == tx_h.ROMAN)                              txio.tx_printf("{0}"' (txio.option_inform) ? "roman" : "ROMAN");                          else if (value == tx_h.REVERSE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "reverse" : "REVERSE");                          else if (value == tx_h.BOLDFACE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "boldface" : "BOLDFACE");                          else if (value == tx_h.EMPHASIS)                              txio.tx_printf("{0}"' (txio.option_inform) ? "emphasis" : "EMPHASIS");                          else if (value == tx_h.FIXED_FONT)                              txio.tx_printf("{0}"' (txio.option_inform) ? "fixed_font" : "FIXED_FONT");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.PATTR:                      if (!decode.first_pass)                      {                          if ((int)value == 1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_enable" : "OUTPUT_ENABLE");                          else if ((int)value == 2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_enable" : "SCRIPTING_ENABLE");                          else if ((int)value == 3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_enable" : "REDIRECT_ENABLE");                          else if ((int)value == 4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_enable" : "RECORD_ENABLE");                          else if ((int)value == -1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_disable" : "OUTPUT_DISABLE");                          else if ((int)value == -2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_disable" : "SCRIPTING_DISABLE");                          else if ((int)value == -3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_disable" : "REDIRECT_DISABLE");                          else if ((int)value == -4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_disable" : "RECORD_DISABLE");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.INDIRECT:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("[{0}]"' (txio.option_inform) ? "sp" : "(SP)+");                          else                          {                              txio.tx_printf("[");                              print_variable(value);                              txio.tx_printf("]");                          }                      }                      break;                    default:                      throw new ArgumentException(String.Format("\nFatal: bad operand type ({0})\n"' (int)par));              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameter,The following statement contains a magic number: switch (par)              {                    case tx_h.NIL:                      if (!decode.first_pass)                      {                          Console.Error.Write("\nWarning: Unexpected Parameter #{0} near {1:X5}\n"' opers' decode.pc);                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ANYTHING:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s > 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' s);                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              if (s > 0)                                  txio.tx_printf(" {0} "' (txio.option_inform) ? "or" : "OR");                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          if (dictionary == 0 && s == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.VAR:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("{0}"' (txio.option_inform) ? "sp" : "(SP)+");                          else                              print_variable(value);                      }                      else                      {                          if ((int)value > 0 && (int)value < 16 && (int)value > locals_count)                              return (1);                      }                      break;                    case tx_h.NUMBER:                      if (!decode.first_pass)                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.PROPNUM:                      if (!decode.first_pass)                          if (symbols.print_property_name(property_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.ATTRNUM:                      if (!decode.first_pass)                          if (symbols.print_attribute_name(attr_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.LOW_ADDR:                      if (!decode.first_pass)                      {                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ROUTINE:                      addr = (ulong)txio.code_scaler * value + (ulong)header.routines_offset * txio.story_scaler;                      if (!decode.first_pass)                      {                          if (option_labels > 0)                              if (value != 0)                              {                                  routine = lookup_routine(addr' 0);                                  if (routine != 0)                                      txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'r' : 'R'' routine);                                  else                                  {                                      Console.Error.Write("\nWarning: found call to nonexistent routine!\n");                                      txio.tx_printf("{0:X}"' addr);                                  }                              }                              else                                  print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          else                              txio.tx_printf("{0:X}"' addr);                      }                      else                      {                          if (addr < decode.low_address &&                              addr >= code_base)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.low_address = addr - 1;                          }                          if (addr > decode.high_address &&                              addr < (ulong)txio.file_size)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.high_address = addr - 1;                          }                      }                      break;                    case tx_h.OBJECT:                      if (!decode.first_pass)                      {                          // if (value == 0 || showobj.print_object_desc ((int)value) == 0) // TODO I don't like this section                          if (value == 0)                          {                              showobj.print_object_desc((int)value);                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          }                      }                      break;                    case tx_h.STATIC:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s != 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' (int)s);                          else                          {  #if !TXD_DEBUG                              Console.Error.WriteLine("\nWarning: printing of nonexistent string\n");  #endif                              txio.tx_printf("{0:X}"' addr);                          }                      }                      break;                    case tx_h.LABEL:                      addr = decode.pc + (ulong)(short)value - 2; // TODO Check this math somehow                      if (decode.first_pass && addr < decode.low_address)                          return (1);                      if (option_labels > 0)                      {                          if (decode.first_pass)                              add_label(addr);                          else                              txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'l' : 'L'' lookup_label(addr' 1));                      }                      else                      {                          if (!decode.first_pass)                              txio.tx_printf("{0:X}"' addr);                      }                      if (addr > decode.high_pc)                          decode.high_pc = addr;                      break;                    case tx_h.PCHAR:                      if (!decode.first_pass)                          if (isprint((char)value))                              txio.tx_printf("\'{0}\'"' (char)value);                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.VATTR:                      if (!decode.first_pass)                      {                          if (value == tx_h.ROMAN)                              txio.tx_printf("{0}"' (txio.option_inform) ? "roman" : "ROMAN");                          else if (value == tx_h.REVERSE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "reverse" : "REVERSE");                          else if (value == tx_h.BOLDFACE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "boldface" : "BOLDFACE");                          else if (value == tx_h.EMPHASIS)                              txio.tx_printf("{0}"' (txio.option_inform) ? "emphasis" : "EMPHASIS");                          else if (value == tx_h.FIXED_FONT)                              txio.tx_printf("{0}"' (txio.option_inform) ? "fixed_font" : "FIXED_FONT");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.PATTR:                      if (!decode.first_pass)                      {                          if ((int)value == 1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_enable" : "OUTPUT_ENABLE");                          else if ((int)value == 2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_enable" : "SCRIPTING_ENABLE");                          else if ((int)value == 3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_enable" : "REDIRECT_ENABLE");                          else if ((int)value == 4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_enable" : "RECORD_ENABLE");                          else if ((int)value == -1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_disable" : "OUTPUT_DISABLE");                          else if ((int)value == -2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_disable" : "SCRIPTING_DISABLE");                          else if ((int)value == -3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_disable" : "REDIRECT_DISABLE");                          else if ((int)value == -4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_disable" : "RECORD_DISABLE");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.INDIRECT:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("[{0}]"' (txio.option_inform) ? "sp" : "(SP)+");                          else                          {                              txio.tx_printf("[");                              print_variable(value);                              txio.tx_printf("]");                          }                      }                      break;                    default:                      throw new ArgumentException(String.Format("\nFatal: bad operand type ({0})\n"' (int)par));              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameter,The following statement contains a magic number: switch (par)              {                    case tx_h.NIL:                      if (!decode.first_pass)                      {                          Console.Error.Write("\nWarning: Unexpected Parameter #{0} near {1:X5}\n"' opers' decode.pc);                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ANYTHING:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s > 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' s);                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              if (s > 0)                                  txio.tx_printf(" {0} "' (txio.option_inform) ? "or" : "OR");                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          if (dictionary == 0 && s == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.VAR:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("{0}"' (txio.option_inform) ? "sp" : "(SP)+");                          else                              print_variable(value);                      }                      else                      {                          if ((int)value > 0 && (int)value < 16 && (int)value > locals_count)                              return (1);                      }                      break;                    case tx_h.NUMBER:                      if (!decode.first_pass)                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.PROPNUM:                      if (!decode.first_pass)                          if (symbols.print_property_name(property_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.ATTRNUM:                      if (!decode.first_pass)                          if (symbols.print_attribute_name(attr_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.LOW_ADDR:                      if (!decode.first_pass)                      {                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ROUTINE:                      addr = (ulong)txio.code_scaler * value + (ulong)header.routines_offset * txio.story_scaler;                      if (!decode.first_pass)                      {                          if (option_labels > 0)                              if (value != 0)                              {                                  routine = lookup_routine(addr' 0);                                  if (routine != 0)                                      txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'r' : 'R'' routine);                                  else                                  {                                      Console.Error.Write("\nWarning: found call to nonexistent routine!\n");                                      txio.tx_printf("{0:X}"' addr);                                  }                              }                              else                                  print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          else                              txio.tx_printf("{0:X}"' addr);                      }                      else                      {                          if (addr < decode.low_address &&                              addr >= code_base)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.low_address = addr - 1;                          }                          if (addr > decode.high_address &&                              addr < (ulong)txio.file_size)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.high_address = addr - 1;                          }                      }                      break;                    case tx_h.OBJECT:                      if (!decode.first_pass)                      {                          // if (value == 0 || showobj.print_object_desc ((int)value) == 0) // TODO I don't like this section                          if (value == 0)                          {                              showobj.print_object_desc((int)value);                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          }                      }                      break;                    case tx_h.STATIC:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s != 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' (int)s);                          else                          {  #if !TXD_DEBUG                              Console.Error.WriteLine("\nWarning: printing of nonexistent string\n");  #endif                              txio.tx_printf("{0:X}"' addr);                          }                      }                      break;                    case tx_h.LABEL:                      addr = decode.pc + (ulong)(short)value - 2; // TODO Check this math somehow                      if (decode.first_pass && addr < decode.low_address)                          return (1);                      if (option_labels > 0)                      {                          if (decode.first_pass)                              add_label(addr);                          else                              txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'l' : 'L'' lookup_label(addr' 1));                      }                      else                      {                          if (!decode.first_pass)                              txio.tx_printf("{0:X}"' addr);                      }                      if (addr > decode.high_pc)                          decode.high_pc = addr;                      break;                    case tx_h.PCHAR:                      if (!decode.first_pass)                          if (isprint((char)value))                              txio.tx_printf("\'{0}\'"' (char)value);                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.VATTR:                      if (!decode.first_pass)                      {                          if (value == tx_h.ROMAN)                              txio.tx_printf("{0}"' (txio.option_inform) ? "roman" : "ROMAN");                          else if (value == tx_h.REVERSE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "reverse" : "REVERSE");                          else if (value == tx_h.BOLDFACE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "boldface" : "BOLDFACE");                          else if (value == tx_h.EMPHASIS)                              txio.tx_printf("{0}"' (txio.option_inform) ? "emphasis" : "EMPHASIS");                          else if (value == tx_h.FIXED_FONT)                              txio.tx_printf("{0}"' (txio.option_inform) ? "fixed_font" : "FIXED_FONT");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.PATTR:                      if (!decode.first_pass)                      {                          if ((int)value == 1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_enable" : "OUTPUT_ENABLE");                          else if ((int)value == 2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_enable" : "SCRIPTING_ENABLE");                          else if ((int)value == 3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_enable" : "REDIRECT_ENABLE");                          else if ((int)value == 4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_enable" : "RECORD_ENABLE");                          else if ((int)value == -1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_disable" : "OUTPUT_DISABLE");                          else if ((int)value == -2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_disable" : "SCRIPTING_DISABLE");                          else if ((int)value == -3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_disable" : "REDIRECT_DISABLE");                          else if ((int)value == -4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_disable" : "RECORD_DISABLE");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.INDIRECT:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("[{0}]"' (txio.option_inform) ? "sp" : "(SP)+");                          else                          {                              txio.tx_printf("[");                              print_variable(value);                              txio.tx_printf("]");                          }                      }                      break;                    default:                      throw new ArgumentException(String.Format("\nFatal: bad operand type ({0})\n"' (int)par));              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameter,The following statement contains a magic number: switch (par)              {                    case tx_h.NIL:                      if (!decode.first_pass)                      {                          Console.Error.Write("\nWarning: Unexpected Parameter #{0} near {1:X5}\n"' opers' decode.pc);                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ANYTHING:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s > 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' s);                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              if (s > 0)                                  txio.tx_printf(" {0} "' (txio.option_inform) ? "or" : "OR");                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          if (dictionary == 0 && s == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.VAR:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("{0}"' (txio.option_inform) ? "sp" : "(SP)+");                          else                              print_variable(value);                      }                      else                      {                          if ((int)value > 0 && (int)value < 16 && (int)value > locals_count)                              return (1);                      }                      break;                    case tx_h.NUMBER:                      if (!decode.first_pass)                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.PROPNUM:                      if (!decode.first_pass)                          if (symbols.print_property_name(property_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.ATTRNUM:                      if (!decode.first_pass)                          if (symbols.print_attribute_name(attr_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.LOW_ADDR:                      if (!decode.first_pass)                      {                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ROUTINE:                      addr = (ulong)txio.code_scaler * value + (ulong)header.routines_offset * txio.story_scaler;                      if (!decode.first_pass)                      {                          if (option_labels > 0)                              if (value != 0)                              {                                  routine = lookup_routine(addr' 0);                                  if (routine != 0)                                      txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'r' : 'R'' routine);                                  else                                  {                                      Console.Error.Write("\nWarning: found call to nonexistent routine!\n");                                      txio.tx_printf("{0:X}"' addr);                                  }                              }                              else                                  print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          else                              txio.tx_printf("{0:X}"' addr);                      }                      else                      {                          if (addr < decode.low_address &&                              addr >= code_base)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.low_address = addr - 1;                          }                          if (addr > decode.high_address &&                              addr < (ulong)txio.file_size)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.high_address = addr - 1;                          }                      }                      break;                    case tx_h.OBJECT:                      if (!decode.first_pass)                      {                          // if (value == 0 || showobj.print_object_desc ((int)value) == 0) // TODO I don't like this section                          if (value == 0)                          {                              showobj.print_object_desc((int)value);                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          }                      }                      break;                    case tx_h.STATIC:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s != 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' (int)s);                          else                          {  #if !TXD_DEBUG                              Console.Error.WriteLine("\nWarning: printing of nonexistent string\n");  #endif                              txio.tx_printf("{0:X}"' addr);                          }                      }                      break;                    case tx_h.LABEL:                      addr = decode.pc + (ulong)(short)value - 2; // TODO Check this math somehow                      if (decode.first_pass && addr < decode.low_address)                          return (1);                      if (option_labels > 0)                      {                          if (decode.first_pass)                              add_label(addr);                          else                              txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'l' : 'L'' lookup_label(addr' 1));                      }                      else                      {                          if (!decode.first_pass)                              txio.tx_printf("{0:X}"' addr);                      }                      if (addr > decode.high_pc)                          decode.high_pc = addr;                      break;                    case tx_h.PCHAR:                      if (!decode.first_pass)                          if (isprint((char)value))                              txio.tx_printf("\'{0}\'"' (char)value);                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.VATTR:                      if (!decode.first_pass)                      {                          if (value == tx_h.ROMAN)                              txio.tx_printf("{0}"' (txio.option_inform) ? "roman" : "ROMAN");                          else if (value == tx_h.REVERSE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "reverse" : "REVERSE");                          else if (value == tx_h.BOLDFACE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "boldface" : "BOLDFACE");                          else if (value == tx_h.EMPHASIS)                              txio.tx_printf("{0}"' (txio.option_inform) ? "emphasis" : "EMPHASIS");                          else if (value == tx_h.FIXED_FONT)                              txio.tx_printf("{0}"' (txio.option_inform) ? "fixed_font" : "FIXED_FONT");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.PATTR:                      if (!decode.first_pass)                      {                          if ((int)value == 1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_enable" : "OUTPUT_ENABLE");                          else if ((int)value == 2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_enable" : "SCRIPTING_ENABLE");                          else if ((int)value == 3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_enable" : "REDIRECT_ENABLE");                          else if ((int)value == 4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_enable" : "RECORD_ENABLE");                          else if ((int)value == -1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_disable" : "OUTPUT_DISABLE");                          else if ((int)value == -2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_disable" : "SCRIPTING_DISABLE");                          else if ((int)value == -3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_disable" : "REDIRECT_DISABLE");                          else if ((int)value == -4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_disable" : "RECORD_DISABLE");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.INDIRECT:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("[{0}]"' (txio.option_inform) ? "sp" : "(SP)+");                          else                          {                              txio.tx_printf("[");                              print_variable(value);                              txio.tx_printf("]");                          }                      }                      break;                    default:                      throw new ArgumentException(String.Format("\nFatal: bad operand type ({0})\n"' (int)par));              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameter,The following statement contains a magic number: switch (par)              {                    case tx_h.NIL:                      if (!decode.first_pass)                      {                          Console.Error.Write("\nWarning: Unexpected Parameter #{0} near {1:X5}\n"' opers' decode.pc);                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ANYTHING:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s > 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' s);                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              if (s > 0)                                  txio.tx_printf(" {0} "' (txio.option_inform) ? "or" : "OR");                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          if (dictionary == 0 && s == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.VAR:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("{0}"' (txio.option_inform) ? "sp" : "(SP)+");                          else                              print_variable(value);                      }                      else                      {                          if ((int)value > 0 && (int)value < 16 && (int)value > locals_count)                              return (1);                      }                      break;                    case tx_h.NUMBER:                      if (!decode.first_pass)                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.PROPNUM:                      if (!decode.first_pass)                          if (symbols.print_property_name(property_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.ATTRNUM:                      if (!decode.first_pass)                          if (symbols.print_attribute_name(attr_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.LOW_ADDR:                      if (!decode.first_pass)                      {                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ROUTINE:                      addr = (ulong)txio.code_scaler * value + (ulong)header.routines_offset * txio.story_scaler;                      if (!decode.first_pass)                      {                          if (option_labels > 0)                              if (value != 0)                              {                                  routine = lookup_routine(addr' 0);                                  if (routine != 0)                                      txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'r' : 'R'' routine);                                  else                                  {                                      Console.Error.Write("\nWarning: found call to nonexistent routine!\n");                                      txio.tx_printf("{0:X}"' addr);                                  }                              }                              else                                  print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          else                              txio.tx_printf("{0:X}"' addr);                      }                      else                      {                          if (addr < decode.low_address &&                              addr >= code_base)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.low_address = addr - 1;                          }                          if (addr > decode.high_address &&                              addr < (ulong)txio.file_size)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.high_address = addr - 1;                          }                      }                      break;                    case tx_h.OBJECT:                      if (!decode.first_pass)                      {                          // if (value == 0 || showobj.print_object_desc ((int)value) == 0) // TODO I don't like this section                          if (value == 0)                          {                              showobj.print_object_desc((int)value);                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          }                      }                      break;                    case tx_h.STATIC:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s != 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' (int)s);                          else                          {  #if !TXD_DEBUG                              Console.Error.WriteLine("\nWarning: printing of nonexistent string\n");  #endif                              txio.tx_printf("{0:X}"' addr);                          }                      }                      break;                    case tx_h.LABEL:                      addr = decode.pc + (ulong)(short)value - 2; // TODO Check this math somehow                      if (decode.first_pass && addr < decode.low_address)                          return (1);                      if (option_labels > 0)                      {                          if (decode.first_pass)                              add_label(addr);                          else                              txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'l' : 'L'' lookup_label(addr' 1));                      }                      else                      {                          if (!decode.first_pass)                              txio.tx_printf("{0:X}"' addr);                      }                      if (addr > decode.high_pc)                          decode.high_pc = addr;                      break;                    case tx_h.PCHAR:                      if (!decode.first_pass)                          if (isprint((char)value))                              txio.tx_printf("\'{0}\'"' (char)value);                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.VATTR:                      if (!decode.first_pass)                      {                          if (value == tx_h.ROMAN)                              txio.tx_printf("{0}"' (txio.option_inform) ? "roman" : "ROMAN");                          else if (value == tx_h.REVERSE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "reverse" : "REVERSE");                          else if (value == tx_h.BOLDFACE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "boldface" : "BOLDFACE");                          else if (value == tx_h.EMPHASIS)                              txio.tx_printf("{0}"' (txio.option_inform) ? "emphasis" : "EMPHASIS");                          else if (value == tx_h.FIXED_FONT)                              txio.tx_printf("{0}"' (txio.option_inform) ? "fixed_font" : "FIXED_FONT");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.PATTR:                      if (!decode.first_pass)                      {                          if ((int)value == 1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_enable" : "OUTPUT_ENABLE");                          else if ((int)value == 2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_enable" : "SCRIPTING_ENABLE");                          else if ((int)value == 3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_enable" : "REDIRECT_ENABLE");                          else if ((int)value == 4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_enable" : "RECORD_ENABLE");                          else if ((int)value == -1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_disable" : "OUTPUT_DISABLE");                          else if ((int)value == -2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_disable" : "SCRIPTING_DISABLE");                          else if ((int)value == -3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_disable" : "REDIRECT_DISABLE");                          else if ((int)value == -4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_disable" : "RECORD_DISABLE");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.INDIRECT:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("[{0}]"' (txio.option_inform) ? "sp" : "(SP)+");                          else                          {                              txio.tx_printf("[");                              print_variable(value);                              txio.tx_printf("]");                          }                      }                      break;                    default:                      throw new ArgumentException(String.Format("\nFatal: bad operand type ({0})\n"' (int)par));              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameter,The following statement contains a magic number: switch (par)              {                    case tx_h.NIL:                      if (!decode.first_pass)                      {                          Console.Error.Write("\nWarning: Unexpected Parameter #{0} near {1:X5}\n"' opers' decode.pc);                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ANYTHING:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s > 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' s);                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              if (s > 0)                                  txio.tx_printf(" {0} "' (txio.option_inform) ? "or" : "OR");                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          if (dictionary == 0 && s == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.VAR:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("{0}"' (txio.option_inform) ? "sp" : "(SP)+");                          else                              print_variable(value);                      }                      else                      {                          if ((int)value > 0 && (int)value < 16 && (int)value > locals_count)                              return (1);                      }                      break;                    case tx_h.NUMBER:                      if (!decode.first_pass)                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.PROPNUM:                      if (!decode.first_pass)                          if (symbols.print_property_name(property_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.ATTRNUM:                      if (!decode.first_pass)                          if (symbols.print_attribute_name(attr_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.LOW_ADDR:                      if (!decode.first_pass)                      {                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ROUTINE:                      addr = (ulong)txio.code_scaler * value + (ulong)header.routines_offset * txio.story_scaler;                      if (!decode.first_pass)                      {                          if (option_labels > 0)                              if (value != 0)                              {                                  routine = lookup_routine(addr' 0);                                  if (routine != 0)                                      txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'r' : 'R'' routine);                                  else                                  {                                      Console.Error.Write("\nWarning: found call to nonexistent routine!\n");                                      txio.tx_printf("{0:X}"' addr);                                  }                              }                              else                                  print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          else                              txio.tx_printf("{0:X}"' addr);                      }                      else                      {                          if (addr < decode.low_address &&                              addr >= code_base)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.low_address = addr - 1;                          }                          if (addr > decode.high_address &&                              addr < (ulong)txio.file_size)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.high_address = addr - 1;                          }                      }                      break;                    case tx_h.OBJECT:                      if (!decode.first_pass)                      {                          // if (value == 0 || showobj.print_object_desc ((int)value) == 0) // TODO I don't like this section                          if (value == 0)                          {                              showobj.print_object_desc((int)value);                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          }                      }                      break;                    case tx_h.STATIC:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s != 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' (int)s);                          else                          {  #if !TXD_DEBUG                              Console.Error.WriteLine("\nWarning: printing of nonexistent string\n");  #endif                              txio.tx_printf("{0:X}"' addr);                          }                      }                      break;                    case tx_h.LABEL:                      addr = decode.pc + (ulong)(short)value - 2; // TODO Check this math somehow                      if (decode.first_pass && addr < decode.low_address)                          return (1);                      if (option_labels > 0)                      {                          if (decode.first_pass)                              add_label(addr);                          else                              txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'l' : 'L'' lookup_label(addr' 1));                      }                      else                      {                          if (!decode.first_pass)                              txio.tx_printf("{0:X}"' addr);                      }                      if (addr > decode.high_pc)                          decode.high_pc = addr;                      break;                    case tx_h.PCHAR:                      if (!decode.first_pass)                          if (isprint((char)value))                              txio.tx_printf("\'{0}\'"' (char)value);                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.VATTR:                      if (!decode.first_pass)                      {                          if (value == tx_h.ROMAN)                              txio.tx_printf("{0}"' (txio.option_inform) ? "roman" : "ROMAN");                          else if (value == tx_h.REVERSE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "reverse" : "REVERSE");                          else if (value == tx_h.BOLDFACE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "boldface" : "BOLDFACE");                          else if (value == tx_h.EMPHASIS)                              txio.tx_printf("{0}"' (txio.option_inform) ? "emphasis" : "EMPHASIS");                          else if (value == tx_h.FIXED_FONT)                              txio.tx_printf("{0}"' (txio.option_inform) ? "fixed_font" : "FIXED_FONT");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.PATTR:                      if (!decode.first_pass)                      {                          if ((int)value == 1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_enable" : "OUTPUT_ENABLE");                          else if ((int)value == 2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_enable" : "SCRIPTING_ENABLE");                          else if ((int)value == 3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_enable" : "REDIRECT_ENABLE");                          else if ((int)value == 4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_enable" : "RECORD_ENABLE");                          else if ((int)value == -1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_disable" : "OUTPUT_DISABLE");                          else if ((int)value == -2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_disable" : "SCRIPTING_DISABLE");                          else if ((int)value == -3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_disable" : "REDIRECT_DISABLE");                          else if ((int)value == -4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_disable" : "RECORD_DISABLE");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.INDIRECT:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("[{0}]"' (txio.option_inform) ? "sp" : "(SP)+");                          else                          {                              txio.tx_printf("[");                              print_variable(value);                              txio.tx_printf("]");                          }                      }                      break;                    default:                      throw new ArgumentException(String.Format("\nFatal: bad operand type ({0})\n"' (int)par));              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameter,The following statement contains a magic number: switch (par)              {                    case tx_h.NIL:                      if (!decode.first_pass)                      {                          Console.Error.Write("\nWarning: Unexpected Parameter #{0} near {1:X5}\n"' opers' decode.pc);                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ANYTHING:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s > 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' s);                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              if (s > 0)                                  txio.tx_printf(" {0} "' (txio.option_inform) ? "or" : "OR");                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          if (dictionary == 0 && s == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.VAR:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("{0}"' (txio.option_inform) ? "sp" : "(SP)+");                          else                              print_variable(value);                      }                      else                      {                          if ((int)value > 0 && (int)value < 16 && (int)value > locals_count)                              return (1);                      }                      break;                    case tx_h.NUMBER:                      if (!decode.first_pass)                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.PROPNUM:                      if (!decode.first_pass)                          if (symbols.print_property_name(property_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.ATTRNUM:                      if (!decode.first_pass)                          if (symbols.print_attribute_name(attr_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.LOW_ADDR:                      if (!decode.first_pass)                      {                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ROUTINE:                      addr = (ulong)txio.code_scaler * value + (ulong)header.routines_offset * txio.story_scaler;                      if (!decode.first_pass)                      {                          if (option_labels > 0)                              if (value != 0)                              {                                  routine = lookup_routine(addr' 0);                                  if (routine != 0)                                      txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'r' : 'R'' routine);                                  else                                  {                                      Console.Error.Write("\nWarning: found call to nonexistent routine!\n");                                      txio.tx_printf("{0:X}"' addr);                                  }                              }                              else                                  print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          else                              txio.tx_printf("{0:X}"' addr);                      }                      else                      {                          if (addr < decode.low_address &&                              addr >= code_base)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.low_address = addr - 1;                          }                          if (addr > decode.high_address &&                              addr < (ulong)txio.file_size)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.high_address = addr - 1;                          }                      }                      break;                    case tx_h.OBJECT:                      if (!decode.first_pass)                      {                          // if (value == 0 || showobj.print_object_desc ((int)value) == 0) // TODO I don't like this section                          if (value == 0)                          {                              showobj.print_object_desc((int)value);                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          }                      }                      break;                    case tx_h.STATIC:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s != 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' (int)s);                          else                          {  #if !TXD_DEBUG                              Console.Error.WriteLine("\nWarning: printing of nonexistent string\n");  #endif                              txio.tx_printf("{0:X}"' addr);                          }                      }                      break;                    case tx_h.LABEL:                      addr = decode.pc + (ulong)(short)value - 2; // TODO Check this math somehow                      if (decode.first_pass && addr < decode.low_address)                          return (1);                      if (option_labels > 0)                      {                          if (decode.first_pass)                              add_label(addr);                          else                              txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'l' : 'L'' lookup_label(addr' 1));                      }                      else                      {                          if (!decode.first_pass)                              txio.tx_printf("{0:X}"' addr);                      }                      if (addr > decode.high_pc)                          decode.high_pc = addr;                      break;                    case tx_h.PCHAR:                      if (!decode.first_pass)                          if (isprint((char)value))                              txio.tx_printf("\'{0}\'"' (char)value);                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.VATTR:                      if (!decode.first_pass)                      {                          if (value == tx_h.ROMAN)                              txio.tx_printf("{0}"' (txio.option_inform) ? "roman" : "ROMAN");                          else if (value == tx_h.REVERSE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "reverse" : "REVERSE");                          else if (value == tx_h.BOLDFACE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "boldface" : "BOLDFACE");                          else if (value == tx_h.EMPHASIS)                              txio.tx_printf("{0}"' (txio.option_inform) ? "emphasis" : "EMPHASIS");                          else if (value == tx_h.FIXED_FONT)                              txio.tx_printf("{0}"' (txio.option_inform) ? "fixed_font" : "FIXED_FONT");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.PATTR:                      if (!decode.first_pass)                      {                          if ((int)value == 1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_enable" : "OUTPUT_ENABLE");                          else if ((int)value == 2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_enable" : "SCRIPTING_ENABLE");                          else if ((int)value == 3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_enable" : "REDIRECT_ENABLE");                          else if ((int)value == 4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_enable" : "RECORD_ENABLE");                          else if ((int)value == -1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_disable" : "OUTPUT_DISABLE");                          else if ((int)value == -2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_disable" : "SCRIPTING_DISABLE");                          else if ((int)value == -3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_disable" : "REDIRECT_DISABLE");                          else if ((int)value == -4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_disable" : "RECORD_DISABLE");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.INDIRECT:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("[{0}]"' (txio.option_inform) ? "sp" : "(SP)+");                          else                          {                              txio.tx_printf("[");                              print_variable(value);                              txio.tx_printf("]");                          }                      }                      break;                    default:                      throw new ArgumentException(String.Format("\nFatal: bad operand type ({0})\n"' (int)par));              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameter,The following statement contains a magic number: switch (par)              {                    case tx_h.NIL:                      if (!decode.first_pass)                      {                          Console.Error.Write("\nWarning: Unexpected Parameter #{0} near {1:X5}\n"' opers' decode.pc);                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ANYTHING:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s > 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' s);                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              if (s > 0)                                  txio.tx_printf(" {0} "' (txio.option_inform) ? "or" : "OR");                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          if (dictionary == 0 && s == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.VAR:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("{0}"' (txio.option_inform) ? "sp" : "(SP)+");                          else                              print_variable(value);                      }                      else                      {                          if ((int)value > 0 && (int)value < 16 && (int)value > locals_count)                              return (1);                      }                      break;                    case tx_h.NUMBER:                      if (!decode.first_pass)                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.PROPNUM:                      if (!decode.first_pass)                          if (symbols.print_property_name(property_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.ATTRNUM:                      if (!decode.first_pass)                          if (symbols.print_attribute_name(attr_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.LOW_ADDR:                      if (!decode.first_pass)                      {                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ROUTINE:                      addr = (ulong)txio.code_scaler * value + (ulong)header.routines_offset * txio.story_scaler;                      if (!decode.first_pass)                      {                          if (option_labels > 0)                              if (value != 0)                              {                                  routine = lookup_routine(addr' 0);                                  if (routine != 0)                                      txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'r' : 'R'' routine);                                  else                                  {                                      Console.Error.Write("\nWarning: found call to nonexistent routine!\n");                                      txio.tx_printf("{0:X}"' addr);                                  }                              }                              else                                  print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          else                              txio.tx_printf("{0:X}"' addr);                      }                      else                      {                          if (addr < decode.low_address &&                              addr >= code_base)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.low_address = addr - 1;                          }                          if (addr > decode.high_address &&                              addr < (ulong)txio.file_size)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.high_address = addr - 1;                          }                      }                      break;                    case tx_h.OBJECT:                      if (!decode.first_pass)                      {                          // if (value == 0 || showobj.print_object_desc ((int)value) == 0) // TODO I don't like this section                          if (value == 0)                          {                              showobj.print_object_desc((int)value);                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          }                      }                      break;                    case tx_h.STATIC:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s != 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' (int)s);                          else                          {  #if !TXD_DEBUG                              Console.Error.WriteLine("\nWarning: printing of nonexistent string\n");  #endif                              txio.tx_printf("{0:X}"' addr);                          }                      }                      break;                    case tx_h.LABEL:                      addr = decode.pc + (ulong)(short)value - 2; // TODO Check this math somehow                      if (decode.first_pass && addr < decode.low_address)                          return (1);                      if (option_labels > 0)                      {                          if (decode.first_pass)                              add_label(addr);                          else                              txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'l' : 'L'' lookup_label(addr' 1));                      }                      else                      {                          if (!decode.first_pass)                              txio.tx_printf("{0:X}"' addr);                      }                      if (addr > decode.high_pc)                          decode.high_pc = addr;                      break;                    case tx_h.PCHAR:                      if (!decode.first_pass)                          if (isprint((char)value))                              txio.tx_printf("\'{0}\'"' (char)value);                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.VATTR:                      if (!decode.first_pass)                      {                          if (value == tx_h.ROMAN)                              txio.tx_printf("{0}"' (txio.option_inform) ? "roman" : "ROMAN");                          else if (value == tx_h.REVERSE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "reverse" : "REVERSE");                          else if (value == tx_h.BOLDFACE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "boldface" : "BOLDFACE");                          else if (value == tx_h.EMPHASIS)                              txio.tx_printf("{0}"' (txio.option_inform) ? "emphasis" : "EMPHASIS");                          else if (value == tx_h.FIXED_FONT)                              txio.tx_printf("{0}"' (txio.option_inform) ? "fixed_font" : "FIXED_FONT");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.PATTR:                      if (!decode.first_pass)                      {                          if ((int)value == 1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_enable" : "OUTPUT_ENABLE");                          else if ((int)value == 2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_enable" : "SCRIPTING_ENABLE");                          else if ((int)value == 3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_enable" : "REDIRECT_ENABLE");                          else if ((int)value == 4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_enable" : "RECORD_ENABLE");                          else if ((int)value == -1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_disable" : "OUTPUT_DISABLE");                          else if ((int)value == -2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_disable" : "SCRIPTING_DISABLE");                          else if ((int)value == -3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_disable" : "REDIRECT_DISABLE");                          else if ((int)value == -4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_disable" : "RECORD_DISABLE");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.INDIRECT:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("[{0}]"' (txio.option_inform) ? "sp" : "(SP)+");                          else                          {                              txio.tx_printf("[");                              print_variable(value);                              txio.tx_printf("]");                          }                      }                      break;                    default:                      throw new ArgumentException(String.Format("\nFatal: bad operand type ({0})\n"' (int)par));              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_parameter,The following statement contains a magic number: switch (par)              {                    case tx_h.NIL:                      if (!decode.first_pass)                      {                          Console.Error.Write("\nWarning: Unexpected Parameter #{0} near {1:X5}\n"' opers' decode.pc);                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ANYTHING:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s > 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' s);                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              if (s > 0)                                  txio.tx_printf(" {0} "' (txio.option_inform) ? "or" : "OR");                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          if (dictionary == 0 && s == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.VAR:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("{0}"' (txio.option_inform) ? "sp" : "(SP)+");                          else                              print_variable(value);                      }                      else                      {                          if ((int)value > 0 && (int)value < 16 && (int)value > locals_count)                              return (1);                      }                      break;                    case tx_h.NUMBER:                      if (!decode.first_pass)                          print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.PROPNUM:                      if (!decode.first_pass)                          if (symbols.print_property_name(property_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.ATTRNUM:                      if (!decode.first_pass)                          if (symbols.print_attribute_name(attr_names_base' (int)value) == 0)                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.LOW_ADDR:                      if (!decode.first_pass)                      {                          addr = (ulong)value;                          dictionary = in_dictionary(addr);                          if (dictionary > 0)                          {                              txio.tx_printf("\"");                              txio.decode_text(ref addr);                              txio.tx_printf("\"");                          }                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.ROUTINE:                      addr = (ulong)txio.code_scaler * value + (ulong)header.routines_offset * txio.story_scaler;                      if (!decode.first_pass)                      {                          if (option_labels > 0)                              if (value != 0)                              {                                  routine = lookup_routine(addr' 0);                                  if (routine != 0)                                      txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'r' : 'R'' routine);                                  else                                  {                                      Console.Error.Write("\nWarning: found call to nonexistent routine!\n");                                      txio.tx_printf("{0:X}"' addr);                                  }                              }                              else                                  print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          else                              txio.tx_printf("{0:X}"' addr);                      }                      else                      {                          if (addr < decode.low_address &&                              addr >= code_base)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.low_address = addr - 1;                          }                          if (addr > decode.high_address &&                              addr < (ulong)txio.file_size)                          {                              vars = txio.read_data_byte(ref addr);                              if (vars >= 0 && vars <= 15)                                  decode.high_address = addr - 1;                          }                      }                      break;                    case tx_h.OBJECT:                      if (!decode.first_pass)                      {                          // if (value == 0 || showobj.print_object_desc ((int)value) == 0) // TODO I don't like this section                          if (value == 0)                          {                              showobj.print_object_desc((int)value);                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                          }                      }                      break;                    case tx_h.STATIC:                      if (!decode.first_pass)                      {                          addr = (ulong)txio.code_scaler * value + (ulong)txio.story_scaler * header.strings_offset;                          s = lookup_string(addr);                          if (s != 0)                              txio.tx_printf("{0}{1'3:d}"' (txio.option_inform) ? 's' : 'S'' (int)s);                          else                          {  #if !TXD_DEBUG                              Console.Error.WriteLine("\nWarning: printing of nonexistent string\n");  #endif                              txio.tx_printf("{0:X}"' addr);                          }                      }                      break;                    case tx_h.LABEL:                      addr = decode.pc + (ulong)(short)value - 2; // TODO Check this math somehow                      if (decode.first_pass && addr < decode.low_address)                          return (1);                      if (option_labels > 0)                      {                          if (decode.first_pass)                              add_label(addr);                          else                              txio.tx_printf("{0}{1'4:d}"' (txio.option_inform) ? 'l' : 'L'' lookup_label(addr' 1));                      }                      else                      {                          if (!decode.first_pass)                              txio.tx_printf("{0:X}"' addr);                      }                      if (addr > decode.high_pc)                          decode.high_pc = addr;                      break;                    case tx_h.PCHAR:                      if (!decode.first_pass)                          if (isprint((char)value))                              txio.tx_printf("\'{0}\'"' (char)value);                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      break;                    case tx_h.VATTR:                      if (!decode.first_pass)                      {                          if (value == tx_h.ROMAN)                              txio.tx_printf("{0}"' (txio.option_inform) ? "roman" : "ROMAN");                          else if (value == tx_h.REVERSE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "reverse" : "REVERSE");                          else if (value == tx_h.BOLDFACE)                              txio.tx_printf("{0}"' (txio.option_inform) ? "boldface" : "BOLDFACE");                          else if (value == tx_h.EMPHASIS)                              txio.tx_printf("{0}"' (txio.option_inform) ? "emphasis" : "EMPHASIS");                          else if (value == tx_h.FIXED_FONT)                              txio.tx_printf("{0}"' (txio.option_inform) ? "fixed_font" : "FIXED_FONT");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.PATTR:                      if (!decode.first_pass)                      {                          if ((int)value == 1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_enable" : "OUTPUT_ENABLE");                          else if ((int)value == 2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_enable" : "SCRIPTING_ENABLE");                          else if ((int)value == 3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_enable" : "REDIRECT_ENABLE");                          else if ((int)value == 4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_enable" : "RECORD_ENABLE");                          else if ((int)value == -1)                              txio.tx_printf("{0}"' (txio.option_inform) ? "output_disable" : "OUTPUT_DISABLE");                          else if ((int)value == -2)                              txio.tx_printf("{0}"' (txio.option_inform) ? "scripting_disable" : "SCRIPTING_DISABLE");                          else if ((int)value == -3)                              txio.tx_printf("{0}"' (txio.option_inform) ? "redirect_disable" : "REDIRECT_DISABLE");                          else if ((int)value == -4)                              txio.tx_printf("{0}"' (txio.option_inform) ? "record_disable" : "RECORD_DISABLE");                          else                              print_integer(value' addr_mode == tx_h.BYTE_IMMED);                      }                      break;                    case tx_h.INDIRECT:                      if (!decode.first_pass)                      {                          if (value == 0)                              txio.tx_printf("[{0}]"' (txio.option_inform) ? "sp" : "(SP)+");                          else                          {                              txio.tx_printf("[");                              print_variable(value);                              txio.tx_printf("]");                          }                      }                      break;                    default:                      throw new ArgumentException(String.Format("\nFatal: bad operand type ({0})\n"' (int)par));              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_extra,The following statement contains a magic number: if (opcode.extra == tx_h.STORE || opcode.extra == tx_h.BOTH)              {                  addr = (zbyte_t)txio.read_data_byte(ref decode.pc);                  if (!decode.first_pass)                  {                      if (!txio.option_inform) // || (txio.option_inform >= 6))                          txio.tx_printf("-> ");                      if (addr == 0)                          txio.tx_printf("{0}"' (txio.option_inform) ? "sp" : "-(SP)");                      else                          print_variable((uint)addr);                        if (opcode.extra == tx_h.BOTH)                          txio.tx_printf(" ");                  }                  else                  {                      if (addr > 0 && addr < 16 && addr > (ulong)locals_count)                          return (tx_h.BAD_OPCODE);                  }              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_extra,The following statement contains a magic number: if (opcode.extra == tx_h.BRANCH || opcode.extra == tx_h.BOTH)              {                  addr = firstbyte = (zbyte_t)txio.read_data_byte(ref decode.pc);                  addr &= 0x7f;                  if ((addr & 0x40) > 0)                      addr &= 0x3f;                  else                  {                      addr = (addr << 8) | (ulong)txio.read_data_byte(ref decode.pc);                      if ((addr & 0x2000) > 0)                      {                          addr &= 0x1fff;                          unchecked                          {                              addr |= (ulong)~0x1fff; // TODO Is there a better way to handle this?                          }                      }                  }                  if (!decode.first_pass)                  {                      if ((addr > 1) && (firstbyte & 0x40) == 0 && (txio.option_inform) && (option_labels > 0)) // TODO Option_inform >= 6                      {                          txio.tx_printf("?");	/* Inform 6 long branch */                      }                      if ((firstbyte & 0x80) > 0)                          txio.tx_printf("{0}"' (txio.option_inform) ? "" : "[TRUE]");                      else                          txio.tx_printf("{0}"' (txio.option_inform) ? "~" : "[FALSE]");                  }                  if (addr == 0)                  {                      if (!decode.first_pass)                          txio.tx_printf("{0}"' (txio.option_inform) ? "rfalse" : " RFALSE");                  }                  else if (addr == 1)                  {                      if (!decode.first_pass)                          txio.tx_printf("{0}"' (txio.option_inform) ? "rtrue" : " RTRUE");                  }                  else                  {                      addr = decode.pc + addr - 2;                      if (decode.first_pass && addr < start_of_routine)                          return (tx_h.BAD_OPCODE);                      if (option_labels > 0)                      {                          if (decode.first_pass)                              add_label(addr);                          else                              txio.tx_printf("{0}{1:d4}"' (txio.option_inform) ? "l" : " L"' (int)lookup_label(addr' 1));                      }                      else                      {                          if (!decode.first_pass)                              txio.tx_printf("{0}{1:X}"' (txio.option_inform) ? "" : " "' (ulong)addr);                      }                      if (addr > decode.high_pc)                          decode.high_pc = addr;                  }              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_extra,The following statement contains a magic number: if (opcode.extra == tx_h.BRANCH || opcode.extra == tx_h.BOTH)              {                  addr = firstbyte = (zbyte_t)txio.read_data_byte(ref decode.pc);                  addr &= 0x7f;                  if ((addr & 0x40) > 0)                      addr &= 0x3f;                  else                  {                      addr = (addr << 8) | (ulong)txio.read_data_byte(ref decode.pc);                      if ((addr & 0x2000) > 0)                      {                          addr &= 0x1fff;                          unchecked                          {                              addr |= (ulong)~0x1fff; // TODO Is there a better way to handle this?                          }                      }                  }                  if (!decode.first_pass)                  {                      if ((addr > 1) && (firstbyte & 0x40) == 0 && (txio.option_inform) && (option_labels > 0)) // TODO Option_inform >= 6                      {                          txio.tx_printf("?");	/* Inform 6 long branch */                      }                      if ((firstbyte & 0x80) > 0)                          txio.tx_printf("{0}"' (txio.option_inform) ? "" : "[TRUE]");                      else                          txio.tx_printf("{0}"' (txio.option_inform) ? "~" : "[FALSE]");                  }                  if (addr == 0)                  {                      if (!decode.first_pass)                          txio.tx_printf("{0}"' (txio.option_inform) ? "rfalse" : " RFALSE");                  }                  else if (addr == 1)                  {                      if (!decode.first_pass)                          txio.tx_printf("{0}"' (txio.option_inform) ? "rtrue" : " RTRUE");                  }                  else                  {                      addr = decode.pc + addr - 2;                      if (decode.first_pass && addr < start_of_routine)                          return (tx_h.BAD_OPCODE);                      if (option_labels > 0)                      {                          if (decode.first_pass)                              add_label(addr);                          else                              txio.tx_printf("{0}{1:d4}"' (txio.option_inform) ? "l" : " L"' (int)lookup_label(addr' 1));                      }                      else                      {                          if (!decode.first_pass)                              txio.tx_printf("{0}{1:X}"' (txio.option_inform) ? "" : " "' (ulong)addr);                      }                      if (addr > decode.high_pc)                          decode.high_pc = addr;                  }              }
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,print_variable,The following statement contains a magic number: if (varnum < 16)              {                  if (option_symbols > 0 && symbols.print_local_name(start_of_routine' (int)(varnum - 1)) > 0) /* null */                  { }                  else if (txio.option_inform)                      txio.tx_printf("local{0}"' varnum - 1);                  else                      txio.tx_printf("L{0:X2}"' varnum - 1);              }              else                  if (option_symbols > 0 && symbols.print_global_name(start_of_routine' (int)(varnum - 16)) > 0) /* null */{ }                  else txio.tx_printf("{0}{1:X2}"' (txio.option_inform) ? 'g' : 'G'' varnum - 16);
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,print_variable,The following statement contains a magic number: if (varnum < 16)              {                  if (option_symbols > 0 && symbols.print_local_name(start_of_routine' (int)(varnum - 1)) > 0) /* null */                  { }                  else if (txio.option_inform)                      txio.tx_printf("local{0}"' varnum - 1);                  else                      txio.tx_printf("L{0:X2}"' varnum - 1);              }              else                  if (option_symbols > 0 && symbols.print_global_name(start_of_routine' (int)(varnum - 16)) > 0) /* null */{ }                  else txio.tx_printf("{0}{1:X2}"' (txio.option_inform) ? 'g' : 'G'' varnum - 16);
Magic Number,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,print_variable,The following statement contains a magic number: if (varnum < 16)              {                  if (option_symbols > 0 && symbols.print_local_name(start_of_routine' (int)(varnum - 1)) > 0) /* null */                  { }                  else if (txio.option_inform)                      txio.tx_printf("local{0}"' varnum - 1);                  else                      txio.tx_printf("L{0:X2}"' varnum - 1);              }              else                  if (option_symbols > 0 && symbols.print_global_name(start_of_routine' (int)(varnum - 16)) > 0) /* null */{ }                  else txio.tx_printf("{0}{1:X2}"' (txio.option_inform) ? 'g' : 'G'' varnum - 16);
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,txio,The following statement contains a magic number: lookup_table = new char[3' 26];
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,txio,The following statement contains a magic number: lookup_table = new char[3' 26];
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,configure,The following statement contains a magic number: if ((uint)header.version < tx_h.V4)              {                  story_scaler = 2;                  story_shift = 1;                  code_scaler = 2;                  code_shift = 1;                  property_mask = tx_h.P3_MAX_PROPERTIES - 1;                  property_size_mask = 0xe0;              }              else if ((uint)header.version < tx_h.V6)              {                  story_scaler = 4;                  story_shift = 2;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else if ((uint)header.version < tx_h.V8)              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 8;                  code_shift = 3;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,configure,The following statement contains a magic number: if ((uint)header.version < tx_h.V4)              {                  story_scaler = 2;                  story_shift = 1;                  code_scaler = 2;                  code_shift = 1;                  property_mask = tx_h.P3_MAX_PROPERTIES - 1;                  property_size_mask = 0xe0;              }              else if ((uint)header.version < tx_h.V6)              {                  story_scaler = 4;                  story_shift = 2;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else if ((uint)header.version < tx_h.V8)              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 8;                  code_shift = 3;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,configure,The following statement contains a magic number: if ((uint)header.version < tx_h.V4)              {                  story_scaler = 2;                  story_shift = 1;                  code_scaler = 2;                  code_shift = 1;                  property_mask = tx_h.P3_MAX_PROPERTIES - 1;                  property_size_mask = 0xe0;              }              else if ((uint)header.version < tx_h.V6)              {                  story_scaler = 4;                  story_shift = 2;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else if ((uint)header.version < tx_h.V8)              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 8;                  code_shift = 3;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,configure,The following statement contains a magic number: if ((uint)header.version < tx_h.V4)              {                  story_scaler = 2;                  story_shift = 1;                  code_scaler = 2;                  code_shift = 1;                  property_mask = tx_h.P3_MAX_PROPERTIES - 1;                  property_size_mask = 0xe0;              }              else if ((uint)header.version < tx_h.V6)              {                  story_scaler = 4;                  story_shift = 2;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else if ((uint)header.version < tx_h.V8)              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 8;                  code_shift = 3;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,configure,The following statement contains a magic number: if ((uint)header.version < tx_h.V4)              {                  story_scaler = 2;                  story_shift = 1;                  code_scaler = 2;                  code_shift = 1;                  property_mask = tx_h.P3_MAX_PROPERTIES - 1;                  property_size_mask = 0xe0;              }              else if ((uint)header.version < tx_h.V6)              {                  story_scaler = 4;                  story_shift = 2;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else if ((uint)header.version < tx_h.V8)              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 8;                  code_shift = 3;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,configure,The following statement contains a magic number: if ((uint)header.version < tx_h.V4)              {                  story_scaler = 2;                  story_shift = 1;                  code_scaler = 2;                  code_shift = 1;                  property_mask = tx_h.P3_MAX_PROPERTIES - 1;                  property_size_mask = 0xe0;              }              else if ((uint)header.version < tx_h.V6)              {                  story_scaler = 4;                  story_shift = 2;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else if ((uint)header.version < tx_h.V8)              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 8;                  code_shift = 3;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,configure,The following statement contains a magic number: if ((uint)header.version < tx_h.V4)              {                  story_scaler = 2;                  story_shift = 1;                  code_scaler = 2;                  code_shift = 1;                  property_mask = tx_h.P3_MAX_PROPERTIES - 1;                  property_size_mask = 0xe0;              }              else if ((uint)header.version < tx_h.V6)              {                  story_scaler = 4;                  story_shift = 2;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else if ((uint)header.version < tx_h.V8)              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 8;                  code_shift = 3;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,configure,The following statement contains a magic number: if ((uint)header.version < tx_h.V4)              {                  story_scaler = 2;                  story_shift = 1;                  code_scaler = 2;                  code_shift = 1;                  property_mask = tx_h.P3_MAX_PROPERTIES - 1;                  property_size_mask = 0xe0;              }              else if ((uint)header.version < tx_h.V6)              {                  story_scaler = 4;                  story_shift = 2;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else if ((uint)header.version < tx_h.V8)              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 8;                  code_shift = 3;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,configure,The following statement contains a magic number: if ((uint)header.version < tx_h.V4)              {                  story_scaler = 2;                  story_shift = 1;                  code_scaler = 2;                  code_shift = 1;                  property_mask = tx_h.P3_MAX_PROPERTIES - 1;                  property_size_mask = 0xe0;              }              else if ((uint)header.version < tx_h.V6)              {                  story_scaler = 4;                  story_shift = 2;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else if ((uint)header.version < tx_h.V8)              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 8;                  code_shift = 3;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,configure,The following statement contains a magic number: if ((uint)header.version < tx_h.V4)              {                  story_scaler = 2;                  story_shift = 1;                  code_scaler = 2;                  code_shift = 1;                  property_mask = tx_h.P3_MAX_PROPERTIES - 1;                  property_size_mask = 0xe0;              }              else if ((uint)header.version < tx_h.V6)              {                  story_scaler = 4;                  story_shift = 2;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else if ((uint)header.version < tx_h.V8)              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 8;                  code_shift = 3;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,configure,The following statement contains a magic number: if ((uint)header.version < tx_h.V4)              {                  story_scaler = 2;                  story_shift = 1;                  code_scaler = 2;                  code_shift = 1;                  property_mask = tx_h.P3_MAX_PROPERTIES - 1;                  property_size_mask = 0xe0;              }              else if ((uint)header.version < tx_h.V6)              {                  story_scaler = 4;                  story_shift = 2;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else if ((uint)header.version < tx_h.V8)              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 8;                  code_shift = 3;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,configure,The following statement contains a magic number: if ((uint)header.version < tx_h.V4)              {                  story_scaler = 2;                  story_shift = 1;                  code_scaler = 2;                  code_shift = 1;                  property_mask = tx_h.P3_MAX_PROPERTIES - 1;                  property_size_mask = 0xe0;              }              else if ((uint)header.version < tx_h.V6)              {                  story_scaler = 4;                  story_shift = 2;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else if ((uint)header.version < tx_h.V8)              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 8;                  code_shift = 3;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,configure,The following statement contains a magic number: if ((uint)header.version < tx_h.V4)              {                  story_scaler = 2;                  story_shift = 1;                  code_scaler = 2;                  code_shift = 1;                  property_mask = tx_h.P3_MAX_PROPERTIES - 1;                  property_size_mask = 0xe0;              }              else if ((uint)header.version < tx_h.V6)              {                  story_scaler = 4;                  story_shift = 2;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else if ((uint)header.version < tx_h.V8)              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 8;                  code_shift = 3;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,configure,The following statement contains a magic number: if ((uint)header.version < tx_h.V4)              {                  story_scaler = 2;                  story_shift = 1;                  code_scaler = 2;                  code_shift = 1;                  property_mask = tx_h.P3_MAX_PROPERTIES - 1;                  property_size_mask = 0xe0;              }              else if ((uint)header.version < tx_h.V6)              {                  story_scaler = 4;                  story_shift = 2;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else if ((uint)header.version < tx_h.V8)              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 4;                  code_shift = 2;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }              else              {                  story_scaler = 8;                  story_shift = 3;                  code_scaler = 8;                  code_shift = 3;                  property_mask = tx_h.P4_MAX_PROPERTIES - 1;                  property_size_mask = 0x3f;              }
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,configure,The following statement contains a magic number: if ((uint)header.file_size == 0)              {                  throw new ArgumentException("Can't handle files with no length. Giving up!");                  // file_size = get_story_size();              }              else if ((uint)header.version <= tx_h.V3)                  file_size = header.file_size * 2;              else if ((uint)header.version <= tx_h.V5)                  file_size = header.file_size * 4;              else                  file_size = header.file_size * 8;
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,configure,The following statement contains a magic number: if ((uint)header.file_size == 0)              {                  throw new ArgumentException("Can't handle files with no length. Giving up!");                  // file_size = get_story_size();              }              else if ((uint)header.version <= tx_h.V3)                  file_size = header.file_size * 2;              else if ((uint)header.version <= tx_h.V5)                  file_size = header.file_size * 4;              else                  file_size = header.file_size * 8;
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,configure,The following statement contains a magic number: if ((uint)header.file_size == 0)              {                  throw new ArgumentException("Can't handle files with no length. Giving up!");                  // file_size = get_story_size();              }              else if ((uint)header.version <= tx_h.V3)                  file_size = header.file_size * 2;              else if ((uint)header.version <= tx_h.V5)                  file_size = header.file_size * 4;              else                  file_size = header.file_size * 8;
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,read_page,The following statement contains a magic number: if (file_size == 0)                  bytes_to_read = 64;              else if (page != (uint)(file_size / tx_h.PAGE_SIZE))                  bytes_to_read = tx_h.PAGE_SIZE;              else                  bytes_to_read = (int)(file_size & tx_h.PAGE_MASK);
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,read_data_word,The following statement contains a magic number: w = (uint)read_data_byte(ref addr) << 8;
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The following statement contains a magic number: if (lookup_table_loaded == 0)              {                  for (i = 0; i < 3; i++)                  {                      for (j = 0; j < 26; j++)                      {                          if ((uint)header.alphabet > 0)                          {                              lookup_table[i' j] = (char)tx_h.get_byte(txio.header.alphabet + (i * 26) + j);                          }                          else                          {                              if ((uint)txio.header.version == tx_h.V1)                                  lookup_table[i' j] = v1_lookup_table[i][j];                              else                                  lookup_table[i' j] = v3_lookup_table[i][j];                          }                            if (option_inform && lookup_table[i' j] == '\"')                          {                              lookup_table[i' j] = '~';                          }                      }                      lookup_table_loaded = 1;                  }              }
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The following statement contains a magic number: if (lookup_table_loaded == 0)              {                  for (i = 0; i < 3; i++)                  {                      for (j = 0; j < 26; j++)                      {                          if ((uint)header.alphabet > 0)                          {                              lookup_table[i' j] = (char)tx_h.get_byte(txio.header.alphabet + (i * 26) + j);                          }                          else                          {                              if ((uint)txio.header.version == tx_h.V1)                                  lookup_table[i' j] = v1_lookup_table[i][j];                              else                                  lookup_table[i' j] = v3_lookup_table[i][j];                          }                            if (option_inform && lookup_table[i' j] == '\"')                          {                              lookup_table[i' j] = '~';                          }                      }                      lookup_table_loaded = 1;                  }              }
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The following statement contains a magic number: if (lookup_table_loaded == 0)              {                  for (i = 0; i < 3; i++)                  {                      for (j = 0; j < 26; j++)                      {                          if ((uint)header.alphabet > 0)                          {                              lookup_table[i' j] = (char)tx_h.get_byte(txio.header.alphabet + (i * 26) + j);                          }                          else                          {                              if ((uint)txio.header.version == tx_h.V1)                                  lookup_table[i' j] = v1_lookup_table[i][j];                              else                                  lookup_table[i' j] = v3_lookup_table[i][j];                          }                            if (option_inform && lookup_table[i' j] == '\"')                          {                              lookup_table[i' j] = '~';                          }                      }                      lookup_table_loaded = 1;                  }              }
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The following statement contains a magic number: do              {                    /*                   * Read one 16 bit word. Each word contains three 5 bit codes. If the                   * high bit is set then this is the last word in the string.                   */                  data = txio.read_data_word(ref address);                    for (i = 10; i >= 0; i -= 5)                  {                      /* Get code' high bits first */                        code = (data >> i) & 0x1f;                        /* Synonym codes */                        if (synonym_flag > 0)                      {                            synonym_flag = 0;                          synonym = (synonym - 1) * 64;                          addr = (ulong)tx_h.get_word(header.abbreviations + synonym + (code * 2)) * 2;                          char_count += txio.decode_text(ref addr);                          shift_state = shift_lock;                            /* ASCII codes */                        }                      else if (ascii_flag > 0)                      {                            /*                           * If this is the first part ASCII code then remember it.                           * Because the codes are only 5 bits you need two codes to make                           * one eight bit ASCII character. The first code contains the                           * top 3 bits. The second code contains the bottom 5 bits.                           */                            if (ascii_flag++ == 1)                                ascii = code << 5;                            /*                           * If this is the second part ASCII code then assemble the                           * character from the two codes and output it.                           */                            else                          {                                ascii_flag = 0;                              txio.tx_printf("{0}"' (char)(ascii | code));                              char_count++;                            }                            /* Character codes */                        }                      else if (code > 5)                      {                            code -= 6;                            /*                           * If this is character 0 in the punctuation set then the next two                           * codes make an ASCII character.                           */                            if (shift_state == 2 && code == 0)                                ascii_flag = 1;                            /*                           * If this is character 1 in the punctuation set then this                           * is a new line.                           */                            else if (shift_state == 2 && code == 1 && (uint)header.version > tx_h.V1)                                txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                    /*                                   * This is a normal character so select it from the character                                   * table appropriate for the current shift state.                           */                            else                          {                                txio.tx_printf("{0}"' (char)lookup_table[shift_state' code]);                              char_count++;                            }                            shift_state = shift_lock;                            /* Special codes 0 to 5 */                        }                      else                      {                            /*                           * Space: 0                           *                           * Output a space character.                           *                           */                            if (code == 0)                          {                                txio.tx_printf(" ");                              char_count++;                            }                          else                          {                                /*                               * The use of the synonym and shift codes is the only difference between                               * the different versions.                               */                                if ((uint)header.version < tx_h.V3)                              {                                    /*                                   * Newline or synonym: 1                                   *                                   * Output a newline character or set synonym flag.                                   *                                   */                                    if (code == 1)                                  {                                        if ((uint)header.version == tx_h.V1)                                      {                                          txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                          char_count++;                                      }                                      else                                      {                                          synonym_flag = 1;                                          synonym = code;                                      }                                        /*                                       * Shift keys: 2' 3' 4 or 5                                       *                                       * Shift keys 2 & 3 only shift the next character and can be used regardless of                                       * the state of the shift lock. Shift keys 4 & 5 lock the shift until reset.                                       *                                       * The following code implements the the shift code state transitions:                                       *                                       *               +-------------+-------------+-------------+-------------+                                       *               |       Shift   State       |        Lock   State       |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | Code        |      2      |       3     |      4      |      5      |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | lowercase   | uppercase   | punctuation | uppercase   | punctuation |                                       * | uppercase   | punctuation | lowercase   | punctuation | lowercase   |                                       * | punctuation | lowercase   | uppercase   | lowercase   | uppercase   |                                       * +-------------+-------------+-------------+-------------+-------------+                                       *                                       */                                    }                                  else                                  {                                      if (code < 4)                                          shift_state = (shift_lock + code + 2) % 3;                                      else                                          shift_lock = shift_state = (shift_lock + code) % 3;                                  }                                }                              else                              {                                    /*                                   * Synonym table: 1' 2 or 3                                   *                                   * Selects which of three synonym tables the synonym                                   * code following in the next code is to use.                                   *                                   */                                    if (code < 4)                                  {                                        synonym_flag = 1;                                      synonym = code;                                      /*                                       * Shift key: 4 or 5                                       *                                       * Selects the shift state for the next character'                                       * either uppercase (4) or punctuation (5). The shift                                       * state automatically gets reset back to lowercase for                                       * V3+ games after the next character is output.                                       *                                       */                                    }                                  else                                  {                                      shift_state = code - 3;                                      shift_lock = 0;                                    }                              }                          }                      }                  }              } while ((data & 0x8000) == 0);
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The following statement contains a magic number: do              {                    /*                   * Read one 16 bit word. Each word contains three 5 bit codes. If the                   * high bit is set then this is the last word in the string.                   */                  data = txio.read_data_word(ref address);                    for (i = 10; i >= 0; i -= 5)                  {                      /* Get code' high bits first */                        code = (data >> i) & 0x1f;                        /* Synonym codes */                        if (synonym_flag > 0)                      {                            synonym_flag = 0;                          synonym = (synonym - 1) * 64;                          addr = (ulong)tx_h.get_word(header.abbreviations + synonym + (code * 2)) * 2;                          char_count += txio.decode_text(ref addr);                          shift_state = shift_lock;                            /* ASCII codes */                        }                      else if (ascii_flag > 0)                      {                            /*                           * If this is the first part ASCII code then remember it.                           * Because the codes are only 5 bits you need two codes to make                           * one eight bit ASCII character. The first code contains the                           * top 3 bits. The second code contains the bottom 5 bits.                           */                            if (ascii_flag++ == 1)                                ascii = code << 5;                            /*                           * If this is the second part ASCII code then assemble the                           * character from the two codes and output it.                           */                            else                          {                                ascii_flag = 0;                              txio.tx_printf("{0}"' (char)(ascii | code));                              char_count++;                            }                            /* Character codes */                        }                      else if (code > 5)                      {                            code -= 6;                            /*                           * If this is character 0 in the punctuation set then the next two                           * codes make an ASCII character.                           */                            if (shift_state == 2 && code == 0)                                ascii_flag = 1;                            /*                           * If this is character 1 in the punctuation set then this                           * is a new line.                           */                            else if (shift_state == 2 && code == 1 && (uint)header.version > tx_h.V1)                                txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                    /*                                   * This is a normal character so select it from the character                                   * table appropriate for the current shift state.                           */                            else                          {                                txio.tx_printf("{0}"' (char)lookup_table[shift_state' code]);                              char_count++;                            }                            shift_state = shift_lock;                            /* Special codes 0 to 5 */                        }                      else                      {                            /*                           * Space: 0                           *                           * Output a space character.                           *                           */                            if (code == 0)                          {                                txio.tx_printf(" ");                              char_count++;                            }                          else                          {                                /*                               * The use of the synonym and shift codes is the only difference between                               * the different versions.                               */                                if ((uint)header.version < tx_h.V3)                              {                                    /*                                   * Newline or synonym: 1                                   *                                   * Output a newline character or set synonym flag.                                   *                                   */                                    if (code == 1)                                  {                                        if ((uint)header.version == tx_h.V1)                                      {                                          txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                          char_count++;                                      }                                      else                                      {                                          synonym_flag = 1;                                          synonym = code;                                      }                                        /*                                       * Shift keys: 2' 3' 4 or 5                                       *                                       * Shift keys 2 & 3 only shift the next character and can be used regardless of                                       * the state of the shift lock. Shift keys 4 & 5 lock the shift until reset.                                       *                                       * The following code implements the the shift code state transitions:                                       *                                       *               +-------------+-------------+-------------+-------------+                                       *               |       Shift   State       |        Lock   State       |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | Code        |      2      |       3     |      4      |      5      |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | lowercase   | uppercase   | punctuation | uppercase   | punctuation |                                       * | uppercase   | punctuation | lowercase   | punctuation | lowercase   |                                       * | punctuation | lowercase   | uppercase   | lowercase   | uppercase   |                                       * +-------------+-------------+-------------+-------------+-------------+                                       *                                       */                                    }                                  else                                  {                                      if (code < 4)                                          shift_state = (shift_lock + code + 2) % 3;                                      else                                          shift_lock = shift_state = (shift_lock + code) % 3;                                  }                                }                              else                              {                                    /*                                   * Synonym table: 1' 2 or 3                                   *                                   * Selects which of three synonym tables the synonym                                   * code following in the next code is to use.                                   *                                   */                                    if (code < 4)                                  {                                        synonym_flag = 1;                                      synonym = code;                                      /*                                       * Shift key: 4 or 5                                       *                                       * Selects the shift state for the next character'                                       * either uppercase (4) or punctuation (5). The shift                                       * state automatically gets reset back to lowercase for                                       * V3+ games after the next character is output.                                       *                                       */                                    }                                  else                                  {                                      shift_state = code - 3;                                      shift_lock = 0;                                    }                              }                          }                      }                  }              } while ((data & 0x8000) == 0);
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The following statement contains a magic number: do              {                    /*                   * Read one 16 bit word. Each word contains three 5 bit codes. If the                   * high bit is set then this is the last word in the string.                   */                  data = txio.read_data_word(ref address);                    for (i = 10; i >= 0; i -= 5)                  {                      /* Get code' high bits first */                        code = (data >> i) & 0x1f;                        /* Synonym codes */                        if (synonym_flag > 0)                      {                            synonym_flag = 0;                          synonym = (synonym - 1) * 64;                          addr = (ulong)tx_h.get_word(header.abbreviations + synonym + (code * 2)) * 2;                          char_count += txio.decode_text(ref addr);                          shift_state = shift_lock;                            /* ASCII codes */                        }                      else if (ascii_flag > 0)                      {                            /*                           * If this is the first part ASCII code then remember it.                           * Because the codes are only 5 bits you need two codes to make                           * one eight bit ASCII character. The first code contains the                           * top 3 bits. The second code contains the bottom 5 bits.                           */                            if (ascii_flag++ == 1)                                ascii = code << 5;                            /*                           * If this is the second part ASCII code then assemble the                           * character from the two codes and output it.                           */                            else                          {                                ascii_flag = 0;                              txio.tx_printf("{0}"' (char)(ascii | code));                              char_count++;                            }                            /* Character codes */                        }                      else if (code > 5)                      {                            code -= 6;                            /*                           * If this is character 0 in the punctuation set then the next two                           * codes make an ASCII character.                           */                            if (shift_state == 2 && code == 0)                                ascii_flag = 1;                            /*                           * If this is character 1 in the punctuation set then this                           * is a new line.                           */                            else if (shift_state == 2 && code == 1 && (uint)header.version > tx_h.V1)                                txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                    /*                                   * This is a normal character so select it from the character                                   * table appropriate for the current shift state.                           */                            else                          {                                txio.tx_printf("{0}"' (char)lookup_table[shift_state' code]);                              char_count++;                            }                            shift_state = shift_lock;                            /* Special codes 0 to 5 */                        }                      else                      {                            /*                           * Space: 0                           *                           * Output a space character.                           *                           */                            if (code == 0)                          {                                txio.tx_printf(" ");                              char_count++;                            }                          else                          {                                /*                               * The use of the synonym and shift codes is the only difference between                               * the different versions.                               */                                if ((uint)header.version < tx_h.V3)                              {                                    /*                                   * Newline or synonym: 1                                   *                                   * Output a newline character or set synonym flag.                                   *                                   */                                    if (code == 1)                                  {                                        if ((uint)header.version == tx_h.V1)                                      {                                          txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                          char_count++;                                      }                                      else                                      {                                          synonym_flag = 1;                                          synonym = code;                                      }                                        /*                                       * Shift keys: 2' 3' 4 or 5                                       *                                       * Shift keys 2 & 3 only shift the next character and can be used regardless of                                       * the state of the shift lock. Shift keys 4 & 5 lock the shift until reset.                                       *                                       * The following code implements the the shift code state transitions:                                       *                                       *               +-------------+-------------+-------------+-------------+                                       *               |       Shift   State       |        Lock   State       |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | Code        |      2      |       3     |      4      |      5      |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | lowercase   | uppercase   | punctuation | uppercase   | punctuation |                                       * | uppercase   | punctuation | lowercase   | punctuation | lowercase   |                                       * | punctuation | lowercase   | uppercase   | lowercase   | uppercase   |                                       * +-------------+-------------+-------------+-------------+-------------+                                       *                                       */                                    }                                  else                                  {                                      if (code < 4)                                          shift_state = (shift_lock + code + 2) % 3;                                      else                                          shift_lock = shift_state = (shift_lock + code) % 3;                                  }                                }                              else                              {                                    /*                                   * Synonym table: 1' 2 or 3                                   *                                   * Selects which of three synonym tables the synonym                                   * code following in the next code is to use.                                   *                                   */                                    if (code < 4)                                  {                                        synonym_flag = 1;                                      synonym = code;                                      /*                                       * Shift key: 4 or 5                                       *                                       * Selects the shift state for the next character'                                       * either uppercase (4) or punctuation (5). The shift                                       * state automatically gets reset back to lowercase for                                       * V3+ games after the next character is output.                                       *                                       */                                    }                                  else                                  {                                      shift_state = code - 3;                                      shift_lock = 0;                                    }                              }                          }                      }                  }              } while ((data & 0x8000) == 0);
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The following statement contains a magic number: do              {                    /*                   * Read one 16 bit word. Each word contains three 5 bit codes. If the                   * high bit is set then this is the last word in the string.                   */                  data = txio.read_data_word(ref address);                    for (i = 10; i >= 0; i -= 5)                  {                      /* Get code' high bits first */                        code = (data >> i) & 0x1f;                        /* Synonym codes */                        if (synonym_flag > 0)                      {                            synonym_flag = 0;                          synonym = (synonym - 1) * 64;                          addr = (ulong)tx_h.get_word(header.abbreviations + synonym + (code * 2)) * 2;                          char_count += txio.decode_text(ref addr);                          shift_state = shift_lock;                            /* ASCII codes */                        }                      else if (ascii_flag > 0)                      {                            /*                           * If this is the first part ASCII code then remember it.                           * Because the codes are only 5 bits you need two codes to make                           * one eight bit ASCII character. The first code contains the                           * top 3 bits. The second code contains the bottom 5 bits.                           */                            if (ascii_flag++ == 1)                                ascii = code << 5;                            /*                           * If this is the second part ASCII code then assemble the                           * character from the two codes and output it.                           */                            else                          {                                ascii_flag = 0;                              txio.tx_printf("{0}"' (char)(ascii | code));                              char_count++;                            }                            /* Character codes */                        }                      else if (code > 5)                      {                            code -= 6;                            /*                           * If this is character 0 in the punctuation set then the next two                           * codes make an ASCII character.                           */                            if (shift_state == 2 && code == 0)                                ascii_flag = 1;                            /*                           * If this is character 1 in the punctuation set then this                           * is a new line.                           */                            else if (shift_state == 2 && code == 1 && (uint)header.version > tx_h.V1)                                txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                    /*                                   * This is a normal character so select it from the character                                   * table appropriate for the current shift state.                           */                            else                          {                                txio.tx_printf("{0}"' (char)lookup_table[shift_state' code]);                              char_count++;                            }                            shift_state = shift_lock;                            /* Special codes 0 to 5 */                        }                      else                      {                            /*                           * Space: 0                           *                           * Output a space character.                           *                           */                            if (code == 0)                          {                                txio.tx_printf(" ");                              char_count++;                            }                          else                          {                                /*                               * The use of the synonym and shift codes is the only difference between                               * the different versions.                               */                                if ((uint)header.version < tx_h.V3)                              {                                    /*                                   * Newline or synonym: 1                                   *                                   * Output a newline character or set synonym flag.                                   *                                   */                                    if (code == 1)                                  {                                        if ((uint)header.version == tx_h.V1)                                      {                                          txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                          char_count++;                                      }                                      else                                      {                                          synonym_flag = 1;                                          synonym = code;                                      }                                        /*                                       * Shift keys: 2' 3' 4 or 5                                       *                                       * Shift keys 2 & 3 only shift the next character and can be used regardless of                                       * the state of the shift lock. Shift keys 4 & 5 lock the shift until reset.                                       *                                       * The following code implements the the shift code state transitions:                                       *                                       *               +-------------+-------------+-------------+-------------+                                       *               |       Shift   State       |        Lock   State       |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | Code        |      2      |       3     |      4      |      5      |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | lowercase   | uppercase   | punctuation | uppercase   | punctuation |                                       * | uppercase   | punctuation | lowercase   | punctuation | lowercase   |                                       * | punctuation | lowercase   | uppercase   | lowercase   | uppercase   |                                       * +-------------+-------------+-------------+-------------+-------------+                                       *                                       */                                    }                                  else                                  {                                      if (code < 4)                                          shift_state = (shift_lock + code + 2) % 3;                                      else                                          shift_lock = shift_state = (shift_lock + code) % 3;                                  }                                }                              else                              {                                    /*                                   * Synonym table: 1' 2 or 3                                   *                                   * Selects which of three synonym tables the synonym                                   * code following in the next code is to use.                                   *                                   */                                    if (code < 4)                                  {                                        synonym_flag = 1;                                      synonym = code;                                      /*                                       * Shift key: 4 or 5                                       *                                       * Selects the shift state for the next character'                                       * either uppercase (4) or punctuation (5). The shift                                       * state automatically gets reset back to lowercase for                                       * V3+ games after the next character is output.                                       *                                       */                                    }                                  else                                  {                                      shift_state = code - 3;                                      shift_lock = 0;                                    }                              }                          }                      }                  }              } while ((data & 0x8000) == 0);
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The following statement contains a magic number: do              {                    /*                   * Read one 16 bit word. Each word contains three 5 bit codes. If the                   * high bit is set then this is the last word in the string.                   */                  data = txio.read_data_word(ref address);                    for (i = 10; i >= 0; i -= 5)                  {                      /* Get code' high bits first */                        code = (data >> i) & 0x1f;                        /* Synonym codes */                        if (synonym_flag > 0)                      {                            synonym_flag = 0;                          synonym = (synonym - 1) * 64;                          addr = (ulong)tx_h.get_word(header.abbreviations + synonym + (code * 2)) * 2;                          char_count += txio.decode_text(ref addr);                          shift_state = shift_lock;                            /* ASCII codes */                        }                      else if (ascii_flag > 0)                      {                            /*                           * If this is the first part ASCII code then remember it.                           * Because the codes are only 5 bits you need two codes to make                           * one eight bit ASCII character. The first code contains the                           * top 3 bits. The second code contains the bottom 5 bits.                           */                            if (ascii_flag++ == 1)                                ascii = code << 5;                            /*                           * If this is the second part ASCII code then assemble the                           * character from the two codes and output it.                           */                            else                          {                                ascii_flag = 0;                              txio.tx_printf("{0}"' (char)(ascii | code));                              char_count++;                            }                            /* Character codes */                        }                      else if (code > 5)                      {                            code -= 6;                            /*                           * If this is character 0 in the punctuation set then the next two                           * codes make an ASCII character.                           */                            if (shift_state == 2 && code == 0)                                ascii_flag = 1;                            /*                           * If this is character 1 in the punctuation set then this                           * is a new line.                           */                            else if (shift_state == 2 && code == 1 && (uint)header.version > tx_h.V1)                                txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                    /*                                   * This is a normal character so select it from the character                                   * table appropriate for the current shift state.                           */                            else                          {                                txio.tx_printf("{0}"' (char)lookup_table[shift_state' code]);                              char_count++;                            }                            shift_state = shift_lock;                            /* Special codes 0 to 5 */                        }                      else                      {                            /*                           * Space: 0                           *                           * Output a space character.                           *                           */                            if (code == 0)                          {                                txio.tx_printf(" ");                              char_count++;                            }                          else                          {                                /*                               * The use of the synonym and shift codes is the only difference between                               * the different versions.                               */                                if ((uint)header.version < tx_h.V3)                              {                                    /*                                   * Newline or synonym: 1                                   *                                   * Output a newline character or set synonym flag.                                   *                                   */                                    if (code == 1)                                  {                                        if ((uint)header.version == tx_h.V1)                                      {                                          txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                          char_count++;                                      }                                      else                                      {                                          synonym_flag = 1;                                          synonym = code;                                      }                                        /*                                       * Shift keys: 2' 3' 4 or 5                                       *                                       * Shift keys 2 & 3 only shift the next character and can be used regardless of                                       * the state of the shift lock. Shift keys 4 & 5 lock the shift until reset.                                       *                                       * The following code implements the the shift code state transitions:                                       *                                       *               +-------------+-------------+-------------+-------------+                                       *               |       Shift   State       |        Lock   State       |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | Code        |      2      |       3     |      4      |      5      |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | lowercase   | uppercase   | punctuation | uppercase   | punctuation |                                       * | uppercase   | punctuation | lowercase   | punctuation | lowercase   |                                       * | punctuation | lowercase   | uppercase   | lowercase   | uppercase   |                                       * +-------------+-------------+-------------+-------------+-------------+                                       *                                       */                                    }                                  else                                  {                                      if (code < 4)                                          shift_state = (shift_lock + code + 2) % 3;                                      else                                          shift_lock = shift_state = (shift_lock + code) % 3;                                  }                                }                              else                              {                                    /*                                   * Synonym table: 1' 2 or 3                                   *                                   * Selects which of three synonym tables the synonym                                   * code following in the next code is to use.                                   *                                   */                                    if (code < 4)                                  {                                        synonym_flag = 1;                                      synonym = code;                                      /*                                       * Shift key: 4 or 5                                       *                                       * Selects the shift state for the next character'                                       * either uppercase (4) or punctuation (5). The shift                                       * state automatically gets reset back to lowercase for                                       * V3+ games after the next character is output.                                       *                                       */                                    }                                  else                                  {                                      shift_state = code - 3;                                      shift_lock = 0;                                    }                              }                          }                      }                  }              } while ((data & 0x8000) == 0);
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The following statement contains a magic number: do              {                    /*                   * Read one 16 bit word. Each word contains three 5 bit codes. If the                   * high bit is set then this is the last word in the string.                   */                  data = txio.read_data_word(ref address);                    for (i = 10; i >= 0; i -= 5)                  {                      /* Get code' high bits first */                        code = (data >> i) & 0x1f;                        /* Synonym codes */                        if (synonym_flag > 0)                      {                            synonym_flag = 0;                          synonym = (synonym - 1) * 64;                          addr = (ulong)tx_h.get_word(header.abbreviations + synonym + (code * 2)) * 2;                          char_count += txio.decode_text(ref addr);                          shift_state = shift_lock;                            /* ASCII codes */                        }                      else if (ascii_flag > 0)                      {                            /*                           * If this is the first part ASCII code then remember it.                           * Because the codes are only 5 bits you need two codes to make                           * one eight bit ASCII character. The first code contains the                           * top 3 bits. The second code contains the bottom 5 bits.                           */                            if (ascii_flag++ == 1)                                ascii = code << 5;                            /*                           * If this is the second part ASCII code then assemble the                           * character from the two codes and output it.                           */                            else                          {                                ascii_flag = 0;                              txio.tx_printf("{0}"' (char)(ascii | code));                              char_count++;                            }                            /* Character codes */                        }                      else if (code > 5)                      {                            code -= 6;                            /*                           * If this is character 0 in the punctuation set then the next two                           * codes make an ASCII character.                           */                            if (shift_state == 2 && code == 0)                                ascii_flag = 1;                            /*                           * If this is character 1 in the punctuation set then this                           * is a new line.                           */                            else if (shift_state == 2 && code == 1 && (uint)header.version > tx_h.V1)                                txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                    /*                                   * This is a normal character so select it from the character                                   * table appropriate for the current shift state.                           */                            else                          {                                txio.tx_printf("{0}"' (char)lookup_table[shift_state' code]);                              char_count++;                            }                            shift_state = shift_lock;                            /* Special codes 0 to 5 */                        }                      else                      {                            /*                           * Space: 0                           *                           * Output a space character.                           *                           */                            if (code == 0)                          {                                txio.tx_printf(" ");                              char_count++;                            }                          else                          {                                /*                               * The use of the synonym and shift codes is the only difference between                               * the different versions.                               */                                if ((uint)header.version < tx_h.V3)                              {                                    /*                                   * Newline or synonym: 1                                   *                                   * Output a newline character or set synonym flag.                                   *                                   */                                    if (code == 1)                                  {                                        if ((uint)header.version == tx_h.V1)                                      {                                          txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                          char_count++;                                      }                                      else                                      {                                          synonym_flag = 1;                                          synonym = code;                                      }                                        /*                                       * Shift keys: 2' 3' 4 or 5                                       *                                       * Shift keys 2 & 3 only shift the next character and can be used regardless of                                       * the state of the shift lock. Shift keys 4 & 5 lock the shift until reset.                                       *                                       * The following code implements the the shift code state transitions:                                       *                                       *               +-------------+-------------+-------------+-------------+                                       *               |       Shift   State       |        Lock   State       |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | Code        |      2      |       3     |      4      |      5      |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | lowercase   | uppercase   | punctuation | uppercase   | punctuation |                                       * | uppercase   | punctuation | lowercase   | punctuation | lowercase   |                                       * | punctuation | lowercase   | uppercase   | lowercase   | uppercase   |                                       * +-------------+-------------+-------------+-------------+-------------+                                       *                                       */                                    }                                  else                                  {                                      if (code < 4)                                          shift_state = (shift_lock + code + 2) % 3;                                      else                                          shift_lock = shift_state = (shift_lock + code) % 3;                                  }                                }                              else                              {                                    /*                                   * Synonym table: 1' 2 or 3                                   *                                   * Selects which of three synonym tables the synonym                                   * code following in the next code is to use.                                   *                                   */                                    if (code < 4)                                  {                                        synonym_flag = 1;                                      synonym = code;                                      /*                                       * Shift key: 4 or 5                                       *                                       * Selects the shift state for the next character'                                       * either uppercase (4) or punctuation (5). The shift                                       * state automatically gets reset back to lowercase for                                       * V3+ games after the next character is output.                                       *                                       */                                    }                                  else                                  {                                      shift_state = code - 3;                                      shift_lock = 0;                                    }                              }                          }                      }                  }              } while ((data & 0x8000) == 0);
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The following statement contains a magic number: do              {                    /*                   * Read one 16 bit word. Each word contains three 5 bit codes. If the                   * high bit is set then this is the last word in the string.                   */                  data = txio.read_data_word(ref address);                    for (i = 10; i >= 0; i -= 5)                  {                      /* Get code' high bits first */                        code = (data >> i) & 0x1f;                        /* Synonym codes */                        if (synonym_flag > 0)                      {                            synonym_flag = 0;                          synonym = (synonym - 1) * 64;                          addr = (ulong)tx_h.get_word(header.abbreviations + synonym + (code * 2)) * 2;                          char_count += txio.decode_text(ref addr);                          shift_state = shift_lock;                            /* ASCII codes */                        }                      else if (ascii_flag > 0)                      {                            /*                           * If this is the first part ASCII code then remember it.                           * Because the codes are only 5 bits you need two codes to make                           * one eight bit ASCII character. The first code contains the                           * top 3 bits. The second code contains the bottom 5 bits.                           */                            if (ascii_flag++ == 1)                                ascii = code << 5;                            /*                           * If this is the second part ASCII code then assemble the                           * character from the two codes and output it.                           */                            else                          {                                ascii_flag = 0;                              txio.tx_printf("{0}"' (char)(ascii | code));                              char_count++;                            }                            /* Character codes */                        }                      else if (code > 5)                      {                            code -= 6;                            /*                           * If this is character 0 in the punctuation set then the next two                           * codes make an ASCII character.                           */                            if (shift_state == 2 && code == 0)                                ascii_flag = 1;                            /*                           * If this is character 1 in the punctuation set then this                           * is a new line.                           */                            else if (shift_state == 2 && code == 1 && (uint)header.version > tx_h.V1)                                txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                    /*                                   * This is a normal character so select it from the character                                   * table appropriate for the current shift state.                           */                            else                          {                                txio.tx_printf("{0}"' (char)lookup_table[shift_state' code]);                              char_count++;                            }                            shift_state = shift_lock;                            /* Special codes 0 to 5 */                        }                      else                      {                            /*                           * Space: 0                           *                           * Output a space character.                           *                           */                            if (code == 0)                          {                                txio.tx_printf(" ");                              char_count++;                            }                          else                          {                                /*                               * The use of the synonym and shift codes is the only difference between                               * the different versions.                               */                                if ((uint)header.version < tx_h.V3)                              {                                    /*                                   * Newline or synonym: 1                                   *                                   * Output a newline character or set synonym flag.                                   *                                   */                                    if (code == 1)                                  {                                        if ((uint)header.version == tx_h.V1)                                      {                                          txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                          char_count++;                                      }                                      else                                      {                                          synonym_flag = 1;                                          synonym = code;                                      }                                        /*                                       * Shift keys: 2' 3' 4 or 5                                       *                                       * Shift keys 2 & 3 only shift the next character and can be used regardless of                                       * the state of the shift lock. Shift keys 4 & 5 lock the shift until reset.                                       *                                       * The following code implements the the shift code state transitions:                                       *                                       *               +-------------+-------------+-------------+-------------+                                       *               |       Shift   State       |        Lock   State       |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | Code        |      2      |       3     |      4      |      5      |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | lowercase   | uppercase   | punctuation | uppercase   | punctuation |                                       * | uppercase   | punctuation | lowercase   | punctuation | lowercase   |                                       * | punctuation | lowercase   | uppercase   | lowercase   | uppercase   |                                       * +-------------+-------------+-------------+-------------+-------------+                                       *                                       */                                    }                                  else                                  {                                      if (code < 4)                                          shift_state = (shift_lock + code + 2) % 3;                                      else                                          shift_lock = shift_state = (shift_lock + code) % 3;                                  }                                }                              else                              {                                    /*                                   * Synonym table: 1' 2 or 3                                   *                                   * Selects which of three synonym tables the synonym                                   * code following in the next code is to use.                                   *                                   */                                    if (code < 4)                                  {                                        synonym_flag = 1;                                      synonym = code;                                      /*                                       * Shift key: 4 or 5                                       *                                       * Selects the shift state for the next character'                                       * either uppercase (4) or punctuation (5). The shift                                       * state automatically gets reset back to lowercase for                                       * V3+ games after the next character is output.                                       *                                       */                                    }                                  else                                  {                                      shift_state = code - 3;                                      shift_lock = 0;                                    }                              }                          }                      }                  }              } while ((data & 0x8000) == 0);
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The following statement contains a magic number: do              {                    /*                   * Read one 16 bit word. Each word contains three 5 bit codes. If the                   * high bit is set then this is the last word in the string.                   */                  data = txio.read_data_word(ref address);                    for (i = 10; i >= 0; i -= 5)                  {                      /* Get code' high bits first */                        code = (data >> i) & 0x1f;                        /* Synonym codes */                        if (synonym_flag > 0)                      {                            synonym_flag = 0;                          synonym = (synonym - 1) * 64;                          addr = (ulong)tx_h.get_word(header.abbreviations + synonym + (code * 2)) * 2;                          char_count += txio.decode_text(ref addr);                          shift_state = shift_lock;                            /* ASCII codes */                        }                      else if (ascii_flag > 0)                      {                            /*                           * If this is the first part ASCII code then remember it.                           * Because the codes are only 5 bits you need two codes to make                           * one eight bit ASCII character. The first code contains the                           * top 3 bits. The second code contains the bottom 5 bits.                           */                            if (ascii_flag++ == 1)                                ascii = code << 5;                            /*                           * If this is the second part ASCII code then assemble the                           * character from the two codes and output it.                           */                            else                          {                                ascii_flag = 0;                              txio.tx_printf("{0}"' (char)(ascii | code));                              char_count++;                            }                            /* Character codes */                        }                      else if (code > 5)                      {                            code -= 6;                            /*                           * If this is character 0 in the punctuation set then the next two                           * codes make an ASCII character.                           */                            if (shift_state == 2 && code == 0)                                ascii_flag = 1;                            /*                           * If this is character 1 in the punctuation set then this                           * is a new line.                           */                            else if (shift_state == 2 && code == 1 && (uint)header.version > tx_h.V1)                                txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                    /*                                   * This is a normal character so select it from the character                                   * table appropriate for the current shift state.                           */                            else                          {                                txio.tx_printf("{0}"' (char)lookup_table[shift_state' code]);                              char_count++;                            }                            shift_state = shift_lock;                            /* Special codes 0 to 5 */                        }                      else                      {                            /*                           * Space: 0                           *                           * Output a space character.                           *                           */                            if (code == 0)                          {                                txio.tx_printf(" ");                              char_count++;                            }                          else                          {                                /*                               * The use of the synonym and shift codes is the only difference between                               * the different versions.                               */                                if ((uint)header.version < tx_h.V3)                              {                                    /*                                   * Newline or synonym: 1                                   *                                   * Output a newline character or set synonym flag.                                   *                                   */                                    if (code == 1)                                  {                                        if ((uint)header.version == tx_h.V1)                                      {                                          txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                          char_count++;                                      }                                      else                                      {                                          synonym_flag = 1;                                          synonym = code;                                      }                                        /*                                       * Shift keys: 2' 3' 4 or 5                                       *                                       * Shift keys 2 & 3 only shift the next character and can be used regardless of                                       * the state of the shift lock. Shift keys 4 & 5 lock the shift until reset.                                       *                                       * The following code implements the the shift code state transitions:                                       *                                       *               +-------------+-------------+-------------+-------------+                                       *               |       Shift   State       |        Lock   State       |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | Code        |      2      |       3     |      4      |      5      |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | lowercase   | uppercase   | punctuation | uppercase   | punctuation |                                       * | uppercase   | punctuation | lowercase   | punctuation | lowercase   |                                       * | punctuation | lowercase   | uppercase   | lowercase   | uppercase   |                                       * +-------------+-------------+-------------+-------------+-------------+                                       *                                       */                                    }                                  else                                  {                                      if (code < 4)                                          shift_state = (shift_lock + code + 2) % 3;                                      else                                          shift_lock = shift_state = (shift_lock + code) % 3;                                  }                                }                              else                              {                                    /*                                   * Synonym table: 1' 2 or 3                                   *                                   * Selects which of three synonym tables the synonym                                   * code following in the next code is to use.                                   *                                   */                                    if (code < 4)                                  {                                        synonym_flag = 1;                                      synonym = code;                                      /*                                       * Shift key: 4 or 5                                       *                                       * Selects the shift state for the next character'                                       * either uppercase (4) or punctuation (5). The shift                                       * state automatically gets reset back to lowercase for                                       * V3+ games after the next character is output.                                       *                                       */                                    }                                  else                                  {                                      shift_state = code - 3;                                      shift_lock = 0;                                    }                              }                          }                      }                  }              } while ((data & 0x8000) == 0);
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The following statement contains a magic number: do              {                    /*                   * Read one 16 bit word. Each word contains three 5 bit codes. If the                   * high bit is set then this is the last word in the string.                   */                  data = txio.read_data_word(ref address);                    for (i = 10; i >= 0; i -= 5)                  {                      /* Get code' high bits first */                        code = (data >> i) & 0x1f;                        /* Synonym codes */                        if (synonym_flag > 0)                      {                            synonym_flag = 0;                          synonym = (synonym - 1) * 64;                          addr = (ulong)tx_h.get_word(header.abbreviations + synonym + (code * 2)) * 2;                          char_count += txio.decode_text(ref addr);                          shift_state = shift_lock;                            /* ASCII codes */                        }                      else if (ascii_flag > 0)                      {                            /*                           * If this is the first part ASCII code then remember it.                           * Because the codes are only 5 bits you need two codes to make                           * one eight bit ASCII character. The first code contains the                           * top 3 bits. The second code contains the bottom 5 bits.                           */                            if (ascii_flag++ == 1)                                ascii = code << 5;                            /*                           * If this is the second part ASCII code then assemble the                           * character from the two codes and output it.                           */                            else                          {                                ascii_flag = 0;                              txio.tx_printf("{0}"' (char)(ascii | code));                              char_count++;                            }                            /* Character codes */                        }                      else if (code > 5)                      {                            code -= 6;                            /*                           * If this is character 0 in the punctuation set then the next two                           * codes make an ASCII character.                           */                            if (shift_state == 2 && code == 0)                                ascii_flag = 1;                            /*                           * If this is character 1 in the punctuation set then this                           * is a new line.                           */                            else if (shift_state == 2 && code == 1 && (uint)header.version > tx_h.V1)                                txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                    /*                                   * This is a normal character so select it from the character                                   * table appropriate for the current shift state.                           */                            else                          {                                txio.tx_printf("{0}"' (char)lookup_table[shift_state' code]);                              char_count++;                            }                            shift_state = shift_lock;                            /* Special codes 0 to 5 */                        }                      else                      {                            /*                           * Space: 0                           *                           * Output a space character.                           *                           */                            if (code == 0)                          {                                txio.tx_printf(" ");                              char_count++;                            }                          else                          {                                /*                               * The use of the synonym and shift codes is the only difference between                               * the different versions.                               */                                if ((uint)header.version < tx_h.V3)                              {                                    /*                                   * Newline or synonym: 1                                   *                                   * Output a newline character or set synonym flag.                                   *                                   */                                    if (code == 1)                                  {                                        if ((uint)header.version == tx_h.V1)                                      {                                          txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                          char_count++;                                      }                                      else                                      {                                          synonym_flag = 1;                                          synonym = code;                                      }                                        /*                                       * Shift keys: 2' 3' 4 or 5                                       *                                       * Shift keys 2 & 3 only shift the next character and can be used regardless of                                       * the state of the shift lock. Shift keys 4 & 5 lock the shift until reset.                                       *                                       * The following code implements the the shift code state transitions:                                       *                                       *               +-------------+-------------+-------------+-------------+                                       *               |       Shift   State       |        Lock   State       |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | Code        |      2      |       3     |      4      |      5      |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | lowercase   | uppercase   | punctuation | uppercase   | punctuation |                                       * | uppercase   | punctuation | lowercase   | punctuation | lowercase   |                                       * | punctuation | lowercase   | uppercase   | lowercase   | uppercase   |                                       * +-------------+-------------+-------------+-------------+-------------+                                       *                                       */                                    }                                  else                                  {                                      if (code < 4)                                          shift_state = (shift_lock + code + 2) % 3;                                      else                                          shift_lock = shift_state = (shift_lock + code) % 3;                                  }                                }                              else                              {                                    /*                                   * Synonym table: 1' 2 or 3                                   *                                   * Selects which of three synonym tables the synonym                                   * code following in the next code is to use.                                   *                                   */                                    if (code < 4)                                  {                                        synonym_flag = 1;                                      synonym = code;                                      /*                                       * Shift key: 4 or 5                                       *                                       * Selects the shift state for the next character'                                       * either uppercase (4) or punctuation (5). The shift                                       * state automatically gets reset back to lowercase for                                       * V3+ games after the next character is output.                                       *                                       */                                    }                                  else                                  {                                      shift_state = code - 3;                                      shift_lock = 0;                                    }                              }                          }                      }                  }              } while ((data & 0x8000) == 0);
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The following statement contains a magic number: do              {                    /*                   * Read one 16 bit word. Each word contains three 5 bit codes. If the                   * high bit is set then this is the last word in the string.                   */                  data = txio.read_data_word(ref address);                    for (i = 10; i >= 0; i -= 5)                  {                      /* Get code' high bits first */                        code = (data >> i) & 0x1f;                        /* Synonym codes */                        if (synonym_flag > 0)                      {                            synonym_flag = 0;                          synonym = (synonym - 1) * 64;                          addr = (ulong)tx_h.get_word(header.abbreviations + synonym + (code * 2)) * 2;                          char_count += txio.decode_text(ref addr);                          shift_state = shift_lock;                            /* ASCII codes */                        }                      else if (ascii_flag > 0)                      {                            /*                           * If this is the first part ASCII code then remember it.                           * Because the codes are only 5 bits you need two codes to make                           * one eight bit ASCII character. The first code contains the                           * top 3 bits. The second code contains the bottom 5 bits.                           */                            if (ascii_flag++ == 1)                                ascii = code << 5;                            /*                           * If this is the second part ASCII code then assemble the                           * character from the two codes and output it.                           */                            else                          {                                ascii_flag = 0;                              txio.tx_printf("{0}"' (char)(ascii | code));                              char_count++;                            }                            /* Character codes */                        }                      else if (code > 5)                      {                            code -= 6;                            /*                           * If this is character 0 in the punctuation set then the next two                           * codes make an ASCII character.                           */                            if (shift_state == 2 && code == 0)                                ascii_flag = 1;                            /*                           * If this is character 1 in the punctuation set then this                           * is a new line.                           */                            else if (shift_state == 2 && code == 1 && (uint)header.version > tx_h.V1)                                txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                    /*                                   * This is a normal character so select it from the character                                   * table appropriate for the current shift state.                           */                            else                          {                                txio.tx_printf("{0}"' (char)lookup_table[shift_state' code]);                              char_count++;                            }                            shift_state = shift_lock;                            /* Special codes 0 to 5 */                        }                      else                      {                            /*                           * Space: 0                           *                           * Output a space character.                           *                           */                            if (code == 0)                          {                                txio.tx_printf(" ");                              char_count++;                            }                          else                          {                                /*                               * The use of the synonym and shift codes is the only difference between                               * the different versions.                               */                                if ((uint)header.version < tx_h.V3)                              {                                    /*                                   * Newline or synonym: 1                                   *                                   * Output a newline character or set synonym flag.                                   *                                   */                                    if (code == 1)                                  {                                        if ((uint)header.version == tx_h.V1)                                      {                                          txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                          char_count++;                                      }                                      else                                      {                                          synonym_flag = 1;                                          synonym = code;                                      }                                        /*                                       * Shift keys: 2' 3' 4 or 5                                       *                                       * Shift keys 2 & 3 only shift the next character and can be used regardless of                                       * the state of the shift lock. Shift keys 4 & 5 lock the shift until reset.                                       *                                       * The following code implements the the shift code state transitions:                                       *                                       *               +-------------+-------------+-------------+-------------+                                       *               |       Shift   State       |        Lock   State       |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | Code        |      2      |       3     |      4      |      5      |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | lowercase   | uppercase   | punctuation | uppercase   | punctuation |                                       * | uppercase   | punctuation | lowercase   | punctuation | lowercase   |                                       * | punctuation | lowercase   | uppercase   | lowercase   | uppercase   |                                       * +-------------+-------------+-------------+-------------+-------------+                                       *                                       */                                    }                                  else                                  {                                      if (code < 4)                                          shift_state = (shift_lock + code + 2) % 3;                                      else                                          shift_lock = shift_state = (shift_lock + code) % 3;                                  }                                }                              else                              {                                    /*                                   * Synonym table: 1' 2 or 3                                   *                                   * Selects which of three synonym tables the synonym                                   * code following in the next code is to use.                                   *                                   */                                    if (code < 4)                                  {                                        synonym_flag = 1;                                      synonym = code;                                      /*                                       * Shift key: 4 or 5                                       *                                       * Selects the shift state for the next character'                                       * either uppercase (4) or punctuation (5). The shift                                       * state automatically gets reset back to lowercase for                                       * V3+ games after the next character is output.                                       *                                       */                                    }                                  else                                  {                                      shift_state = code - 3;                                      shift_lock = 0;                                    }                              }                          }                      }                  }              } while ((data & 0x8000) == 0);
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The following statement contains a magic number: do              {                    /*                   * Read one 16 bit word. Each word contains three 5 bit codes. If the                   * high bit is set then this is the last word in the string.                   */                  data = txio.read_data_word(ref address);                    for (i = 10; i >= 0; i -= 5)                  {                      /* Get code' high bits first */                        code = (data >> i) & 0x1f;                        /* Synonym codes */                        if (synonym_flag > 0)                      {                            synonym_flag = 0;                          synonym = (synonym - 1) * 64;                          addr = (ulong)tx_h.get_word(header.abbreviations + synonym + (code * 2)) * 2;                          char_count += txio.decode_text(ref addr);                          shift_state = shift_lock;                            /* ASCII codes */                        }                      else if (ascii_flag > 0)                      {                            /*                           * If this is the first part ASCII code then remember it.                           * Because the codes are only 5 bits you need two codes to make                           * one eight bit ASCII character. The first code contains the                           * top 3 bits. The second code contains the bottom 5 bits.                           */                            if (ascii_flag++ == 1)                                ascii = code << 5;                            /*                           * If this is the second part ASCII code then assemble the                           * character from the two codes and output it.                           */                            else                          {                                ascii_flag = 0;                              txio.tx_printf("{0}"' (char)(ascii | code));                              char_count++;                            }                            /* Character codes */                        }                      else if (code > 5)                      {                            code -= 6;                            /*                           * If this is character 0 in the punctuation set then the next two                           * codes make an ASCII character.                           */                            if (shift_state == 2 && code == 0)                                ascii_flag = 1;                            /*                           * If this is character 1 in the punctuation set then this                           * is a new line.                           */                            else if (shift_state == 2 && code == 1 && (uint)header.version > tx_h.V1)                                txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                    /*                                   * This is a normal character so select it from the character                                   * table appropriate for the current shift state.                           */                            else                          {                                txio.tx_printf("{0}"' (char)lookup_table[shift_state' code]);                              char_count++;                            }                            shift_state = shift_lock;                            /* Special codes 0 to 5 */                        }                      else                      {                            /*                           * Space: 0                           *                           * Output a space character.                           *                           */                            if (code == 0)                          {                                txio.tx_printf(" ");                              char_count++;                            }                          else                          {                                /*                               * The use of the synonym and shift codes is the only difference between                               * the different versions.                               */                                if ((uint)header.version < tx_h.V3)                              {                                    /*                                   * Newline or synonym: 1                                   *                                   * Output a newline character or set synonym flag.                                   *                                   */                                    if (code == 1)                                  {                                        if ((uint)header.version == tx_h.V1)                                      {                                          txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                          char_count++;                                      }                                      else                                      {                                          synonym_flag = 1;                                          synonym = code;                                      }                                        /*                                       * Shift keys: 2' 3' 4 or 5                                       *                                       * Shift keys 2 & 3 only shift the next character and can be used regardless of                                       * the state of the shift lock. Shift keys 4 & 5 lock the shift until reset.                                       *                                       * The following code implements the the shift code state transitions:                                       *                                       *               +-------------+-------------+-------------+-------------+                                       *               |       Shift   State       |        Lock   State       |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | Code        |      2      |       3     |      4      |      5      |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | lowercase   | uppercase   | punctuation | uppercase   | punctuation |                                       * | uppercase   | punctuation | lowercase   | punctuation | lowercase   |                                       * | punctuation | lowercase   | uppercase   | lowercase   | uppercase   |                                       * +-------------+-------------+-------------+-------------+-------------+                                       *                                       */                                    }                                  else                                  {                                      if (code < 4)                                          shift_state = (shift_lock + code + 2) % 3;                                      else                                          shift_lock = shift_state = (shift_lock + code) % 3;                                  }                                }                              else                              {                                    /*                                   * Synonym table: 1' 2 or 3                                   *                                   * Selects which of three synonym tables the synonym                                   * code following in the next code is to use.                                   *                                   */                                    if (code < 4)                                  {                                        synonym_flag = 1;                                      synonym = code;                                      /*                                       * Shift key: 4 or 5                                       *                                       * Selects the shift state for the next character'                                       * either uppercase (4) or punctuation (5). The shift                                       * state automatically gets reset back to lowercase for                                       * V3+ games after the next character is output.                                       *                                       */                                    }                                  else                                  {                                      shift_state = code - 3;                                      shift_lock = 0;                                    }                              }                          }                      }                  }              } while ((data & 0x8000) == 0);
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The following statement contains a magic number: do              {                    /*                   * Read one 16 bit word. Each word contains three 5 bit codes. If the                   * high bit is set then this is the last word in the string.                   */                  data = txio.read_data_word(ref address);                    for (i = 10; i >= 0; i -= 5)                  {                      /* Get code' high bits first */                        code = (data >> i) & 0x1f;                        /* Synonym codes */                        if (synonym_flag > 0)                      {                            synonym_flag = 0;                          synonym = (synonym - 1) * 64;                          addr = (ulong)tx_h.get_word(header.abbreviations + synonym + (code * 2)) * 2;                          char_count += txio.decode_text(ref addr);                          shift_state = shift_lock;                            /* ASCII codes */                        }                      else if (ascii_flag > 0)                      {                            /*                           * If this is the first part ASCII code then remember it.                           * Because the codes are only 5 bits you need two codes to make                           * one eight bit ASCII character. The first code contains the                           * top 3 bits. The second code contains the bottom 5 bits.                           */                            if (ascii_flag++ == 1)                                ascii = code << 5;                            /*                           * If this is the second part ASCII code then assemble the                           * character from the two codes and output it.                           */                            else                          {                                ascii_flag = 0;                              txio.tx_printf("{0}"' (char)(ascii | code));                              char_count++;                            }                            /* Character codes */                        }                      else if (code > 5)                      {                            code -= 6;                            /*                           * If this is character 0 in the punctuation set then the next two                           * codes make an ASCII character.                           */                            if (shift_state == 2 && code == 0)                                ascii_flag = 1;                            /*                           * If this is character 1 in the punctuation set then this                           * is a new line.                           */                            else if (shift_state == 2 && code == 1 && (uint)header.version > tx_h.V1)                                txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                    /*                                   * This is a normal character so select it from the character                                   * table appropriate for the current shift state.                           */                            else                          {                                txio.tx_printf("{0}"' (char)lookup_table[shift_state' code]);                              char_count++;                            }                            shift_state = shift_lock;                            /* Special codes 0 to 5 */                        }                      else                      {                            /*                           * Space: 0                           *                           * Output a space character.                           *                           */                            if (code == 0)                          {                                txio.tx_printf(" ");                              char_count++;                            }                          else                          {                                /*                               * The use of the synonym and shift codes is the only difference between                               * the different versions.                               */                                if ((uint)header.version < tx_h.V3)                              {                                    /*                                   * Newline or synonym: 1                                   *                                   * Output a newline character or set synonym flag.                                   *                                   */                                    if (code == 1)                                  {                                        if ((uint)header.version == tx_h.V1)                                      {                                          txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                          char_count++;                                      }                                      else                                      {                                          synonym_flag = 1;                                          synonym = code;                                      }                                        /*                                       * Shift keys: 2' 3' 4 or 5                                       *                                       * Shift keys 2 & 3 only shift the next character and can be used regardless of                                       * the state of the shift lock. Shift keys 4 & 5 lock the shift until reset.                                       *                                       * The following code implements the the shift code state transitions:                                       *                                       *               +-------------+-------------+-------------+-------------+                                       *               |       Shift   State       |        Lock   State       |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | Code        |      2      |       3     |      4      |      5      |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | lowercase   | uppercase   | punctuation | uppercase   | punctuation |                                       * | uppercase   | punctuation | lowercase   | punctuation | lowercase   |                                       * | punctuation | lowercase   | uppercase   | lowercase   | uppercase   |                                       * +-------------+-------------+-------------+-------------+-------------+                                       *                                       */                                    }                                  else                                  {                                      if (code < 4)                                          shift_state = (shift_lock + code + 2) % 3;                                      else                                          shift_lock = shift_state = (shift_lock + code) % 3;                                  }                                }                              else                              {                                    /*                                   * Synonym table: 1' 2 or 3                                   *                                   * Selects which of three synonym tables the synonym                                   * code following in the next code is to use.                                   *                                   */                                    if (code < 4)                                  {                                        synonym_flag = 1;                                      synonym = code;                                      /*                                       * Shift key: 4 or 5                                       *                                       * Selects the shift state for the next character'                                       * either uppercase (4) or punctuation (5). The shift                                       * state automatically gets reset back to lowercase for                                       * V3+ games after the next character is output.                                       *                                       */                                    }                                  else                                  {                                      shift_state = code - 3;                                      shift_lock = 0;                                    }                              }                          }                      }                  }              } while ((data & 0x8000) == 0);
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The following statement contains a magic number: do              {                    /*                   * Read one 16 bit word. Each word contains three 5 bit codes. If the                   * high bit is set then this is the last word in the string.                   */                  data = txio.read_data_word(ref address);                    for (i = 10; i >= 0; i -= 5)                  {                      /* Get code' high bits first */                        code = (data >> i) & 0x1f;                        /* Synonym codes */                        if (synonym_flag > 0)                      {                            synonym_flag = 0;                          synonym = (synonym - 1) * 64;                          addr = (ulong)tx_h.get_word(header.abbreviations + synonym + (code * 2)) * 2;                          char_count += txio.decode_text(ref addr);                          shift_state = shift_lock;                            /* ASCII codes */                        }                      else if (ascii_flag > 0)                      {                            /*                           * If this is the first part ASCII code then remember it.                           * Because the codes are only 5 bits you need two codes to make                           * one eight bit ASCII character. The first code contains the                           * top 3 bits. The second code contains the bottom 5 bits.                           */                            if (ascii_flag++ == 1)                                ascii = code << 5;                            /*                           * If this is the second part ASCII code then assemble the                           * character from the two codes and output it.                           */                            else                          {                                ascii_flag = 0;                              txio.tx_printf("{0}"' (char)(ascii | code));                              char_count++;                            }                            /* Character codes */                        }                      else if (code > 5)                      {                            code -= 6;                            /*                           * If this is character 0 in the punctuation set then the next two                           * codes make an ASCII character.                           */                            if (shift_state == 2 && code == 0)                                ascii_flag = 1;                            /*                           * If this is character 1 in the punctuation set then this                           * is a new line.                           */                            else if (shift_state == 2 && code == 1 && (uint)header.version > tx_h.V1)                                txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                    /*                                   * This is a normal character so select it from the character                                   * table appropriate for the current shift state.                           */                            else                          {                                txio.tx_printf("{0}"' (char)lookup_table[shift_state' code]);                              char_count++;                            }                            shift_state = shift_lock;                            /* Special codes 0 to 5 */                        }                      else                      {                            /*                           * Space: 0                           *                           * Output a space character.                           *                           */                            if (code == 0)                          {                                txio.tx_printf(" ");                              char_count++;                            }                          else                          {                                /*                               * The use of the synonym and shift codes is the only difference between                               * the different versions.                               */                                if ((uint)header.version < tx_h.V3)                              {                                    /*                                   * Newline or synonym: 1                                   *                                   * Output a newline character or set synonym flag.                                   *                                   */                                    if (code == 1)                                  {                                        if ((uint)header.version == tx_h.V1)                                      {                                          txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                          char_count++;                                      }                                      else                                      {                                          synonym_flag = 1;                                          synonym = code;                                      }                                        /*                                       * Shift keys: 2' 3' 4 or 5                                       *                                       * Shift keys 2 & 3 only shift the next character and can be used regardless of                                       * the state of the shift lock. Shift keys 4 & 5 lock the shift until reset.                                       *                                       * The following code implements the the shift code state transitions:                                       *                                       *               +-------------+-------------+-------------+-------------+                                       *               |       Shift   State       |        Lock   State       |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | Code        |      2      |       3     |      4      |      5      |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | lowercase   | uppercase   | punctuation | uppercase   | punctuation |                                       * | uppercase   | punctuation | lowercase   | punctuation | lowercase   |                                       * | punctuation | lowercase   | uppercase   | lowercase   | uppercase   |                                       * +-------------+-------------+-------------+-------------+-------------+                                       *                                       */                                    }                                  else                                  {                                      if (code < 4)                                          shift_state = (shift_lock + code + 2) % 3;                                      else                                          shift_lock = shift_state = (shift_lock + code) % 3;                                  }                                }                              else                              {                                    /*                                   * Synonym table: 1' 2 or 3                                   *                                   * Selects which of three synonym tables the synonym                                   * code following in the next code is to use.                                   *                                   */                                    if (code < 4)                                  {                                        synonym_flag = 1;                                      synonym = code;                                      /*                                       * Shift key: 4 or 5                                       *                                       * Selects the shift state for the next character'                                       * either uppercase (4) or punctuation (5). The shift                                       * state automatically gets reset back to lowercase for                                       * V3+ games after the next character is output.                                       *                                       */                                    }                                  else                                  {                                      shift_state = code - 3;                                      shift_lock = 0;                                    }                              }                          }                      }                  }              } while ((data & 0x8000) == 0);
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The following statement contains a magic number: do              {                    /*                   * Read one 16 bit word. Each word contains three 5 bit codes. If the                   * high bit is set then this is the last word in the string.                   */                  data = txio.read_data_word(ref address);                    for (i = 10; i >= 0; i -= 5)                  {                      /* Get code' high bits first */                        code = (data >> i) & 0x1f;                        /* Synonym codes */                        if (synonym_flag > 0)                      {                            synonym_flag = 0;                          synonym = (synonym - 1) * 64;                          addr = (ulong)tx_h.get_word(header.abbreviations + synonym + (code * 2)) * 2;                          char_count += txio.decode_text(ref addr);                          shift_state = shift_lock;                            /* ASCII codes */                        }                      else if (ascii_flag > 0)                      {                            /*                           * If this is the first part ASCII code then remember it.                           * Because the codes are only 5 bits you need two codes to make                           * one eight bit ASCII character. The first code contains the                           * top 3 bits. The second code contains the bottom 5 bits.                           */                            if (ascii_flag++ == 1)                                ascii = code << 5;                            /*                           * If this is the second part ASCII code then assemble the                           * character from the two codes and output it.                           */                            else                          {                                ascii_flag = 0;                              txio.tx_printf("{0}"' (char)(ascii | code));                              char_count++;                            }                            /* Character codes */                        }                      else if (code > 5)                      {                            code -= 6;                            /*                           * If this is character 0 in the punctuation set then the next two                           * codes make an ASCII character.                           */                            if (shift_state == 2 && code == 0)                                ascii_flag = 1;                            /*                           * If this is character 1 in the punctuation set then this                           * is a new line.                           */                            else if (shift_state == 2 && code == 1 && (uint)header.version > tx_h.V1)                                txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                    /*                                   * This is a normal character so select it from the character                                   * table appropriate for the current shift state.                           */                            else                          {                                txio.tx_printf("{0}"' (char)lookup_table[shift_state' code]);                              char_count++;                            }                            shift_state = shift_lock;                            /* Special codes 0 to 5 */                        }                      else                      {                            /*                           * Space: 0                           *                           * Output a space character.                           *                           */                            if (code == 0)                          {                                txio.tx_printf(" ");                              char_count++;                            }                          else                          {                                /*                               * The use of the synonym and shift codes is the only difference between                               * the different versions.                               */                                if ((uint)header.version < tx_h.V3)                              {                                    /*                                   * Newline or synonym: 1                                   *                                   * Output a newline character or set synonym flag.                                   *                                   */                                    if (code == 1)                                  {                                        if ((uint)header.version == tx_h.V1)                                      {                                          txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                          char_count++;                                      }                                      else                                      {                                          synonym_flag = 1;                                          synonym = code;                                      }                                        /*                                       * Shift keys: 2' 3' 4 or 5                                       *                                       * Shift keys 2 & 3 only shift the next character and can be used regardless of                                       * the state of the shift lock. Shift keys 4 & 5 lock the shift until reset.                                       *                                       * The following code implements the the shift code state transitions:                                       *                                       *               +-------------+-------------+-------------+-------------+                                       *               |       Shift   State       |        Lock   State       |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | Code        |      2      |       3     |      4      |      5      |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | lowercase   | uppercase   | punctuation | uppercase   | punctuation |                                       * | uppercase   | punctuation | lowercase   | punctuation | lowercase   |                                       * | punctuation | lowercase   | uppercase   | lowercase   | uppercase   |                                       * +-------------+-------------+-------------+-------------+-------------+                                       *                                       */                                    }                                  else                                  {                                      if (code < 4)                                          shift_state = (shift_lock + code + 2) % 3;                                      else                                          shift_lock = shift_state = (shift_lock + code) % 3;                                  }                                }                              else                              {                                    /*                                   * Synonym table: 1' 2 or 3                                   *                                   * Selects which of three synonym tables the synonym                                   * code following in the next code is to use.                                   *                                   */                                    if (code < 4)                                  {                                        synonym_flag = 1;                                      synonym = code;                                      /*                                       * Shift key: 4 or 5                                       *                                       * Selects the shift state for the next character'                                       * either uppercase (4) or punctuation (5). The shift                                       * state automatically gets reset back to lowercase for                                       * V3+ games after the next character is output.                                       *                                       */                                    }                                  else                                  {                                      shift_state = code - 3;                                      shift_lock = 0;                                    }                              }                          }                      }                  }              } while ((data & 0x8000) == 0);
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The following statement contains a magic number: do              {                    /*                   * Read one 16 bit word. Each word contains three 5 bit codes. If the                   * high bit is set then this is the last word in the string.                   */                  data = txio.read_data_word(ref address);                    for (i = 10; i >= 0; i -= 5)                  {                      /* Get code' high bits first */                        code = (data >> i) & 0x1f;                        /* Synonym codes */                        if (synonym_flag > 0)                      {                            synonym_flag = 0;                          synonym = (synonym - 1) * 64;                          addr = (ulong)tx_h.get_word(header.abbreviations + synonym + (code * 2)) * 2;                          char_count += txio.decode_text(ref addr);                          shift_state = shift_lock;                            /* ASCII codes */                        }                      else if (ascii_flag > 0)                      {                            /*                           * If this is the first part ASCII code then remember it.                           * Because the codes are only 5 bits you need two codes to make                           * one eight bit ASCII character. The first code contains the                           * top 3 bits. The second code contains the bottom 5 bits.                           */                            if (ascii_flag++ == 1)                                ascii = code << 5;                            /*                           * If this is the second part ASCII code then assemble the                           * character from the two codes and output it.                           */                            else                          {                                ascii_flag = 0;                              txio.tx_printf("{0}"' (char)(ascii | code));                              char_count++;                            }                            /* Character codes */                        }                      else if (code > 5)                      {                            code -= 6;                            /*                           * If this is character 0 in the punctuation set then the next two                           * codes make an ASCII character.                           */                            if (shift_state == 2 && code == 0)                                ascii_flag = 1;                            /*                           * If this is character 1 in the punctuation set then this                           * is a new line.                           */                            else if (shift_state == 2 && code == 1 && (uint)header.version > tx_h.V1)                                txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                    /*                                   * This is a normal character so select it from the character                                   * table appropriate for the current shift state.                           */                            else                          {                                txio.tx_printf("{0}"' (char)lookup_table[shift_state' code]);                              char_count++;                            }                            shift_state = shift_lock;                            /* Special codes 0 to 5 */                        }                      else                      {                            /*                           * Space: 0                           *                           * Output a space character.                           *                           */                            if (code == 0)                          {                                txio.tx_printf(" ");                              char_count++;                            }                          else                          {                                /*                               * The use of the synonym and shift codes is the only difference between                               * the different versions.                               */                                if ((uint)header.version < tx_h.V3)                              {                                    /*                                   * Newline or synonym: 1                                   *                                   * Output a newline character or set synonym flag.                                   *                                   */                                    if (code == 1)                                  {                                        if ((uint)header.version == tx_h.V1)                                      {                                          txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                          char_count++;                                      }                                      else                                      {                                          synonym_flag = 1;                                          synonym = code;                                      }                                        /*                                       * Shift keys: 2' 3' 4 or 5                                       *                                       * Shift keys 2 & 3 only shift the next character and can be used regardless of                                       * the state of the shift lock. Shift keys 4 & 5 lock the shift until reset.                                       *                                       * The following code implements the the shift code state transitions:                                       *                                       *               +-------------+-------------+-------------+-------------+                                       *               |       Shift   State       |        Lock   State       |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | Code        |      2      |       3     |      4      |      5      |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | lowercase   | uppercase   | punctuation | uppercase   | punctuation |                                       * | uppercase   | punctuation | lowercase   | punctuation | lowercase   |                                       * | punctuation | lowercase   | uppercase   | lowercase   | uppercase   |                                       * +-------------+-------------+-------------+-------------+-------------+                                       *                                       */                                    }                                  else                                  {                                      if (code < 4)                                          shift_state = (shift_lock + code + 2) % 3;                                      else                                          shift_lock = shift_state = (shift_lock + code) % 3;                                  }                                }                              else                              {                                    /*                                   * Synonym table: 1' 2 or 3                                   *                                   * Selects which of three synonym tables the synonym                                   * code following in the next code is to use.                                   *                                   */                                    if (code < 4)                                  {                                        synonym_flag = 1;                                      synonym = code;                                      /*                                       * Shift key: 4 or 5                                       *                                       * Selects the shift state for the next character'                                       * either uppercase (4) or punctuation (5). The shift                                       * state automatically gets reset back to lowercase for                                       * V3+ games after the next character is output.                                       *                                       */                                    }                                  else                                  {                                      shift_state = code - 3;                                      shift_lock = 0;                                    }                              }                          }                      }                  }              } while ((data & 0x8000) == 0);
Magic Number,ZTools,txio,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txio.cs,decode_text,The following statement contains a magic number: do              {                    /*                   * Read one 16 bit word. Each word contains three 5 bit codes. If the                   * high bit is set then this is the last word in the string.                   */                  data = txio.read_data_word(ref address);                    for (i = 10; i >= 0; i -= 5)                  {                      /* Get code' high bits first */                        code = (data >> i) & 0x1f;                        /* Synonym codes */                        if (synonym_flag > 0)                      {                            synonym_flag = 0;                          synonym = (synonym - 1) * 64;                          addr = (ulong)tx_h.get_word(header.abbreviations + synonym + (code * 2)) * 2;                          char_count += txio.decode_text(ref addr);                          shift_state = shift_lock;                            /* ASCII codes */                        }                      else if (ascii_flag > 0)                      {                            /*                           * If this is the first part ASCII code then remember it.                           * Because the codes are only 5 bits you need two codes to make                           * one eight bit ASCII character. The first code contains the                           * top 3 bits. The second code contains the bottom 5 bits.                           */                            if (ascii_flag++ == 1)                                ascii = code << 5;                            /*                           * If this is the second part ASCII code then assemble the                           * character from the two codes and output it.                           */                            else                          {                                ascii_flag = 0;                              txio.tx_printf("{0}"' (char)(ascii | code));                              char_count++;                            }                            /* Character codes */                        }                      else if (code > 5)                      {                            code -= 6;                            /*                           * If this is character 0 in the punctuation set then the next two                           * codes make an ASCII character.                           */                            if (shift_state == 2 && code == 0)                                ascii_flag = 1;                            /*                           * If this is character 1 in the punctuation set then this                           * is a new line.                           */                            else if (shift_state == 2 && code == 1 && (uint)header.version > tx_h.V1)                                txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                    /*                                   * This is a normal character so select it from the character                                   * table appropriate for the current shift state.                           */                            else                          {                                txio.tx_printf("{0}"' (char)lookup_table[shift_state' code]);                              char_count++;                            }                            shift_state = shift_lock;                            /* Special codes 0 to 5 */                        }                      else                      {                            /*                           * Space: 0                           *                           * Output a space character.                           *                           */                            if (code == 0)                          {                                txio.tx_printf(" ");                              char_count++;                            }                          else                          {                                /*                               * The use of the synonym and shift codes is the only difference between                               * the different versions.                               */                                if ((uint)header.version < tx_h.V3)                              {                                    /*                                   * Newline or synonym: 1                                   *                                   * Output a newline character or set synonym flag.                                   *                                   */                                    if (code == 1)                                  {                                        if ((uint)header.version == tx_h.V1)                                      {                                          txio.tx_printf("{0}"' (option_inform) ? '^' : '\n');                                          char_count++;                                      }                                      else                                      {                                          synonym_flag = 1;                                          synonym = code;                                      }                                        /*                                       * Shift keys: 2' 3' 4 or 5                                       *                                       * Shift keys 2 & 3 only shift the next character and can be used regardless of                                       * the state of the shift lock. Shift keys 4 & 5 lock the shift until reset.                                       *                                       * The following code implements the the shift code state transitions:                                       *                                       *               +-------------+-------------+-------------+-------------+                                       *               |       Shift   State       |        Lock   State       |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | Code        |      2      |       3     |      4      |      5      |                                       * +-------------+-------------+-------------+-------------+-------------+                                       * | lowercase   | uppercase   | punctuation | uppercase   | punctuation |                                       * | uppercase   | punctuation | lowercase   | punctuation | lowercase   |                                       * | punctuation | lowercase   | uppercase   | lowercase   | uppercase   |                                       * +-------------+-------------+-------------+-------------+-------------+                                       *                                       */                                    }                                  else                                  {                                      if (code < 4)                                          shift_state = (shift_lock + code + 2) % 3;                                      else                                          shift_lock = shift_state = (shift_lock + code) % 3;                                  }                                }                              else                              {                                    /*                                   * Synonym table: 1' 2 or 3                                   *                                   * Selects which of three synonym tables the synonym                                   * code following in the next code is to use.                                   *                                   */                                    if (code < 4)                                  {                                        synonym_flag = 1;                                      synonym = code;                                      /*                                       * Shift key: 4 or 5                                       *                                       * Selects the shift state for the next character'                                       * either uppercase (4) or punctuation (5). The shift                                       * state automatically gets reset back to lowercase for                                       * V3+ games after the next character is output.                                       *                                       */                                    }                                  else                                  {                                      shift_state = code - 3;                                      shift_lock = 0;                                    }                              }                          }                      }                  }              } while ((data & 0x8000) == 0);
Magic Number,ZTools,tx_h,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\tx_h.cs,VERB_NUM,The following statement contains a magic number: return (((parser_type) >= (int)tx_h.parser_types.inform_gv2a) ? (uint)(index) : ((uint)(255 - (index))));
Magic Number,ZTools,tx_h,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\tx_h.cs,get_word,The following statement contains a magic number: return (ushort)((datap[offset] << 8) + (datap[offset + 1]));
Magic Number,ZTools,tx_h,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\tx_h.cs,set_word,The following statement contains a magic number: datap[offset] = (zbyte_t)(value >> 8);
Missing Default,Frotz.Generic,Hotkey,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\hotkey.cs,handle_hot_key,The following switch statement is missing a default case: switch (key)                  {                      case CharCodes.ZC_HKEY_RECORD: aborting = hot_key_recording(); break;                      case CharCodes.ZC_HKEY_PLAYBACK: aborting = hot_key_playback(); break;                      case CharCodes.ZC_HKEY_SEED: aborting = hot_key_seed(); break;                      case CharCodes.ZC_HKEY_UNDO: aborting = hot_key_undo(); break;                      case CharCodes.ZC_HKEY_RESTART: aborting = hot_key_restart(); break;                      case CharCodes.ZC_HKEY_QUIT: aborting = hot_key_quit(); break;                      case CharCodes.ZC_HKEY_DEBUG: aborting = hot_key_debugging(); break;                      case CharCodes.ZC_HKEY_HELP: aborting = hot_key_help(); break;                  }
Missing Default,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,amiga_screen_model,The following switch statement is missing a default case: switch (main.story_id)                  {                      case Story.BEYOND_ZORK:                      case Story.ZORK_ZERO:                      case Story.SHOGUN:                      case Story.ARTHUR:                      case Story.JOURNEY:                          return true;                  }
Missing Default,Frotz.Generic,Screen,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\screen.cs,z_window_style,The following switch statement is missing a default case: switch (Process.zargs[2])              {                  case 0: wp[win].attribute = flags; break;                  case 1: wp[win].attribute |= flags; break;                  case 2: wp[win].attribute &= (zword)(~flags); break;                  case 3: wp[win].attribute ^= flags; break;              }
Missing Default,Frotz.Generic,Sound,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\sound.cs,z_sound_effect,The following switch statement is missing a default case: switch (effect)                  {                        case EFFECT_PREPARE:                          os_.prepare_sample(number);                          break;                      case EFFECT_PLAY:                          start_sample(number' FastMem.LO(volume)' FastMem.HI(volume)'                              (zword)((Process.zargc == 4) ? Process.zargs[3] : 0));                          break;                      case EFFECT_STOP:                          os_.stop_sample(number);                          break;                      case EFFECT_FINISH_WITH:                          os_.finish_with_sample(number);                          break;                    }
Missing Default,Frotz.Generic,Stream,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\stream.cs,z_output_stream,The following switch statement is missing a default case: switch ((short)Process.zargs[0]) {                    case 1: main.ostream_screen = true;                      break;                  case -1: main.ostream_screen = false;                      break;                  case 2: if (!main.ostream_script) Files.script_open();                      break;                  case -2: if (main.ostream_script) Files.script_close();                      break;                  case 3: Redirect.memory_open(Process.zargs[1]' Process.zargs[2]' Process.zargc >= 3);                      break;                  case -3: Redirect.memory_close();                      break;                  case 4: if (!main.ostream_record) Files.record_open();                      break;                  case -4: if (main.ostream_record) Files.record_close();                      break;                }
Missing Default,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,encode_text,The following switch statement is missing a default case: switch (decoded[0])                      {                          case 'g': decoded = again; break;                          case 'x': decoded = examine; break;                          case 'z': decoded = wait; break;                      }
Missing Default,Frotz.Generic,Text,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\Frotz\Generic\text.cs,decode_text,The following switch statement is missing a default case: switch (status) {                            case 0:	/* normal operation */                                if (shift_state == 2 && c == 6)                                  status = 2;                                else if (main.h_version == ZMachine.V1 && c == 1)                                  Buffer.new_line();                                else if (main.h_version >= ZMachine.V2 && shift_state == 2 && c == 7)                                  Buffer.new_line();                                else if (c >= 6)                                  outchar(st' alphabet(shift_state' c - 6));                                else if (c == 0)                                  outchar(st' ' ');                                else if (main.h_version >= ZMachine.V2 && c == 1)                                  status = 1;                                else if (main.h_version >= ZMachine.V3 && c <= 3)                                  status = 1;                                else {                                    shift_state = (shift_lock + (c & 1) + 1) % 3;                                    if (main.h_version <= ZMachine.V2 && c >= 4)                                      shift_lock = shift_state;                                    break;                                }                                shift_state = shift_lock;                                break;                            case 1:	/* abbreviation */                                ptr_addr = (zword)(main.h_abbreviations + 64 * (prev_c - 1) + 2 * c);                                FastMem.LOW_WORD(ptr_addr' out abbr_addr);                              decode_text(string_type.ABBREVIATION' abbr_addr);                                status = 0;                              break;                            case 2:	/* ZSCII character - first part */                                status = 3;                              break;                            case 3:	/* ZSCII character - second part */                                zc = (zword)((prev_c << 5) | c);                                c2 = translate_from_zscii((zbyte)zc); // TODO This doesn't seem right                              outchar(st' c2);                                status = 0;                              break;                      }
Missing Default,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,read_file_name,The following switch statement is missing a default case: switch (flag)              {                  case FileTypes.FILE_SAVE:                      fileName = _screen.OpenNewOrExistingFile(FastMem.save_name' "Choose save game file"' "Save Files (*.sav)|*.sav"' ".sav");                      break;                  case FileTypes.FILE_RESTORE:                      fileName = _screen.OpenExistingFile(FastMem.save_name' "Choose save game to restore"' "Save Files (*.sav)|*.sav");                      break;                  case FileTypes.FILE_SCRIPT:                      fileName = _screen.OpenNewOrExistingFile(General.DEFAULT_SCRIPT_NAME' "Choose Script File"' "Script File (*.scr)|*.scr"' ".scr");                      break;                  case FileTypes.FILE_RECORD:                      fileName = _screen.OpenNewOrExistingFile(default_name' "Choose File to Record To"' "Record File(*.rec)|*.rec"' ".rec");                      break;                  case FileTypes.FILE_PLAYBACK:                      fileName = _screen.OpenExistingFile(default_name' "Choose File to playback from"' "Record File(*.rec)|*.rec");                      break;                  case FileTypes.FILE_SAVE_AUX:                  case FileTypes.FILE_LOAD_AUX:                      fail("Need to implement other types of files");                      break;              }
Missing Default,Frotz,os_,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\os_WPF.cs,read_line,The following switch statement is missing a default case: switch (c)                      {                          case CharCodes.ZC_HKEY_HELP:                          case CharCodes.ZC_HKEY_DEBUG:                          case CharCodes.ZC_HKEY_PLAYBACK:                          case CharCodes.ZC_HKEY_RECORD:                            case CharCodes.ZC_HKEY_SEED:                          case CharCodes.ZC_HKEY_UNDO:                          case CharCodes.ZC_HKEY_RESTART:                          case CharCodes.ZC_HKEY_QUIT:                              return c;                      }
Missing Default,ZTools,showdict,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\showdict.cs,show_dictionary,The following switch statement is missing a default case: switch (flag)                          {                              case tx_h.DIR_FIRST:                                  if ((dictpar1 & tx_h.DIR) > 0)                                      txio.tx_printf(" <dir>");                                  break;                              case tx_h.ADJ_FIRST:                                  if ((dictpar1 & tx_h.DESC) > 0)                                      txio.tx_printf(" <adj>");                                  break;                              case tx_h.VERB_FIRST:                                  if ((dictpar1 & tx_h.VERB) > 0)                                      txio.tx_printf(" <verb>");                                  break;                              case tx_h.PREP_FIRST:                                  if ((dictpar1 & tx_h.PREP) > 0)                                      txio.tx_printf(" <prep>");                                  break;                          }
Missing Default,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The following switch statement is missing a default case: switch ((int)header.version)                              {                                  case tx_h.V1:                                  case tx_h.V2:                                  case tx_h.V3:                                      switch (code)                                      {                                          case 0x20: return decode_operands("CALL"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL);                                            case 0x24: return decode_operands("READ"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x29: return decode_operands("PULL"' tx_h.VAR' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                      }                                      break;                                  case tx_h.V4:                                      switch (code)                                      {                                          case 0x19: return decode_operands("CALL_2S"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.CALL);                                            case 0x20: return decode_operands("CALL_VS"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL);                                            case 0x24: return decode_operands("READ"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.ROUTINE' tx_h.NONE' tx_h.PLAIN);                                            case 0x29: return decode_operands("PULL"' tx_h.VAR' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x2C: return decode_operands("CALL_VS2"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL);                                          case 0x2D: return decode_operands("ERASE_WINDOW"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x2E: return decode_operands("ERASE_LINE"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x2F: return decode_operands("SET_CURSOR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x31: return decode_operands("SET_TEXT_STYLE"' tx_h.VATTR' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x32: return decode_operands("BUFFER_MODE"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x36: return decode_operands("READ_CHAR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.ROUTINE' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                          case 0x37: return decode_operands("SCAN_TABLE"' tx_h.ANYTHING' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.BOTH' tx_h.PLAIN);                                      }                                      break;                                  case tx_h.V5:                                  case tx_h.V7:                                  case tx_h.V8:                                      switch (code)                                      {                                          case 0x19: return decode_operands("CALL_2S"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.CALL);                                          case 0x1A: return decode_operands("CALL_2N"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.CALL);                                          case 0x1B: return decode_operands("SET_COLOUR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x20: return decode_operands("CALL_VS"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL);                                            case 0x24: return decode_operands("READ"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.ROUTINE' tx_h.STORE' tx_h.PLAIN);                                            case 0x29: return decode_operands("PULL"' tx_h.VAR' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x2C: return decode_operands("CALL_VS2"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL);                                          case 0x2D: return decode_operands("ERASE_WINDOW"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x2E: return decode_operands("ERASE_LINE"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x2F: return decode_operands("SET_CURSOR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x31: return decode_operands("SET_TEXT_STYLE"' tx_h.VATTR' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x32: return decode_operands("BUFFER_MODE"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x36: return decode_operands("READ_CHAR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.ROUTINE' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                          case 0x37: return decode_operands("SCAN_TABLE"' tx_h.ANYTHING' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.BOTH' tx_h.PLAIN);                                            case 0x39: return decode_operands("CALL_VN"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.NONE' tx_h.CALL);                                          case 0x3A: return decode_operands("CALL_VN2"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.NONE' tx_h.CALL);                                          case 0x3B: return decode_operands("TOKENISE"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NONE' tx_h.PLAIN);                                          case 0x3C: return decode_operands("ENCODE_TEXT"' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.LOW_ADDR' tx_h.NONE' tx_h.PLAIN);                                          case 0x3D: return decode_operands("COPY_TABLE"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x3E: return decode_operands("PRINT_TABLE"' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.NUMBER' tx_h.NONE' tx_h.PLAIN);                                          case 0x3F: return decode_operands("CHECK_ARG_COUNT"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.BRANCH' tx_h.PLAIN);                                      }                                      break;                                  case tx_h.V6:                                      switch (code)                                      {                                          case 0x19: return decode_operands("CALL_2S"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.CALL);                                          case 0x1A: return decode_operands("CALL_2N"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.CALL);                                          case 0x1B: return decode_operands("SET_COLOUR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x1C: return decode_operands("THROW"' tx_h.ANYTHING' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x20: return decode_operands("CALL_VS"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL);                                            case 0x24: return decode_operands("READ"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.ROUTINE' tx_h.STORE' tx_h.PLAIN);                                            case 0x29: return decode_operands("PULL"' tx_h.LOW_ADDR' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                            case 0x2C: return decode_operands("CALL_VS2"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL);                                          case 0x2D: return decode_operands("ERASE_WINDOW"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x2E: return decode_operands("ERASE_LINE"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x2F: return decode_operands("SET_CURSOR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NUMBER' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x30: return decode_operands("GET_CURSOR"' tx_h.LOW_ADDR' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x31: return decode_operands("SET_TEXT_STYLE"' tx_h.VATTR' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x32: return decode_operands("BUFFER_MODE"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x36: return decode_operands("READ_CHAR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.ROUTINE' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                          case 0x37: return decode_operands("SCAN_TABLE"' tx_h.ANYTHING' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.BOTH' tx_h.PLAIN);                                          case 0x38: return decode_operands("NOT"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                          case 0x39: return decode_operands("CALL_VN"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.NONE' tx_h.CALL);                                          case 0x3A: return decode_operands("CALL_VN2"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.NONE' tx_h.CALL);                                          case 0x3B: return decode_operands("TOKENISE"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NONE' tx_h.PLAIN);                                          case 0x3C: return decode_operands("ENCODE_TEXT"' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.LOW_ADDR' tx_h.NONE' tx_h.PLAIN);                                          case 0x3D: return decode_operands("COPY_TABLE"' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.LOW_ADDR' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x3E: return decode_operands("PRINT_TABLE"' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.NUMBER' tx_h.NONE' tx_h.PLAIN);                                          case 0x3F: return decode_operands("CHECK_ARG_COUNT"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.BRANCH' tx_h.PLAIN);                                      }                                      break;                              }
Missing Default,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The following switch statement is missing a default case: switch (code)                                      {                                          case 0x20: return decode_operands("CALL"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL);                                            case 0x24: return decode_operands("READ"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x29: return decode_operands("PULL"' tx_h.VAR' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                      }
Missing Default,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The following switch statement is missing a default case: switch (code)                                      {                                          case 0x19: return decode_operands("CALL_2S"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.CALL);                                            case 0x20: return decode_operands("CALL_VS"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL);                                            case 0x24: return decode_operands("READ"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.ROUTINE' tx_h.NONE' tx_h.PLAIN);                                            case 0x29: return decode_operands("PULL"' tx_h.VAR' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x2C: return decode_operands("CALL_VS2"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL);                                          case 0x2D: return decode_operands("ERASE_WINDOW"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x2E: return decode_operands("ERASE_LINE"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x2F: return decode_operands("SET_CURSOR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x31: return decode_operands("SET_TEXT_STYLE"' tx_h.VATTR' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x32: return decode_operands("BUFFER_MODE"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x36: return decode_operands("READ_CHAR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.ROUTINE' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                          case 0x37: return decode_operands("SCAN_TABLE"' tx_h.ANYTHING' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.BOTH' tx_h.PLAIN);                                      }
Missing Default,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The following switch statement is missing a default case: switch (code)                                      {                                          case 0x19: return decode_operands("CALL_2S"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.CALL);                                          case 0x1A: return decode_operands("CALL_2N"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.CALL);                                          case 0x1B: return decode_operands("SET_COLOUR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x20: return decode_operands("CALL_VS"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL);                                            case 0x24: return decode_operands("READ"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.ROUTINE' tx_h.STORE' tx_h.PLAIN);                                            case 0x29: return decode_operands("PULL"' tx_h.VAR' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x2C: return decode_operands("CALL_VS2"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL);                                          case 0x2D: return decode_operands("ERASE_WINDOW"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x2E: return decode_operands("ERASE_LINE"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x2F: return decode_operands("SET_CURSOR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x31: return decode_operands("SET_TEXT_STYLE"' tx_h.VATTR' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x32: return decode_operands("BUFFER_MODE"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x36: return decode_operands("READ_CHAR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.ROUTINE' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                          case 0x37: return decode_operands("SCAN_TABLE"' tx_h.ANYTHING' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.BOTH' tx_h.PLAIN);                                            case 0x39: return decode_operands("CALL_VN"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.NONE' tx_h.CALL);                                          case 0x3A: return decode_operands("CALL_VN2"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.NONE' tx_h.CALL);                                          case 0x3B: return decode_operands("TOKENISE"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NONE' tx_h.PLAIN);                                          case 0x3C: return decode_operands("ENCODE_TEXT"' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.LOW_ADDR' tx_h.NONE' tx_h.PLAIN);                                          case 0x3D: return decode_operands("COPY_TABLE"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x3E: return decode_operands("PRINT_TABLE"' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.NUMBER' tx_h.NONE' tx_h.PLAIN);                                          case 0x3F: return decode_operands("CHECK_ARG_COUNT"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.BRANCH' tx_h.PLAIN);                                      }
Missing Default,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The following switch statement is missing a default case: switch (code)                                      {                                          case 0x19: return decode_operands("CALL_2S"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.CALL);                                          case 0x1A: return decode_operands("CALL_2N"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.CALL);                                          case 0x1B: return decode_operands("SET_COLOUR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x1C: return decode_operands("THROW"' tx_h.ANYTHING' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x20: return decode_operands("CALL_VS"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL);                                            case 0x24: return decode_operands("READ"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.ROUTINE' tx_h.STORE' tx_h.PLAIN);                                            case 0x29: return decode_operands("PULL"' tx_h.LOW_ADDR' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                            case 0x2C: return decode_operands("CALL_VS2"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.STORE' tx_h.CALL);                                          case 0x2D: return decode_operands("ERASE_WINDOW"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x2E: return decode_operands("ERASE_LINE"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x2F: return decode_operands("SET_CURSOR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.NUMBER' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x30: return decode_operands("GET_CURSOR"' tx_h.LOW_ADDR' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x31: return decode_operands("SET_TEXT_STYLE"' tx_h.VATTR' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x32: return decode_operands("BUFFER_MODE"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x36: return decode_operands("READ_CHAR"' tx_h.NUMBER' tx_h.NUMBER' tx_h.ROUTINE' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                          case 0x37: return decode_operands("SCAN_TABLE"' tx_h.ANYTHING' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.BOTH' tx_h.PLAIN);                                          case 0x38: return decode_operands("NOT"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                          case 0x39: return decode_operands("CALL_VN"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.NONE' tx_h.CALL);                                          case 0x3A: return decode_operands("CALL_VN2"' tx_h.ROUTINE' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.ANYTHING' tx_h.NONE' tx_h.CALL);                                          case 0x3B: return decode_operands("TOKENISE"' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NONE' tx_h.PLAIN);                                          case 0x3C: return decode_operands("ENCODE_TEXT"' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.LOW_ADDR' tx_h.NONE' tx_h.PLAIN);                                          case 0x3D: return decode_operands("COPY_TABLE"' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.LOW_ADDR' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                          case 0x3E: return decode_operands("PRINT_TABLE"' tx_h.LOW_ADDR' tx_h.NUMBER' tx_h.NUMBER' tx_h.NUMBER' tx_h.NONE' tx_h.PLAIN);                                          case 0x3F: return decode_operands("CHECK_ARG_COUNT"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.BRANCH' tx_h.PLAIN);                                      }
Missing Default,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The following switch statement is missing a default case: switch ((int)header.version)                              {                                  case tx_h.V1:                                  case tx_h.V2:                                  case tx_h.V3:                                      switch (code)                                      {                                          case 0x0F: return decode_operands("NOT"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                      }                                      break;                                  case tx_h.V4:                                      switch (code)                                      {                                          case 0x08: return decode_operands("CALL_1S"' tx_h.ROUTINE' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.CALL);                                            case 0x0F: return decode_operands("NOT"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                      }                                      break;                                  case tx_h.V5:                                  case tx_h.V6:                                  case tx_h.V7:                                  case tx_h.V8:                                      switch (code)                                      {                                          case 0x08: return decode_operands(".CALL_1S"' tx_h.ROUTINE' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.CALL);                                            case 0x0F: return decode_operands("CALL_1N"' tx_h.ROUTINE' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.CALL);                                      }                                      break;                              }
Missing Default,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The following switch statement is missing a default case: switch (code)                                      {                                          case 0x0F: return decode_operands("NOT"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                      }
Missing Default,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The following switch statement is missing a default case: switch (code)                                      {                                          case 0x08: return decode_operands("CALL_1S"' tx_h.ROUTINE' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.CALL);                                            case 0x0F: return decode_operands("NOT"' tx_h.NUMBER' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                      }
Missing Default,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The following switch statement is missing a default case: switch (code)                                      {                                          case 0x08: return decode_operands(".CALL_1S"' tx_h.ROUTINE' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.CALL);                                            case 0x0F: return decode_operands("CALL_1N"' tx_h.ROUTINE' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.CALL);                                      }
Missing Default,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The following switch statement is missing a default case: switch (header.version)                              {                                  case tx_h.V1:                                  case tx_h.V2:                                  case tx_h.V3:                                      switch (code)                                      {                                          case 0x05: return decode_operands("SAVE"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.BRANCH' tx_h.PLAIN);                                          case 0x06: return decode_operands("RESTORE"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.BRANCH' tx_h.PLAIN);                                            case 0x09: return decode_operands("POP"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x0C: return decode_operands("SHOW_STATUS"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                      }                                      break;                                  case tx_h.V4:                                      switch (code)                                      {                                          case 0x09: return decode_operands("POP"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x05: return decode_operands("SAVE"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                          case 0x06: return decode_operands("RESTORE"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                      }                                      break;                                  case tx_h.V5:                                  case tx_h.V7:                                  case tx_h.V8:                                      switch (code)                                      {                                          case 0x09: return decode_operands("CATCH"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                          /* From a bug in Wishbringer V23 */                                          case 0x0C: return decode_operands("SHOW_STATUS"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                      }                                      break;                                  case tx_h.V6:                                      switch (code)                                      {                                          case 0x09: return decode_operands("CATCH"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                            case 0x0F: return decode_operands("PIRACY"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.BRANCH' tx_h.PLAIN);                                      }                                      break;                              }
Missing Default,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The following switch statement is missing a default case: switch (code)                                      {                                          case 0x05: return decode_operands("SAVE"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.BRANCH' tx_h.PLAIN);                                          case 0x06: return decode_operands("RESTORE"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.BRANCH' tx_h.PLAIN);                                            case 0x09: return decode_operands("POP"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x0C: return decode_operands("SHOW_STATUS"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                      }
Missing Default,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The following switch statement is missing a default case: switch (code)                                      {                                          case 0x09: return decode_operands("POP"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                            case 0x05: return decode_operands("SAVE"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                          case 0x06: return decode_operands("RESTORE"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                      }
Missing Default,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The following switch statement is missing a default case: switch (code)                                      {                                          case 0x09: return decode_operands("CATCH"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                          /* From a bug in Wishbringer V23 */                                          case 0x0C: return decode_operands("SHOW_STATUS"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NONE' tx_h.PLAIN);                                      }
Missing Default,ZTools,txd,C:\repos\CosmosOS_Cosmos\Demos\zMachine\Frotz.Net\source\Desktop\FrotzBase\ZTools\txd.cs,decode_opcode,The following switch statement is missing a default case: switch (code)                                      {                                          case 0x09: return decode_operands("CATCH"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.STORE' tx_h.PLAIN);                                            case 0x0F: return decode_operands("PIRACY"' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.NIL' tx_h.BRANCH' tx_h.PLAIN);                                      }
