Implementation smell,Namespace,Class,File,Method,Description
Long Method,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The method has 131 lines of code.
Long Method,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SendCmd,The method has 118 lines of code.
Complex Method,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,Cyclomatic complexity of the method is 25
Complex Method,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SendCmd,Cyclomatic complexity of the method is 9
Complex Method,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForSignature,Cyclomatic complexity of the method is 10
Complex Method,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,HandleFileSending,Cyclomatic complexity of the method is 9
Long Parameter List,Cosmos.Debug.DebugConnectors,CoreDump,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\CoreDump.cs,CoreDump,The method has 10 parameters. Parameters: eax' ebx' ecx' edx' esi' edi' ebp' esp' eip' stackTrace
Long Parameter List,Cosmos.Debug.DebugConnectors,DebugConnectorPipeClient,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorPipeClient.cs,PeekNamedPipe,The method has 6 parameters. Parameters: handle' buffer' nBufferSize' bytesRead' bytesAvail' BytesLeftThisMessage
Long Parameter List,Cosmos.Debug.DebugConnectors,DebugConnectorPipeServer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorPipeServer.cs,PeekNamedPipe,The method has 6 parameters. Parameters: handle' buffer' nBufferSize' bytesRead' bytesAvail' BytesLeftThisMessage
Long Parameter List,Cosmos.Debug.DebugConnectors,DebugConnectorTestPipeServer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorTestPipeServer.cs,CreateNamedPipe,The method has 8 parameters. Parameters: pipeName' dwOpenMode' dwPipeMode' nMaxInstances' nOutBufferSize' nInBufferSize' nDefaultTimeOut' lpSecurityAttributes
Long Statement,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The length of the statement  "            //DoDebugMsg(String.Format("DC - PacketMsg: {0}"' DebugConnectorStreamWithTimeouts.BytesToString(aPacket' 0' aPacket.Length))); " is 127.
Complex Conditional,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SendCmd,The conditional expression  "(!resetID && lastCmdCompletedID < mCommandID)                                          || (resetID && lastCmdCompletedID > 5)"  is complex.
Magic Number,Cosmos.Debug.DebugConnectors,CoreDump,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\CoreDump.cs,FromStackArray,The following statement contains a magic number: var stack = new Stack<uint>(stackBytes.Length / 4);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,WaitForSignature,The following statement contains a magic number: mSigCheck[1] = mSigCheck[2];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,WaitForSignature,The following statement contains a magic number: mSigCheck[2] = mSigCheck[3];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,WaitForSignature,The following statement contains a magic number: mSigCheck[2] = mSigCheck[3];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,WaitForSignature,The following statement contains a magic number: mSigCheck[3] = aPacket[0];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SetBreakpoint,The following statement contains a magic number: var xData = new byte[5];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SetBreakpoint,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(aAddress)' 0' xData' 0' 4);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SetBreakpoint,The following statement contains a magic number: xData[4] = (byte)aID;
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,GetMemoryData,The following statement contains a magic number: var xData = new byte[8];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,GetMemoryData,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(address)' 0' xData' 0' 4);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,GetMemoryData,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(size)' 0' xData' 4' 4);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,GetMemoryData,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(size)' 0' xData' 4' 4);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,GetStackData,The following statement contains a magic number: var xData = new byte[8];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,GetStackData,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(offsetToEBP)' 0' xData' 0' 4);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,GetStackData,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(size)' 0' xData' 4' 4);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,GetStackData,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(size)' 0' xData' 4' 4);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,BytesToString,The following statement contains a magic number: count > 100 || count <= 0 || bytes.Length == 0
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,BytesToString,The following statement contains a magic number: var xSB = new StringBuilder(2 + (bytes.Length * 2));
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,BytesToString,The following statement contains a magic number: var xSB = new StringBuilder(2 + (bytes.Length * 2));
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SizePacket,The following statement contains a magic number: int xSize = aPacket[0] + (aPacket[1] << 8);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,RawSendHelper,The following statement contains a magic number: xEvent.Wait(25)
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,Next,The following statement contains a magic number: aPacketSize > (1024 * 1024)
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,Next,The following statement contains a magic number: aPacketSize > (1024 * 1024)
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,ProcessPendingActions,The following statement contains a magic number: var xBytesRead = TryRead(xPendingRead.Packet' xPendingRead.CurrentPos' xNrOfBytesToRead' 5);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,ProcessPendingActions,The following statement contains a magic number: xPendingRead != null || mPendingReads.TryTake(out xPendingRead' 5)
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,ProcessPendingActions,The following statement contains a magic number: mPendingWrites.TryTake(out xPendingWrite' 5)
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForSignature,The following statement contains a magic number: switch (mBootStage)              {                  // start by sending out a message to the window                  case 0:                      base.SendTextToConsole("Waiting for U-Boot bootloader prompt...\r\n");                      mBootStage = 1;                      break;                  // the bootloader should be configured to wait for input:                  case 1:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("Sending kernel now\r\n");                          SendTextToConsole("Filename = '" + mKernelFile + "'\r\n");                          SendRawData("\0loady 0x1000000\r\n");                          mBootStage = 2;                      }                      break;                  case 2:                      if (HandleFileSending(aPacket))                      {                          SendTextToConsole("Done sending kernel file\r\n");                          mBootStage = 4;                      }                      break;                  //case 3:                  //    if (WaitForBootPrompt(aPacket))                  //    {                  //        SendTextToConsole("mw.l 0xFF009000 0x11F8 1\r\n");                  //        SendRawData("mw.l 0xFF009000 0x11F8 1\r\n");                  //        mBootStage = 4;                  //    }                  //    break;                  case 4:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("mw.l 0xFF009000 0x10F8 1\r\n");                          SendRawData("mw.l 0xFF009000 0x10F8 1\r\n");                          mBootStage = 5;                      }                      break;                  case 5:                      if (WaitForBootPrompt(aPacket))                      {                          // now at boot prompt.                          SendTextToConsole("Now starting kernel\r\n");                          mBootStage = 6;                          SendRawData("go 0x1000000\r\n");                      }                      break;                  case 6:                      //if (WaitForBootPrompt(aPacket))                      //{                      //    SendRawData("\0A");                      //}                      base.WaitForSignature(aPacket);                      return;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForSignature,The following statement contains a magic number: switch (mBootStage)              {                  // start by sending out a message to the window                  case 0:                      base.SendTextToConsole("Waiting for U-Boot bootloader prompt...\r\n");                      mBootStage = 1;                      break;                  // the bootloader should be configured to wait for input:                  case 1:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("Sending kernel now\r\n");                          SendTextToConsole("Filename = '" + mKernelFile + "'\r\n");                          SendRawData("\0loady 0x1000000\r\n");                          mBootStage = 2;                      }                      break;                  case 2:                      if (HandleFileSending(aPacket))                      {                          SendTextToConsole("Done sending kernel file\r\n");                          mBootStage = 4;                      }                      break;                  //case 3:                  //    if (WaitForBootPrompt(aPacket))                  //    {                  //        SendTextToConsole("mw.l 0xFF009000 0x11F8 1\r\n");                  //        SendRawData("mw.l 0xFF009000 0x11F8 1\r\n");                  //        mBootStage = 4;                  //    }                  //    break;                  case 4:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("mw.l 0xFF009000 0x10F8 1\r\n");                          SendRawData("mw.l 0xFF009000 0x10F8 1\r\n");                          mBootStage = 5;                      }                      break;                  case 5:                      if (WaitForBootPrompt(aPacket))                      {                          // now at boot prompt.                          SendTextToConsole("Now starting kernel\r\n");                          mBootStage = 6;                          SendRawData("go 0x1000000\r\n");                      }                      break;                  case 6:                      //if (WaitForBootPrompt(aPacket))                      //{                      //    SendRawData("\0A");                      //}                      base.WaitForSignature(aPacket);                      return;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForSignature,The following statement contains a magic number: switch (mBootStage)              {                  // start by sending out a message to the window                  case 0:                      base.SendTextToConsole("Waiting for U-Boot bootloader prompt...\r\n");                      mBootStage = 1;                      break;                  // the bootloader should be configured to wait for input:                  case 1:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("Sending kernel now\r\n");                          SendTextToConsole("Filename = '" + mKernelFile + "'\r\n");                          SendRawData("\0loady 0x1000000\r\n");                          mBootStage = 2;                      }                      break;                  case 2:                      if (HandleFileSending(aPacket))                      {                          SendTextToConsole("Done sending kernel file\r\n");                          mBootStage = 4;                      }                      break;                  //case 3:                  //    if (WaitForBootPrompt(aPacket))                  //    {                  //        SendTextToConsole("mw.l 0xFF009000 0x11F8 1\r\n");                  //        SendRawData("mw.l 0xFF009000 0x11F8 1\r\n");                  //        mBootStage = 4;                  //    }                  //    break;                  case 4:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("mw.l 0xFF009000 0x10F8 1\r\n");                          SendRawData("mw.l 0xFF009000 0x10F8 1\r\n");                          mBootStage = 5;                      }                      break;                  case 5:                      if (WaitForBootPrompt(aPacket))                      {                          // now at boot prompt.                          SendTextToConsole("Now starting kernel\r\n");                          mBootStage = 6;                          SendRawData("go 0x1000000\r\n");                      }                      break;                  case 6:                      //if (WaitForBootPrompt(aPacket))                      //{                      //    SendRawData("\0A");                      //}                      base.WaitForSignature(aPacket);                      return;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForSignature,The following statement contains a magic number: switch (mBootStage)              {                  // start by sending out a message to the window                  case 0:                      base.SendTextToConsole("Waiting for U-Boot bootloader prompt...\r\n");                      mBootStage = 1;                      break;                  // the bootloader should be configured to wait for input:                  case 1:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("Sending kernel now\r\n");                          SendTextToConsole("Filename = '" + mKernelFile + "'\r\n");                          SendRawData("\0loady 0x1000000\r\n");                          mBootStage = 2;                      }                      break;                  case 2:                      if (HandleFileSending(aPacket))                      {                          SendTextToConsole("Done sending kernel file\r\n");                          mBootStage = 4;                      }                      break;                  //case 3:                  //    if (WaitForBootPrompt(aPacket))                  //    {                  //        SendTextToConsole("mw.l 0xFF009000 0x11F8 1\r\n");                  //        SendRawData("mw.l 0xFF009000 0x11F8 1\r\n");                  //        mBootStage = 4;                  //    }                  //    break;                  case 4:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("mw.l 0xFF009000 0x10F8 1\r\n");                          SendRawData("mw.l 0xFF009000 0x10F8 1\r\n");                          mBootStage = 5;                      }                      break;                  case 5:                      if (WaitForBootPrompt(aPacket))                      {                          // now at boot prompt.                          SendTextToConsole("Now starting kernel\r\n");                          mBootStage = 6;                          SendRawData("go 0x1000000\r\n");                      }                      break;                  case 6:                      //if (WaitForBootPrompt(aPacket))                      //{                      //    SendRawData("\0A");                      //}                      base.WaitForSignature(aPacket);                      return;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForSignature,The following statement contains a magic number: switch (mBootStage)              {                  // start by sending out a message to the window                  case 0:                      base.SendTextToConsole("Waiting for U-Boot bootloader prompt...\r\n");                      mBootStage = 1;                      break;                  // the bootloader should be configured to wait for input:                  case 1:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("Sending kernel now\r\n");                          SendTextToConsole("Filename = '" + mKernelFile + "'\r\n");                          SendRawData("\0loady 0x1000000\r\n");                          mBootStage = 2;                      }                      break;                  case 2:                      if (HandleFileSending(aPacket))                      {                          SendTextToConsole("Done sending kernel file\r\n");                          mBootStage = 4;                      }                      break;                  //case 3:                  //    if (WaitForBootPrompt(aPacket))                  //    {                  //        SendTextToConsole("mw.l 0xFF009000 0x11F8 1\r\n");                  //        SendRawData("mw.l 0xFF009000 0x11F8 1\r\n");                  //        mBootStage = 4;                  //    }                  //    break;                  case 4:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("mw.l 0xFF009000 0x10F8 1\r\n");                          SendRawData("mw.l 0xFF009000 0x10F8 1\r\n");                          mBootStage = 5;                      }                      break;                  case 5:                      if (WaitForBootPrompt(aPacket))                      {                          // now at boot prompt.                          SendTextToConsole("Now starting kernel\r\n");                          mBootStage = 6;                          SendRawData("go 0x1000000\r\n");                      }                      break;                  case 6:                      //if (WaitForBootPrompt(aPacket))                      //{                      //    SendRawData("\0A");                      //}                      base.WaitForSignature(aPacket);                      return;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForSignature,The following statement contains a magic number: switch (mBootStage)              {                  // start by sending out a message to the window                  case 0:                      base.SendTextToConsole("Waiting for U-Boot bootloader prompt...\r\n");                      mBootStage = 1;                      break;                  // the bootloader should be configured to wait for input:                  case 1:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("Sending kernel now\r\n");                          SendTextToConsole("Filename = '" + mKernelFile + "'\r\n");                          SendRawData("\0loady 0x1000000\r\n");                          mBootStage = 2;                      }                      break;                  case 2:                      if (HandleFileSending(aPacket))                      {                          SendTextToConsole("Done sending kernel file\r\n");                          mBootStage = 4;                      }                      break;                  //case 3:                  //    if (WaitForBootPrompt(aPacket))                  //    {                  //        SendTextToConsole("mw.l 0xFF009000 0x11F8 1\r\n");                  //        SendRawData("mw.l 0xFF009000 0x11F8 1\r\n");                  //        mBootStage = 4;                  //    }                  //    break;                  case 4:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("mw.l 0xFF009000 0x10F8 1\r\n");                          SendRawData("mw.l 0xFF009000 0x10F8 1\r\n");                          mBootStage = 5;                      }                      break;                  case 5:                      if (WaitForBootPrompt(aPacket))                      {                          // now at boot prompt.                          SendTextToConsole("Now starting kernel\r\n");                          mBootStage = 6;                          SendRawData("go 0x1000000\r\n");                      }                      break;                  case 6:                      //if (WaitForBootPrompt(aPacket))                      //{                      //    SendRawData("\0A");                      //}                      base.WaitForSignature(aPacket);                      return;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForSignature,The following statement contains a magic number: switch (mBootStage)              {                  // start by sending out a message to the window                  case 0:                      base.SendTextToConsole("Waiting for U-Boot bootloader prompt...\r\n");                      mBootStage = 1;                      break;                  // the bootloader should be configured to wait for input:                  case 1:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("Sending kernel now\r\n");                          SendTextToConsole("Filename = '" + mKernelFile + "'\r\n");                          SendRawData("\0loady 0x1000000\r\n");                          mBootStage = 2;                      }                      break;                  case 2:                      if (HandleFileSending(aPacket))                      {                          SendTextToConsole("Done sending kernel file\r\n");                          mBootStage = 4;                      }                      break;                  //case 3:                  //    if (WaitForBootPrompt(aPacket))                  //    {                  //        SendTextToConsole("mw.l 0xFF009000 0x11F8 1\r\n");                  //        SendRawData("mw.l 0xFF009000 0x11F8 1\r\n");                  //        mBootStage = 4;                  //    }                  //    break;                  case 4:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("mw.l 0xFF009000 0x10F8 1\r\n");                          SendRawData("mw.l 0xFF009000 0x10F8 1\r\n");                          mBootStage = 5;                      }                      break;                  case 5:                      if (WaitForBootPrompt(aPacket))                      {                          // now at boot prompt.                          SendTextToConsole("Now starting kernel\r\n");                          mBootStage = 6;                          SendRawData("go 0x1000000\r\n");                      }                      break;                  case 6:                      //if (WaitForBootPrompt(aPacket))                      //{                      //    SendRawData("\0A");                      //}                      base.WaitForSignature(aPacket);                      return;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForSignature,The following statement contains a magic number: switch (mBootStage)              {                  // start by sending out a message to the window                  case 0:                      base.SendTextToConsole("Waiting for U-Boot bootloader prompt...\r\n");                      mBootStage = 1;                      break;                  // the bootloader should be configured to wait for input:                  case 1:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("Sending kernel now\r\n");                          SendTextToConsole("Filename = '" + mKernelFile + "'\r\n");                          SendRawData("\0loady 0x1000000\r\n");                          mBootStage = 2;                      }                      break;                  case 2:                      if (HandleFileSending(aPacket))                      {                          SendTextToConsole("Done sending kernel file\r\n");                          mBootStage = 4;                      }                      break;                  //case 3:                  //    if (WaitForBootPrompt(aPacket))                  //    {                  //        SendTextToConsole("mw.l 0xFF009000 0x11F8 1\r\n");                  //        SendRawData("mw.l 0xFF009000 0x11F8 1\r\n");                  //        mBootStage = 4;                  //    }                  //    break;                  case 4:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("mw.l 0xFF009000 0x10F8 1\r\n");                          SendRawData("mw.l 0xFF009000 0x10F8 1\r\n");                          mBootStage = 5;                      }                      break;                  case 5:                      if (WaitForBootPrompt(aPacket))                      {                          // now at boot prompt.                          SendTextToConsole("Now starting kernel\r\n");                          mBootStage = 6;                          SendRawData("go 0x1000000\r\n");                      }                      break;                  case 6:                      //if (WaitForBootPrompt(aPacket))                      //{                      //    SendRawData("\0A");                      //}                      base.WaitForSignature(aPacket);                      return;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[1] = mBootPromptCheck[2];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[2] = mBootPromptCheck[3];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[2] = mBootPromptCheck[3];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[3] = mBootPromptCheck[4];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[3] = mBootPromptCheck[4];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[4] = mBootPromptCheck[5];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[4] = mBootPromptCheck[5];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[5] = mBootPromptCheck[6];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[5] = mBootPromptCheck[6];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[6] = aPacket[0];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,HandleFileSending,The following statement contains a magic number: aPacket[0] == 67
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,ConstructNextLargePacket,The following statement contains a magic number: xMS.WriteByte((byte)(255 - mLastPacketIdx));
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,ConstructNextLargePacket,The following statement contains a magic number: var xBuff = new byte[1024];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,ConstructNextLargePacket,The following statement contains a magic number: xMS.WriteByte((byte)(xCrc >> 8));
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,ConstructNullPacket,The following statement contains a magic number: xMS.WriteByte((byte)(255 - mLastPacketIdx));
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,ConstructNullPacket,The following statement contains a magic number: var xBuff = new byte[1024];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,ConstructNullPacket,The following statement contains a magic number: xMS.WriteByte((byte)(xCrc >> 8));
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,Crc16,The following statement contains a magic number: cksum = (ushort)(Crc16Constants[((cksum >> 8) ^ data[i]) & 0xFF] ^ (cksum << 8));
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,Crc16,The following statement contains a magic number: cksum = (ushort)(Crc16Constants[((cksum >> 8) ^ data[i]) & 0xFF] ^ (cksum << 8));
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorPipeServer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorPipeServer.cs,DebugConnectorPipeServer,The following statement contains a magic number: mPipe = new NamedPipeServerStream(aName' PipeDirection.InOut' 1' PipeTransmissionMode.Byte'                                                PipeOptions.None' 1024' 1);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorSerial,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorSerial.cs,DebugConnectorSerial,The following statement contains a magic number: mPort.BaudRate = 115200;
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorSerial,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorSerial.cs,DebugConnectorSerial,The following statement contains a magic number: mPort.DataBits = 8;
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorTCPServer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorTCPServer.cs,DebugConnectorTCPServer,The following statement contains a magic number: var xTCPListener = new TcpListener(IPAddress.Loopback' 4444);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorTestPipeServer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorTestPipeServer.cs,DebugConnectorTestPipeServer,The following statement contains a magic number: mHandle = CreateNamedPipe(@"\\.\pipe\" + aName' 3 | 0x40000000'                                        0'                                        1'                                        1'                                        12'                                        0'                                        IntPtr.Zero                  );
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorTestPipeServer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorTestPipeServer.cs,DebugConnectorTestPipeServer,The following statement contains a magic number: mHandle = CreateNamedPipe(@"\\.\pipe\" + aName' 3 | 0x40000000'                                        0'                                        1'                                        1'                                        12'                                        0'                                        IntPtr.Zero                  );
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorTestPipeServer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorTestPipeServer.cs,InitializeBackground,The following statement contains a magic number: mPipe = new FileStream(mHandle' FileAccess.ReadWrite' 8192' false);
Missing Default,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,D:\research\architectureSmells\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForSignature,The following switch statement is missing a default case: switch (mBootStage)              {                  // start by sending out a message to the window                  case 0:                      base.SendTextToConsole("Waiting for U-Boot bootloader prompt...\r\n");                      mBootStage = 1;                      break;                  // the bootloader should be configured to wait for input:                  case 1:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("Sending kernel now\r\n");                          SendTextToConsole("Filename = '" + mKernelFile + "'\r\n");                          SendRawData("\0loady 0x1000000\r\n");                          mBootStage = 2;                      }                      break;                  case 2:                      if (HandleFileSending(aPacket))                      {                          SendTextToConsole("Done sending kernel file\r\n");                          mBootStage = 4;                      }                      break;                  //case 3:                  //    if (WaitForBootPrompt(aPacket))                  //    {                  //        SendTextToConsole("mw.l 0xFF009000 0x11F8 1\r\n");                  //        SendRawData("mw.l 0xFF009000 0x11F8 1\r\n");                  //        mBootStage = 4;                  //    }                  //    break;                  case 4:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("mw.l 0xFF009000 0x10F8 1\r\n");                          SendRawData("mw.l 0xFF009000 0x10F8 1\r\n");                          mBootStage = 5;                      }                      break;                  case 5:                      if (WaitForBootPrompt(aPacket))                      {                          // now at boot prompt.                          SendTextToConsole("Now starting kernel\r\n");                          mBootStage = 6;                          SendRawData("go 0x1000000\r\n");                      }                      break;                  case 6:                      //if (WaitForBootPrompt(aPacket))                      //{                      //    SendRawData("\0A");                      //}                      base.WaitForSignature(aPacket);                      return;              }
