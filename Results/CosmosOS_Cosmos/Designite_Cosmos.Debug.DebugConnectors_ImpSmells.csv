Implementation smell,Namespace,Class,File,Method,Description
Long Method,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The method has 131 lines of code.
Long Method,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SendCmd,The method has 118 lines of code.
Long Parameter List,Cosmos.Debug.DebugConnectors,DebugConnectorPipeClient,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorPipeClient.cs,PeekNamedPipe,The method has 6 parameters. Parameters: handle' buffer' nBufferSize' bytesRead' bytesAvail' BytesLeftThisMessage
Long Parameter List,Cosmos.Debug.DebugConnectors,DebugConnectorPipeServer,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorPipeServer.cs,PeekNamedPipe,The method has 6 parameters. Parameters: handle' buffer' nBufferSize' bytesRead' bytesAvail' BytesLeftThisMessage
Long Parameter List,Cosmos.Debug.DebugConnectors,DebugConnectorTestPipeServer,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorTestPipeServer.cs,CreateNamedPipe,The method has 8 parameters. Parameters: pipeName' dwOpenMode' dwPipeMode' nMaxInstances' nOutBufferSize' nInBufferSize' nDefaultTimeOut' lpSecurityAttributes
Long Statement,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The length of the statement  "            //DoDebugMsg(String.Format("DC - PacketMsg: {0}"' DebugConnectorStreamWithTimeouts.BytesToString(aPacket' 0' aPacket.Length))); " is 127.
Complex Conditional,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SendCmd,The conditional expression  "(!resetID && lastCmdCompletedID < mCommandID)                                          || (resetID && lastCmdCompletedID > 5)"  is complex.
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketMsg,The following statement contains a magic number: switch (mCurrentMsgType)              {                  case Ds2Vs.TracePoint:                      DebugLog("DC Recv: TracePoint");                      Next(4' PacketTracePoint);                      break;                    case Ds2Vs.BreakPoint:                      DebugLog("DC Recv: BreakPoint");                      Next(4' PacketBreakPoint);                      break;                    case Ds2Vs.Message:                      DebugLog("DC Recv: Message");                      Next(2' PacketTextSize);                      break;                    case Ds2Vs.MessageBox:                      DebugLog("DC Recv: MessageBox");                      Next(2' PacketMessageBoxTextSize);                      break;                    case Ds2Vs.Started:                      DebugLog("DC Recv: Started");                      // Call WaitForMessage first' else it blocks because Ds2Vs.Started triggers                      // other commands which need responses.                      WaitForMessage();                        // Guests never get the first byte sent. So we send a noop.                      // This dummy byte seems to clear out the serial channel.                      // Its never received' but if it ever is' its a noop anyways.                      SendCmd(Vs2Ds.Noop);                        // Send signature                      var xData = new byte[4];                      Array.Copy(BitConverter.GetBytes(Consts.SerialSignature)' 0' xData' 0' 4);                      SendRawData(xData);                        CmdStarted();                      break;                    case Ds2Vs.Noop:                      DebugLog("DC Recv: Noop");                      // MtW: When implementing Serial support for debugging on real hardware' it appears                      //      that when booting a machine' in the bios it emits zero's to the serial port.                      // Kudzu: Made a Noop command to handle this                      WaitForMessage();                      break;                    case Ds2Vs.CmdCompleted:                      DebugLog("DC Recv: CmdCompleted");                      Next(1' PacketCmdCompleted);                      break;                    case Ds2Vs.MethodContext:                      DebugLog("DC Recv: MethodContext");                      Next(mDataSize' PacketMethodContext);                      break;                    case Ds2Vs.MemoryData:                      DebugLog("DC Recv: MemoryData");                      Next(mDataSize' PacketMemoryData);                      break;                    case Ds2Vs.Registers:                      DebugLog("DC Recv: Registers");                      Next(40' PacketRegisters);                      break;                    case Ds2Vs.Frame:                      DebugLog("DC Recv: Frame");                      Next(-1' PacketFrame);                      break;                    case Ds2Vs.Stack:                      DebugLog("DC Recv: Stack");                      Next(-1' PacketStack);                      break;                    case Ds2Vs.Pong:                      DebugLog("DC Recv: Pong");                      Next(0' PacketPong);                      break;                    case Ds2Vs.StackCorruptionOccurred:                      DebugLog("DC Recv: StackCorruptionOccurred");                      Next(4' PacketStackCorruptionOccurred);                      break;                    case Ds2Vs.StackOverflowOccurred:                      DebugLog("DC Recv: StackOverflowOccurred");                      Next(4' PacketStackOverflowOccurred);                      break;                    case Ds2Vs.InterruptOccurred:                      DebugLog("DC Recv: InterruptOccurred");                      Next(4' PacketInterruptOccurred);                      break;                    case Ds2Vs.NullReferenceOccurred:                      DebugLog("DC Recv: NullReferenceOccurred");                      Next(4' PacketNullReferenceOccurred);                      break;                    case Ds2Vs.SimpleNumber:                      DebugLog("DC Recv: SimpleNumber");                      Next(4' PacketSimpleNumber);                      break;                    case Ds2Vs.KernelPanic:                      DebugLog("DC Recv: KernelPanic");                      Next(4' PacketKernelPanic);                      break;                    case Ds2Vs.SimpleLongNumber:                      DebugLog("DC Recv: SimpleLongNumber");                      Next(8' PacketSimpleLongNumber);                      break;                    case Ds2Vs.ComplexNumber:                      DebugLog("DC Recv: ComplexNumber");                      Next(4' PacketComplexNumber);                      break;                    case Ds2Vs.ComplexLongNumber:                      DebugLog("DC Recv: ComplexLongNumber");                      Next(8' PacketComplexLongNumber);                      break;                    case Ds2Vs.CoreDump:                      DebugLog("DC Recv: CoreDump");                      Next(-1' PacketCoreDump);                      break;                    default:                      if (mCurrentMsgType > 128)                      {                          // other channels than debugstub                          DebugLog("DC Recv: Console");                          // copy to local variable' so the anonymous method will get the correct value!                          var xChannel = mCurrentMsgType;                          Next(1' data => PacketOtherChannelCommand(xChannel' data));                          break;                      }                      // Exceptions crash VS so use MsgBox instead                      DebugLog("Unknown debug command: " + mCurrentMsgType);                      // Despite it being unkonwn' we try again. Normally this will                      // just cause more unknowns' but can be useful for debugging.                      WaitForMessage();                      break;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,WaitForSignature,The following statement contains a magic number: mSigCheck[1] = mSigCheck[2];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,WaitForSignature,The following statement contains a magic number: mSigCheck[2] = mSigCheck[3];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,WaitForSignature,The following statement contains a magic number: mSigCheck[2] = mSigCheck[3];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,WaitForSignature,The following statement contains a magic number: mSigCheck[3] = aPacket[0];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SendPacketToConsole,The following statement contains a magic number: CmdChannel(129' 0' aPacket);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SetBreakpoint,The following statement contains a magic number: var xData = new byte[5];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SetBreakpoint,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(aAddress)' 0' xData' 0' 4);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SetBreakpoint,The following statement contains a magic number: xData[4] = (byte)aID;
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,GetMemoryData,The following statement contains a magic number: if (!IsConnected)              {                  return null;              }              else if (size == 0)              {                  // no point in retrieving 0 bytes' better not request at all. also' debugstub "crashes" then                  throw new NotSupportedException("Requested memory data of size = 0");              }              else if (size > 512)              {                  // for now refuse to retrieve large amounts of data:                  throw new NotSupportedException("Too large amount of data requested");              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,GetMemoryData,The following statement contains a magic number: var xData = new byte[8];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,GetMemoryData,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(address)' 0' xData' 0' 4);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,GetMemoryData,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(size)' 0' xData' 4' 4);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,GetMemoryData,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(size)' 0' xData' 4' 4);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,GetStackData,The following statement contains a magic number: var xData = new byte[8];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,GetStackData,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(offsetToEBP)' 0' xData' 0' 4);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,GetStackData,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(size)' 0' xData' 4' 4);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,GetStackData,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(size)' 0' xData' 4' 4);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,BytesToString,The following statement contains a magic number: if (count > 100 || count <= 0 || bytes.Length == 0)              {                  return String.Empty;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,BytesToString,The following statement contains a magic number: var xSB = new StringBuilder(2 + (bytes.Length * 2));
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,BytesToString,The following statement contains a magic number: var xSB = new StringBuilder(2 + (bytes.Length * 2));
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,PacketOtherChannelCommand,The following statement contains a magic number: Next(4' data => PacketOtherChannelSize(aChannel' aPacket[0]' data));
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SizePacket,The following statement contains a magic number: int xSize = aPacket[0] + (aPacket[1] << 8);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,RawSendHelper,The following statement contains a magic number: if (aWait)              {                  using (var xEvent = new ManualResetEventSlim(false))                  {                      mPendingWrites.Add(new Outgoing {Packet = aData' Completed = xEvent});                      while (IsConnected)                      {                          if (xEvent.Wait(25))                          {                              break;                          }                      }                      return IsConnected; // ??                  }              }              else              {                  mPendingWrites.Add(new Outgoing {Packet = aData});                  return true;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SendCmd,The following statement contains a magic number: if (SigReceived)              {                  // This lock is used for:                  //  1) VSDebugEngine is threaded and could send commands concurrently                  //  2) Becuase in VSDebugEngine and commands from Debug.Windows can occur concurrently                  lock (mSendCmdLock)                  {                      try                      {                          // for debug:                          mCurrentSendingCmd = aCmd;                          mCurrentSendingData = aData;                          mCurrentSendingStackTrace = Environment.StackTrace;                          // end - for debug                              DebugLog("DC Send: " + aCmd.ToString() + "' data.Length = " + aData.Length + "' aWait = " + aWait);                          DebugLog("Send locked...");                          if (IsInBackgroundThread)                          {                              DebugLog("In background thread already");                          }                            BeforeSendCmd();                            if (aCmd == Vs2Ds.Noop)                          {                              // Noops dont have any data.                              // This is becuase Noops are used to clear out the                              // channel and are often not received. Sending noop + data                              // usually causes the data to be interpreted as a command                              // as its often the first byte received.                                RawSendHelper(new byte[1]                                            {                                                Vs2Ds.Noop                                            }' aWait);                          }                          else                          {                              // +2 - Leave room for Cmd and CmdID                              var xData = new byte[aData.Length + 2];                              // See comments about flow control in the DebugStub class                              // to see why we limit to 16.                              if (aData.Length > 16)                              {                                  throw new Exception("Command is too large. 16 bytes max.");                              }                                xData[0] = (byte)aCmd;                              aData.CopyTo(xData' 2);                                bool resetID = false;                              if (mCommandID == 255)                              {                                  mCommandID = 0;                                  resetID = true;                              }                              else                              {                                  mCommandID++;                              }                              xData[1] = mCommandID;                              mCurrCmdID = mCommandID;                                if (RawSendHelper(xData' aWait))                              {                                  if (aWait)                                  {                                      // All commands except NOOP reply back from the DebugStub                                      // with an ACK. The ACK will set the event and allow us to proceed.                                      // This wait causes this method to wait on the ACK to be receive back from                                      // DebugStub.                                        //Sometimes we get out of sync or recieve something we aren't expecting                                      //So this forces us to only return when we are back in-sync or after we think we've frozen the system for                                      //too long                                      //If we haven't gone past the command already!                                      if ((!resetID && lastCmdCompletedID < mCommandID)                                          || (resetID && lastCmdCompletedID > 5))                                      {                                          int attempts = 0;                                          do                                          {                                              mCmdWait.WaitOne(200 /*60000*/);                                                if (IsInBackgroundThread)                                              {                                                  // we're running inside our message loop (see ThreadMethod). Which means we need to kick it off once' to allow                                                  // it to read new stuff.                                                  ProcessPendingActions();                                              }                                          }                                          while ((                                                     (!resetID && lastCmdCompletedID < mCommandID) ||                                                     (resetID && lastCmdCompletedID > 5)                                                 )                                                 &&                                                 ++attempts < 100);                                      }                                  }                              }                          }                      }                      finally                      {                          mCurrentSendingCmd = null;                          mCurrentSendingData = null;                          mCurrentSendingStackTrace = null;                      }                  }                    DebugLog("Send unlocked.");              }              else              {                  DebugLog("Tried to send command " + aCmd + "' but signature was not yet received!");              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SendCmd,The following statement contains a magic number: if (SigReceived)              {                  // This lock is used for:                  //  1) VSDebugEngine is threaded and could send commands concurrently                  //  2) Becuase in VSDebugEngine and commands from Debug.Windows can occur concurrently                  lock (mSendCmdLock)                  {                      try                      {                          // for debug:                          mCurrentSendingCmd = aCmd;                          mCurrentSendingData = aData;                          mCurrentSendingStackTrace = Environment.StackTrace;                          // end - for debug                              DebugLog("DC Send: " + aCmd.ToString() + "' data.Length = " + aData.Length + "' aWait = " + aWait);                          DebugLog("Send locked...");                          if (IsInBackgroundThread)                          {                              DebugLog("In background thread already");                          }                            BeforeSendCmd();                            if (aCmd == Vs2Ds.Noop)                          {                              // Noops dont have any data.                              // This is becuase Noops are used to clear out the                              // channel and are often not received. Sending noop + data                              // usually causes the data to be interpreted as a command                              // as its often the first byte received.                                RawSendHelper(new byte[1]                                            {                                                Vs2Ds.Noop                                            }' aWait);                          }                          else                          {                              // +2 - Leave room for Cmd and CmdID                              var xData = new byte[aData.Length + 2];                              // See comments about flow control in the DebugStub class                              // to see why we limit to 16.                              if (aData.Length > 16)                              {                                  throw new Exception("Command is too large. 16 bytes max.");                              }                                xData[0] = (byte)aCmd;                              aData.CopyTo(xData' 2);                                bool resetID = false;                              if (mCommandID == 255)                              {                                  mCommandID = 0;                                  resetID = true;                              }                              else                              {                                  mCommandID++;                              }                              xData[1] = mCommandID;                              mCurrCmdID = mCommandID;                                if (RawSendHelper(xData' aWait))                              {                                  if (aWait)                                  {                                      // All commands except NOOP reply back from the DebugStub                                      // with an ACK. The ACK will set the event and allow us to proceed.                                      // This wait causes this method to wait on the ACK to be receive back from                                      // DebugStub.                                        //Sometimes we get out of sync or recieve something we aren't expecting                                      //So this forces us to only return when we are back in-sync or after we think we've frozen the system for                                      //too long                                      //If we haven't gone past the command already!                                      if ((!resetID && lastCmdCompletedID < mCommandID)                                          || (resetID && lastCmdCompletedID > 5))                                      {                                          int attempts = 0;                                          do                                          {                                              mCmdWait.WaitOne(200 /*60000*/);                                                if (IsInBackgroundThread)                                              {                                                  // we're running inside our message loop (see ThreadMethod). Which means we need to kick it off once' to allow                                                  // it to read new stuff.                                                  ProcessPendingActions();                                              }                                          }                                          while ((                                                     (!resetID && lastCmdCompletedID < mCommandID) ||                                                     (resetID && lastCmdCompletedID > 5)                                                 )                                                 &&                                                 ++attempts < 100);                                      }                                  }                              }                          }                      }                      finally                      {                          mCurrentSendingCmd = null;                          mCurrentSendingData = null;                          mCurrentSendingStackTrace = null;                      }                  }                    DebugLog("Send unlocked.");              }              else              {                  DebugLog("Tried to send command " + aCmd + "' but signature was not yet received!");              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SendCmd,The following statement contains a magic number: if (SigReceived)              {                  // This lock is used for:                  //  1) VSDebugEngine is threaded and could send commands concurrently                  //  2) Becuase in VSDebugEngine and commands from Debug.Windows can occur concurrently                  lock (mSendCmdLock)                  {                      try                      {                          // for debug:                          mCurrentSendingCmd = aCmd;                          mCurrentSendingData = aData;                          mCurrentSendingStackTrace = Environment.StackTrace;                          // end - for debug                              DebugLog("DC Send: " + aCmd.ToString() + "' data.Length = " + aData.Length + "' aWait = " + aWait);                          DebugLog("Send locked...");                          if (IsInBackgroundThread)                          {                              DebugLog("In background thread already");                          }                            BeforeSendCmd();                            if (aCmd == Vs2Ds.Noop)                          {                              // Noops dont have any data.                              // This is becuase Noops are used to clear out the                              // channel and are often not received. Sending noop + data                              // usually causes the data to be interpreted as a command                              // as its often the first byte received.                                RawSendHelper(new byte[1]                                            {                                                Vs2Ds.Noop                                            }' aWait);                          }                          else                          {                              // +2 - Leave room for Cmd and CmdID                              var xData = new byte[aData.Length + 2];                              // See comments about flow control in the DebugStub class                              // to see why we limit to 16.                              if (aData.Length > 16)                              {                                  throw new Exception("Command is too large. 16 bytes max.");                              }                                xData[0] = (byte)aCmd;                              aData.CopyTo(xData' 2);                                bool resetID = false;                              if (mCommandID == 255)                              {                                  mCommandID = 0;                                  resetID = true;                              }                              else                              {                                  mCommandID++;                              }                              xData[1] = mCommandID;                              mCurrCmdID = mCommandID;                                if (RawSendHelper(xData' aWait))                              {                                  if (aWait)                                  {                                      // All commands except NOOP reply back from the DebugStub                                      // with an ACK. The ACK will set the event and allow us to proceed.                                      // This wait causes this method to wait on the ACK to be receive back from                                      // DebugStub.                                        //Sometimes we get out of sync or recieve something we aren't expecting                                      //So this forces us to only return when we are back in-sync or after we think we've frozen the system for                                      //too long                                      //If we haven't gone past the command already!                                      if ((!resetID && lastCmdCompletedID < mCommandID)                                          || (resetID && lastCmdCompletedID > 5))                                      {                                          int attempts = 0;                                          do                                          {                                              mCmdWait.WaitOne(200 /*60000*/);                                                if (IsInBackgroundThread)                                              {                                                  // we're running inside our message loop (see ThreadMethod). Which means we need to kick it off once' to allow                                                  // it to read new stuff.                                                  ProcessPendingActions();                                              }                                          }                                          while ((                                                     (!resetID && lastCmdCompletedID < mCommandID) ||                                                     (resetID && lastCmdCompletedID > 5)                                                 )                                                 &&                                                 ++attempts < 100);                                      }                                  }                              }                          }                      }                      finally                      {                          mCurrentSendingCmd = null;                          mCurrentSendingData = null;                          mCurrentSendingStackTrace = null;                      }                  }                    DebugLog("Send unlocked.");              }              else              {                  DebugLog("Tried to send command " + aCmd + "' but signature was not yet received!");              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SendCmd,The following statement contains a magic number: if (SigReceived)              {                  // This lock is used for:                  //  1) VSDebugEngine is threaded and could send commands concurrently                  //  2) Becuase in VSDebugEngine and commands from Debug.Windows can occur concurrently                  lock (mSendCmdLock)                  {                      try                      {                          // for debug:                          mCurrentSendingCmd = aCmd;                          mCurrentSendingData = aData;                          mCurrentSendingStackTrace = Environment.StackTrace;                          // end - for debug                              DebugLog("DC Send: " + aCmd.ToString() + "' data.Length = " + aData.Length + "' aWait = " + aWait);                          DebugLog("Send locked...");                          if (IsInBackgroundThread)                          {                              DebugLog("In background thread already");                          }                            BeforeSendCmd();                            if (aCmd == Vs2Ds.Noop)                          {                              // Noops dont have any data.                              // This is becuase Noops are used to clear out the                              // channel and are often not received. Sending noop + data                              // usually causes the data to be interpreted as a command                              // as its often the first byte received.                                RawSendHelper(new byte[1]                                            {                                                Vs2Ds.Noop                                            }' aWait);                          }                          else                          {                              // +2 - Leave room for Cmd and CmdID                              var xData = new byte[aData.Length + 2];                              // See comments about flow control in the DebugStub class                              // to see why we limit to 16.                              if (aData.Length > 16)                              {                                  throw new Exception("Command is too large. 16 bytes max.");                              }                                xData[0] = (byte)aCmd;                              aData.CopyTo(xData' 2);                                bool resetID = false;                              if (mCommandID == 255)                              {                                  mCommandID = 0;                                  resetID = true;                              }                              else                              {                                  mCommandID++;                              }                              xData[1] = mCommandID;                              mCurrCmdID = mCommandID;                                if (RawSendHelper(xData' aWait))                              {                                  if (aWait)                                  {                                      // All commands except NOOP reply back from the DebugStub                                      // with an ACK. The ACK will set the event and allow us to proceed.                                      // This wait causes this method to wait on the ACK to be receive back from                                      // DebugStub.                                        //Sometimes we get out of sync or recieve something we aren't expecting                                      //So this forces us to only return when we are back in-sync or after we think we've frozen the system for                                      //too long                                      //If we haven't gone past the command already!                                      if ((!resetID && lastCmdCompletedID < mCommandID)                                          || (resetID && lastCmdCompletedID > 5))                                      {                                          int attempts = 0;                                          do                                          {                                              mCmdWait.WaitOne(200 /*60000*/);                                                if (IsInBackgroundThread)                                              {                                                  // we're running inside our message loop (see ThreadMethod). Which means we need to kick it off once' to allow                                                  // it to read new stuff.                                                  ProcessPendingActions();                                              }                                          }                                          while ((                                                     (!resetID && lastCmdCompletedID < mCommandID) ||                                                     (resetID && lastCmdCompletedID > 5)                                                 )                                                 &&                                                 ++attempts < 100);                                      }                                  }                              }                          }                      }                      finally                      {                          mCurrentSendingCmd = null;                          mCurrentSendingData = null;                          mCurrentSendingStackTrace = null;                      }                  }                    DebugLog("Send unlocked.");              }              else              {                  DebugLog("Tried to send command " + aCmd + "' but signature was not yet received!");              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SendCmd,The following statement contains a magic number: if (SigReceived)              {                  // This lock is used for:                  //  1) VSDebugEngine is threaded and could send commands concurrently                  //  2) Becuase in VSDebugEngine and commands from Debug.Windows can occur concurrently                  lock (mSendCmdLock)                  {                      try                      {                          // for debug:                          mCurrentSendingCmd = aCmd;                          mCurrentSendingData = aData;                          mCurrentSendingStackTrace = Environment.StackTrace;                          // end - for debug                              DebugLog("DC Send: " + aCmd.ToString() + "' data.Length = " + aData.Length + "' aWait = " + aWait);                          DebugLog("Send locked...");                          if (IsInBackgroundThread)                          {                              DebugLog("In background thread already");                          }                            BeforeSendCmd();                            if (aCmd == Vs2Ds.Noop)                          {                              // Noops dont have any data.                              // This is becuase Noops are used to clear out the                              // channel and are often not received. Sending noop + data                              // usually causes the data to be interpreted as a command                              // as its often the first byte received.                                RawSendHelper(new byte[1]                                            {                                                Vs2Ds.Noop                                            }' aWait);                          }                          else                          {                              // +2 - Leave room for Cmd and CmdID                              var xData = new byte[aData.Length + 2];                              // See comments about flow control in the DebugStub class                              // to see why we limit to 16.                              if (aData.Length > 16)                              {                                  throw new Exception("Command is too large. 16 bytes max.");                              }                                xData[0] = (byte)aCmd;                              aData.CopyTo(xData' 2);                                bool resetID = false;                              if (mCommandID == 255)                              {                                  mCommandID = 0;                                  resetID = true;                              }                              else                              {                                  mCommandID++;                              }                              xData[1] = mCommandID;                              mCurrCmdID = mCommandID;                                if (RawSendHelper(xData' aWait))                              {                                  if (aWait)                                  {                                      // All commands except NOOP reply back from the DebugStub                                      // with an ACK. The ACK will set the event and allow us to proceed.                                      // This wait causes this method to wait on the ACK to be receive back from                                      // DebugStub.                                        //Sometimes we get out of sync or recieve something we aren't expecting                                      //So this forces us to only return when we are back in-sync or after we think we've frozen the system for                                      //too long                                      //If we haven't gone past the command already!                                      if ((!resetID && lastCmdCompletedID < mCommandID)                                          || (resetID && lastCmdCompletedID > 5))                                      {                                          int attempts = 0;                                          do                                          {                                              mCmdWait.WaitOne(200 /*60000*/);                                                if (IsInBackgroundThread)                                              {                                                  // we're running inside our message loop (see ThreadMethod). Which means we need to kick it off once' to allow                                                  // it to read new stuff.                                                  ProcessPendingActions();                                              }                                          }                                          while ((                                                     (!resetID && lastCmdCompletedID < mCommandID) ||                                                     (resetID && lastCmdCompletedID > 5)                                                 )                                                 &&                                                 ++attempts < 100);                                      }                                  }                              }                          }                      }                      finally                      {                          mCurrentSendingCmd = null;                          mCurrentSendingData = null;                          mCurrentSendingStackTrace = null;                      }                  }                    DebugLog("Send unlocked.");              }              else              {                  DebugLog("Tried to send command " + aCmd + "' but signature was not yet received!");              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SendCmd,The following statement contains a magic number: if (SigReceived)              {                  // This lock is used for:                  //  1) VSDebugEngine is threaded and could send commands concurrently                  //  2) Becuase in VSDebugEngine and commands from Debug.Windows can occur concurrently                  lock (mSendCmdLock)                  {                      try                      {                          // for debug:                          mCurrentSendingCmd = aCmd;                          mCurrentSendingData = aData;                          mCurrentSendingStackTrace = Environment.StackTrace;                          // end - for debug                              DebugLog("DC Send: " + aCmd.ToString() + "' data.Length = " + aData.Length + "' aWait = " + aWait);                          DebugLog("Send locked...");                          if (IsInBackgroundThread)                          {                              DebugLog("In background thread already");                          }                            BeforeSendCmd();                            if (aCmd == Vs2Ds.Noop)                          {                              // Noops dont have any data.                              // This is becuase Noops are used to clear out the                              // channel and are often not received. Sending noop + data                              // usually causes the data to be interpreted as a command                              // as its often the first byte received.                                RawSendHelper(new byte[1]                                            {                                                Vs2Ds.Noop                                            }' aWait);                          }                          else                          {                              // +2 - Leave room for Cmd and CmdID                              var xData = new byte[aData.Length + 2];                              // See comments about flow control in the DebugStub class                              // to see why we limit to 16.                              if (aData.Length > 16)                              {                                  throw new Exception("Command is too large. 16 bytes max.");                              }                                xData[0] = (byte)aCmd;                              aData.CopyTo(xData' 2);                                bool resetID = false;                              if (mCommandID == 255)                              {                                  mCommandID = 0;                                  resetID = true;                              }                              else                              {                                  mCommandID++;                              }                              xData[1] = mCommandID;                              mCurrCmdID = mCommandID;                                if (RawSendHelper(xData' aWait))                              {                                  if (aWait)                                  {                                      // All commands except NOOP reply back from the DebugStub                                      // with an ACK. The ACK will set the event and allow us to proceed.                                      // This wait causes this method to wait on the ACK to be receive back from                                      // DebugStub.                                        //Sometimes we get out of sync or recieve something we aren't expecting                                      //So this forces us to only return when we are back in-sync or after we think we've frozen the system for                                      //too long                                      //If we haven't gone past the command already!                                      if ((!resetID && lastCmdCompletedID < mCommandID)                                          || (resetID && lastCmdCompletedID > 5))                                      {                                          int attempts = 0;                                          do                                          {                                              mCmdWait.WaitOne(200 /*60000*/);                                                if (IsInBackgroundThread)                                              {                                                  // we're running inside our message loop (see ThreadMethod). Which means we need to kick it off once' to allow                                                  // it to read new stuff.                                                  ProcessPendingActions();                                              }                                          }                                          while ((                                                     (!resetID && lastCmdCompletedID < mCommandID) ||                                                     (resetID && lastCmdCompletedID > 5)                                                 )                                                 &&                                                 ++attempts < 100);                                      }                                  }                              }                          }                      }                      finally                      {                          mCurrentSendingCmd = null;                          mCurrentSendingData = null;                          mCurrentSendingStackTrace = null;                      }                  }                    DebugLog("Send unlocked.");              }              else              {                  DebugLog("Tried to send command " + aCmd + "' but signature was not yet received!");              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SendCmd,The following statement contains a magic number: if (SigReceived)              {                  // This lock is used for:                  //  1) VSDebugEngine is threaded and could send commands concurrently                  //  2) Becuase in VSDebugEngine and commands from Debug.Windows can occur concurrently                  lock (mSendCmdLock)                  {                      try                      {                          // for debug:                          mCurrentSendingCmd = aCmd;                          mCurrentSendingData = aData;                          mCurrentSendingStackTrace = Environment.StackTrace;                          // end - for debug                              DebugLog("DC Send: " + aCmd.ToString() + "' data.Length = " + aData.Length + "' aWait = " + aWait);                          DebugLog("Send locked...");                          if (IsInBackgroundThread)                          {                              DebugLog("In background thread already");                          }                            BeforeSendCmd();                            if (aCmd == Vs2Ds.Noop)                          {                              // Noops dont have any data.                              // This is becuase Noops are used to clear out the                              // channel and are often not received. Sending noop + data                              // usually causes the data to be interpreted as a command                              // as its often the first byte received.                                RawSendHelper(new byte[1]                                            {                                                Vs2Ds.Noop                                            }' aWait);                          }                          else                          {                              // +2 - Leave room for Cmd and CmdID                              var xData = new byte[aData.Length + 2];                              // See comments about flow control in the DebugStub class                              // to see why we limit to 16.                              if (aData.Length > 16)                              {                                  throw new Exception("Command is too large. 16 bytes max.");                              }                                xData[0] = (byte)aCmd;                              aData.CopyTo(xData' 2);                                bool resetID = false;                              if (mCommandID == 255)                              {                                  mCommandID = 0;                                  resetID = true;                              }                              else                              {                                  mCommandID++;                              }                              xData[1] = mCommandID;                              mCurrCmdID = mCommandID;                                if (RawSendHelper(xData' aWait))                              {                                  if (aWait)                                  {                                      // All commands except NOOP reply back from the DebugStub                                      // with an ACK. The ACK will set the event and allow us to proceed.                                      // This wait causes this method to wait on the ACK to be receive back from                                      // DebugStub.                                        //Sometimes we get out of sync or recieve something we aren't expecting                                      //So this forces us to only return when we are back in-sync or after we think we've frozen the system for                                      //too long                                      //If we haven't gone past the command already!                                      if ((!resetID && lastCmdCompletedID < mCommandID)                                          || (resetID && lastCmdCompletedID > 5))                                      {                                          int attempts = 0;                                          do                                          {                                              mCmdWait.WaitOne(200 /*60000*/);                                                if (IsInBackgroundThread)                                              {                                                  // we're running inside our message loop (see ThreadMethod). Which means we need to kick it off once' to allow                                                  // it to read new stuff.                                                  ProcessPendingActions();                                              }                                          }                                          while ((                                                     (!resetID && lastCmdCompletedID < mCommandID) ||                                                     (resetID && lastCmdCompletedID > 5)                                                 )                                                 &&                                                 ++attempts < 100);                                      }                                  }                              }                          }                      }                      finally                      {                          mCurrentSendingCmd = null;                          mCurrentSendingData = null;                          mCurrentSendingStackTrace = null;                      }                  }                    DebugLog("Send unlocked.");              }              else              {                  DebugLog("Tried to send command " + aCmd + "' but signature was not yet received!");              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,SendCmd,The following statement contains a magic number: if (SigReceived)              {                  // This lock is used for:                  //  1) VSDebugEngine is threaded and could send commands concurrently                  //  2) Becuase in VSDebugEngine and commands from Debug.Windows can occur concurrently                  lock (mSendCmdLock)                  {                      try                      {                          // for debug:                          mCurrentSendingCmd = aCmd;                          mCurrentSendingData = aData;                          mCurrentSendingStackTrace = Environment.StackTrace;                          // end - for debug                              DebugLog("DC Send: " + aCmd.ToString() + "' data.Length = " + aData.Length + "' aWait = " + aWait);                          DebugLog("Send locked...");                          if (IsInBackgroundThread)                          {                              DebugLog("In background thread already");                          }                            BeforeSendCmd();                            if (aCmd == Vs2Ds.Noop)                          {                              // Noops dont have any data.                              // This is becuase Noops are used to clear out the                              // channel and are often not received. Sending noop + data                              // usually causes the data to be interpreted as a command                              // as its often the first byte received.                                RawSendHelper(new byte[1]                                            {                                                Vs2Ds.Noop                                            }' aWait);                          }                          else                          {                              // +2 - Leave room for Cmd and CmdID                              var xData = new byte[aData.Length + 2];                              // See comments about flow control in the DebugStub class                              // to see why we limit to 16.                              if (aData.Length > 16)                              {                                  throw new Exception("Command is too large. 16 bytes max.");                              }                                xData[0] = (byte)aCmd;                              aData.CopyTo(xData' 2);                                bool resetID = false;                              if (mCommandID == 255)                              {                                  mCommandID = 0;                                  resetID = true;                              }                              else                              {                                  mCommandID++;                              }                              xData[1] = mCommandID;                              mCurrCmdID = mCommandID;                                if (RawSendHelper(xData' aWait))                              {                                  if (aWait)                                  {                                      // All commands except NOOP reply back from the DebugStub                                      // with an ACK. The ACK will set the event and allow us to proceed.                                      // This wait causes this method to wait on the ACK to be receive back from                                      // DebugStub.                                        //Sometimes we get out of sync or recieve something we aren't expecting                                      //So this forces us to only return when we are back in-sync or after we think we've frozen the system for                                      //too long                                      //If we haven't gone past the command already!                                      if ((!resetID && lastCmdCompletedID < mCommandID)                                          || (resetID && lastCmdCompletedID > 5))                                      {                                          int attempts = 0;                                          do                                          {                                              mCmdWait.WaitOne(200 /*60000*/);                                                if (IsInBackgroundThread)                                              {                                                  // we're running inside our message loop (see ThreadMethod). Which means we need to kick it off once' to allow                                                  // it to read new stuff.                                                  ProcessPendingActions();                                              }                                          }                                          while ((                                                     (!resetID && lastCmdCompletedID < mCommandID) ||                                                     (resetID && lastCmdCompletedID > 5)                                                 )                                                 &&                                                 ++attempts < 100);                                      }                                  }                              }                          }                      }                      finally                      {                          mCurrentSendingCmd = null;                          mCurrentSendingData = null;                          mCurrentSendingStackTrace = null;                      }                  }                    DebugLog("Send unlocked.");              }              else              {                  DebugLog("Tried to send command " + aCmd + "' but signature was not yet received!");              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,Next,The following statement contains a magic number: if (aPacketSize == 0)              {                  // Can occur with variable size packets for exampmle.                  // Dont call read' becuase that will close the stream.                  // So we just call the Completed directly                  aCompleted(new byte[0]);                  return;              }              else if (aPacketSize == -1)              {                  // Variable size packet' split into two reads                  mCompletedAfterSize = aCompleted;                  aPacketSize = 2;                  xIncoming.Completed = SizePacket;              }              else              {                  xIncoming.Completed = bytes =>                  {                      DebugLog(String.Format("DC - Received: 0x{0}"' BytesToString(bytes' 0' bytes.Length)));                      try                      {                          aCompleted(bytes);                      }                      catch (Exception E)                      {                          HandleError(E);                      }                  };              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,Next,The following statement contains a magic number: if (aPacketSize > (1024 * 1024))              {                  throw new Exception("Safety exception. Receiving " + aPacketSize + " bytes!");              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,Next,The following statement contains a magic number: if (aPacketSize > (1024 * 1024))              {                  throw new Exception("Safety exception. Receiving " + aPacketSize + " bytes!");              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,ProcessPendingActions,The following statement contains a magic number: if (xPendingRead != null || mPendingReads.TryTake(out xPendingRead' 5))              {                  var xNrOfBytesToRead = xPendingRead.Packet.Length - xPendingRead.CurrentPos;                  var xBytesRead = TryRead(xPendingRead.Packet' xPendingRead.CurrentPos' xNrOfBytesToRead' 5);                    xPendingRead.CurrentPos += xBytesRead;                    if (xPendingRead.CurrentPos == xPendingRead.Packet.Length)                  {                      // Full packet received' process it                      xPendingRead.Completed(xPendingRead.Packet);                      mIncompletePendingRead = null;                  }                  else                  {                      mIncompletePendingRead = xPendingRead;                  }              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,ProcessPendingActions,The following statement contains a magic number: if (xPendingRead != null || mPendingReads.TryTake(out xPendingRead' 5))              {                  var xNrOfBytesToRead = xPendingRead.Packet.Length - xPendingRead.CurrentPos;                  var xBytesRead = TryRead(xPendingRead.Packet' xPendingRead.CurrentPos' xNrOfBytesToRead' 5);                    xPendingRead.CurrentPos += xBytesRead;                    if (xPendingRead.CurrentPos == xPendingRead.Packet.Length)                  {                      // Full packet received' process it                      xPendingRead.Completed(xPendingRead.Packet);                      mIncompletePendingRead = null;                  }                  else                  {                      mIncompletePendingRead = xPendingRead;                  }              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnector,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnector.cs,ProcessPendingActions,The following statement contains a magic number: if (mPendingWrites.TryTake(out xPendingWrite' 5))              {                  if (!SendRawData(xPendingWrite.Packet))                  {                      throw new Exception("SendRawData returned false!");                  }                  if (xPendingWrite.Completed != null)                  {                      xPendingWrite.Completed.Set();                  }              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForSignature,The following statement contains a magic number: switch (mBootStage)              {                  // start by sending out a message to the window                  case 0:                      base.SendTextToConsole("Waiting for U-Boot bootloader prompt...\r\n");                      mBootStage = 1;                      break;                  // the bootloader should be configured to wait for input:                  case 1:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("Sending kernel now\r\n");                          SendTextToConsole("Filename = '" + mKernelFile + "'\r\n");                          SendRawData("\0loady 0x1000000\r\n");                          mBootStage = 2;                      }                      break;                  case 2:                      if (HandleFileSending(aPacket))                      {                          SendTextToConsole("Done sending kernel file\r\n");                          mBootStage = 4;                      }                      break;                  //case 3:                  //    if (WaitForBootPrompt(aPacket))                  //    {                  //        SendTextToConsole("mw.l 0xFF009000 0x11F8 1\r\n");                  //        SendRawData("mw.l 0xFF009000 0x11F8 1\r\n");                  //        mBootStage = 4;                  //    }                  //    break;                  case 4:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("mw.l 0xFF009000 0x10F8 1\r\n");                          SendRawData("mw.l 0xFF009000 0x10F8 1\r\n");                          mBootStage = 5;                      }                      break;                  case 5:                      if (WaitForBootPrompt(aPacket))                      {                          // now at boot prompt.                          SendTextToConsole("Now starting kernel\r\n");                          mBootStage = 6;                          SendRawData("go 0x1000000\r\n");                      }                      break;                  case 6:                      //if (WaitForBootPrompt(aPacket))                      //{                      //    SendRawData("\0A");                      //}                      base.WaitForSignature(aPacket);                      return;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForSignature,The following statement contains a magic number: switch (mBootStage)              {                  // start by sending out a message to the window                  case 0:                      base.SendTextToConsole("Waiting for U-Boot bootloader prompt...\r\n");                      mBootStage = 1;                      break;                  // the bootloader should be configured to wait for input:                  case 1:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("Sending kernel now\r\n");                          SendTextToConsole("Filename = '" + mKernelFile + "'\r\n");                          SendRawData("\0loady 0x1000000\r\n");                          mBootStage = 2;                      }                      break;                  case 2:                      if (HandleFileSending(aPacket))                      {                          SendTextToConsole("Done sending kernel file\r\n");                          mBootStage = 4;                      }                      break;                  //case 3:                  //    if (WaitForBootPrompt(aPacket))                  //    {                  //        SendTextToConsole("mw.l 0xFF009000 0x11F8 1\r\n");                  //        SendRawData("mw.l 0xFF009000 0x11F8 1\r\n");                  //        mBootStage = 4;                  //    }                  //    break;                  case 4:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("mw.l 0xFF009000 0x10F8 1\r\n");                          SendRawData("mw.l 0xFF009000 0x10F8 1\r\n");                          mBootStage = 5;                      }                      break;                  case 5:                      if (WaitForBootPrompt(aPacket))                      {                          // now at boot prompt.                          SendTextToConsole("Now starting kernel\r\n");                          mBootStage = 6;                          SendRawData("go 0x1000000\r\n");                      }                      break;                  case 6:                      //if (WaitForBootPrompt(aPacket))                      //{                      //    SendRawData("\0A");                      //}                      base.WaitForSignature(aPacket);                      return;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForSignature,The following statement contains a magic number: switch (mBootStage)              {                  // start by sending out a message to the window                  case 0:                      base.SendTextToConsole("Waiting for U-Boot bootloader prompt...\r\n");                      mBootStage = 1;                      break;                  // the bootloader should be configured to wait for input:                  case 1:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("Sending kernel now\r\n");                          SendTextToConsole("Filename = '" + mKernelFile + "'\r\n");                          SendRawData("\0loady 0x1000000\r\n");                          mBootStage = 2;                      }                      break;                  case 2:                      if (HandleFileSending(aPacket))                      {                          SendTextToConsole("Done sending kernel file\r\n");                          mBootStage = 4;                      }                      break;                  //case 3:                  //    if (WaitForBootPrompt(aPacket))                  //    {                  //        SendTextToConsole("mw.l 0xFF009000 0x11F8 1\r\n");                  //        SendRawData("mw.l 0xFF009000 0x11F8 1\r\n");                  //        mBootStage = 4;                  //    }                  //    break;                  case 4:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("mw.l 0xFF009000 0x10F8 1\r\n");                          SendRawData("mw.l 0xFF009000 0x10F8 1\r\n");                          mBootStage = 5;                      }                      break;                  case 5:                      if (WaitForBootPrompt(aPacket))                      {                          // now at boot prompt.                          SendTextToConsole("Now starting kernel\r\n");                          mBootStage = 6;                          SendRawData("go 0x1000000\r\n");                      }                      break;                  case 6:                      //if (WaitForBootPrompt(aPacket))                      //{                      //    SendRawData("\0A");                      //}                      base.WaitForSignature(aPacket);                      return;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForSignature,The following statement contains a magic number: switch (mBootStage)              {                  // start by sending out a message to the window                  case 0:                      base.SendTextToConsole("Waiting for U-Boot bootloader prompt...\r\n");                      mBootStage = 1;                      break;                  // the bootloader should be configured to wait for input:                  case 1:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("Sending kernel now\r\n");                          SendTextToConsole("Filename = '" + mKernelFile + "'\r\n");                          SendRawData("\0loady 0x1000000\r\n");                          mBootStage = 2;                      }                      break;                  case 2:                      if (HandleFileSending(aPacket))                      {                          SendTextToConsole("Done sending kernel file\r\n");                          mBootStage = 4;                      }                      break;                  //case 3:                  //    if (WaitForBootPrompt(aPacket))                  //    {                  //        SendTextToConsole("mw.l 0xFF009000 0x11F8 1\r\n");                  //        SendRawData("mw.l 0xFF009000 0x11F8 1\r\n");                  //        mBootStage = 4;                  //    }                  //    break;                  case 4:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("mw.l 0xFF009000 0x10F8 1\r\n");                          SendRawData("mw.l 0xFF009000 0x10F8 1\r\n");                          mBootStage = 5;                      }                      break;                  case 5:                      if (WaitForBootPrompt(aPacket))                      {                          // now at boot prompt.                          SendTextToConsole("Now starting kernel\r\n");                          mBootStage = 6;                          SendRawData("go 0x1000000\r\n");                      }                      break;                  case 6:                      //if (WaitForBootPrompt(aPacket))                      //{                      //    SendRawData("\0A");                      //}                      base.WaitForSignature(aPacket);                      return;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForSignature,The following statement contains a magic number: switch (mBootStage)              {                  // start by sending out a message to the window                  case 0:                      base.SendTextToConsole("Waiting for U-Boot bootloader prompt...\r\n");                      mBootStage = 1;                      break;                  // the bootloader should be configured to wait for input:                  case 1:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("Sending kernel now\r\n");                          SendTextToConsole("Filename = '" + mKernelFile + "'\r\n");                          SendRawData("\0loady 0x1000000\r\n");                          mBootStage = 2;                      }                      break;                  case 2:                      if (HandleFileSending(aPacket))                      {                          SendTextToConsole("Done sending kernel file\r\n");                          mBootStage = 4;                      }                      break;                  //case 3:                  //    if (WaitForBootPrompt(aPacket))                  //    {                  //        SendTextToConsole("mw.l 0xFF009000 0x11F8 1\r\n");                  //        SendRawData("mw.l 0xFF009000 0x11F8 1\r\n");                  //        mBootStage = 4;                  //    }                  //    break;                  case 4:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("mw.l 0xFF009000 0x10F8 1\r\n");                          SendRawData("mw.l 0xFF009000 0x10F8 1\r\n");                          mBootStage = 5;                      }                      break;                  case 5:                      if (WaitForBootPrompt(aPacket))                      {                          // now at boot prompt.                          SendTextToConsole("Now starting kernel\r\n");                          mBootStage = 6;                          SendRawData("go 0x1000000\r\n");                      }                      break;                  case 6:                      //if (WaitForBootPrompt(aPacket))                      //{                      //    SendRawData("\0A");                      //}                      base.WaitForSignature(aPacket);                      return;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForSignature,The following statement contains a magic number: switch (mBootStage)              {                  // start by sending out a message to the window                  case 0:                      base.SendTextToConsole("Waiting for U-Boot bootloader prompt...\r\n");                      mBootStage = 1;                      break;                  // the bootloader should be configured to wait for input:                  case 1:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("Sending kernel now\r\n");                          SendTextToConsole("Filename = '" + mKernelFile + "'\r\n");                          SendRawData("\0loady 0x1000000\r\n");                          mBootStage = 2;                      }                      break;                  case 2:                      if (HandleFileSending(aPacket))                      {                          SendTextToConsole("Done sending kernel file\r\n");                          mBootStage = 4;                      }                      break;                  //case 3:                  //    if (WaitForBootPrompt(aPacket))                  //    {                  //        SendTextToConsole("mw.l 0xFF009000 0x11F8 1\r\n");                  //        SendRawData("mw.l 0xFF009000 0x11F8 1\r\n");                  //        mBootStage = 4;                  //    }                  //    break;                  case 4:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("mw.l 0xFF009000 0x10F8 1\r\n");                          SendRawData("mw.l 0xFF009000 0x10F8 1\r\n");                          mBootStage = 5;                      }                      break;                  case 5:                      if (WaitForBootPrompt(aPacket))                      {                          // now at boot prompt.                          SendTextToConsole("Now starting kernel\r\n");                          mBootStage = 6;                          SendRawData("go 0x1000000\r\n");                      }                      break;                  case 6:                      //if (WaitForBootPrompt(aPacket))                      //{                      //    SendRawData("\0A");                      //}                      base.WaitForSignature(aPacket);                      return;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForSignature,The following statement contains a magic number: switch (mBootStage)              {                  // start by sending out a message to the window                  case 0:                      base.SendTextToConsole("Waiting for U-Boot bootloader prompt...\r\n");                      mBootStage = 1;                      break;                  // the bootloader should be configured to wait for input:                  case 1:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("Sending kernel now\r\n");                          SendTextToConsole("Filename = '" + mKernelFile + "'\r\n");                          SendRawData("\0loady 0x1000000\r\n");                          mBootStage = 2;                      }                      break;                  case 2:                      if (HandleFileSending(aPacket))                      {                          SendTextToConsole("Done sending kernel file\r\n");                          mBootStage = 4;                      }                      break;                  //case 3:                  //    if (WaitForBootPrompt(aPacket))                  //    {                  //        SendTextToConsole("mw.l 0xFF009000 0x11F8 1\r\n");                  //        SendRawData("mw.l 0xFF009000 0x11F8 1\r\n");                  //        mBootStage = 4;                  //    }                  //    break;                  case 4:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("mw.l 0xFF009000 0x10F8 1\r\n");                          SendRawData("mw.l 0xFF009000 0x10F8 1\r\n");                          mBootStage = 5;                      }                      break;                  case 5:                      if (WaitForBootPrompt(aPacket))                      {                          // now at boot prompt.                          SendTextToConsole("Now starting kernel\r\n");                          mBootStage = 6;                          SendRawData("go 0x1000000\r\n");                      }                      break;                  case 6:                      //if (WaitForBootPrompt(aPacket))                      //{                      //    SendRawData("\0A");                      //}                      base.WaitForSignature(aPacket);                      return;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForSignature,The following statement contains a magic number: switch (mBootStage)              {                  // start by sending out a message to the window                  case 0:                      base.SendTextToConsole("Waiting for U-Boot bootloader prompt...\r\n");                      mBootStage = 1;                      break;                  // the bootloader should be configured to wait for input:                  case 1:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("Sending kernel now\r\n");                          SendTextToConsole("Filename = '" + mKernelFile + "'\r\n");                          SendRawData("\0loady 0x1000000\r\n");                          mBootStage = 2;                      }                      break;                  case 2:                      if (HandleFileSending(aPacket))                      {                          SendTextToConsole("Done sending kernel file\r\n");                          mBootStage = 4;                      }                      break;                  //case 3:                  //    if (WaitForBootPrompt(aPacket))                  //    {                  //        SendTextToConsole("mw.l 0xFF009000 0x11F8 1\r\n");                  //        SendRawData("mw.l 0xFF009000 0x11F8 1\r\n");                  //        mBootStage = 4;                  //    }                  //    break;                  case 4:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("mw.l 0xFF009000 0x10F8 1\r\n");                          SendRawData("mw.l 0xFF009000 0x10F8 1\r\n");                          mBootStage = 5;                      }                      break;                  case 5:                      if (WaitForBootPrompt(aPacket))                      {                          // now at boot prompt.                          SendTextToConsole("Now starting kernel\r\n");                          mBootStage = 6;                          SendRawData("go 0x1000000\r\n");                      }                      break;                  case 6:                      //if (WaitForBootPrompt(aPacket))                      //{                      //    SendRawData("\0A");                      //}                      base.WaitForSignature(aPacket);                      return;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[1] = mBootPromptCheck[2];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[2] = mBootPromptCheck[3];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[2] = mBootPromptCheck[3];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[3] = mBootPromptCheck[4];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[3] = mBootPromptCheck[4];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[4] = mBootPromptCheck[5];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[4] = mBootPromptCheck[5];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[5] = mBootPromptCheck[6];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[5] = mBootPromptCheck[6];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForBootPrompt,The following statement contains a magic number: mBootPromptCheck[6] = aPacket[0];
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,HandleFileSending,The following statement contains a magic number: if (mKernelFileStream == null)              {                  // wait for packet with C (67)                  if (aPacket[0] == 67)                  {                      // start sending                      mKernelFileStream = File.Open(mKernelFile' FileMode.Open);                      SendRawData(ConstructNextLargePacket());                      SendTextToConsole(".");                      return false;                  }                  return false;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,ConstructNextLargePacket,The following statement contains a magic number: using (var xMS = new MemoryStream(1030))              {                  xMS.WriteByte(YModem_STX);                  mLastPacketIdx++;                  xMS.WriteByte(mLastPacketIdx);                  xMS.WriteByte((byte)(255 - mLastPacketIdx));                  var xBuff = new byte[1024];                  var xLength = mKernelFileStream.Read(xBuff' 0' xBuff.Length);                  if (xLength < xBuff.Length)                  {                      for (int i = xLength; i < xBuff.Length; i++)                      {                          xBuff[i] = YModem_EOF;                      }                  }                  xMS.Write(xBuff' 0' xBuff.Length);                  var xCrc = Crc16(xBuff);                  xMS.WriteByte((byte)(xCrc >> 8));                  xMS.WriteByte((byte)(xCrc & 0xFF));                  mLastPacket = xMS.ToArray();                  return mLastPacket;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,ConstructNextLargePacket,The following statement contains a magic number: using (var xMS = new MemoryStream(1030))              {                  xMS.WriteByte(YModem_STX);                  mLastPacketIdx++;                  xMS.WriteByte(mLastPacketIdx);                  xMS.WriteByte((byte)(255 - mLastPacketIdx));                  var xBuff = new byte[1024];                  var xLength = mKernelFileStream.Read(xBuff' 0' xBuff.Length);                  if (xLength < xBuff.Length)                  {                      for (int i = xLength; i < xBuff.Length; i++)                      {                          xBuff[i] = YModem_EOF;                      }                  }                  xMS.Write(xBuff' 0' xBuff.Length);                  var xCrc = Crc16(xBuff);                  xMS.WriteByte((byte)(xCrc >> 8));                  xMS.WriteByte((byte)(xCrc & 0xFF));                  mLastPacket = xMS.ToArray();                  return mLastPacket;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,ConstructNextLargePacket,The following statement contains a magic number: using (var xMS = new MemoryStream(1030))              {                  xMS.WriteByte(YModem_STX);                  mLastPacketIdx++;                  xMS.WriteByte(mLastPacketIdx);                  xMS.WriteByte((byte)(255 - mLastPacketIdx));                  var xBuff = new byte[1024];                  var xLength = mKernelFileStream.Read(xBuff' 0' xBuff.Length);                  if (xLength < xBuff.Length)                  {                      for (int i = xLength; i < xBuff.Length; i++)                      {                          xBuff[i] = YModem_EOF;                      }                  }                  xMS.Write(xBuff' 0' xBuff.Length);                  var xCrc = Crc16(xBuff);                  xMS.WriteByte((byte)(xCrc >> 8));                  xMS.WriteByte((byte)(xCrc & 0xFF));                  mLastPacket = xMS.ToArray();                  return mLastPacket;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,ConstructNextLargePacket,The following statement contains a magic number: using (var xMS = new MemoryStream(1030))              {                  xMS.WriteByte(YModem_STX);                  mLastPacketIdx++;                  xMS.WriteByte(mLastPacketIdx);                  xMS.WriteByte((byte)(255 - mLastPacketIdx));                  var xBuff = new byte[1024];                  var xLength = mKernelFileStream.Read(xBuff' 0' xBuff.Length);                  if (xLength < xBuff.Length)                  {                      for (int i = xLength; i < xBuff.Length; i++)                      {                          xBuff[i] = YModem_EOF;                      }                  }                  xMS.Write(xBuff' 0' xBuff.Length);                  var xCrc = Crc16(xBuff);                  xMS.WriteByte((byte)(xCrc >> 8));                  xMS.WriteByte((byte)(xCrc & 0xFF));                  mLastPacket = xMS.ToArray();                  return mLastPacket;              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,ConstructNullPacket,The following statement contains a magic number: using (var xMS = new MemoryStream(1030))              {                  xMS.WriteByte(YModem_STX);                  mLastPacketIdx++;                  xMS.WriteByte(mLastPacketIdx);                  xMS.WriteByte((byte)(255 - mLastPacketIdx));                  var xBuff = new byte[1024];                  xMS.Write(xBuff' 0' xBuff.Length);                  var xCrc = Crc16(xBuff);                  xMS.WriteByte((byte)(xCrc >> 8));                  xMS.WriteByte((byte)(xCrc & 0xFF));                  return xMS.ToArray();              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,ConstructNullPacket,The following statement contains a magic number: using (var xMS = new MemoryStream(1030))              {                  xMS.WriteByte(YModem_STX);                  mLastPacketIdx++;                  xMS.WriteByte(mLastPacketIdx);                  xMS.WriteByte((byte)(255 - mLastPacketIdx));                  var xBuff = new byte[1024];                  xMS.Write(xBuff' 0' xBuff.Length);                  var xCrc = Crc16(xBuff);                  xMS.WriteByte((byte)(xCrc >> 8));                  xMS.WriteByte((byte)(xCrc & 0xFF));                  return xMS.ToArray();              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,ConstructNullPacket,The following statement contains a magic number: using (var xMS = new MemoryStream(1030))              {                  xMS.WriteByte(YModem_STX);                  mLastPacketIdx++;                  xMS.WriteByte(mLastPacketIdx);                  xMS.WriteByte((byte)(255 - mLastPacketIdx));                  var xBuff = new byte[1024];                  xMS.Write(xBuff' 0' xBuff.Length);                  var xCrc = Crc16(xBuff);                  xMS.WriteByte((byte)(xCrc >> 8));                  xMS.WriteByte((byte)(xCrc & 0xFF));                  return xMS.ToArray();              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,ConstructNullPacket,The following statement contains a magic number: using (var xMS = new MemoryStream(1030))              {                  xMS.WriteByte(YModem_STX);                  mLastPacketIdx++;                  xMS.WriteByte(mLastPacketIdx);                  xMS.WriteByte((byte)(255 - mLastPacketIdx));                  var xBuff = new byte[1024];                  xMS.Write(xBuff' 0' xBuff.Length);                  var xCrc = Crc16(xBuff);                  xMS.WriteByte((byte)(xCrc >> 8));                  xMS.WriteByte((byte)(xCrc & 0xFF));                  return xMS.ToArray();              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,Crc16,The following statement contains a magic number: for (i = 0; i < data.Length; i++)              {                  cksum = (ushort)(Crc16Constants[((cksum >> 8) ^ data[i]) & 0xFF] ^ (cksum << 8));              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,Crc16,The following statement contains a magic number: for (i = 0; i < data.Length; i++)              {                  cksum = (ushort)(Crc16Constants[((cksum >> 8) ^ data[i]) & 0xFF] ^ (cksum << 8));              }
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorPipeServer,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorPipeServer.cs,DebugConnectorPipeServer,The following statement contains a magic number: mPipe = new NamedPipeServerStream(aName' PipeDirection.InOut' 1' PipeTransmissionMode.Byte'                                                PipeOptions.None' 1024' 1);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorSerial,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorSerial.cs,DebugConnectorSerial,The following statement contains a magic number: mPort.BaudRate = 115200;
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorSerial,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorSerial.cs,DebugConnectorSerial,The following statement contains a magic number: mPort.DataBits = 8;
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorTCPServer,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorTCPServer.cs,DebugConnectorTCPServer,The following statement contains a magic number: var xTCPListener = new TcpListener(IPAddress.Loopback' 4444);
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorTestPipeServer,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorTestPipeServer.cs,DebugConnectorTestPipeServer,The following statement contains a magic number: mHandle = CreateNamedPipe(@"\\.\pipe\" + aName' 3 | 0x40000000'                                        0'                                        1'                                        1'                                        12'                                        0'                                        IntPtr.Zero                  );
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorTestPipeServer,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorTestPipeServer.cs,DebugConnectorTestPipeServer,The following statement contains a magic number: mHandle = CreateNamedPipe(@"\\.\pipe\" + aName' 3 | 0x40000000'                                        0'                                        1'                                        1'                                        12'                                        0'                                        IntPtr.Zero                  );
Magic Number,Cosmos.Debug.DebugConnectors,DebugConnectorTestPipeServer,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorTestPipeServer.cs,InitializeBackground,The following statement contains a magic number: mPipe = new FileStream(mHandle' FileAccess.ReadWrite' 8192' false);
Missing Default,Cosmos.Debug.DebugConnectors,DebugConnectorEdison,C:\repos\CosmosOS_Cosmos\source\Cosmos.Debug.DebugConnectors\DebugConnectorEdison.cs,WaitForSignature,The following switch statement is missing a default case: switch (mBootStage)              {                  // start by sending out a message to the window                  case 0:                      base.SendTextToConsole("Waiting for U-Boot bootloader prompt...\r\n");                      mBootStage = 1;                      break;                  // the bootloader should be configured to wait for input:                  case 1:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("Sending kernel now\r\n");                          SendTextToConsole("Filename = '" + mKernelFile + "'\r\n");                          SendRawData("\0loady 0x1000000\r\n");                          mBootStage = 2;                      }                      break;                  case 2:                      if (HandleFileSending(aPacket))                      {                          SendTextToConsole("Done sending kernel file\r\n");                          mBootStage = 4;                      }                      break;                  //case 3:                  //    if (WaitForBootPrompt(aPacket))                  //    {                  //        SendTextToConsole("mw.l 0xFF009000 0x11F8 1\r\n");                  //        SendRawData("mw.l 0xFF009000 0x11F8 1\r\n");                  //        mBootStage = 4;                  //    }                  //    break;                  case 4:                      if (WaitForBootPrompt(aPacket))                      {                          SendTextToConsole("mw.l 0xFF009000 0x10F8 1\r\n");                          SendRawData("mw.l 0xFF009000 0x10F8 1\r\n");                          mBootStage = 5;                      }                      break;                  case 5:                      if (WaitForBootPrompt(aPacket))                      {                          // now at boot prompt.                          SendTextToConsole("Now starting kernel\r\n");                          mBootStage = 6;                          SendRawData("go 0x1000000\r\n");                      }                      break;                  case 6:                      //if (WaitForBootPrompt(aPacket))                      //{                      //    SendRawData("\0A");                      //}                      base.WaitForSignature(aPacket);                      return;              }
