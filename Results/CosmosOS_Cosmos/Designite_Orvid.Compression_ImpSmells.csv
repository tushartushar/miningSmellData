Implementation smell,Namespace,Class,File,Method,Description
Long Method,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Code,The method has 114 lines of code.
Long Method,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The method has 449 lines of code.
Long Method,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,CodeOneBlock,The method has 156 lines of code.
Long Method,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,The method has 122 lines of code.
Long Method,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GetAndMoveToFrontDecode,The method has 152 lines of code.
Long Method,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The method has 351 lines of code.
Long Method,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,QSort3,The method has 119 lines of code.
Long Method,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The method has 196 lines of code.
Long Method,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,FullGtU,The method has 126 lines of code.
Long Method,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The method has 102 lines of code.
Long Method,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The method has 139 lines of code.
Long Method,Orvid.Compression.Streams,InflaterDynHeader,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The method has 115 lines of code.
Long Method,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The method has 110 lines of code.
Long Method,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadHeader,The method has 151 lines of code.
Long Method,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The method has 179 lines of code.
Complex Method,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,Cyclomatic complexity of the method is 58
Complex Method,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,CodeOneBlock,Cyclomatic complexity of the method is 14
Complex Method,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,Cyclomatic complexity of the method is 21
Complex Method,Orvid.Compression.Checksums,Adler32,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\Adler32.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,Cyclomatic complexity of the method is 17
Complex Method,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GetAndMoveToFrontDecode,Cyclomatic complexity of the method is 13
Complex Method,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbCreateDecodeTables,Cyclomatic complexity of the method is 10
Complex Method,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,Cyclomatic complexity of the method is 58
Complex Method,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SimpleSort,Cyclomatic complexity of the method is 15
Complex Method,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,QSort3,Cyclomatic complexity of the method is 16
Complex Method,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,Cyclomatic complexity of the method is 10
Complex Method,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,Cyclomatic complexity of the method is 22
Complex Method,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,Cyclomatic complexity of the method is 10
Complex Method,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildLength,Cyclomatic complexity of the method is 9
Complex Method,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateFast,Cyclomatic complexity of the method is 10
Complex Method,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateSlow,Cyclomatic complexity of the method is 12
Complex Method,Orvid.Compression.Streams,Deflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,Cyclomatic complexity of the method is 10
Complex Method,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadHeader,Cyclomatic complexity of the method is 30
Long Parameter List,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,Orvid.Compression,LZMARangeBitTreeEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,ReverseEncode,The method has 5 parameters. Parameters: Models' startIndex' rangeEncoder' NumBitLevels' symbol
Long Parameter List,Orvid.Compression,ICoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbCreateDecodeTables,The method has 7 parameters. Parameters: limit' baseArray' perm' length' minLen' maxLen' alphaSize
Long Parameter List,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbAssignCodes,The method has 5 parameters. Parameters: code' length' minLen' maxLen' alphaSize
Long Parameter List,Orvid.Compression.Streams,DeflaterInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Orvid.Compression.Streams,DeflaterOutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Orvid.Compression.Streams,DeflaterOutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Identifier,Orvid.Compression,LZMABase,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,,The length of the parameter kNumLitPosStatesBitsEncodingMax is 31.
Long Statement,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The length of the statement  "                                UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 130.
Long Statement,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The length of the statement  "                                        UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 130.
Long Statement,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,FillDistancesPrices,The length of the statement  "                        _posSlotPrices[st + posSlot] += ((((posSlot >> 1) - 1) - LZMABase.kNumAlignBits) << LZMARangeBitEncoder.kNumBitPriceShiftBits); " is 127.
Long Statement,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The length of the statement  "                        while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) " is 127.
Long Statement,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The length of the statement  "                        (int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff))); " is 125.
Long Statement,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateSlow,The length of the statement  "                        if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) " is 121.
Long Statement,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,ParseHeader,The length of the statement  "                throw new Exception("Stream compressed with " + maxBits + " bits' but decompression can only handle " + LzwConstants.MAX_BITS + " bits."); " is 138.
Complex Conditional,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,Initialize,The conditional expression  "magic1 != 'B' || magic2 != 'Z' || magic3 != 'h' || magic4 < '1' || magic4 > '9'"  is complex.
Complex Conditional,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,InitBlock,The conditional expression  "magic1 == 0x17 && magic2 == 0x72 && magic3 == 0x45 && magic4 == 0x38 && magic5 == 0x50 && magic6 == 0x90"  is complex.
Complex Conditional,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,InitBlock,The conditional expression  "magic1 != 0x31 || magic2 != 0x41 || magic3 != 0x59 || magic4 != 0x26 || magic5 != 0x53 || magic6 != 0x59"  is complex.
Complex Conditional,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SetDecompressStructureSizes,The conditional expression  "!(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k && blockSize100k <= 9)"  is complex.
Complex Conditional,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The conditional expression  "ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1)"  is complex.
Complex Conditional,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,AllocateCompressStructures,The conditional expression  "block == null || quadrant == null || zptr == null || ftab == null"  is complex.
Complex Conditional,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FindLongestMatch,The conditional expression  "window[curMatch + best_len] != scan_end ||                      window[curMatch + best_len - 1] != scan_end1 ||                      window[curMatch] != window[scan] ||                      window[curMatch + 1] != window[scan + 1]"  is complex.
Complex Conditional,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FindLongestMatch,The conditional expression  "window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      (scan < strend)"  is complex.
Complex Conditional,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateStored,The conditional expression  "(storedLength >= DeflaterConstants.MAX_BLOCK_SIZE) || // Block is full                  (blockStart < WSIZE && storedLength >= MAX_DIST) ||   // Block may move out of window                  flush"  is complex.
Complex Conditional,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateFast,The conditional expression  "lookahead >= MIN_MATCH &&                      (hashHead = InsertString()) != 0 &&                      strategy != DeflateStrategy.HuffmanOnly &&                      strstart - hashHead <= MAX_DIST &&                      FindLongestMatch(hashHead)"  is complex.
Complex Conditional,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateSlow,The conditional expression  "strategy != DeflateStrategy.HuffmanOnly &&                          hashHead != 0 &&                          strstart - hashHead <= MAX_DIST &&                          FindLongestMatch(hashHead)"  is complex.
Complex Conditional,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateSlow,The conditional expression  "matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))"  is complex.
Magic Number,Orvid.Compression,LZMA,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Compress,The following statement contains a magic number: for (int i = 0; i < 8; i++)                  outStream.WriteByte((Byte)(fileSize >> (8 * i)));
Magic Number,Orvid.Compression,LZMA,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Compress,The following statement contains a magic number: for (int i = 0; i < 8; i++)                  outStream.WriteByte((Byte)(fileSize >> (8 * i)));
Magic Number,Orvid.Compression,LZMA,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Decompress,The following statement contains a magic number: byte[] properties2 = new byte[5];
Magic Number,Orvid.Compression,LZMA,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Decompress,The following statement contains a magic number: if (newInStream.Read(properties2' 0' 5) != 5)                  throw (new Exception("input .lzma is too short"));
Magic Number,Orvid.Compression,LZMA,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Decompress,The following statement contains a magic number: if (newInStream.Read(properties2' 0' 5) != 5)                  throw (new Exception("input .lzma is too short"));
Magic Number,Orvid.Compression,LZMA,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  int v = newInStream.ReadByte();                  if (v < 0)                      throw (new Exception("Can't Read 1"));                  outSize |= ((long)(byte)v) << (8 * i);              }
Magic Number,Orvid.Compression,LZMA,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  int v = newInStream.ReadByte();                  if (v < 0)                      throw (new Exception("Can't Read 1"));                  outSize |= ((long)(byte)v) << (8 * i);              }
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                      else if (Index < 10) Index -= 3;                      else Index -= 6;
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                      else if (Index < 10) Index -= 3;                      else Index -= 6;
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                      else if (Index < 10) Index -= 3;                      else Index -= 6;
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                      else if (Index < 10) Index -= 3;                      else Index -= 6;
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,IsCharState,The following statement contains a magic number: return Index < 7;
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetDictionarySize,The following statement contains a magic number: if (m_DictionarySize != dictionarySize)                  {                      m_DictionarySize = dictionarySize;                      m_DictionarySizeCheck = Math.Max(m_DictionarySize' 1);                      uint blockSize = Math.Max(m_DictionarySizeCheck' (1 << 12));                      m_OutWindow.Create(blockSize);                  }
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetLiteralProperties,The following statement contains a magic number: if (lp > 8)                      throw new Exception();
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetLiteralProperties,The following statement contains a magic number: if (lc > 8)                      throw new Exception();
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Code,The following statement contains a magic number: while (nowPos64 < outSize64)                  {                      // UInt64 next = Math.Min(nowPos64 + (1 << 18)' outSize64);                      // while(nowPos64 < next)                      {                          uint posState = (uint)nowPos64 & m_PosStateMask;                          if (m_IsMatchDecoders[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)                          {                              byte b;                              byte prevByte = m_OutWindow.GetByte(0);                              if (!state.IsCharState())                                  b = m_LiteralDecoder.DecodeWithMatchByte(m_RangeDecoder'                                      (uint)nowPos64' prevByte' m_OutWindow.GetByte(rep0));                              else                                  b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder' (uint)nowPos64' prevByte);                              m_OutWindow.PutByte(b);                              state.UpdateChar();                              nowPos64++;                          }                          else                          {                              uint len;                              if (m_IsRepDecoders[state.Index].Decode(m_RangeDecoder) == 1)                              {                                  if (m_IsRepG0Decoders[state.Index].Decode(m_RangeDecoder) == 0)                                  {                                      if (m_IsRep0LongDecoders[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)                                      {                                          state.UpdateShortRep();                                          m_OutWindow.PutByte(m_OutWindow.GetByte(rep0));                                          nowPos64++;                                          continue;                                      }                                  }                                  else                                  {                                      UInt32 distance;                                      if (m_IsRepG1Decoders[state.Index].Decode(m_RangeDecoder) == 0)                                      {                                          distance = rep1;                                      }                                      else                                      {                                          if (m_IsRepG2Decoders[state.Index].Decode(m_RangeDecoder) == 0)                                              distance = rep2;                                          else                                          {                                              distance = rep3;                                              rep3 = rep2;                                          }                                          rep2 = rep1;                                      }                                      rep1 = rep0;                                      rep0 = distance;                                  }                                  len = m_RepLenDecoder.Decode(m_RangeDecoder' posState) + LZMABase.kMatchMinLen;                                  state.UpdateRep();                              }                              else                              {                                  rep3 = rep2;                                  rep2 = rep1;                                  rep1 = rep0;                                  len = LZMABase.kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder' posState);                                  state.UpdateMatch();                                  uint posSlot = m_PosSlotDecoder[LZMABase.GetLenToPosState(len)].Decode(m_RangeDecoder);                                  if (posSlot >= LZMABase.kStartPosModelIndex)                                  {                                      int numDirectBits = (int)((posSlot >> 1) - 1);                                      rep0 = ((2 | (posSlot & 1)) << numDirectBits);                                      if (posSlot < LZMABase.kEndPosModelIndex)                                          rep0 += LZMARangeBitTreeDecoder.ReverseDecode(m_PosDecoders'                                                  rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);                                      else                                      {                                          rep0 += (m_RangeDecoder.DecodeDirectBits(                                              numDirectBits - LZMABase.kNumAlignBits) << LZMABase.kNumAlignBits);                                          rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);                                      }                                  }                                  else                                      rep0 = posSlot;                              }                              if (rep0 >= nowPos64 || rep0 >= m_DictionarySizeCheck)                              {                                  if (rep0 == 0xFFFFFFFF)                                      break;                                  throw new Exception();                              }                              m_OutWindow.CopyBlock(rep0' len);                              nowPos64 += len;                          }                      }                  }
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetDecoderProperties,The following statement contains a magic number: if (properties.Length < 5)                      throw new Exception();
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetDecoderProperties,The following statement contains a magic number: int lc = properties[0] % 9;
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetDecoderProperties,The following statement contains a magic number: int remainder = properties[0] / 9;
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetDecoderProperties,The following statement contains a magic number: int lp = remainder % 5;
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetDecoderProperties,The following statement contains a magic number: int pb = remainder / 5;
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                      dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                      dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,Orvid.Compression,LiteralDecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetState,The following statement contains a magic number: return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
Magic Number,Orvid.Compression,Decoder2,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,DecodeWithMatchByte,The following statement contains a magic number: do                          {                              uint matchBit = (uint)(matchByte >> 7) & 1;                              matchByte <<= 1;                              uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);                              symbol = (symbol << 1) | bit;                              if (matchBit != bit)                              {                                  while (symbol < 0x100)                                      symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);                                  break;                              }                          }                          while (symbol < 0x100);
Magic Number,Orvid.Compression,Decoder2,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,DecodeWithMatchByte,The following statement contains a magic number: do                          {                              uint matchBit = (uint)(matchByte >> 7) & 1;                              matchByte <<= 1;                              uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);                              symbol = (symbol << 1) | bit;                              if (matchBit != bit)                              {                                  while (symbol < 0x100)                                      symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);                                  break;                              }                          }                          while (symbol < 0x100);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,LZMAEncoder,The following statement contains a magic number: const Byte kFastSlots = 22;
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,LZMAEncoder,The following statement contains a magic number: int c = 2;
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,LZMAEncoder,The following statement contains a magic number: for (Byte slotFast = 2; slotFast < kFastSlots; slotFast++)                  {                      UInt32 k = ((UInt32)1 << ((slotFast >> 1) - 1));                      for (UInt32 j = 0; j < k; j++' c++)                          g_FastPos[c] = slotFast;                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 11))                      return g_FastPos[pos];
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))                      return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))                      return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))                      return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))                      return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))                      return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))                      return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))                      return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))                      return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))                      return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: if (_matchFinder == null)                  {                      LZBinTree bt = new LZBinTree();                      int numHashBytes = 4;                      if (_matchFinderType == EMatchFinderType.BT2)                          numHashBytes = 2;                      bt.SetType(numHashBytes);                      _matchFinder = bt;                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: if (_matchFinder == null)                  {                      LZBinTree bt = new LZBinTree();                      int numHashBytes = 4;                      if (_matchFinderType == EMatchFinderType.BT2)                          numHashBytes = 2;                      bt.SetType(numHashBytes);                      _matchFinder = bt;                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,ReadMatchDistances,The following statement contains a magic number: if (numDistancePairs > 0)                  {                      lenRes = _matchDistances[numDistancePairs - 2];                      if (lenRes == _numFastBytes)                          lenRes += _matchFinder.GetMatchLen((int)lenRes - 1' _matchDistances[numDistancePairs - 1]'                              LZMABase.kMatchMaxLen - lenRes);                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPureRepPrice,The following statement contains a magic number: if (repIndex == 0)                  {                      price = _isRepG0[state.Index].GetPrice0();                      price += _isRep0Long[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  }                  else                  {                      price = _isRepG0[state.Index].GetPrice1();                      if (repIndex == 1)                          price += _isRepG1[state.Index].GetPrice0();                      else                      {                          price += _isRepG1[state.Index].GetPrice1();                          price += _isRepG2[state.Index].GetPrice(repIndex - 2);                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: if (numAvailableBytes < 2)                  {                      backRes = 0xFFFFFFFF;                      return 1;                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2)                  {                      backRes = (UInt32)0xFFFFFFFF;                      return 1;                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2)                  {                      backRes = (UInt32)0xFFFFFFFF;                      return 1;                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: if (lenEnd < 2)                  {                      backRes = _optimum[1].BackPrev;                      return 1;                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs2 = reps[2];
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs3 = reps[3];
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: do                      _optimum[len--].Price = kIfinityPrice;                  while (len >= 2);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < LZMABase.kNumRepDistances; i++)                  {                      UInt32 repLen = repLens[i];                      if (repLen < 2)                          continue;                      UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);                      do                      {                          UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);                          Optimal optimum = _optimum[repLen];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = 0;                              optimum.BackPrev = i;                              optimum.Prev1IsChar = false;                          }                      }                      while (--repLen >= 2);                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < LZMABase.kNumRepDistances; i++)                  {                      UInt32 repLen = repLens[i];                      if (repLen < 2)                          continue;                      UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);                      do                      {                          UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);                          Optimal optimum = _optimum[repLen];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = 0;                              optimum.BackPrev = i;                              optimum.Prev1IsChar = false;                          }                      }                      while (--repLen >= 2);                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < LZMABase.kNumRepDistances; i++)                  {                      UInt32 repLen = repLens[i];                      if (repLen < 2)                          continue;                      UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);                      do                      {                          UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);                          Optimal optimum = _optimum[repLen];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = 0;                              optimum.BackPrev = i;                              optimum.Prev1IsChar = false;                          }                      }                      while (--repLen >= 2);                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain)                  {                      UInt32 offs = 0;                      while (len > _matchDistances[offs])                          offs += 2;                      for (; ; len++)                      {                          UInt32 distance = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance' len' posState);                          Optimal optimum = _optimum[len];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = 0;                              optimum.BackPrev = distance + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                          if (len == _matchDistances[offs])                          {                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain)                  {                      UInt32 offs = 0;                      while (len > _matchDistances[offs])                          offs += 2;                      for (; ; len++)                      {                          UInt32 distance = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance' len' posState);                          Optimal optimum = _optimum[len];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = 0;                              optimum.BackPrev = distance + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                          if (len == _matchDistances[offs])                          {                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: while (true)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                      UInt32 newLen;                      ReadMatchDistances(out newLen' out numDistancePairs);                      if (newLen >= _numFastBytes)                      {                          _numDistancePairs = numDistancePairs;                          _longestMatchLength = newLen;                          _longestMatchWasFound = true;                          return Backward(out backRes' cur);                      }                      position++;                      UInt32 posPrev = _optimum[cur].PosPrev;                      LZMABase.State state;                      if (_optimum[cur].Prev1IsChar)                      {                          posPrev--;                          if (_optimum[cur].Prev2)                          {                              state = _optimum[_optimum[cur].PosPrev2].State;                              if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          else                              state = _optimum[posPrev].State;                          state.UpdateChar();                      }                      else                          state = _optimum[posPrev].State;                      if (posPrev == cur - 1)                      {                          if (_optimum[cur].IsShortRep())                              state.UpdateShortRep();                          else                              state.UpdateChar();                      }                      else                      {                          UInt32 pos;                          if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                          {                              posPrev = _optimum[cur].PosPrev2;                              pos = _optimum[cur].BackPrev2;                              state.UpdateRep();                          }                          else                          {                              pos = _optimum[cur].BackPrev;                              if (pos < LZMABase.kNumRepDistances)                                  state.UpdateRep();                              else                                  state.UpdateMatch();                          }                          Optimal opt = _optimum[posPrev];                          if (pos < LZMABase.kNumRepDistances)                          {                              if (pos == 0)                              {                                  reps[0] = opt.Backs0;                                  reps[1] = opt.Backs1;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 1)                              {                                  reps[0] = opt.Backs1;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs2;                                  reps[3] = opt.Backs3;                              }                              else if (pos == 2)                              {                                  reps[0] = opt.Backs2;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs3;                              }                              else                              {                                  reps[0] = opt.Backs3;                                  reps[1] = opt.Backs0;                                  reps[2] = opt.Backs1;                                  reps[3] = opt.Backs2;                              }                          }                          else                          {                              reps[0] = (pos - LZMABase.kNumRepDistances);                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      _optimum[cur].State = state;                      _optimum[cur].Backs0 = reps[0];                      _optimum[cur].Backs1 = reps[1];                      _optimum[cur].Backs2 = reps[2];                      _optimum[cur].Backs3 = reps[3];                      UInt32 curPrice = _optimum[cur].Price;                        currentByte = _matchFinder.GetIndexByte(0 - 1);                      matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                        posState = (position & _posStateMask);                        UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);                        Optimal nextOptimum = _optimum[cur + 1];                        bool nextIsChar = false;                      if (curAnd1Price < nextOptimum.Price)                      {                          nextOptimum.Price = curAnd1Price;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsChar();                          nextIsChar = true;                      }                        matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                      repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                        if (matchByte == currentByte &&                          !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                      {                          UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOptimum.Price)                          {                              nextOptimum.Price = shortRepPrice;                              nextOptimum.PosPrev = cur;                              nextOptimum.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                      numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                      numAvailableBytes = numAvailableBytesFull;                        if (numAvailableBytes < 2)                          continue;                      if (numAvailableBytes > _numFastBytes)                          numAvailableBytes = _numFastBytes;                      if (!nextIsChar && matchByte != currentByte)                      {                          // try Literal + rep0                          UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateChar();                              UInt32 posStateNext = (position + 1) & _posStateMask;                              UInt32 nextRepMatchPrice = curAnd1Price +                                  _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                                  _isRep[state2.Index].GetPrice1();                              {                                  UInt32 offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                      0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = false;                                  }                              }                          }                      }                        UInt32 startLen = 2; // speed optimization                         for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                      {                          UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                          if (lenTest < 2)                              continue;                          UInt32 lenTestTemp = lenTest;                          do                          {                              while (lenEnd < cur + lenTest)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = repIndex;                                  optimum.Prev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            // if (_maxMode)                          if (lenTest < numAvailableBytesFull)                          {                              UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                              UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                              if (lenTest2 >= 2)                              {                                  LZMABase.State state2 = state;                                  state2.UpdateRep();                                  UInt32 posStateNext = (position + lenTest) & _posStateMask;                                  UInt32 curAndLenCharPrice =                                          repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                  state2.UpdateChar();                                  posStateNext = (position + lenTest + 1) & _posStateMask;                                  UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                  UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                    // for(; lenTest2 >= 2; lenTest2--)                                  {                                      UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      Optimal optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        if (newLen > numAvailableBytes)                      {                          newLen = numAvailableBytes;                          for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                          _matchDistances[numDistancePairs] = newLen;                          numDistancePairs += 2;                      }                      if (newLen >= startLen)                      {                          normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                          while (lenEnd < cur + newLen)                              _optimum[++lenEnd].Price = kIfinityPrice;                            UInt32 offs = 0;                          while (startLen > _matchDistances[offs])                              offs += 2;                            for (UInt32 lenTest = startLen; ; lenTest++)                          {                              UInt32 curBack = _matchDistances[offs + 1];                              UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                              Optimal optimum = _optimum[cur + lenTest];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur;                                  optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                                  optimum.Prev1IsChar = false;                              }                                if (lenTest == _matchDistances[offs])                              {                                  if (lenTest < numAvailableBytesFull)                                  {                                      UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                      UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                      if (lenTest2 >= 2)                                      {                                          LZMABase.State state2 = state;                                          state2.UpdateMatch();                                          UInt32 posStateNext = (position + lenTest) & _posStateMask;                                          UInt32 curAndLenCharPrice = curAndLenPrice +                                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                              _literalEncoder.GetSubCoder(position + lenTest'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                              GetPrice(true'                                              _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                              _matchFinder.GetIndexByte((Int32)lenTest - 1));                                          state2.UpdateChar();                                          posStateNext = (position + lenTest + 1) & _posStateMask;                                          UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                          UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                            UInt32 offset = lenTest + 1 + lenTest2;                                          while (lenEnd < cur + offset)                                              _optimum[++lenEnd].Price = kIfinityPrice;                                          curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          optimum = _optimum[cur + offset];                                          if (curAndLenPrice < optimum.Price)                                          {                                              optimum.Price = curAndLenPrice;                                              optimum.PosPrev = cur + lenTest + 1;                                              optimum.BackPrev = 0;                                              optimum.Prev1IsChar = true;                                              optimum.Prev2 = true;                                              optimum.PosPrev2 = cur;                                              optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                          }                                      }                                  }                                  offs += 2;                                  if (offs == numDistancePairs)                                      break;                              }                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,ChangePair,The following statement contains a magic number: const int kDif = 7;
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,ChangePair,The following statement contains a magic number: return (smallDist < ((UInt32)(1) << (32 - kDif)) && bigDist >= (smallDist << kDif));
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,WriteEndMarker,The following statement contains a magic number: int footerBits = 30;
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,CodeOneBlock,The following statement contains a magic number: while (true)                  {                      UInt32 pos;                      UInt32 len = GetOptimum((UInt32)nowPos64' out pos);                        UInt32 posState = ((UInt32)nowPos64) & _posStateMask;                      UInt32 complexState = (_state.Index << LZMABase.kNumPosStatesBitsMax) + posState;                      if (len == 1 && pos == 0xFFFFFFFF)                      {                          _isMatch[complexState].Encode(_rangeEncoder' 0);                          Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));                          LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);                          if (!_state.IsCharState())                          {                              Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));                              subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);                          }                          else                              subCoder.Encode(_rangeEncoder' curByte);                          _previousByte = curByte;                          _state.UpdateChar();                      }                      else                      {                          _isMatch[complexState].Encode(_rangeEncoder' 1);                          if (pos < LZMABase.kNumRepDistances)                          {                              _isRep[_state.Index].Encode(_rangeEncoder' 1);                              if (pos == 0)                              {                                  _isRepG0[_state.Index].Encode(_rangeEncoder' 0);                                  if (len == 1)                                      _isRep0Long[complexState].Encode(_rangeEncoder' 0);                                  else                                      _isRep0Long[complexState].Encode(_rangeEncoder' 1);                              }                              else                              {                                  _isRepG0[_state.Index].Encode(_rangeEncoder' 1);                                  if (pos == 1)                                      _isRepG1[_state.Index].Encode(_rangeEncoder' 0);                                  else                                  {                                      _isRepG1[_state.Index].Encode(_rangeEncoder' 1);                                      _isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);                                  }                              }                              if (len == 1)                                  _state.UpdateShortRep();                              else                              {                                  _repMatchLenEncoder.Encode(_rangeEncoder' len - LZMABase.kMatchMinLen' posState);                                  _state.UpdateRep();                              }                              UInt32 distance = _repDistances[pos];                              if (pos != 0)                              {                                  for (UInt32 i = pos; i >= 1; i--)                                      _repDistances[i] = _repDistances[i - 1];                                  _repDistances[0] = distance;                              }                          }                          else                          {                              _isRep[_state.Index].Encode(_rangeEncoder' 0);                              _state.UpdateMatch();                              _lenEncoder.Encode(_rangeEncoder' len - LZMABase.kMatchMinLen' posState);                              pos -= LZMABase.kNumRepDistances;                              UInt32 posSlot = GetPosSlot(pos);                              UInt32 lenToPosState = LZMABase.GetLenToPosState(len);                              _posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);                                if (posSlot >= LZMABase.kStartPosModelIndex)                              {                                  int footerBits = (int)((posSlot >> 1) - 1);                                  UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                                  UInt32 posReduced = pos - baseVal;                                    if (posSlot < LZMABase.kEndPosModelIndex)                                      LZMARangeBitTreeEncoder.ReverseEncode(_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);                                  else                                  {                                      _rangeEncoder.EncodeDirectBits(posReduced >> LZMABase.kNumAlignBits' footerBits - LZMABase.kNumAlignBits);                                      _posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & LZMABase.kAlignMask);                                      _alignPriceCount++;                                  }                              }                              UInt32 distance = pos;                              for (UInt32 i = LZMABase.kNumRepDistances - 1; i >= 1; i--)                                  _repDistances[i] = _repDistances[i - 1];                              _repDistances[0] = distance;                              _matchPriceCount++;                          }                          _previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));                      }                      _additionalOffset -= len;                      nowPos64 += len;                      if (_additionalOffset == 0)                      {                          // if (!_fastMode)                          if (_matchPriceCount >= (1 << 7))                              FillDistancesPrices();                          if (_alignPriceCount >= LZMABase.kAlignTableSize)                              FillAlignPrices();                          inSize = nowPos64;                          outSize = _rangeEncoder.GetProcessedSizeAdd();                          if (_matchFinder.GetNumAvailableBytes() == 0)                          {                              Flush((UInt32)nowPos64);                              return;                          }                            if (nowPos64 - progressPosValuePrev >= (1 << 12))                          {                              _finished = false;                              finished = false;                              return;                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,CodeOneBlock,The following statement contains a magic number: while (true)                  {                      UInt32 pos;                      UInt32 len = GetOptimum((UInt32)nowPos64' out pos);                        UInt32 posState = ((UInt32)nowPos64) & _posStateMask;                      UInt32 complexState = (_state.Index << LZMABase.kNumPosStatesBitsMax) + posState;                      if (len == 1 && pos == 0xFFFFFFFF)                      {                          _isMatch[complexState].Encode(_rangeEncoder' 0);                          Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));                          LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);                          if (!_state.IsCharState())                          {                              Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));                              subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);                          }                          else                              subCoder.Encode(_rangeEncoder' curByte);                          _previousByte = curByte;                          _state.UpdateChar();                      }                      else                      {                          _isMatch[complexState].Encode(_rangeEncoder' 1);                          if (pos < LZMABase.kNumRepDistances)                          {                              _isRep[_state.Index].Encode(_rangeEncoder' 1);                              if (pos == 0)                              {                                  _isRepG0[_state.Index].Encode(_rangeEncoder' 0);                                  if (len == 1)                                      _isRep0Long[complexState].Encode(_rangeEncoder' 0);                                  else                                      _isRep0Long[complexState].Encode(_rangeEncoder' 1);                              }                              else                              {                                  _isRepG0[_state.Index].Encode(_rangeEncoder' 1);                                  if (pos == 1)                                      _isRepG1[_state.Index].Encode(_rangeEncoder' 0);                                  else                                  {                                      _isRepG1[_state.Index].Encode(_rangeEncoder' 1);                                      _isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);                                  }                              }                              if (len == 1)                                  _state.UpdateShortRep();                              else                              {                                  _repMatchLenEncoder.Encode(_rangeEncoder' len - LZMABase.kMatchMinLen' posState);                                  _state.UpdateRep();                              }                              UInt32 distance = _repDistances[pos];                              if (pos != 0)                              {                                  for (UInt32 i = pos; i >= 1; i--)                                      _repDistances[i] = _repDistances[i - 1];                                  _repDistances[0] = distance;                              }                          }                          else                          {                              _isRep[_state.Index].Encode(_rangeEncoder' 0);                              _state.UpdateMatch();                              _lenEncoder.Encode(_rangeEncoder' len - LZMABase.kMatchMinLen' posState);                              pos -= LZMABase.kNumRepDistances;                              UInt32 posSlot = GetPosSlot(pos);                              UInt32 lenToPosState = LZMABase.GetLenToPosState(len);                              _posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);                                if (posSlot >= LZMABase.kStartPosModelIndex)                              {                                  int footerBits = (int)((posSlot >> 1) - 1);                                  UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                                  UInt32 posReduced = pos - baseVal;                                    if (posSlot < LZMABase.kEndPosModelIndex)                                      LZMARangeBitTreeEncoder.ReverseEncode(_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);                                  else                                  {                                      _rangeEncoder.EncodeDirectBits(posReduced >> LZMABase.kNumAlignBits' footerBits - LZMABase.kNumAlignBits);                                      _posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & LZMABase.kAlignMask);                                      _alignPriceCount++;                                  }                              }                              UInt32 distance = pos;                              for (UInt32 i = LZMABase.kNumRepDistances - 1; i >= 1; i--)                                  _repDistances[i] = _repDistances[i - 1];                              _repDistances[0] = distance;                              _matchPriceCount++;                          }                          _previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));                      }                      _additionalOffset -= len;                      nowPos64 += len;                      if (_additionalOffset == 0)                      {                          // if (!_fastMode)                          if (_matchPriceCount >= (1 << 7))                              FillDistancesPrices();                          if (_alignPriceCount >= LZMABase.kAlignTableSize)                              FillAlignPrices();                          inSize = nowPos64;                          outSize = _rangeEncoder.GetProcessedSizeAdd();                          if (_matchFinder.GetNumAvailableBytes() == 0)                          {                              Flush((UInt32)nowPos64);                              return;                          }                            if (nowPos64 - progressPosValuePrev >= (1 << 12))                          {                              _finished = false;                              finished = false;                              return;                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,CodeOneBlock,The following statement contains a magic number: while (true)                  {                      UInt32 pos;                      UInt32 len = GetOptimum((UInt32)nowPos64' out pos);                        UInt32 posState = ((UInt32)nowPos64) & _posStateMask;                      UInt32 complexState = (_state.Index << LZMABase.kNumPosStatesBitsMax) + posState;                      if (len == 1 && pos == 0xFFFFFFFF)                      {                          _isMatch[complexState].Encode(_rangeEncoder' 0);                          Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));                          LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);                          if (!_state.IsCharState())                          {                              Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));                              subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);                          }                          else                              subCoder.Encode(_rangeEncoder' curByte);                          _previousByte = curByte;                          _state.UpdateChar();                      }                      else                      {                          _isMatch[complexState].Encode(_rangeEncoder' 1);                          if (pos < LZMABase.kNumRepDistances)                          {                              _isRep[_state.Index].Encode(_rangeEncoder' 1);                              if (pos == 0)                              {                                  _isRepG0[_state.Index].Encode(_rangeEncoder' 0);                                  if (len == 1)                                      _isRep0Long[complexState].Encode(_rangeEncoder' 0);                                  else                                      _isRep0Long[complexState].Encode(_rangeEncoder' 1);                              }                              else                              {                                  _isRepG0[_state.Index].Encode(_rangeEncoder' 1);                                  if (pos == 1)                                      _isRepG1[_state.Index].Encode(_rangeEncoder' 0);                                  else                                  {                                      _isRepG1[_state.Index].Encode(_rangeEncoder' 1);                                      _isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);                                  }                              }                              if (len == 1)                                  _state.UpdateShortRep();                              else                              {                                  _repMatchLenEncoder.Encode(_rangeEncoder' len - LZMABase.kMatchMinLen' posState);                                  _state.UpdateRep();                              }                              UInt32 distance = _repDistances[pos];                              if (pos != 0)                              {                                  for (UInt32 i = pos; i >= 1; i--)                                      _repDistances[i] = _repDistances[i - 1];                                  _repDistances[0] = distance;                              }                          }                          else                          {                              _isRep[_state.Index].Encode(_rangeEncoder' 0);                              _state.UpdateMatch();                              _lenEncoder.Encode(_rangeEncoder' len - LZMABase.kMatchMinLen' posState);                              pos -= LZMABase.kNumRepDistances;                              UInt32 posSlot = GetPosSlot(pos);                              UInt32 lenToPosState = LZMABase.GetLenToPosState(len);                              _posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);                                if (posSlot >= LZMABase.kStartPosModelIndex)                              {                                  int footerBits = (int)((posSlot >> 1) - 1);                                  UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                                  UInt32 posReduced = pos - baseVal;                                    if (posSlot < LZMABase.kEndPosModelIndex)                                      LZMARangeBitTreeEncoder.ReverseEncode(_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);                                  else                                  {                                      _rangeEncoder.EncodeDirectBits(posReduced >> LZMABase.kNumAlignBits' footerBits - LZMABase.kNumAlignBits);                                      _posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & LZMABase.kAlignMask);                                      _alignPriceCount++;                                  }                              }                              UInt32 distance = pos;                              for (UInt32 i = LZMABase.kNumRepDistances - 1; i >= 1; i--)                                  _repDistances[i] = _repDistances[i - 1];                              _repDistances[0] = distance;                              _matchPriceCount++;                          }                          _previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));                      }                      _additionalOffset -= len;                      nowPos64 += len;                      if (_additionalOffset == 0)                      {                          // if (!_fastMode)                          if (_matchPriceCount >= (1 << 7))                              FillDistancesPrices();                          if (_alignPriceCount >= LZMABase.kAlignTableSize)                              FillAlignPrices();                          inSize = nowPos64;                          outSize = _rangeEncoder.GetProcessedSizeAdd();                          if (_matchFinder.GetNumAvailableBytes() == 0)                          {                              Flush((UInt32)nowPos64);                              return;                          }                            if (nowPos64 - progressPosValuePrev >= (1 << 12))                          {                              _finished = false;                              finished = false;                              return;                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,CodeOneBlock,The following statement contains a magic number: while (true)                  {                      UInt32 pos;                      UInt32 len = GetOptimum((UInt32)nowPos64' out pos);                        UInt32 posState = ((UInt32)nowPos64) & _posStateMask;                      UInt32 complexState = (_state.Index << LZMABase.kNumPosStatesBitsMax) + posState;                      if (len == 1 && pos == 0xFFFFFFFF)                      {                          _isMatch[complexState].Encode(_rangeEncoder' 0);                          Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));                          LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);                          if (!_state.IsCharState())                          {                              Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));                              subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);                          }                          else                              subCoder.Encode(_rangeEncoder' curByte);                          _previousByte = curByte;                          _state.UpdateChar();                      }                      else                      {                          _isMatch[complexState].Encode(_rangeEncoder' 1);                          if (pos < LZMABase.kNumRepDistances)                          {                              _isRep[_state.Index].Encode(_rangeEncoder' 1);                              if (pos == 0)                              {                                  _isRepG0[_state.Index].Encode(_rangeEncoder' 0);                                  if (len == 1)                                      _isRep0Long[complexState].Encode(_rangeEncoder' 0);                                  else                                      _isRep0Long[complexState].Encode(_rangeEncoder' 1);                              }                              else                              {                                  _isRepG0[_state.Index].Encode(_rangeEncoder' 1);                                  if (pos == 1)                                      _isRepG1[_state.Index].Encode(_rangeEncoder' 0);                                  else                                  {                                      _isRepG1[_state.Index].Encode(_rangeEncoder' 1);                                      _isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);                                  }                              }                              if (len == 1)                                  _state.UpdateShortRep();                              else                              {                                  _repMatchLenEncoder.Encode(_rangeEncoder' len - LZMABase.kMatchMinLen' posState);                                  _state.UpdateRep();                              }                              UInt32 distance = _repDistances[pos];                              if (pos != 0)                              {                                  for (UInt32 i = pos; i >= 1; i--)                                      _repDistances[i] = _repDistances[i - 1];                                  _repDistances[0] = distance;                              }                          }                          else                          {                              _isRep[_state.Index].Encode(_rangeEncoder' 0);                              _state.UpdateMatch();                              _lenEncoder.Encode(_rangeEncoder' len - LZMABase.kMatchMinLen' posState);                              pos -= LZMABase.kNumRepDistances;                              UInt32 posSlot = GetPosSlot(pos);                              UInt32 lenToPosState = LZMABase.GetLenToPosState(len);                              _posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);                                if (posSlot >= LZMABase.kStartPosModelIndex)                              {                                  int footerBits = (int)((posSlot >> 1) - 1);                                  UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                                  UInt32 posReduced = pos - baseVal;                                    if (posSlot < LZMABase.kEndPosModelIndex)                                      LZMARangeBitTreeEncoder.ReverseEncode(_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);                                  else                                  {                                      _rangeEncoder.EncodeDirectBits(posReduced >> LZMABase.kNumAlignBits' footerBits - LZMABase.kNumAlignBits);                                      _posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & LZMABase.kAlignMask);                                      _alignPriceCount++;                                  }                              }                              UInt32 distance = pos;                              for (UInt32 i = LZMABase.kNumRepDistances - 1; i >= 1; i--)                                  _repDistances[i] = _repDistances[i - 1];                              _repDistances[0] = distance;                              _matchPriceCount++;                          }                          _previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));                      }                      _additionalOffset -= len;                      nowPos64 += len;                      if (_additionalOffset == 0)                      {                          // if (!_fastMode)                          if (_matchPriceCount >= (1 << 7))                              FillDistancesPrices();                          if (_alignPriceCount >= LZMABase.kAlignTableSize)                              FillAlignPrices();                          inSize = nowPos64;                          outSize = _rangeEncoder.GetProcessedSizeAdd();                          if (_matchFinder.GetNumAvailableBytes() == 0)                          {                              Flush((UInt32)nowPos64);                              return;                          }                            if (nowPos64 - progressPosValuePrev >= (1 << 12))                          {                              _finished = false;                              finished = false;                              return;                          }                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                      properties[1 + i] = (Byte)(_dictionarySize >> (8 * i));
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                      properties[1 + i] = (Byte)(_dictionarySize >> (8 * i));
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,FillDistancesPrices,The following statement contains a magic number: for (UInt32 i = LZMABase.kStartPosModelIndex; i < LZMABase.kNumFullDistances; i++)                  {                      UInt32 posSlot = GetPosSlot(i);                      int footerBits = (int)((posSlot >> 1) - 1);                      UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                      tempPrices[i] = LZMARangeBitTreeEncoder.ReverseGetPrice(_posEncoders' baseVal - posSlot - 1' footerBits' i - baseVal);                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)                  {                      object prop = properties[i];                      switch (propIDs[i])                      {                          case CoderPropID.NumFastBytes:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 numFastBytes = (Int32)prop;                                  if (numFastBytes < 5 || numFastBytes > LZMABase.kMatchMaxLen)                                      throw new Exception();                                  _numFastBytes = (UInt32)numFastBytes;                                  break;                              }                          case CoderPropID.Algorithm:                              {                                  break;                              }                          case CoderPropID.MatchFinder:                              {                                  if (!(prop is String))                                      throw new Exception();                                  EMatchFinderType matchFinderIndexPrev = _matchFinderType;                                  int m = FindMatchFinder(((string)prop).ToUpper());                                  if (m < 0)                                      throw new Exception();                                  _matchFinderType = (EMatchFinderType)m;                                  if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                                  {                                      _dictionarySizePrev = 0xFFFFFFFF;                                      _matchFinder = null;                                  }                                  break;                              }                          case CoderPropID.DictionarySize:                              {                                  const int kDicLogSizeMaxCompress = 30;                                  if (!(prop is Int32))                                      throw new Exception(); ;                                  Int32 dictionarySize = (Int32)prop;                                  if (dictionarySize < (UInt32)(1 << LZMABase.kDicLogSizeMin) ||                                      dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                                      throw new Exception();                                  _dictionarySize = (UInt32)dictionarySize;                                  int dicLogSize;                                  for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                                      if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                          break;                                  _distTableSize = (UInt32)dicLogSize * 2;                                  break;                              }                          case CoderPropID.PosStateBits:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 v = (Int32)prop;                                  if (v < 0 || v > (UInt32)LZMABase.kNumPosStatesBitsEncodingMax)                                      throw new Exception();                                  _posStateBits = (int)v;                                  _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                                  break;                              }                          case CoderPropID.LitPosBits:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 v = (Int32)prop;                                  if (v < 0 || v > (UInt32)LZMABase.kNumLitPosStatesBitsEncodingMax)                                      throw new Exception();                                  _numLiteralPosStateBits = (int)v;                                  break;                              }                          case CoderPropID.LitContextBits:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 v = (Int32)prop;                                  if (v < 0 || v > (UInt32)LZMABase.kNumLitContextBitsMax)                                      throw new Exception(); ;                                  _numLiteralContextBits = (int)v;                                  break;                              }                          case CoderPropID.EndMarker:                              {                                  if (!(prop is Boolean))                                      throw new Exception();                                  SetWriteEndMarkerMode((Boolean)prop);                                  break;                              }                          default:                              throw new Exception();                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)                  {                      object prop = properties[i];                      switch (propIDs[i])                      {                          case CoderPropID.NumFastBytes:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 numFastBytes = (Int32)prop;                                  if (numFastBytes < 5 || numFastBytes > LZMABase.kMatchMaxLen)                                      throw new Exception();                                  _numFastBytes = (UInt32)numFastBytes;                                  break;                              }                          case CoderPropID.Algorithm:                              {                                  break;                              }                          case CoderPropID.MatchFinder:                              {                                  if (!(prop is String))                                      throw new Exception();                                  EMatchFinderType matchFinderIndexPrev = _matchFinderType;                                  int m = FindMatchFinder(((string)prop).ToUpper());                                  if (m < 0)                                      throw new Exception();                                  _matchFinderType = (EMatchFinderType)m;                                  if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                                  {                                      _dictionarySizePrev = 0xFFFFFFFF;                                      _matchFinder = null;                                  }                                  break;                              }                          case CoderPropID.DictionarySize:                              {                                  const int kDicLogSizeMaxCompress = 30;                                  if (!(prop is Int32))                                      throw new Exception(); ;                                  Int32 dictionarySize = (Int32)prop;                                  if (dictionarySize < (UInt32)(1 << LZMABase.kDicLogSizeMin) ||                                      dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                                      throw new Exception();                                  _dictionarySize = (UInt32)dictionarySize;                                  int dicLogSize;                                  for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                                      if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                          break;                                  _distTableSize = (UInt32)dicLogSize * 2;                                  break;                              }                          case CoderPropID.PosStateBits:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 v = (Int32)prop;                                  if (v < 0 || v > (UInt32)LZMABase.kNumPosStatesBitsEncodingMax)                                      throw new Exception();                                  _posStateBits = (int)v;                                  _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                                  break;                              }                          case CoderPropID.LitPosBits:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 v = (Int32)prop;                                  if (v < 0 || v > (UInt32)LZMABase.kNumLitPosStatesBitsEncodingMax)                                      throw new Exception();                                  _numLiteralPosStateBits = (int)v;                                  break;                              }                          case CoderPropID.LitContextBits:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 v = (Int32)prop;                                  if (v < 0 || v > (UInt32)LZMABase.kNumLitContextBitsMax)                                      throw new Exception(); ;                                  _numLiteralContextBits = (int)v;                                  break;                              }                          case CoderPropID.EndMarker:                              {                                  if (!(prop is Boolean))                                      throw new Exception();                                  SetWriteEndMarkerMode((Boolean)prop);                                  break;                              }                          default:                              throw new Exception();                      }                  }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)                  {                      object prop = properties[i];                      switch (propIDs[i])                      {                          case CoderPropID.NumFastBytes:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 numFastBytes = (Int32)prop;                                  if (numFastBytes < 5 || numFastBytes > LZMABase.kMatchMaxLen)                                      throw new Exception();                                  _numFastBytes = (UInt32)numFastBytes;                                  break;                              }                          case CoderPropID.Algorithm:                              {                                  break;                              }                          case CoderPropID.MatchFinder:                              {                                  if (!(prop is String))                                      throw new Exception();                                  EMatchFinderType matchFinderIndexPrev = _matchFinderType;                                  int m = FindMatchFinder(((string)prop).ToUpper());                                  if (m < 0)                                      throw new Exception();                                  _matchFinderType = (EMatchFinderType)m;                                  if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                                  {                                      _dictionarySizePrev = 0xFFFFFFFF;                                      _matchFinder = null;                                  }                                  break;                              }                          case CoderPropID.DictionarySize:                              {                                  const int kDicLogSizeMaxCompress = 30;                                  if (!(prop is Int32))                                      throw new Exception(); ;                                  Int32 dictionarySize = (Int32)prop;                                  if (dictionarySize < (UInt32)(1 << LZMABase.kDicLogSizeMin) ||                                      dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                                      throw new Exception();                                  _dictionarySize = (UInt32)dictionarySize;                                  int dicLogSize;                                  for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                                      if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                          break;                                  _distTableSize = (UInt32)dicLogSize * 2;                                  break;                              }                          case CoderPropID.PosStateBits:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 v = (Int32)prop;                                  if (v < 0 || v > (UInt32)LZMABase.kNumPosStatesBitsEncodingMax)                                      throw new Exception();                                  _posStateBits = (int)v;                                  _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                                  break;                              }                          case CoderPropID.LitPosBits:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 v = (Int32)prop;                                  if (v < 0 || v > (UInt32)LZMABase.kNumLitPosStatesBitsEncodingMax)                                      throw new Exception();                                  _numLiteralPosStateBits = (int)v;                                  break;                              }                          case CoderPropID.LitContextBits:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 v = (Int32)prop;                                  if (v < 0 || v > (UInt32)LZMABase.kNumLitContextBitsMax)                                      throw new Exception(); ;                                  _numLiteralContextBits = (int)v;                                  break;                              }                          case CoderPropID.EndMarker:                              {                                  if (!(prop is Boolean))                                      throw new Exception();                                  SetWriteEndMarkerMode((Boolean)prop);                                  break;                              }                          default:                              throw new Exception();                      }                  }
Magic Number,Orvid.Compression,LiteralEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetSubCoder,The following statement contains a magic number: return m_Coders[((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits))];
Magic Number,Orvid.Compression,Encoder2,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Encode,The following statement contains a magic number: for (int i = 7; i >= 0; i--)                          {                              uint bit = (uint)((symbol >> i) & 1);                              m_Encoders[context].Encode(rangeEncoder' bit);                              context = (context << 1) | bit;                          }
Magic Number,Orvid.Compression,Encoder2,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,EncodeMatched,The following statement contains a magic number: for (int i = 7; i >= 0; i--)                          {                              uint bit = (uint)((symbol >> i) & 1);                              uint state = context;                              if (same)                              {                                  uint matchBit = (uint)((matchByte >> i) & 1);                                  state += ((1 + matchBit) << 8);                                  same = (matchBit == bit);                              }                              m_Encoders[state].Encode(rangeEncoder' bit);                              context = (context << 1) | bit;                          }
Magic Number,Orvid.Compression,Encoder2,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,EncodeMatched,The following statement contains a magic number: for (int i = 7; i >= 0; i--)                          {                              uint bit = (uint)((symbol >> i) & 1);                              uint state = context;                              if (same)                              {                                  uint matchBit = (uint)((matchByte >> i) & 1);                                  state += ((1 + matchBit) << 8);                                  same = (matchBit == bit);                              }                              m_Encoders[state].Encode(rangeEncoder' bit);                              context = (context << 1) | bit;                          }
Magic Number,Orvid.Compression,Encoder2,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPrice,The following statement contains a magic number: int i = 7;
Magic Number,Orvid.Compression,Encoder2,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPrice,The following statement contains a magic number: if (matchMode)                          {                              for (; i >= 0; i--)                              {                                  uint matchBit = (uint)(matchByte >> i) & 1;                                  uint bit = (uint)(symbol >> i) & 1;                                  price += m_Encoders[((1 + matchBit) << 8) + context].GetPrice(bit);                                  context = (context << 1) | bit;                                  if (matchBit != bit)                                  {                                      i--;                                      break;                                  }                              }                          }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetType,The following statement contains a magic number: HASH_ARRAY = (numHashBytes > 2);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)                  {                      kNumHashDirectBytes = 0;                      kMinMatchCheck = 4;                      kFixHashSize = kHash2Size + kHash3Size;                  }                  else                  {                      kNumHashDirectBytes = 2;                      kMinMatchCheck = 2 + 1;                      kFixHashSize = 0;                  }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)                  {                      kNumHashDirectBytes = 0;                      kMinMatchCheck = 4;                      kFixHashSize = kHash2Size + kHash3Size;                  }                  else                  {                      kNumHashDirectBytes = 2;                      kMinMatchCheck = 2 + 1;                      kFixHashSize = 0;                  }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)                  {                      kNumHashDirectBytes = 0;                      kMinMatchCheck = 4;                      kFixHashSize = kHash2Size + kHash3Size;                  }                  else                  {                      kNumHashDirectBytes = 2;                      kMinMatchCheck = 2 + 1;                      kFixHashSize = 0;                  }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: if (historySize > kMaxValForNormalize - 256)                      throw new Exception();
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: _cutValue = 16 + (matchMaxLen >> 1);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +                          matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +                          matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: if (_cyclicBufferSize != cyclicBufferSize)                      _son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)                  {                      hs = historySize - 1;                      hs |= (hs >> 1);                      hs |= (hs >> 2);                      hs |= (hs >> 4);                      hs |= (hs >> 8);                      hs >>= 1;                      hs |= 0xFFFF;                      if (hs > (1 << 24))                          hs >>= 1;                      _hashMask = hs;                      hs++;                      hs += kFixHashSize;                  }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)                  {                      hs = historySize - 1;                      hs |= (hs >> 1);                      hs |= (hs >> 2);                      hs |= (hs >> 4);                      hs |= (hs >> 8);                      hs >>= 1;                      hs |= 0xFFFF;                      if (hs > (1 << 24))                          hs >>= 1;                      _hashMask = hs;                      hs++;                      hs += kFixHashSize;                  }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)                  {                      hs = historySize - 1;                      hs |= (hs >> 1);                      hs |= (hs >> 2);                      hs |= (hs >> 4);                      hs |= (hs >> 8);                      hs >>= 1;                      hs |= 0xFFFF;                      if (hs > (1 << 24))                          hs >>= 1;                      _hashMask = hs;                      hs++;                      hs += kFixHashSize;                  }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)                  {                      hs = historySize - 1;                      hs |= (hs >> 1);                      hs |= (hs >> 2);                      hs |= (hs >> 4);                      hs |= (hs >> 8);                      hs >>= 1;                      hs |= 0xFFFF;                      if (hs > (1 << 24))                          hs >>= 1;                      _hashMask = hs;                      hs++;                      hs += kFixHashSize;                  }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)                  {                      UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                      hash2Value = temp & (kHash2Size - 1);                      temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                      hash3Value = temp & (kHash3Size - 1);                      hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                  }                  else                      hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)                  {                      UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                      hash2Value = temp & (kHash2Size - 1);                      temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                      hash3Value = temp & (kHash3Size - 1);                      hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                  }                  else                      hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)                  {                      UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                      hash2Value = temp & (kHash2Size - 1);                      temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                      hash3Value = temp & (kHash3Size - 1);                      hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                  }                  else                      hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)                  {                      UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                      hash2Value = temp & (kHash2Size - 1);                      temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                      hash3Value = temp & (kHash3Size - 1);                      hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                  }                  else                      hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)                  {                      UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                      hash2Value = temp & (kHash2Size - 1);                      temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                      hash3Value = temp & (kHash3Size - 1);                      hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                  }                  else                      hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)                  {                      UInt32 curMatch2 = _hash[hash2Value];                      UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];                      _hash[hash2Value] = _pos;                      _hash[kHash3Offset + hash3Value] = _pos;                      if (curMatch2 > matchMinPos)                          if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])                          {                              distances[offset++] = maxLen = 2;                              distances[offset++] = _pos - curMatch2 - 1;                          }                      if (curMatch3 > matchMinPos)                          if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])                          {                              if (curMatch3 == curMatch2)                                  offset -= 2;                              distances[offset++] = maxLen = 3;                              distances[offset++] = _pos - curMatch3 - 1;                              curMatch2 = curMatch3;                          }                      if (offset != 0 && curMatch2 == curMatch)                      {                          offset -= 2;                          maxLen = kStartMaxLen;                      }                  }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)                  {                      UInt32 curMatch2 = _hash[hash2Value];                      UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];                      _hash[hash2Value] = _pos;                      _hash[kHash3Offset + hash3Value] = _pos;                      if (curMatch2 > matchMinPos)                          if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])                          {                              distances[offset++] = maxLen = 2;                              distances[offset++] = _pos - curMatch2 - 1;                          }                      if (curMatch3 > matchMinPos)                          if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])                          {                              if (curMatch3 == curMatch2)                                  offset -= 2;                              distances[offset++] = maxLen = 3;                              distances[offset++] = _pos - curMatch3 - 1;                              curMatch2 = curMatch3;                          }                      if (offset != 0 && curMatch2 == curMatch)                      {                          offset -= 2;                          maxLen = kStartMaxLen;                      }                  }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)                  {                      UInt32 curMatch2 = _hash[hash2Value];                      UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];                      _hash[hash2Value] = _pos;                      _hash[kHash3Offset + hash3Value] = _pos;                      if (curMatch2 > matchMinPos)                          if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])                          {                              distances[offset++] = maxLen = 2;                              distances[offset++] = _pos - curMatch2 - 1;                          }                      if (curMatch3 > matchMinPos)                          if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])                          {                              if (curMatch3 == curMatch2)                                  offset -= 2;                              distances[offset++] = maxLen = 3;                              distances[offset++] = _pos - curMatch3 - 1;                              curMatch2 = curMatch3;                          }                      if (offset != 0 && curMatch2 == curMatch)                      {                          offset -= 2;                          maxLen = kStartMaxLen;                      }                  }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)                  {                      UInt32 curMatch2 = _hash[hash2Value];                      UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];                      _hash[hash2Value] = _pos;                      _hash[kHash3Offset + hash3Value] = _pos;                      if (curMatch2 > matchMinPos)                          if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])                          {                              distances[offset++] = maxLen = 2;                              distances[offset++] = _pos - curMatch2 - 1;                          }                      if (curMatch3 > matchMinPos)                          if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])                          {                              if (curMatch3 == curMatch2)                                  offset -= 2;                              distances[offset++] = maxLen = 3;                              distances[offset++] = _pos - curMatch3 - 1;                              curMatch2 = curMatch3;                          }                      if (offset != 0 && curMatch2 == curMatch)                      {                          offset -= 2;                          maxLen = kStartMaxLen;                      }                  }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Skip,The following statement contains a magic number: do                  {                      UInt32 lenLimit;                      if (_pos + _matchMaxLen <= _streamPos)                          lenLimit = _matchMaxLen;                      else                      {                          lenLimit = _streamPos - _pos;                          if (lenLimit < kMinMatchCheck)                          {                              MovePos();                              continue;                          }                      }                        UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                      UInt32 cur = _bufferOffset + _pos;                        UInt32 hashValue;                        if (HASH_ARRAY)                      {                          UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                          UInt32 hash2Value = temp & (kHash2Size - 1);                          _hash[hash2Value] = _pos;                          temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                          UInt32 hash3Value = temp & (kHash3Size - 1);                          _hash[kHash3Offset + hash3Value] = _pos;                          hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                      }                      else                          hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                        UInt32 curMatch = _hash[kFixHashSize + hashValue];                      _hash[kFixHashSize + hashValue] = _pos;                        UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                      UInt32 ptr1 = (_cyclicBufferPos << 1);                        UInt32 len0' len1;                      len0 = len1 = kNumHashDirectBytes;                        UInt32 count = _cutValue;                      while (true)                      {                          if (curMatch <= matchMinPos || count-- == 0)                          {                              _son[ptr0] = _son[ptr1] = kEmptyHashValue;                              break;                          }                            UInt32 delta = _pos - curMatch;                          UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                      (_cyclicBufferPos - delta) :                                      (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                            UInt32 pby1 = _bufferOffset + curMatch;                          UInt32 len = Math.Min(len0' len1);                          if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                          {                              while (++len != lenLimit)                                  if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                      break;                              if (len == lenLimit)                              {                                  _son[ptr1] = _son[cyclicPos];                                  _son[ptr0] = _son[cyclicPos + 1];                                  break;                              }                          }                          if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                          {                              _son[ptr1] = curMatch;                              ptr1 = cyclicPos + 1;                              curMatch = _son[ptr1];                              len1 = len;                          }                          else                          {                              _son[ptr0] = curMatch;                              ptr0 = cyclicPos;                              curMatch = _son[ptr0];                              len0 = len;                          }                      }                      MovePos();                  }                  while (--num != 0);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Skip,The following statement contains a magic number: do                  {                      UInt32 lenLimit;                      if (_pos + _matchMaxLen <= _streamPos)                          lenLimit = _matchMaxLen;                      else                      {                          lenLimit = _streamPos - _pos;                          if (lenLimit < kMinMatchCheck)                          {                              MovePos();                              continue;                          }                      }                        UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                      UInt32 cur = _bufferOffset + _pos;                        UInt32 hashValue;                        if (HASH_ARRAY)                      {                          UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                          UInt32 hash2Value = temp & (kHash2Size - 1);                          _hash[hash2Value] = _pos;                          temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                          UInt32 hash3Value = temp & (kHash3Size - 1);                          _hash[kHash3Offset + hash3Value] = _pos;                          hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                      }                      else                          hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                        UInt32 curMatch = _hash[kFixHashSize + hashValue];                      _hash[kFixHashSize + hashValue] = _pos;                        UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                      UInt32 ptr1 = (_cyclicBufferPos << 1);                        UInt32 len0' len1;                      len0 = len1 = kNumHashDirectBytes;                        UInt32 count = _cutValue;                      while (true)                      {                          if (curMatch <= matchMinPos || count-- == 0)                          {                              _son[ptr0] = _son[ptr1] = kEmptyHashValue;                              break;                          }                            UInt32 delta = _pos - curMatch;                          UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                      (_cyclicBufferPos - delta) :                                      (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                            UInt32 pby1 = _bufferOffset + curMatch;                          UInt32 len = Math.Min(len0' len1);                          if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                          {                              while (++len != lenLimit)                                  if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                      break;                              if (len == lenLimit)                              {                                  _son[ptr1] = _son[cyclicPos];                                  _son[ptr0] = _son[cyclicPos + 1];                                  break;                              }                          }                          if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                          {                              _son[ptr1] = curMatch;                              ptr1 = cyclicPos + 1;                              curMatch = _son[ptr1];                              len1 = len;                          }                          else                          {                              _son[ptr0] = curMatch;                              ptr0 = cyclicPos;                              curMatch = _son[ptr0];                              len0 = len;                          }                      }                      MovePos();                  }                  while (--num != 0);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Skip,The following statement contains a magic number: do                  {                      UInt32 lenLimit;                      if (_pos + _matchMaxLen <= _streamPos)                          lenLimit = _matchMaxLen;                      else                      {                          lenLimit = _streamPos - _pos;                          if (lenLimit < kMinMatchCheck)                          {                              MovePos();                              continue;                          }                      }                        UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                      UInt32 cur = _bufferOffset + _pos;                        UInt32 hashValue;                        if (HASH_ARRAY)                      {                          UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                          UInt32 hash2Value = temp & (kHash2Size - 1);                          _hash[hash2Value] = _pos;                          temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                          UInt32 hash3Value = temp & (kHash3Size - 1);                          _hash[kHash3Offset + hash3Value] = _pos;                          hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                      }                      else                          hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                        UInt32 curMatch = _hash[kFixHashSize + hashValue];                      _hash[kFixHashSize + hashValue] = _pos;                        UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                      UInt32 ptr1 = (_cyclicBufferPos << 1);                        UInt32 len0' len1;                      len0 = len1 = kNumHashDirectBytes;                        UInt32 count = _cutValue;                      while (true)                      {                          if (curMatch <= matchMinPos || count-- == 0)                          {                              _son[ptr0] = _son[ptr1] = kEmptyHashValue;                              break;                          }                            UInt32 delta = _pos - curMatch;                          UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                      (_cyclicBufferPos - delta) :                                      (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                            UInt32 pby1 = _bufferOffset + curMatch;                          UInt32 len = Math.Min(len0' len1);                          if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                          {                              while (++len != lenLimit)                                  if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                      break;                              if (len == lenLimit)                              {                                  _son[ptr1] = _son[cyclicPos];                                  _son[ptr0] = _son[cyclicPos + 1];                                  break;                              }                          }                          if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                          {                              _son[ptr1] = curMatch;                              ptr1 = cyclicPos + 1;                              curMatch = _son[ptr1];                              len1 = len;                          }                          else                          {                              _son[ptr0] = curMatch;                              ptr0 = cyclicPos;                              curMatch = _son[ptr0];                              len0 = len;                          }                      }                      MovePos();                  }                  while (--num != 0);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Skip,The following statement contains a magic number: do                  {                      UInt32 lenLimit;                      if (_pos + _matchMaxLen <= _streamPos)                          lenLimit = _matchMaxLen;                      else                      {                          lenLimit = _streamPos - _pos;                          if (lenLimit < kMinMatchCheck)                          {                              MovePos();                              continue;                          }                      }                        UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                      UInt32 cur = _bufferOffset + _pos;                        UInt32 hashValue;                        if (HASH_ARRAY)                      {                          UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                          UInt32 hash2Value = temp & (kHash2Size - 1);                          _hash[hash2Value] = _pos;                          temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                          UInt32 hash3Value = temp & (kHash3Size - 1);                          _hash[kHash3Offset + hash3Value] = _pos;                          hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                      }                      else                          hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                        UInt32 curMatch = _hash[kFixHashSize + hashValue];                      _hash[kFixHashSize + hashValue] = _pos;                        UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                      UInt32 ptr1 = (_cyclicBufferPos << 1);                        UInt32 len0' len1;                      len0 = len1 = kNumHashDirectBytes;                        UInt32 count = _cutValue;                      while (true)                      {                          if (curMatch <= matchMinPos || count-- == 0)                          {                              _son[ptr0] = _son[ptr1] = kEmptyHashValue;                              break;                          }                            UInt32 delta = _pos - curMatch;                          UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                      (_cyclicBufferPos - delta) :                                      (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                            UInt32 pby1 = _bufferOffset + curMatch;                          UInt32 len = Math.Min(len0' len1);                          if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                          {                              while (++len != lenLimit)                                  if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                      break;                              if (len == lenLimit)                              {                                  _son[ptr1] = _son[cyclicPos];                                  _son[ptr0] = _son[cyclicPos + 1];                                  break;                              }                          }                          if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                          {                              _son[ptr1] = curMatch;                              ptr1 = cyclicPos + 1;                              curMatch = _son[ptr1];                              len1 = len;                          }                          else                          {                              _son[ptr0] = curMatch;                              ptr0 = cyclicPos;                              curMatch = _son[ptr0];                              len0 = len;                          }                      }                      MovePos();                  }                  while (--num != 0);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Skip,The following statement contains a magic number: do                  {                      UInt32 lenLimit;                      if (_pos + _matchMaxLen <= _streamPos)                          lenLimit = _matchMaxLen;                      else                      {                          lenLimit = _streamPos - _pos;                          if (lenLimit < kMinMatchCheck)                          {                              MovePos();                              continue;                          }                      }                        UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                      UInt32 cur = _bufferOffset + _pos;                        UInt32 hashValue;                        if (HASH_ARRAY)                      {                          UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                          UInt32 hash2Value = temp & (kHash2Size - 1);                          _hash[hash2Value] = _pos;                          temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                          UInt32 hash3Value = temp & (kHash3Size - 1);                          _hash[kHash3Offset + hash3Value] = _pos;                          hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                      }                      else                          hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                        UInt32 curMatch = _hash[kFixHashSize + hashValue];                      _hash[kFixHashSize + hashValue] = _pos;                        UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                      UInt32 ptr1 = (_cyclicBufferPos << 1);                        UInt32 len0' len1;                      len0 = len1 = kNumHashDirectBytes;                        UInt32 count = _cutValue;                      while (true)                      {                          if (curMatch <= matchMinPos || count-- == 0)                          {                              _son[ptr0] = _son[ptr1] = kEmptyHashValue;                              break;                          }                            UInt32 delta = _pos - curMatch;                          UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                      (_cyclicBufferPos - delta) :                                      (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                            UInt32 pby1 = _bufferOffset + curMatch;                          UInt32 len = Math.Min(len0' len1);                          if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                          {                              while (++len != lenLimit)                                  if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                      break;                              if (len == lenLimit)                              {                                  _son[ptr1] = _son[cyclicPos];                                  _son[ptr0] = _son[cyclicPos + 1];                                  break;                              }                          }                          if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                          {                              _son[ptr1] = curMatch;                              ptr1 = cyclicPos + 1;                              curMatch = _son[ptr1];                              len1 = len;                          }                          else                          {                              _son[ptr0] = curMatch;                              ptr0 = cyclicPos;                              curMatch = _son[ptr0];                              len0 = len;                          }                      }                      MovePos();                  }                  while (--num != 0);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Normalize,The following statement contains a magic number: NormalizeLinks(_son' _cyclicBufferSize * 2' subValue);
Magic Number,Orvid.Compression,CRC,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,CRC,The following statement contains a magic number: Table = new uint[256];
Magic Number,Orvid.Compression,CRC,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)                  {                      uint r = i;                      for (int j = 0; j < 8; j++)                          if ((r & 1) != 0)                              r = (r >> 1) ^ kPoly;                          else                              r >>= 1;                      Table[i] = r;                  }
Magic Number,Orvid.Compression,CRC,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)                  {                      uint r = i;                      for (int j = 0; j < 8; j++)                          if ((r & 1) != 0)                              r = (r >> 1) ^ kPoly;                          else                              r >>= 1;                      Table[i] = r;                  }
Magic Number,Orvid.Compression,CRC,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateByte,The following statement contains a magic number: _value = Table[(((byte)(_value)) ^ b)] ^ (_value >> 8);
Magic Number,Orvid.Compression,CRC,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Update,The following statement contains a magic number: for (uint i = 0; i < size; i++)                      _value = Table[(((byte)(_value)) ^ data[offset + i])] ^ (_value >> 8);
Magic Number,Orvid.Compression,LZMARangeEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,FlushData,The following statement contains a magic number: for (int i = 0; i < 5; i++)                      ShiftLow();
Magic Number,Orvid.Compression,LZMARangeEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Encode,The following statement contains a magic number: while (Range < kTopValue)                  {                      Range <<= 8;                      ShiftLow();                  }
Magic Number,Orvid.Compression,LZMARangeEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)                  {                      byte temp = _cache;                      do                      {                          Stream.WriteByte((byte)(temp + (Low >> 32)));                          temp = 0xFF;                      } while (--_cacheSize != 0);                        _cache = (byte)(((uint)Low) >> 24);                  }
Magic Number,Orvid.Compression,LZMARangeEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)                  {                      byte temp = _cache;                      do                      {                          Stream.WriteByte((byte)(temp + (Low >> 32)));                          temp = 0xFF;                      } while (--_cacheSize != 0);                        _cache = (byte)(((uint)Low) >> 24);                  }
Magic Number,Orvid.Compression,LZMARangeEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)                  {                      byte temp = _cache;                      do                      {                          Stream.WriteByte((byte)(temp + (Low >> 32)));                          temp = 0xFF;                      } while (--_cacheSize != 0);                        _cache = (byte)(((uint)Low) >> 24);                  }
Magic Number,Orvid.Compression,LZMARangeEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,ShiftLow,The following statement contains a magic number: Low = ((uint)Low) << 8;
Magic Number,Orvid.Compression,LZMARangeEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,EncodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits - 1; i >= 0; i--)                  {                      Range >>= 1;                      if (((v >> i) & 1) == 1)                          Low += Range;                      if (Range < kTopValue)                      {                          Range <<= 8;                          ShiftLow();                      }                  }
Magic Number,Orvid.Compression,LZMARangeEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,EncodeBit,The following statement contains a magic number: while (Range < kTopValue)                  {                      Range <<= 8;                      ShiftLow();                  }
Magic Number,Orvid.Compression,LZMARangeEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetProcessedSizeAdd,The following statement contains a magic number: return _cacheSize + Stream.Position - StartPosition + 4;
Magic Number,Orvid.Compression,LZMARangeDecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)                      Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,Orvid.Compression,LZMARangeDecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)                      Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,Orvid.Compression,LZMARangeDecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)                  {                      Code = (Code << 8) | (byte)Stream.ReadByte();                      Range <<= 8;                  }
Magic Number,Orvid.Compression,LZMARangeDecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)                  {                      Code = (Code << 8) | (byte)Stream.ReadByte();                      Range <<= 8;                  }
Magic Number,Orvid.Compression,LZMARangeDecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue)                  {                      Code = (Code << 8) | (byte)Stream.ReadByte();                      Range <<= 8;                  }
Magic Number,Orvid.Compression,LZMARangeDecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue)                  {                      Code = (Code << 8) | (byte)Stream.ReadByte();                      Range <<= 8;                  }
Magic Number,Orvid.Compression,LZMARangeDecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)                  {                      range >>= 1;                      uint t = (code - range) >> 31;                      code -= range & (t - 1);                      result = (result << 1) | (1 - t);                        if (range < kTopValue)                      {                          code = (code << 8) | (byte)Stream.ReadByte();                          range <<= 8;                      }                  }
Magic Number,Orvid.Compression,LZMARangeDecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)                  {                      range >>= 1;                      uint t = (code - range) >> 31;                      code -= range & (t - 1);                      result = (result << 1) | (1 - t);                        if (range < kTopValue)                      {                          code = (code << 8) | (byte)Stream.ReadByte();                          range <<= 8;                      }                  }
Magic Number,Orvid.Compression,LZMARangeDecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)                  {                      range >>= 1;                      uint t = (code - range) >> 31;                      code -= range & (t - 1);                      result = (result << 1) | (1 - t);                        if (range < kTopValue)                      {                          code = (code << 8) | (byte)Stream.ReadByte();                          range <<= 8;                      }                  }
Magic Number,Orvid.Compression,LZMARangeBitEncoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Encode,The following statement contains a magic number: if (encoder.Range < LZMARangeEncoder.kTopValue)                  {                      encoder.Range <<= 8;                      encoder.ShiftLow();                  }
Magic Number,Orvid.Compression,LZMARangeBitDecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)                  {                      rangeDecoder.Range = newBound;                      Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                      if (rangeDecoder.Range < LZMARangeDecoder.kTopValue)                      {                          rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                          rangeDecoder.Range <<= 8;                      }                      return 0;                  }                  else                  {                      rangeDecoder.Range -= newBound;                      rangeDecoder.Code -= newBound;                      Prob -= (Prob) >> kNumMoveBits;                      if (rangeDecoder.Range < LZMARangeDecoder.kTopValue)                      {                          rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                          rangeDecoder.Range <<= 8;                      }                      return 1;                  }
Magic Number,Orvid.Compression,LZMARangeBitDecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)                  {                      rangeDecoder.Range = newBound;                      Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                      if (rangeDecoder.Range < LZMARangeDecoder.kTopValue)                      {                          rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                          rangeDecoder.Range <<= 8;                      }                      return 0;                  }                  else                  {                      rangeDecoder.Range -= newBound;                      rangeDecoder.Code -= newBound;                      Prob -= (Prob) >> kNumMoveBits;                      if (rangeDecoder.Range < LZMARangeDecoder.kTopValue)                      {                          rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                          rangeDecoder.Range <<= 8;                      }                      return 1;                  }
Magic Number,Orvid.Compression,LZMARangeBitDecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)                  {                      rangeDecoder.Range = newBound;                      Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                      if (rangeDecoder.Range < LZMARangeDecoder.kTopValue)                      {                          rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                          rangeDecoder.Range <<= 8;                      }                      return 0;                  }                  else                  {                      rangeDecoder.Range -= newBound;                      rangeDecoder.Code -= newBound;                      Prob -= (Prob) >> kNumMoveBits;                      if (rangeDecoder.Range < LZMARangeDecoder.kTopValue)                      {                          rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                          rangeDecoder.Range <<= 8;                      }                      return 1;                  }
Magic Number,Orvid.Compression,LZMARangeBitDecoder,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)                  {                      rangeDecoder.Range = newBound;                      Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                      if (rangeDecoder.Range < LZMARangeDecoder.kTopValue)                      {                          rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                          rangeDecoder.Range <<= 8;                      }                      return 0;                  }                  else                  {                      rangeDecoder.Range -= newBound;                      rangeDecoder.Code -= newBound;                      Prob -= (Prob) >> kNumMoveBits;                      if (rangeDecoder.Range < LZMARangeDecoder.kTopValue)                      {                          rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                          rangeDecoder.Range <<= 8;                      }                      return 1;                  }
Magic Number,Orvid.Compression.Checksums,Adler32,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\Adler32.cs,Update,The following statement contains a magic number: uint s2 = checksum >> 16;
Magic Number,Orvid.Compression.Checksums,Adler32,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) + s1;
Magic Number,Orvid.Compression.Checksums,Adler32,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\Adler32.cs,Update,The following statement contains a magic number: uint s2 = checksum >> 16;
Magic Number,Orvid.Compression.Checksums,Adler32,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\Adler32.cs,Update,The following statement contains a magic number: while (count > 0) {  				// We can defer the modulo operation:  				// s1 maximally grows from 65521 to 65521 + 255 * 3800  				// s2 maximally grows by 3800 * median(s1) = 2090079800 < 2^31  				int n = 3800;  				if (n > count) {  					n = count;  				}  				count -= n;  				while (--n >= 0) {  					s1 = s1 + (uint)(buffer[offset++] & 0xff);  					s2 = s2 + s1;  				}  				s1 %= BASE;  				s2 %= BASE;  			}
Magic Number,Orvid.Compression.Checksums,Adler32,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) | s1;
Magic Number,Orvid.Compression.Checksums,Crc32,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\CRC32.cs,ComputeCrc32,The following statement contains a magic number: return (uint)(Crc32.CrcTable[(oldCrc ^ value) & 0xFF] ^ (oldCrc >> 8));
Magic Number,Orvid.Compression.Checksums,Crc32,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\CRC32.cs,Update,The following statement contains a magic number: crc  = CrcTable[(crc ^ value) & 0xFF] ^ (crc >> 8);
Magic Number,Orvid.Compression.Checksums,Crc32,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\CRC32.cs,Update,The following statement contains a magic number: while (--count >= 0) {  				crc = CrcTable[(crc ^ buffer[offset++]) & 0xFF] ^ (crc >> 8);  			}
Magic Number,Orvid.Compression.Checksums,StrangeCRC,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\StrangeCRC.cs,Update,The following statement contains a magic number: int temp = (globalCrc >> 24) ^ value;
Magic Number,Orvid.Compression.Checksums,StrangeCRC,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\StrangeCRC.cs,Update,The following statement contains a magic number: if (temp < 0) {  				temp = 256 + temp;  			}
Magic Number,Orvid.Compression.Checksums,StrangeCRC,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\StrangeCRC.cs,Update,The following statement contains a magic number: globalCrc = unchecked((int)((globalCrc << 8) ^ crc32Table[temp]));
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MakeMaps,The following statement contains a magic number: for (int i = 0; i < 256; ++i)              {                  if (inUse[i])                  {                      seqToUnseq[nInUse] = (byte)i;                      unseqToSeq[i] = (byte)nInUse;                      nInUse++;                  }              }
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,EndBlock,The following statement contains a magic number: computedCombinedCRC = ((computedCombinedCRC << 1) & 0xFFFFFFFF) | (computedCombinedCRC >> 31);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,FillBuffer,The following statement contains a magic number: bsBuff = (bsBuff << 8) | (thech & 0xFF);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,FillBuffer,The following statement contains a magic number: bsLive += 8;
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsGetUChar,The following statement contains a magic number: return (char)BsR(8);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsGetInt32,The following statement contains a magic number: int result = BsR(8);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR(8);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR(8);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR(8);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR(8);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR(8);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR(8);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: bool[] inUse16 = new bool[16];
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  inUse16[i] = (BsR(1) == 1);              }
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if (inUse16[i])                  {                      for (int j = 0; j < 16; j++)                      {                          inUse[i * 16 + j] = (BsR(1) == 1);                      }                  }                  else                  {                      for (int j = 0; j < 16; j++)                      {                          inUse[i * 16 + j] = false;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if (inUse16[i])                  {                      for (int j = 0; j < 16; j++)                      {                          inUse[i * 16 + j] = (BsR(1) == 1);                      }                  }                  else                  {                      for (int j = 0; j < 16; j++)                      {                          inUse[i * 16 + j] = false;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if (inUse16[i])                  {                      for (int j = 0; j < 16; j++)                      {                          inUse[i * 16 + j] = (BsR(1) == 1);                      }                  }                  else                  {                      for (int j = 0; j < 16; j++)                      {                          inUse[i * 16 + j] = false;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if (inUse16[i])                  {                      for (int j = 0; j < 16; j++)                      {                          inUse[i * 16 + j] = (BsR(1) == 1);                      }                  }                  else                  {                      for (int j = 0; j < 16; j++)                      {                          inUse[i * 16 + j] = false;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if (inUse16[i])                  {                      for (int j = 0; j < 16; j++)                      {                          inUse[i * 16 + j] = (BsR(1) == 1);                      }                  }                  else                  {                      for (int j = 0; j < 16; j++)                      {                          inUse[i * 16 + j] = false;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: int alphaSize = nInUse + 2;
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: int nGroups = BsR(3);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: int nSelectors = BsR(15);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: for (int t = 0; t < nGroups; t++)              {                  int curr = BsR(5);                  for (int i = 0; i < alphaSize; i++)                  {                      while (BsR(1) == 1)                      {                          if (BsR(1) == 0)                          {                              curr++;                          }                          else                          {                              curr--;                          }                      }                      len[t][i] = (char)curr;                  }              }
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: for (int t = 0; t < nGroups; t++)              {                  int minLen = 32;                  int maxLen = 0;                  for (int i = 0; i < alphaSize; i++)                  {                      maxLen = Math.Max(maxLen' len[t][i]);                      minLen = Math.Min(minLen' len[t][i]);                  }                  HbCreateDecodeTables(limit[t]' baseArray[t]' perm[t]' len[t]' minLen' maxLen' alphaSize);                  minLens[t] = minLen;              }
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: byte[] yy = new byte[256];
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: origPtr = BsGetIntVS(24);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: for (int i = 0; i <= 255; i++)              {                  unzftab[i] = 0;              }
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: for (int i = 0; i <= 255; i++)              {                  yy[i] = (byte)i;              }
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: while (zvec > limit[zt][zn])              {                  if (zn > 20)                  { // the longest code                      throw new Exception("Bzip data error");                  }                  zn++;                  while (bsLive < 1)                  {                      FillBuffer();                  }                  zj = (bsBuff >> (bsLive - 1)) & 1;                  bsLive--;                  zvec = (zvec << 1) | zj;              }
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SetupBlock,The following statement contains a magic number: int[] cftab = new int[257];
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SetupBlock,The following statement contains a magic number: Array.Copy(unzftab' 0' cftab' 1' 256);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SetupBlock,The following statement contains a magic number: for (int i = 1; i <= 256; i++)              {                  cftab[i] += cftab[i - 1];              }
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SetupBlock,The following statement contains a magic number: ch2 = 256;
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SetupRandPartA,The following statement contains a magic number: if (i2 <= last)              {                  chPrev = ch2;                  ch2 = ll8[tPos];                  tPos = tt[tPos];                  if (rNToGo == 0)                  {                      rNToGo = BZip2Constants.RandomNumbers[rTPos];                      rTPos++;                      if (rTPos == 512)                      {                          rTPos = 0;                      }                  }                  rNToGo--;                  ch2 ^= (int)((rNToGo == 1) ? 1 : 0);                  i2++;                    currentChar = ch2;                  currentState = RAND_PART_B_STATE;                  mCrc.Update(ch2);              }              else              {                  EndBlock();                  InitBlock();                  SetupBlock();              }
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SetupRandPartB,The following statement contains a magic number: if (ch2 != chPrev)              {                  currentState = RAND_PART_A_STATE;                  count = 1;                  SetupRandPartA();              }              else              {                  count++;                  if (count >= 4)                  {                      z = ll8[tPos];                      tPos = tt[tPos];                      if (rNToGo == 0)                      {                          rNToGo = BZip2Constants.RandomNumbers[rTPos];                          rTPos++;                          if (rTPos == 512)                          {                              rTPos = 0;                          }                      }                      rNToGo--;                      z ^= (byte)((rNToGo == 1) ? 1 : 0);                      j2 = 0;                      currentState = RAND_PART_C_STATE;                      SetupRandPartC();                  }                  else                  {                      currentState = RAND_PART_A_STATE;                      SetupRandPartA();                  }              }
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SetupRandPartB,The following statement contains a magic number: if (ch2 != chPrev)              {                  currentState = RAND_PART_A_STATE;                  count = 1;                  SetupRandPartA();              }              else              {                  count++;                  if (count >= 4)                  {                      z = ll8[tPos];                      tPos = tt[tPos];                      if (rNToGo == 0)                      {                          rNToGo = BZip2Constants.RandomNumbers[rTPos];                          rTPos++;                          if (rTPos == 512)                          {                              rTPos = 0;                          }                      }                      rNToGo--;                      z ^= (byte)((rNToGo == 1) ? 1 : 0);                      j2 = 0;                      currentState = RAND_PART_C_STATE;                      SetupRandPartC();                  }                  else                  {                      currentState = RAND_PART_A_STATE;                      SetupRandPartA();                  }              }
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SetupNoRandPartB,The following statement contains a magic number: if (ch2 != chPrev)              {                  currentState = NO_RAND_PART_A_STATE;                  count = 1;                  SetupNoRandPartA();              }              else              {                  count++;                  if (count >= 4)                  {                      z = ll8[tPos];                      tPos = tt[tPos];                      currentState = NO_RAND_PART_C_STATE;                      j2 = 0;                      SetupNoRandPartC();                  }                  else                  {                      currentState = NO_RAND_PART_A_STATE;                      SetupNoRandPartA();                  }              }
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SetDecompressStructureSizes,The following statement contains a magic number: if (!(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k && blockSize100k <= 9))              {                  throw new Exception("Invalid block size");              }
Magic Number,Orvid.Compression.Streams,BZip2InputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SetDecompressStructureSizes,The following statement contains a magic number: if (!(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k && blockSize100k <= 9))              {                  throw new Exception("Invalid block size");              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BZip2OutputStream,The following statement contains a magic number: workFactor = 50;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BZip2OutputStream,The following statement contains a magic number: if (blockSize > 9)              {                  blockSize = 9;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BZip2OutputStream,The following statement contains a magic number: if (blockSize > 9)              {                  blockSize = 9;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,WriteByte,The following statement contains a magic number: int b = (256 + value) % 256;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,WriteByte,The following statement contains a magic number: int b = (256 + value) % 256;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,WriteByte,The following statement contains a magic number: if (currentChar != -1)              {                  if (currentChar == b)                  {                      runLength++;                      if (runLength > 254)                      {                          WriteRun();                          currentChar = -1;                          runLength = 0;                      }                  }                  else                  {                      WriteRun();                      runLength = 1;                      currentChar = b;                  }              }              else              {                  currentChar = b;                  runLength++;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MakeMaps,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  if (inUse[i])                  {                      seqToUnseq[nInUse] = (char)i;                      unseqToSeq[i] = (char)nInUse;                      nInUse++;                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,WriteRun,The following statement contains a magic number: if (last < allowableBlockSize)              {                  inUse[currentChar] = true;                  for (int i = 0; i < runLength; i++)                  {                      mCrc.Update(currentChar);                  }                    switch (runLength)                  {                      case 1:                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      case 2:                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      case 3:                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      default:                          inUse[runLength - 4] = true;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)(runLength - 4);                          break;                  }              }              else              {                  EndBlock();                  InitBlock();                  WriteRun();              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,WriteRun,The following statement contains a magic number: if (last < allowableBlockSize)              {                  inUse[currentChar] = true;                  for (int i = 0; i < runLength; i++)                  {                      mCrc.Update(currentChar);                  }                    switch (runLength)                  {                      case 1:                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      case 2:                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      case 3:                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      default:                          inUse[runLength - 4] = true;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)(runLength - 4);                          break;                  }              }              else              {                  EndBlock();                  InitBlock();                  WriteRun();              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,WriteRun,The following statement contains a magic number: if (last < allowableBlockSize)              {                  inUse[currentChar] = true;                  for (int i = 0; i < runLength; i++)                  {                      mCrc.Update(currentChar);                  }                    switch (runLength)                  {                      case 1:                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      case 2:                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      case 3:                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      default:                          inUse[runLength - 4] = true;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)(runLength - 4);                          break;                  }              }              else              {                  EndBlock();                  InitBlock();                  WriteRun();              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,WriteRun,The following statement contains a magic number: if (last < allowableBlockSize)              {                  inUse[currentChar] = true;                  for (int i = 0; i < runLength; i++)                  {                      mCrc.Update(currentChar);                  }                    switch (runLength)                  {                      case 1:                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      case 2:                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      case 3:                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      default:                          inUse[runLength - 4] = true;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)(runLength - 4);                          break;                  }              }              else              {                  EndBlock();                  InitBlock();                  WriteRun();              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,InitBlock,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  inUse[i] = false;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,InitBlock,The following statement contains a magic number: allowableBlockSize = BZip2Constants.BaseBlockSize * blockSize100k - 20;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,EndBlock,The following statement contains a magic number: combinedCRC = (combinedCRC << 1) | (combinedCRC >> 31);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsFinishedWithStream,The following statement contains a magic number: while (bsLive > 0)              {                  int ch = (bsBuff >> 24);                  baseStream.WriteByte((byte)ch); // write 8-bit                  bsBuff <<= 8;                  bsLive -= 8;                  bytesOut++;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsFinishedWithStream,The following statement contains a magic number: while (bsLive > 0)              {                  int ch = (bsBuff >> 24);                  baseStream.WriteByte((byte)ch); // write 8-bit                  bsBuff <<= 8;                  bsLive -= 8;                  bytesOut++;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsFinishedWithStream,The following statement contains a magic number: while (bsLive > 0)              {                  int ch = (bsBuff >> 24);                  baseStream.WriteByte((byte)ch); // write 8-bit                  bsBuff <<= 8;                  bsLive -= 8;                  bytesOut++;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsW,The following statement contains a magic number: while (bsLive >= 8)              {                  int ch = (bsBuff >> 24);                  unchecked { baseStream.WriteByte((byte)ch); } // write 8-bit                  bsBuff <<= 8;                  bsLive -= 8;                  ++bytesOut;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsW,The following statement contains a magic number: while (bsLive >= 8)              {                  int ch = (bsBuff >> 24);                  unchecked { baseStream.WriteByte((byte)ch); } // write 8-bit                  bsBuff <<= 8;                  bsLive -= 8;                  ++bytesOut;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsW,The following statement contains a magic number: while (bsLive >= 8)              {                  int ch = (bsBuff >> 24);                  unchecked { baseStream.WriteByte((byte)ch); } // write 8-bit                  bsBuff <<= 8;                  bsLive -= 8;                  ++bytesOut;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsW,The following statement contains a magic number: while (bsLive >= 8)              {                  int ch = (bsBuff >> 24);                  unchecked { baseStream.WriteByte((byte)ch); } // write 8-bit                  bsBuff <<= 8;                  bsLive -= 8;                  ++bytesOut;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsW,The following statement contains a magic number: bsBuff |= (v << (32 - bsLive - n));
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsPutUChar,The following statement contains a magic number: BsW(8' c);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 24) & 0xFF);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 24) & 0xFF);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 16) & 0xFF);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 16) & 0xFF);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 8) & 0xFF);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 8) & 0xFF);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsPutint,The following statement contains a magic number: BsW(8' u & 0xFF);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: alphaSize = nInUse + 2;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200)              {                  nGroups = 2;              }              else if (nMTF < 600)              {                  nGroups = 3;              }              else if (nMTF < 1200)              {                  nGroups = 4;              }              else if (nMTF < 2400)              {                  nGroups = 5;              }              else              {                  nGroups = 6;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200)              {                  nGroups = 2;              }              else if (nMTF < 600)              {                  nGroups = 3;              }              else if (nMTF < 1200)              {                  nGroups = 4;              }              else if (nMTF < 2400)              {                  nGroups = 5;              }              else              {                  nGroups = 6;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200)              {                  nGroups = 2;              }              else if (nMTF < 600)              {                  nGroups = 3;              }              else if (nMTF < 1200)              {                  nGroups = 4;              }              else if (nMTF < 2400)              {                  nGroups = 5;              }              else              {                  nGroups = 6;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200)              {                  nGroups = 2;              }              else if (nMTF < 600)              {                  nGroups = 3;              }              else if (nMTF < 1200)              {                  nGroups = 4;              }              else if (nMTF < 2400)              {                  nGroups = 5;              }              else              {                  nGroups = 6;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200)              {                  nGroups = 2;              }              else if (nMTF < 600)              {                  nGroups = 3;              }              else if (nMTF < 1200)              {                  nGroups = 4;              }              else if (nMTF < 2400)              {                  nGroups = 5;              }              else              {                  nGroups = 6;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200)              {                  nGroups = 2;              }              else if (nMTF < 600)              {                  nGroups = 3;              }              else if (nMTF < 1200)              {                  nGroups = 4;              }              else if (nMTF < 2400)              {                  nGroups = 5;              }              else              {                  nGroups = 6;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200)              {                  nGroups = 2;              }              else if (nMTF < 600)              {                  nGroups = 3;              }              else if (nMTF < 1200)              {                  nGroups = 4;              }              else if (nMTF < 2400)              {                  nGroups = 5;              }              else              {                  nGroups = 6;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200)              {                  nGroups = 2;              }              else if (nMTF < 600)              {                  nGroups = 3;              }              else if (nMTF < 1200)              {                  nGroups = 4;              }              else if (nMTF < 2400)              {                  nGroups = 5;              }              else              {                  nGroups = 6;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200)              {                  nGroups = 2;              }              else if (nMTF < 600)              {                  nGroups = 3;              }              else if (nMTF < 1200)              {                  nGroups = 4;              }              else if (nMTF < 2400)              {                  nGroups = 5;              }              else              {                  nGroups = 6;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: while (nPart > 0)              {                  int tFreq = remF / nPart;                  int aFreq = 0;                  ge = gs - 1;                  while (aFreq < tFreq && ge < alphaSize - 1)                  {                      ge++;                      aFreq += mtfFreq[ge];                  }                    if (ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1))                  {                      aFreq -= mtfFreq[ge];                      ge--;                  }                    for (int v = 0; v < alphaSize; v++)                  {                      if (v >= gs && v <= ge)                      {                          len[nPart - 1][v] = (char)LESSER_ICOST;                      }                      else                      {                          len[nPart - 1][v] = (char)GREATER_ICOST;                      }                  }                    nPart--;                  gs = ge + 1;                  remF -= aFreq;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter)              {                  for (int t = 0; t < nGroups; ++t)                  {                      fave[t] = 0;                  }                    for (int t = 0; t < nGroups; ++t)                  {                      for (int v = 0; v < alphaSize; ++v)                      {                          rfreq[t][v] = 0;                      }                  }                    nSelectors = 0;                  totc = 0;                  gs = 0;                  while (true)                  {                      /*--- Set group start & end marks. --*/                      if (gs >= nMTF)                      {                          break;                      }                      ge = gs + BZip2Constants.GroupSize - 1;                      if (ge >= nMTF)                      {                          ge = nMTF - 1;                      }                        /*--                      Calculate the cost of this group as coded                      by each of the coding tables.                      --*/                      for (int t = 0; t < nGroups; t++)                      {                          cost[t] = 0;                      }                        if (nGroups == 6)                      {                          short cost0' cost1' cost2' cost3' cost4' cost5;                          cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              cost0 += (short)len[0][icv];                              cost1 += (short)len[1][icv];                              cost2 += (short)len[2][icv];                              cost3 += (short)len[3][icv];                              cost4 += (short)len[4][icv];                              cost5 += (short)len[5][icv];                          }                          cost[0] = cost0;                          cost[1] = cost1;                          cost[2] = cost2;                          cost[3] = cost3;                          cost[4] = cost4;                          cost[5] = cost5;                      }                      else                      {                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              for (int t = 0; t < nGroups; t++)                              {                                  cost[t] += (short)len[t][icv];                              }                          }                      }                        /*--                      Find the coding table which is best for this group'                      and record its identity in the selector table.                      --*/                      bc = 999999999;                      bt = -1;                      for (int t = 0; t < nGroups; ++t)                      {                          if (cost[t] < bc)                          {                              bc = cost[t];                              bt = t;                          }                      }                      totc += bc;                      fave[bt]++;                      selector[nSelectors] = (char)bt;                      nSelectors++;                        /*--                      Increment the symbol frequencies for the selected table.                      --*/                      for (int i = gs; i <= ge; ++i)                      {                          ++rfreq[bt][szptr[i]];                      }                        gs = ge + 1;                  }                    /*--                  Recompute the tables based on the accumulated frequencies.                  --*/                  for (int t = 0; t < nGroups; ++t)                  {                      HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter)              {                  for (int t = 0; t < nGroups; ++t)                  {                      fave[t] = 0;                  }                    for (int t = 0; t < nGroups; ++t)                  {                      for (int v = 0; v < alphaSize; ++v)                      {                          rfreq[t][v] = 0;                      }                  }                    nSelectors = 0;                  totc = 0;                  gs = 0;                  while (true)                  {                      /*--- Set group start & end marks. --*/                      if (gs >= nMTF)                      {                          break;                      }                      ge = gs + BZip2Constants.GroupSize - 1;                      if (ge >= nMTF)                      {                          ge = nMTF - 1;                      }                        /*--                      Calculate the cost of this group as coded                      by each of the coding tables.                      --*/                      for (int t = 0; t < nGroups; t++)                      {                          cost[t] = 0;                      }                        if (nGroups == 6)                      {                          short cost0' cost1' cost2' cost3' cost4' cost5;                          cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              cost0 += (short)len[0][icv];                              cost1 += (short)len[1][icv];                              cost2 += (short)len[2][icv];                              cost3 += (short)len[3][icv];                              cost4 += (short)len[4][icv];                              cost5 += (short)len[5][icv];                          }                          cost[0] = cost0;                          cost[1] = cost1;                          cost[2] = cost2;                          cost[3] = cost3;                          cost[4] = cost4;                          cost[5] = cost5;                      }                      else                      {                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              for (int t = 0; t < nGroups; t++)                              {                                  cost[t] += (short)len[t][icv];                              }                          }                      }                        /*--                      Find the coding table which is best for this group'                      and record its identity in the selector table.                      --*/                      bc = 999999999;                      bt = -1;                      for (int t = 0; t < nGroups; ++t)                      {                          if (cost[t] < bc)                          {                              bc = cost[t];                              bt = t;                          }                      }                      totc += bc;                      fave[bt]++;                      selector[nSelectors] = (char)bt;                      nSelectors++;                        /*--                      Increment the symbol frequencies for the selected table.                      --*/                      for (int i = gs; i <= ge; ++i)                      {                          ++rfreq[bt][szptr[i]];                      }                        gs = ge + 1;                  }                    /*--                  Recompute the tables based on the accumulated frequencies.                  --*/                  for (int t = 0; t < nGroups; ++t)                  {                      HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter)              {                  for (int t = 0; t < nGroups; ++t)                  {                      fave[t] = 0;                  }                    for (int t = 0; t < nGroups; ++t)                  {                      for (int v = 0; v < alphaSize; ++v)                      {                          rfreq[t][v] = 0;                      }                  }                    nSelectors = 0;                  totc = 0;                  gs = 0;                  while (true)                  {                      /*--- Set group start & end marks. --*/                      if (gs >= nMTF)                      {                          break;                      }                      ge = gs + BZip2Constants.GroupSize - 1;                      if (ge >= nMTF)                      {                          ge = nMTF - 1;                      }                        /*--                      Calculate the cost of this group as coded                      by each of the coding tables.                      --*/                      for (int t = 0; t < nGroups; t++)                      {                          cost[t] = 0;                      }                        if (nGroups == 6)                      {                          short cost0' cost1' cost2' cost3' cost4' cost5;                          cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              cost0 += (short)len[0][icv];                              cost1 += (short)len[1][icv];                              cost2 += (short)len[2][icv];                              cost3 += (short)len[3][icv];                              cost4 += (short)len[4][icv];                              cost5 += (short)len[5][icv];                          }                          cost[0] = cost0;                          cost[1] = cost1;                          cost[2] = cost2;                          cost[3] = cost3;                          cost[4] = cost4;                          cost[5] = cost5;                      }                      else                      {                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              for (int t = 0; t < nGroups; t++)                              {                                  cost[t] += (short)len[t][icv];                              }                          }                      }                        /*--                      Find the coding table which is best for this group'                      and record its identity in the selector table.                      --*/                      bc = 999999999;                      bt = -1;                      for (int t = 0; t < nGroups; ++t)                      {                          if (cost[t] < bc)                          {                              bc = cost[t];                              bt = t;                          }                      }                      totc += bc;                      fave[bt]++;                      selector[nSelectors] = (char)bt;                      nSelectors++;                        /*--                      Increment the symbol frequencies for the selected table.                      --*/                      for (int i = gs; i <= ge; ++i)                      {                          ++rfreq[bt][szptr[i]];                      }                        gs = ge + 1;                  }                    /*--                  Recompute the tables based on the accumulated frequencies.                  --*/                  for (int t = 0; t < nGroups; ++t)                  {                      HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter)              {                  for (int t = 0; t < nGroups; ++t)                  {                      fave[t] = 0;                  }                    for (int t = 0; t < nGroups; ++t)                  {                      for (int v = 0; v < alphaSize; ++v)                      {                          rfreq[t][v] = 0;                      }                  }                    nSelectors = 0;                  totc = 0;                  gs = 0;                  while (true)                  {                      /*--- Set group start & end marks. --*/                      if (gs >= nMTF)                      {                          break;                      }                      ge = gs + BZip2Constants.GroupSize - 1;                      if (ge >= nMTF)                      {                          ge = nMTF - 1;                      }                        /*--                      Calculate the cost of this group as coded                      by each of the coding tables.                      --*/                      for (int t = 0; t < nGroups; t++)                      {                          cost[t] = 0;                      }                        if (nGroups == 6)                      {                          short cost0' cost1' cost2' cost3' cost4' cost5;                          cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              cost0 += (short)len[0][icv];                              cost1 += (short)len[1][icv];                              cost2 += (short)len[2][icv];                              cost3 += (short)len[3][icv];                              cost4 += (short)len[4][icv];                              cost5 += (short)len[5][icv];                          }                          cost[0] = cost0;                          cost[1] = cost1;                          cost[2] = cost2;                          cost[3] = cost3;                          cost[4] = cost4;                          cost[5] = cost5;                      }                      else                      {                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              for (int t = 0; t < nGroups; t++)                              {                                  cost[t] += (short)len[t][icv];                              }                          }                      }                        /*--                      Find the coding table which is best for this group'                      and record its identity in the selector table.                      --*/                      bc = 999999999;                      bt = -1;                      for (int t = 0; t < nGroups; ++t)                      {                          if (cost[t] < bc)                          {                              bc = cost[t];                              bt = t;                          }                      }                      totc += bc;                      fave[bt]++;                      selector[nSelectors] = (char)bt;                      nSelectors++;                        /*--                      Increment the symbol frequencies for the selected table.                      --*/                      for (int i = gs; i <= ge; ++i)                      {                          ++rfreq[bt][szptr[i]];                      }                        gs = ge + 1;                  }                    /*--                  Recompute the tables based on the accumulated frequencies.                  --*/                  for (int t = 0; t < nGroups; ++t)                  {                      HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter)              {                  for (int t = 0; t < nGroups; ++t)                  {                      fave[t] = 0;                  }                    for (int t = 0; t < nGroups; ++t)                  {                      for (int v = 0; v < alphaSize; ++v)                      {                          rfreq[t][v] = 0;                      }                  }                    nSelectors = 0;                  totc = 0;                  gs = 0;                  while (true)                  {                      /*--- Set group start & end marks. --*/                      if (gs >= nMTF)                      {                          break;                      }                      ge = gs + BZip2Constants.GroupSize - 1;                      if (ge >= nMTF)                      {                          ge = nMTF - 1;                      }                        /*--                      Calculate the cost of this group as coded                      by each of the coding tables.                      --*/                      for (int t = 0; t < nGroups; t++)                      {                          cost[t] = 0;                      }                        if (nGroups == 6)                      {                          short cost0' cost1' cost2' cost3' cost4' cost5;                          cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              cost0 += (short)len[0][icv];                              cost1 += (short)len[1][icv];                              cost2 += (short)len[2][icv];                              cost3 += (short)len[3][icv];                              cost4 += (short)len[4][icv];                              cost5 += (short)len[5][icv];                          }                          cost[0] = cost0;                          cost[1] = cost1;                          cost[2] = cost2;                          cost[3] = cost3;                          cost[4] = cost4;                          cost[5] = cost5;                      }                      else                      {                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              for (int t = 0; t < nGroups; t++)                              {                                  cost[t] += (short)len[t][icv];                              }                          }                      }                        /*--                      Find the coding table which is best for this group'                      and record its identity in the selector table.                      --*/                      bc = 999999999;                      bt = -1;                      for (int t = 0; t < nGroups; ++t)                      {                          if (cost[t] < bc)                          {                              bc = cost[t];                              bt = t;                          }                      }                      totc += bc;                      fave[bt]++;                      selector[nSelectors] = (char)bt;                      nSelectors++;                        /*--                      Increment the symbol frequencies for the selected table.                      --*/                      for (int i = gs; i <= ge; ++i)                      {                          ++rfreq[bt][szptr[i]];                      }                        gs = ge + 1;                  }                    /*--                  Recompute the tables based on the accumulated frequencies.                  --*/                  for (int t = 0; t < nGroups; ++t)                  {                      HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter)              {                  for (int t = 0; t < nGroups; ++t)                  {                      fave[t] = 0;                  }                    for (int t = 0; t < nGroups; ++t)                  {                      for (int v = 0; v < alphaSize; ++v)                      {                          rfreq[t][v] = 0;                      }                  }                    nSelectors = 0;                  totc = 0;                  gs = 0;                  while (true)                  {                      /*--- Set group start & end marks. --*/                      if (gs >= nMTF)                      {                          break;                      }                      ge = gs + BZip2Constants.GroupSize - 1;                      if (ge >= nMTF)                      {                          ge = nMTF - 1;                      }                        /*--                      Calculate the cost of this group as coded                      by each of the coding tables.                      --*/                      for (int t = 0; t < nGroups; t++)                      {                          cost[t] = 0;                      }                        if (nGroups == 6)                      {                          short cost0' cost1' cost2' cost3' cost4' cost5;                          cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              cost0 += (short)len[0][icv];                              cost1 += (short)len[1][icv];                              cost2 += (short)len[2][icv];                              cost3 += (short)len[3][icv];                              cost4 += (short)len[4][icv];                              cost5 += (short)len[5][icv];                          }                          cost[0] = cost0;                          cost[1] = cost1;                          cost[2] = cost2;                          cost[3] = cost3;                          cost[4] = cost4;                          cost[5] = cost5;                      }                      else                      {                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              for (int t = 0; t < nGroups; t++)                              {                                  cost[t] += (short)len[t][icv];                              }                          }                      }                        /*--                      Find the coding table which is best for this group'                      and record its identity in the selector table.                      --*/                      bc = 999999999;                      bt = -1;                      for (int t = 0; t < nGroups; ++t)                      {                          if (cost[t] < bc)                          {                              bc = cost[t];                              bt = t;                          }                      }                      totc += bc;                      fave[bt]++;                      selector[nSelectors] = (char)bt;                      nSelectors++;                        /*--                      Increment the symbol frequencies for the selected table.                      --*/                      for (int i = gs; i <= ge; ++i)                      {                          ++rfreq[bt][szptr[i]];                      }                        gs = ge + 1;                  }                    /*--                  Recompute the tables based on the accumulated frequencies.                  --*/                  for (int t = 0; t < nGroups; ++t)                  {                      HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter)              {                  for (int t = 0; t < nGroups; ++t)                  {                      fave[t] = 0;                  }                    for (int t = 0; t < nGroups; ++t)                  {                      for (int v = 0; v < alphaSize; ++v)                      {                          rfreq[t][v] = 0;                      }                  }                    nSelectors = 0;                  totc = 0;                  gs = 0;                  while (true)                  {                      /*--- Set group start & end marks. --*/                      if (gs >= nMTF)                      {                          break;                      }                      ge = gs + BZip2Constants.GroupSize - 1;                      if (ge >= nMTF)                      {                          ge = nMTF - 1;                      }                        /*--                      Calculate the cost of this group as coded                      by each of the coding tables.                      --*/                      for (int t = 0; t < nGroups; t++)                      {                          cost[t] = 0;                      }                        if (nGroups == 6)                      {                          short cost0' cost1' cost2' cost3' cost4' cost5;                          cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              cost0 += (short)len[0][icv];                              cost1 += (short)len[1][icv];                              cost2 += (short)len[2][icv];                              cost3 += (short)len[3][icv];                              cost4 += (short)len[4][icv];                              cost5 += (short)len[5][icv];                          }                          cost[0] = cost0;                          cost[1] = cost1;                          cost[2] = cost2;                          cost[3] = cost3;                          cost[4] = cost4;                          cost[5] = cost5;                      }                      else                      {                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              for (int t = 0; t < nGroups; t++)                              {                                  cost[t] += (short)len[t][icv];                              }                          }                      }                        /*--                      Find the coding table which is best for this group'                      and record its identity in the selector table.                      --*/                      bc = 999999999;                      bt = -1;                      for (int t = 0; t < nGroups; ++t)                      {                          if (cost[t] < bc)                          {                              bc = cost[t];                              bt = t;                          }                      }                      totc += bc;                      fave[bt]++;                      selector[nSelectors] = (char)bt;                      nSelectors++;                        /*--                      Increment the symbol frequencies for the selected table.                      --*/                      for (int i = gs; i <= ge; ++i)                      {                          ++rfreq[bt][szptr[i]];                      }                        gs = ge + 1;                  }                    /*--                  Recompute the tables based on the accumulated frequencies.                  --*/                  for (int t = 0; t < nGroups; ++t)                  {                      HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter)              {                  for (int t = 0; t < nGroups; ++t)                  {                      fave[t] = 0;                  }                    for (int t = 0; t < nGroups; ++t)                  {                      for (int v = 0; v < alphaSize; ++v)                      {                          rfreq[t][v] = 0;                      }                  }                    nSelectors = 0;                  totc = 0;                  gs = 0;                  while (true)                  {                      /*--- Set group start & end marks. --*/                      if (gs >= nMTF)                      {                          break;                      }                      ge = gs + BZip2Constants.GroupSize - 1;                      if (ge >= nMTF)                      {                          ge = nMTF - 1;                      }                        /*--                      Calculate the cost of this group as coded                      by each of the coding tables.                      --*/                      for (int t = 0; t < nGroups; t++)                      {                          cost[t] = 0;                      }                        if (nGroups == 6)                      {                          short cost0' cost1' cost2' cost3' cost4' cost5;                          cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              cost0 += (short)len[0][icv];                              cost1 += (short)len[1][icv];                              cost2 += (short)len[2][icv];                              cost3 += (short)len[3][icv];                              cost4 += (short)len[4][icv];                              cost5 += (short)len[5][icv];                          }                          cost[0] = cost0;                          cost[1] = cost1;                          cost[2] = cost2;                          cost[3] = cost3;                          cost[4] = cost4;                          cost[5] = cost5;                      }                      else                      {                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              for (int t = 0; t < nGroups; t++)                              {                                  cost[t] += (short)len[t][icv];                              }                          }                      }                        /*--                      Find the coding table which is best for this group'                      and record its identity in the selector table.                      --*/                      bc = 999999999;                      bt = -1;                      for (int t = 0; t < nGroups; ++t)                      {                          if (cost[t] < bc)                          {                              bc = cost[t];                              bt = t;                          }                      }                      totc += bc;                      fave[bt]++;                      selector[nSelectors] = (char)bt;                      nSelectors++;                        /*--                      Increment the symbol frequencies for the selected table.                      --*/                      for (int i = gs; i <= ge; ++i)                      {                          ++rfreq[bt][szptr[i]];                      }                        gs = ge + 1;                  }                    /*--                  Recompute the tables based on the accumulated frequencies.                  --*/                  for (int t = 0; t < nGroups; ++t)                  {                      HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter)              {                  for (int t = 0; t < nGroups; ++t)                  {                      fave[t] = 0;                  }                    for (int t = 0; t < nGroups; ++t)                  {                      for (int v = 0; v < alphaSize; ++v)                      {                          rfreq[t][v] = 0;                      }                  }                    nSelectors = 0;                  totc = 0;                  gs = 0;                  while (true)                  {                      /*--- Set group start & end marks. --*/                      if (gs >= nMTF)                      {                          break;                      }                      ge = gs + BZip2Constants.GroupSize - 1;                      if (ge >= nMTF)                      {                          ge = nMTF - 1;                      }                        /*--                      Calculate the cost of this group as coded                      by each of the coding tables.                      --*/                      for (int t = 0; t < nGroups; t++)                      {                          cost[t] = 0;                      }                        if (nGroups == 6)                      {                          short cost0' cost1' cost2' cost3' cost4' cost5;                          cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              cost0 += (short)len[0][icv];                              cost1 += (short)len[1][icv];                              cost2 += (short)len[2][icv];                              cost3 += (short)len[3][icv];                              cost4 += (short)len[4][icv];                              cost5 += (short)len[5][icv];                          }                          cost[0] = cost0;                          cost[1] = cost1;                          cost[2] = cost2;                          cost[3] = cost3;                          cost[4] = cost4;                          cost[5] = cost5;                      }                      else                      {                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              for (int t = 0; t < nGroups; t++)                              {                                  cost[t] += (short)len[t][icv];                              }                          }                      }                        /*--                      Find the coding table which is best for this group'                      and record its identity in the selector table.                      --*/                      bc = 999999999;                      bt = -1;                      for (int t = 0; t < nGroups; ++t)                      {                          if (cost[t] < bc)                          {                              bc = cost[t];                              bt = t;                          }                      }                      totc += bc;                      fave[bt]++;                      selector[nSelectors] = (char)bt;                      nSelectors++;                        /*--                      Increment the symbol frequencies for the selected table.                      --*/                      for (int i = gs; i <= ge; ++i)                      {                          ++rfreq[bt][szptr[i]];                      }                        gs = ge + 1;                  }                    /*--                  Recompute the tables based on the accumulated frequencies.                  --*/                  for (int t = 0; t < nGroups; ++t)                  {                      HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter)              {                  for (int t = 0; t < nGroups; ++t)                  {                      fave[t] = 0;                  }                    for (int t = 0; t < nGroups; ++t)                  {                      for (int v = 0; v < alphaSize; ++v)                      {                          rfreq[t][v] = 0;                      }                  }                    nSelectors = 0;                  totc = 0;                  gs = 0;                  while (true)                  {                      /*--- Set group start & end marks. --*/                      if (gs >= nMTF)                      {                          break;                      }                      ge = gs + BZip2Constants.GroupSize - 1;                      if (ge >= nMTF)                      {                          ge = nMTF - 1;                      }                        /*--                      Calculate the cost of this group as coded                      by each of the coding tables.                      --*/                      for (int t = 0; t < nGroups; t++)                      {                          cost[t] = 0;                      }                        if (nGroups == 6)                      {                          short cost0' cost1' cost2' cost3' cost4' cost5;                          cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              cost0 += (short)len[0][icv];                              cost1 += (short)len[1][icv];                              cost2 += (short)len[2][icv];                              cost3 += (short)len[3][icv];                              cost4 += (short)len[4][icv];                              cost5 += (short)len[5][icv];                          }                          cost[0] = cost0;                          cost[1] = cost1;                          cost[2] = cost2;                          cost[3] = cost3;                          cost[4] = cost4;                          cost[5] = cost5;                      }                      else                      {                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              for (int t = 0; t < nGroups; t++)                              {                                  cost[t] += (short)len[t][icv];                              }                          }                      }                        /*--                      Find the coding table which is best for this group'                      and record its identity in the selector table.                      --*/                      bc = 999999999;                      bt = -1;                      for (int t = 0; t < nGroups; ++t)                      {                          if (cost[t] < bc)                          {                              bc = cost[t];                              bt = t;                          }                      }                      totc += bc;                      fave[bt]++;                      selector[nSelectors] = (char)bt;                      nSelectors++;                        /*--                      Increment the symbol frequencies for the selected table.                      --*/                      for (int i = gs; i <= ge; ++i)                      {                          ++rfreq[bt][szptr[i]];                      }                        gs = ge + 1;                  }                    /*--                  Recompute the tables based on the accumulated frequencies.                  --*/                  for (int t = 0; t < nGroups; ++t)                  {                      HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter)              {                  for (int t = 0; t < nGroups; ++t)                  {                      fave[t] = 0;                  }                    for (int t = 0; t < nGroups; ++t)                  {                      for (int v = 0; v < alphaSize; ++v)                      {                          rfreq[t][v] = 0;                      }                  }                    nSelectors = 0;                  totc = 0;                  gs = 0;                  while (true)                  {                      /*--- Set group start & end marks. --*/                      if (gs >= nMTF)                      {                          break;                      }                      ge = gs + BZip2Constants.GroupSize - 1;                      if (ge >= nMTF)                      {                          ge = nMTF - 1;                      }                        /*--                      Calculate the cost of this group as coded                      by each of the coding tables.                      --*/                      for (int t = 0; t < nGroups; t++)                      {                          cost[t] = 0;                      }                        if (nGroups == 6)                      {                          short cost0' cost1' cost2' cost3' cost4' cost5;                          cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              cost0 += (short)len[0][icv];                              cost1 += (short)len[1][icv];                              cost2 += (short)len[2][icv];                              cost3 += (short)len[3][icv];                              cost4 += (short)len[4][icv];                              cost5 += (short)len[5][icv];                          }                          cost[0] = cost0;                          cost[1] = cost1;                          cost[2] = cost2;                          cost[3] = cost3;                          cost[4] = cost4;                          cost[5] = cost5;                      }                      else                      {                          for (int i = gs; i <= ge; ++i)                          {                              short icv = szptr[i];                              for (int t = 0; t < nGroups; t++)                              {                                  cost[t] += (short)len[t][icv];                              }                          }                      }                        /*--                      Find the coding table which is best for this group'                      and record its identity in the selector table.                      --*/                      bc = 999999999;                      bt = -1;                      for (int t = 0; t < nGroups; ++t)                      {                          if (cost[t] < bc)                          {                              bc = cost[t];                              bt = t;                          }                      }                      totc += bc;                      fave[bt]++;                      selector[nSelectors] = (char)bt;                      nSelectors++;                        /*--                      Increment the symbol frequencies for the selected table.                      --*/                      for (int i = gs; i <= ge; ++i)                      {                          ++rfreq[bt][szptr[i]];                      }                        gs = ge + 1;                  }                    /*--                  Recompute the tables based on the accumulated frequencies.                  --*/                  for (int t = 0; t < nGroups; ++t)                  {                      HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: if (!(nGroups < 8))              {                  Panic();              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / BZip2Constants.GroupSize))))              {                  Panic();              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / BZip2Constants.GroupSize))))              {                  Panic();              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / BZip2Constants.GroupSize))))              {                  Panic();              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; t++)              {                  minLen = 32;                  maxLen = 0;                  for (int i = 0; i < alphaSize; i++)                  {                      if (len[t][i] > maxLen)                      {                          maxLen = len[t][i];                      }                      if (len[t][i] < minLen)                      {                          minLen = len[t][i];                      }                  }                  if (maxLen > 20)                  {                      Panic();                  }                  if (minLen < 1)                  {                      Panic();                  }                  HbAssignCodes(code[t]' len[t]' minLen' maxLen' alphaSize);              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; t++)              {                  minLen = 32;                  maxLen = 0;                  for (int i = 0; i < alphaSize; i++)                  {                      if (len[t][i] > maxLen)                      {                          maxLen = len[t][i];                      }                      if (len[t][i] < minLen)                      {                          minLen = len[t][i];                      }                  }                  if (maxLen > 20)                  {                      Panic();                  }                  if (minLen < 1)                  {                      Panic();                  }                  HbAssignCodes(code[t]' len[t]' minLen' maxLen' alphaSize);              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: bool[] inUse16 = new bool[16];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  inUse16[i] = false;                  for (int j = 0; j < 16; ++j)                  {                      if (inUse[i * 16 + j])                      {                          inUse16[i] = true;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  inUse16[i] = false;                  for (int j = 0; j < 16; ++j)                  {                      if (inUse[i * 16 + j])                      {                          inUse16[i] = true;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  inUse16[i] = false;                  for (int j = 0; j < 16; ++j)                  {                      if (inUse[i * 16 + j])                      {                          inUse16[i] = true;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  if (inUse16[i])                  {                      BsW(1' 1);                  }                  else                  {                      BsW(1' 0);                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  if (inUse16[i])                  {                      for (int j = 0; j < 16; ++j)                      {                          if (inUse[i * 16 + j])                          {                              BsW(1' 1);                          }                          else                          {                              BsW(1' 0);                          }                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  if (inUse16[i])                  {                      for (int j = 0; j < 16; ++j)                      {                          if (inUse[i * 16 + j])                          {                              BsW(1' 1);                          }                          else                          {                              BsW(1' 0);                          }                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  if (inUse16[i])                  {                      for (int j = 0; j < 16; ++j)                      {                          if (inUse[i * 16 + j])                          {                              BsW(1' 1);                          }                          else                          {                              BsW(1' 0);                          }                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: BsW(3' nGroups);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: BsW(15' nSelectors);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t)              {                  int curr = len[t][0];                  BsW(5' curr);                  for (int i = 0; i < alphaSize; ++i)                  {                      while (curr < len[t][i])                      {                          BsW(2' 2);                          curr++; /* 10 */                      }                      while (curr > len[t][i])                      {                          BsW(2' 3);                          curr--; /* 11 */                      }                      BsW(1' 0);                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t)              {                  int curr = len[t][0];                  BsW(5' curr);                  for (int i = 0; i < alphaSize; ++i)                  {                      while (curr < len[t][i])                      {                          BsW(2' 2);                          curr++; /* 10 */                      }                      while (curr > len[t][i])                      {                          BsW(2' 3);                          curr--; /* 11 */                      }                      BsW(1' 0);                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t)              {                  int curr = len[t][0];                  BsW(5' curr);                  for (int i = 0; i < alphaSize; ++i)                  {                      while (curr < len[t][i])                      {                          BsW(2' 2);                          curr++; /* 10 */                      }                      while (curr > len[t][i])                      {                          BsW(2' 3);                          curr--; /* 11 */                      }                      BsW(1' 0);                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t)              {                  int curr = len[t][0];                  BsW(5' curr);                  for (int i = 0; i < alphaSize; ++i)                  {                      while (curr < len[t][i])                      {                          BsW(2' 2);                          curr++; /* 10 */                      }                      while (curr > len[t][i])                      {                          BsW(2' 3);                          curr--; /* 11 */                      }                      BsW(1' 0);                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t)              {                  int curr = len[t][0];                  BsW(5' curr);                  for (int i = 0; i < alphaSize; ++i)                  {                      while (curr < len[t][i])                      {                          BsW(2' 2);                          curr++; /* 10 */                      }                      while (curr > len[t][i])                      {                          BsW(2' 3);                          curr--; /* 11 */                      }                      BsW(1' 0);                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MoveToFrontCodeAndSend,The following statement contains a magic number: BsPutIntVS(24' origPtr);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SimpleSort,The following statement contains a magic number: if (bigN < 2)              {                  return;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: int[] runningOrder = new int[256];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: int[] copy = new int[256];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: bool[] bigDone = new bool[256];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: for (i = 0; i < BZip2Constants.OvershootBytes; i++)              {                  block[last + i + 2] = block[(i % (last + 1)) + 1];              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: if (last < 4000)              {                  /*--                  Use simpleSort()' since the full sorting mechanism                  has quite a large constant overhead.                  --*/                  for (i = 0; i <= last; i++)                  {                      zptr[i] = i;                  }                  firstAttempt = false;                  workDone = workLimit = 0;                  SimpleSort(0' last' 0);              }              else              {                  numQSorted = 0;                  for (i = 0; i <= 255; i++)                  {                      bigDone[i] = false;                  }                  for (i = 0; i <= 65536; i++)                  {                      ftab[i] = 0;                  }                    c1 = block[0];                  for (i = 0; i <= last; i++)                  {                      c2 = block[i + 1];                      ftab[(c1 << 8) + c2]++;                      c1 = c2;                  }                    for (i = 1; i <= 65536; i++)                  {                      ftab[i] += ftab[i - 1];                  }                    c1 = block[1];                  for (i = 0; i < last; i++)                  {                      c2 = block[i + 2];                      j = (c1 << 8) + c2;                      c1 = c2;                      ftab[j]--;                      zptr[ftab[j]] = i;                  }                    j = ((block[last + 1]) << 8) + (block[1]);                  ftab[j]--;                  zptr[ftab[j]] = last;                    /*--                  Now ftab contains the first loc of every small bucket.                  Calculate the running order' from smallest to largest                  big bucket.                  --*/                    for (i = 0; i <= 255; i++)                  {                      runningOrder[i] = i;                  }                    int vv;                  int h = 1;                  do                  {                      h = 3 * h + 1;                  } while (h <= 256);                  do                  {                      h = h / 3;                      for (i = h; i <= 255; i++)                      {                          vv = runningOrder[i];                          j = i;                          while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))                          {                              runningOrder[j] = runningOrder[j - h];                              j = j - h;                              if (j <= (h - 1))                              {                                  break;                              }                          }                          runningOrder[j] = vv;                      }                  } while (h != 1);                    /*--                  The main sorting loop.                  --*/                  for (i = 0; i <= 255; i++)                  {                        /*--                      Process big buckets' starting with the least full.                      --*/                      ss = runningOrder[i];                        /*--                      Complete the big bucket [ss] by quicksorting                      any unsorted small buckets [ss' j].  Hopefully                      previous pointer-scanning phases have already                      completed many of the small buckets [ss' j]' so                      we don't have to sort them at all.                      --*/                      for (j = 0; j <= 255; j++)                      {                          sb = (ss << 8) + j;                          if (!((ftab[sb] & SETMASK) == SETMASK))                          {                              int lo = ftab[sb] & CLEARMASK;                              int hi = (ftab[sb + 1] & CLEARMASK) - 1;                              if (hi > lo)                              {                                  QSort3(lo' hi' 2);                                  numQSorted += (hi - lo + 1);                                  if (workDone > workLimit && firstAttempt)                                  {                                      return;                                  }                              }                              ftab[sb] |= SETMASK;                          }                      }                        /*--                      The ss big bucket is now done.  Record this fact'                      and update the quadrant descriptors.  Remember to                      update quadrants in the overshoot area too' if                      necessary.  The "if (i < 255)" test merely skips                      this updating for the last bucket processed' since                      updating for the last bucket is pointless.                      --*/                      bigDone[ss] = true;                        if (i < 255)                      {                          int bbStart = ftab[ss << 8] & CLEARMASK;                          int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                          int shifts = 0;                            while ((bbSize >> shifts) > 65534)                          {                              shifts++;                          }                            for (j = 0; j < bbSize; j++)                          {                              int a2update = zptr[bbStart + j];                              int qVal = (j >> shifts);                              quadrant[a2update] = qVal;                              if (a2update < BZip2Constants.OvershootBytes)                              {                                  quadrant[a2update + last + 1] = qVal;                              }                          }                            if (!(((bbSize - 1) >> shifts) <= 65535))                          {                              Panic();                          }                      }                        /*--                      Now scan this big bucket so as to synthesise the                      sorted order for small buckets [t' ss] for all t != ss.                      --*/                      for (j = 0; j <= 255; j++)                      {                          copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                      }                        for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++)                      {                          c1 = block[zptr[j]];                          if (!bigDone[c1])                          {                              zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;                              copy[c1]++;                          }                      }                        for (j = 0; j <= 255; j++)                      {                          ftab[(j << 8) + ss] |= SETMASK;                      }                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RandomiseBlock,The following statement contains a magic number: for (i = 0; i < 256; i++)              {                  inUse[i] = false;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RandomiseBlock,The following statement contains a magic number: for (i = 0; i <= last; i++)              {                  if (rNToGo == 0)                  {                      rNToGo = (int)BZip2Constants.RandomNumbers[rTPos];                      rTPos++;                      if (rTPos == 512)                      {                          rTPos = 0;                      }                  }                  rNToGo--;                  block[i + 1] ^= (byte)((rNToGo == 1) ? 1 : 0);                  // handle 16 bit signed numbers                  block[i + 1] &= 0xFF;                    inUse[block[i + 1]] = true;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,FullGtU,The following statement contains a magic number: do              {                  c1 = block[i1 + 1];                  c2 = block[i2 + 1];                  if (c1 != c2)                  {                      return c1 > c2;                  }                  s1 = quadrant[i1];                  s2 = quadrant[i2];                  if (s1 != s2)                  {                      return s1 > s2;                  }                  i1++;                  i2++;                    c1 = block[i1 + 1];                  c2 = block[i2 + 1];                  if (c1 != c2)                  {                      return c1 > c2;                  }                  s1 = quadrant[i1];                  s2 = quadrant[i2];                  if (s1 != s2)                  {                      return s1 > s2;                  }                  i1++;                  i2++;                    c1 = block[i1 + 1];                  c2 = block[i2 + 1];                  if (c1 != c2)                  {                      return c1 > c2;                  }                  s1 = quadrant[i1];                  s2 = quadrant[i2];                  if (s1 != s2)                  {                      return s1 > s2;                  }                  i1++;                  i2++;                    c1 = block[i1 + 1];                  c2 = block[i2 + 1];                  if (c1 != c2)                  {                      return c1 > c2;                  }                  s1 = quadrant[i1];                  s2 = quadrant[i2];                  if (s1 != s2)                  {                      return s1 > s2;                  }                  i1++;                  i2++;                    if (i1 > last)                  {                      i1 -= last;                      i1--;                  }                  if (i2 > last)                  {                      i2 -= last;                      i2--;                  }                    k -= 4;                  ++workDone;              } while (k >= 0);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,AllocateCompressStructures,The following statement contains a magic number: ftab = new int[65537];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,AllocateCompressStructures,The following statement contains a magic number: szptr = new short[2 * n];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The following statement contains a magic number: char[] yy = new char[256];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The following statement contains a magic number: for (i = 0; i <= last; i++)              {                  char ll_i;                    ll_i = unseqToSeq[block[zptr[i]]];                    j = 0;                  tmp = yy[j];                  while (ll_i != tmp)                  {                      j++;                      tmp2 = tmp;                      tmp = yy[j];                      yy[j] = tmp2;                  }                  yy[0] = tmp;                    if (j == 0)                  {                      zPend++;                  }                  else                  {                      if (zPend > 0)                      {                          zPend--;                          while (true)                          {                              switch (zPend % 2)                              {                                  case 0:                                      szptr[wr] = (short)BZip2Constants.RunA;                                      wr++;                                      mtfFreq[BZip2Constants.RunA]++;                                      break;                                  case 1:                                      szptr[wr] = (short)BZip2Constants.RunB;                                      wr++;                                      mtfFreq[BZip2Constants.RunB]++;                                      break;                              }                              if (zPend < 2)                              {                                  break;                              }                              zPend = (zPend - 2) / 2;                          }                          zPend = 0;                      }                      szptr[wr] = (short)(j + 1);                      wr++;                      mtfFreq[j + 1]++;                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The following statement contains a magic number: for (i = 0; i <= last; i++)              {                  char ll_i;                    ll_i = unseqToSeq[block[zptr[i]]];                    j = 0;                  tmp = yy[j];                  while (ll_i != tmp)                  {                      j++;                      tmp2 = tmp;                      tmp = yy[j];                      yy[j] = tmp2;                  }                  yy[0] = tmp;                    if (j == 0)                  {                      zPend++;                  }                  else                  {                      if (zPend > 0)                      {                          zPend--;                          while (true)                          {                              switch (zPend % 2)                              {                                  case 0:                                      szptr[wr] = (short)BZip2Constants.RunA;                                      wr++;                                      mtfFreq[BZip2Constants.RunA]++;                                      break;                                  case 1:                                      szptr[wr] = (short)BZip2Constants.RunB;                                      wr++;                                      mtfFreq[BZip2Constants.RunB]++;                                      break;                              }                              if (zPend < 2)                              {                                  break;                              }                              zPend = (zPend - 2) / 2;                          }                          zPend = 0;                      }                      szptr[wr] = (short)(j + 1);                      wr++;                      mtfFreq[j + 1]++;                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The following statement contains a magic number: for (i = 0; i <= last; i++)              {                  char ll_i;                    ll_i = unseqToSeq[block[zptr[i]]];                    j = 0;                  tmp = yy[j];                  while (ll_i != tmp)                  {                      j++;                      tmp2 = tmp;                      tmp = yy[j];                      yy[j] = tmp2;                  }                  yy[0] = tmp;                    if (j == 0)                  {                      zPend++;                  }                  else                  {                      if (zPend > 0)                      {                          zPend--;                          while (true)                          {                              switch (zPend % 2)                              {                                  case 0:                                      szptr[wr] = (short)BZip2Constants.RunA;                                      wr++;                                      mtfFreq[BZip2Constants.RunA]++;                                      break;                                  case 1:                                      szptr[wr] = (short)BZip2Constants.RunB;                                      wr++;                                      mtfFreq[BZip2Constants.RunB]++;                                      break;                              }                              if (zPend < 2)                              {                                  break;                              }                              zPend = (zPend - 2) / 2;                          }                          zPend = 0;                      }                      szptr[wr] = (short)(j + 1);                      wr++;                      mtfFreq[j + 1]++;                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The following statement contains a magic number: for (i = 0; i <= last; i++)              {                  char ll_i;                    ll_i = unseqToSeq[block[zptr[i]]];                    j = 0;                  tmp = yy[j];                  while (ll_i != tmp)                  {                      j++;                      tmp2 = tmp;                      tmp = yy[j];                      yy[j] = tmp2;                  }                  yy[0] = tmp;                    if (j == 0)                  {                      zPend++;                  }                  else                  {                      if (zPend > 0)                      {                          zPend--;                          while (true)                          {                              switch (zPend % 2)                              {                                  case 0:                                      szptr[wr] = (short)BZip2Constants.RunA;                                      wr++;                                      mtfFreq[BZip2Constants.RunA]++;                                      break;                                  case 1:                                      szptr[wr] = (short)BZip2Constants.RunB;                                      wr++;                                      mtfFreq[BZip2Constants.RunB]++;                                      break;                              }                              if (zPend < 2)                              {                                  break;                              }                              zPend = (zPend - 2) / 2;                          }                          zPend = 0;                      }                      szptr[wr] = (short)(j + 1);                      wr++;                      mtfFreq[j + 1]++;                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0)              {                  zPend--;                  while (true)                  {                      switch (zPend % 2)                      {                          case 0:                              szptr[wr] = (short)BZip2Constants.RunA;                              wr++;                              mtfFreq[BZip2Constants.RunA]++;                              break;                          case 1:                              szptr[wr] = (short)BZip2Constants.RunB;                              wr++;                              mtfFreq[BZip2Constants.RunB]++;                              break;                      }                      if (zPend < 2)                      {                          break;                      }                      zPend = (zPend - 2) / 2;                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0)              {                  zPend--;                  while (true)                  {                      switch (zPend % 2)                      {                          case 0:                              szptr[wr] = (short)BZip2Constants.RunA;                              wr++;                              mtfFreq[BZip2Constants.RunA]++;                              break;                          case 1:                              szptr[wr] = (short)BZip2Constants.RunB;                              wr++;                              mtfFreq[BZip2Constants.RunB]++;                              break;                      }                      if (zPend < 2)                      {                          break;                      }                      zPend = (zPend - 2) / 2;                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0)              {                  zPend--;                  while (true)                  {                      switch (zPend % 2)                      {                          case 0:                              szptr[wr] = (short)BZip2Constants.RunA;                              wr++;                              mtfFreq[BZip2Constants.RunA]++;                              break;                          case 1:                              szptr[wr] = (short)BZip2Constants.RunB;                              wr++;                              mtfFreq[BZip2Constants.RunB]++;                              break;                      }                      if (zPend < 2)                      {                          break;                      }                      zPend = (zPend - 2) / 2;                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0)              {                  zPend--;                  while (true)                  {                      switch (zPend % 2)                      {                          case 0:                              szptr[wr] = (short)BZip2Constants.RunA;                              wr++;                              mtfFreq[BZip2Constants.RunA]++;                              break;                          case 1:                              szptr[wr] = (short)BZip2Constants.RunB;                              wr++;                              mtfFreq[BZip2Constants.RunB]++;                              break;                      }                      if (zPend < 2)                      {                          break;                      }                      zPend = (zPend - 2) / 2;                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: int[] heap = new int[BZip2Constants.MaximumAlphaSize + 2];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: int[] weight = new int[BZip2Constants.MaximumAlphaSize * 2];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: int[] parent = new int[BZip2Constants.MaximumAlphaSize * 2];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: for (int i = 0; i < alphaSize; ++i)              {                  weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true)              {                  nNodes = alphaSize;                  nHeap = 0;                    heap[0] = 0;                  weight[0] = 0;                  parent[0] = -2;                    for (int i = 1; i <= alphaSize; ++i)                  {                      parent[i] = -1;                      nHeap++;                      heap[nHeap] = i;                      int zz = nHeap;                      int tmp = heap[zz];                      while (weight[tmp] < weight[heap[zz >> 1]])                      {                          heap[zz] = heap[zz >> 1];                          zz >>= 1;                      }                      heap[zz] = tmp;                  }                  if (!(nHeap < (BZip2Constants.MaximumAlphaSize + 2)))                  {                      Panic();                  }                    while (nHeap > 1)                  {                      n1 = heap[1];                      heap[1] = heap[nHeap];                      nHeap--;                      int zz = 1;                      int yy = 0;                      int tmp = heap[zz];                      while (true)                      {                          yy = zz << 1;                          if (yy > nHeap)                          {                              break;                          }                          if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]])                          {                              yy++;                          }                          if (weight[tmp] < weight[heap[yy]])                          {                              break;                          }                            heap[zz] = heap[yy];                          zz = yy;                      }                      heap[zz] = tmp;                      n2 = heap[1];                      heap[1] = heap[nHeap];                      nHeap--;                        zz = 1;                      yy = 0;                      tmp = heap[zz];                      while (true)                      {                          yy = zz << 1;                          if (yy > nHeap)                          {                              break;                          }                          if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]])                          {                              yy++;                          }                          if (weight[tmp] < weight[heap[yy]])                          {                              break;                          }                          heap[zz] = heap[yy];                          zz = yy;                      }                      heap[zz] = tmp;                      nNodes++;                      parent[n1] = parent[n2] = nNodes;                        weight[nNodes] = (int)((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) |                          (int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));                        parent[nNodes] = -1;                      nHeap++;                      heap[nHeap] = nNodes;                        zz = nHeap;                      tmp = heap[zz];                      while (weight[tmp] < weight[heap[zz >> 1]])                      {                          heap[zz] = heap[zz >> 1];                          zz >>= 1;                      }                      heap[zz] = tmp;                  }                  if (!(nNodes < (BZip2Constants.MaximumAlphaSize * 2)))                  {                      Panic();                  }                    tooLong = false;                  for (int i = 1; i <= alphaSize; ++i)                  {                      j = 0;                      k = i;                      while (parent[k] >= 0)                      {                          k = parent[k];                          j++;                      }                      len[i - 1] = (char)j;                      if (j > maxLen)                      {                          tooLong = true;                      }                  }                    if (!tooLong)                  {                      break;                  }                    for (int i = 1; i < alphaSize; ++i)                  {                      j = weight[i] >> 8;                      j = 1 + (j / 2);                      weight[i] = j << 8;                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true)              {                  nNodes = alphaSize;                  nHeap = 0;                    heap[0] = 0;                  weight[0] = 0;                  parent[0] = -2;                    for (int i = 1; i <= alphaSize; ++i)                  {                      parent[i] = -1;                      nHeap++;                      heap[nHeap] = i;                      int zz = nHeap;                      int tmp = heap[zz];                      while (weight[tmp] < weight[heap[zz >> 1]])                      {                          heap[zz] = heap[zz >> 1];                          zz >>= 1;                      }                      heap[zz] = tmp;                  }                  if (!(nHeap < (BZip2Constants.MaximumAlphaSize + 2)))                  {                      Panic();                  }                    while (nHeap > 1)                  {                      n1 = heap[1];                      heap[1] = heap[nHeap];                      nHeap--;                      int zz = 1;                      int yy = 0;                      int tmp = heap[zz];                      while (true)                      {                          yy = zz << 1;                          if (yy > nHeap)                          {                              break;                          }                          if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]])                          {                              yy++;                          }                          if (weight[tmp] < weight[heap[yy]])                          {                              break;                          }                            heap[zz] = heap[yy];                          zz = yy;                      }                      heap[zz] = tmp;                      n2 = heap[1];                      heap[1] = heap[nHeap];                      nHeap--;                        zz = 1;                      yy = 0;                      tmp = heap[zz];                      while (true)                      {                          yy = zz << 1;                          if (yy > nHeap)                          {                              break;                          }                          if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]])                          {                              yy++;                          }                          if (weight[tmp] < weight[heap[yy]])                          {                              break;                          }                          heap[zz] = heap[yy];                          zz = yy;                      }                      heap[zz] = tmp;                      nNodes++;                      parent[n1] = parent[n2] = nNodes;                        weight[nNodes] = (int)((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) |                          (int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));                        parent[nNodes] = -1;                      nHeap++;                      heap[nHeap] = nNodes;                        zz = nHeap;                      tmp = heap[zz];                      while (weight[tmp] < weight[heap[zz >> 1]])                      {                          heap[zz] = heap[zz >> 1];                          zz >>= 1;                      }                      heap[zz] = tmp;                  }                  if (!(nNodes < (BZip2Constants.MaximumAlphaSize * 2)))                  {                      Panic();                  }                    tooLong = false;                  for (int i = 1; i <= alphaSize; ++i)                  {                      j = 0;                      k = i;                      while (parent[k] >= 0)                      {                          k = parent[k];                          j++;                      }                      len[i - 1] = (char)j;                      if (j > maxLen)                      {                          tooLong = true;                      }                  }                    if (!tooLong)                  {                      break;                  }                    for (int i = 1; i < alphaSize; ++i)                  {                      j = weight[i] >> 8;                      j = 1 + (j / 2);                      weight[i] = j << 8;                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true)              {                  nNodes = alphaSize;                  nHeap = 0;                    heap[0] = 0;                  weight[0] = 0;                  parent[0] = -2;                    for (int i = 1; i <= alphaSize; ++i)                  {                      parent[i] = -1;                      nHeap++;                      heap[nHeap] = i;                      int zz = nHeap;                      int tmp = heap[zz];                      while (weight[tmp] < weight[heap[zz >> 1]])                      {                          heap[zz] = heap[zz >> 1];                          zz >>= 1;                      }                      heap[zz] = tmp;                  }                  if (!(nHeap < (BZip2Constants.MaximumAlphaSize + 2)))                  {                      Panic();                  }                    while (nHeap > 1)                  {                      n1 = heap[1];                      heap[1] = heap[nHeap];                      nHeap--;                      int zz = 1;                      int yy = 0;                      int tmp = heap[zz];                      while (true)                      {                          yy = zz << 1;                          if (yy > nHeap)                          {                              break;                          }                          if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]])                          {                              yy++;                          }                          if (weight[tmp] < weight[heap[yy]])                          {                              break;                          }                            heap[zz] = heap[yy];                          zz = yy;                      }                      heap[zz] = tmp;                      n2 = heap[1];                      heap[1] = heap[nHeap];                      nHeap--;                        zz = 1;                      yy = 0;                      tmp = heap[zz];                      while (true)                      {                          yy = zz << 1;                          if (yy > nHeap)                          {                              break;                          }                          if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]])                          {                              yy++;                          }                          if (weight[tmp] < weight[heap[yy]])                          {                              break;                          }                          heap[zz] = heap[yy];                          zz = yy;                      }                      heap[zz] = tmp;                      nNodes++;                      parent[n1] = parent[n2] = nNodes;                        weight[nNodes] = (int)((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) |                          (int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));                        parent[nNodes] = -1;                      nHeap++;                      heap[nHeap] = nNodes;                        zz = nHeap;                      tmp = heap[zz];                      while (weight[tmp] < weight[heap[zz >> 1]])                      {                          heap[zz] = heap[zz >> 1];                          zz >>= 1;                      }                      heap[zz] = tmp;                  }                  if (!(nNodes < (BZip2Constants.MaximumAlphaSize * 2)))                  {                      Panic();                  }                    tooLong = false;                  for (int i = 1; i <= alphaSize; ++i)                  {                      j = 0;                      k = i;                      while (parent[k] >= 0)                      {                          k = parent[k];                          j++;                      }                      len[i - 1] = (char)j;                      if (j > maxLen)                      {                          tooLong = true;                      }                  }                    if (!tooLong)                  {                      break;                  }                    for (int i = 1; i < alphaSize; ++i)                  {                      j = weight[i] >> 8;                      j = 1 + (j / 2);                      weight[i] = j << 8;                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true)              {                  nNodes = alphaSize;                  nHeap = 0;                    heap[0] = 0;                  weight[0] = 0;                  parent[0] = -2;                    for (int i = 1; i <= alphaSize; ++i)                  {                      parent[i] = -1;                      nHeap++;                      heap[nHeap] = i;                      int zz = nHeap;                      int tmp = heap[zz];                      while (weight[tmp] < weight[heap[zz >> 1]])                      {                          heap[zz] = heap[zz >> 1];                          zz >>= 1;                      }                      heap[zz] = tmp;                  }                  if (!(nHeap < (BZip2Constants.MaximumAlphaSize + 2)))                  {                      Panic();                  }                    while (nHeap > 1)                  {                      n1 = heap[1];                      heap[1] = heap[nHeap];                      nHeap--;                      int zz = 1;                      int yy = 0;                      int tmp = heap[zz];                      while (true)                      {                          yy = zz << 1;                          if (yy > nHeap)                          {                              break;                          }                          if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]])                          {                              yy++;                          }                          if (weight[tmp] < weight[heap[yy]])                          {                              break;                          }                            heap[zz] = heap[yy];                          zz = yy;                      }                      heap[zz] = tmp;                      n2 = heap[1];                      heap[1] = heap[nHeap];                      nHeap--;                        zz = 1;                      yy = 0;                      tmp = heap[zz];                      while (true)                      {                          yy = zz << 1;                          if (yy > nHeap)                          {                              break;                          }                          if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]])                          {                              yy++;                          }                          if (weight[tmp] < weight[heap[yy]])                          {                              break;                          }                          heap[zz] = heap[yy];                          zz = yy;                      }                      heap[zz] = tmp;                      nNodes++;                      parent[n1] = parent[n2] = nNodes;                        weight[nNodes] = (int)((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) |                          (int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));                        parent[nNodes] = -1;                      nHeap++;                      heap[nHeap] = nNodes;                        zz = nHeap;                      tmp = heap[zz];                      while (weight[tmp] < weight[heap[zz >> 1]])                      {                          heap[zz] = heap[zz >> 1];                          zz >>= 1;                      }                      heap[zz] = tmp;                  }                  if (!(nNodes < (BZip2Constants.MaximumAlphaSize * 2)))                  {                      Panic();                  }                    tooLong = false;                  for (int i = 1; i <= alphaSize; ++i)                  {                      j = 0;                      k = i;                      while (parent[k] >= 0)                      {                          k = parent[k];                          j++;                      }                      len[i - 1] = (char)j;                      if (j > maxLen)                      {                          tooLong = true;                      }                  }                    if (!tooLong)                  {                      break;                  }                    for (int i = 1; i < alphaSize; ++i)                  {                      j = weight[i] >> 8;                      j = 1 + (j / 2);                      weight[i] = j << 8;                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true)              {                  nNodes = alphaSize;                  nHeap = 0;                    heap[0] = 0;                  weight[0] = 0;                  parent[0] = -2;                    for (int i = 1; i <= alphaSize; ++i)                  {                      parent[i] = -1;                      nHeap++;                      heap[nHeap] = i;                      int zz = nHeap;                      int tmp = heap[zz];                      while (weight[tmp] < weight[heap[zz >> 1]])                      {                          heap[zz] = heap[zz >> 1];                          zz >>= 1;                      }                      heap[zz] = tmp;                  }                  if (!(nHeap < (BZip2Constants.MaximumAlphaSize + 2)))                  {                      Panic();                  }                    while (nHeap > 1)                  {                      n1 = heap[1];                      heap[1] = heap[nHeap];                      nHeap--;                      int zz = 1;                      int yy = 0;                      int tmp = heap[zz];                      while (true)                      {                          yy = zz << 1;                          if (yy > nHeap)                          {                              break;                          }                          if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]])                          {                              yy++;                          }                          if (weight[tmp] < weight[heap[yy]])                          {                              break;                          }                            heap[zz] = heap[yy];                          zz = yy;                      }                      heap[zz] = tmp;                      n2 = heap[1];                      heap[1] = heap[nHeap];                      nHeap--;                        zz = 1;                      yy = 0;                      tmp = heap[zz];                      while (true)                      {                          yy = zz << 1;                          if (yy > nHeap)                          {                              break;                          }                          if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]])                          {                              yy++;                          }                          if (weight[tmp] < weight[heap[yy]])                          {                              break;                          }                          heap[zz] = heap[yy];                          zz = yy;                      }                      heap[zz] = tmp;                      nNodes++;                      parent[n1] = parent[n2] = nNodes;                        weight[nNodes] = (int)((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) |                          (int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));                        parent[nNodes] = -1;                      nHeap++;                      heap[nHeap] = nNodes;                        zz = nHeap;                      tmp = heap[zz];                      while (weight[tmp] < weight[heap[zz >> 1]])                      {                          heap[zz] = heap[zz >> 1];                          zz >>= 1;                      }                      heap[zz] = tmp;                  }                  if (!(nNodes < (BZip2Constants.MaximumAlphaSize * 2)))                  {                      Panic();                  }                    tooLong = false;                  for (int i = 1; i <= alphaSize; ++i)                  {                      j = 0;                      k = i;                      while (parent[k] >= 0)                      {                          k = parent[k];                          j++;                      }                      len[i - 1] = (char)j;                      if (j > maxLen)                      {                          tooLong = true;                      }                  }                    if (!tooLong)                  {                      break;                  }                    for (int i = 1; i < alphaSize; ++i)                  {                      j = weight[i] >> 8;                      j = 1 + (j / 2);                      weight[i] = j << 8;                  }              }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true)              {                  nNodes = alphaSize;                  nHeap = 0;                    heap[0] = 0;                  weight[0] = 0;                  parent[0] = -2;                    for (int i = 1; i <= alphaSize; ++i)                  {                      parent[i] = -1;                      nHeap++;                      heap[nHeap] = i;                      int zz = nHeap;                      int tmp = heap[zz];                      while (weight[tmp] < weight[heap[zz >> 1]])                      {                          heap[zz] = heap[zz >> 1];                          zz >>= 1;                      }                      heap[zz] = tmp;                  }                  if (!(nHeap < (BZip2Constants.MaximumAlphaSize + 2)))                  {                      Panic();                  }                    while (nHeap > 1)                  {                      n1 = heap[1];                      heap[1] = heap[nHeap];                      nHeap--;                      int zz = 1;                      int yy = 0;                      int tmp = heap[zz];                      while (true)                      {                          yy = zz << 1;                          if (yy > nHeap)                          {                              break;                          }                          if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]])                          {                              yy++;                          }                          if (weight[tmp] < weight[heap[yy]])                          {                              break;                          }                            heap[zz] = heap[yy];                          zz = yy;                      }                      heap[zz] = tmp;                      n2 = heap[1];                      heap[1] = heap[nHeap];                      nHeap--;                        zz = 1;                      yy = 0;                      tmp = heap[zz];                      while (true)                      {                          yy = zz << 1;                          if (yy > nHeap)                          {                              break;                          }                          if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]])                          {                              yy++;                          }                          if (weight[tmp] < weight[heap[yy]])                          {                              break;                          }                          heap[zz] = heap[yy];                          zz = yy;                      }                      heap[zz] = tmp;                      nNodes++;                      parent[n1] = parent[n2] = nNodes;                        weight[nNodes] = (int)((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) |                          (int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));                        parent[nNodes] = -1;                      nHeap++;                      heap[nHeap] = nNodes;                        zz = nHeap;                      tmp = heap[zz];                      while (weight[tmp] < weight[heap[zz >> 1]])                      {                          heap[zz] = heap[zz >> 1];                          zz >>= 1;                      }                      heap[zz] = tmp;                  }                  if (!(nNodes < (BZip2Constants.MaximumAlphaSize * 2)))                  {                      Panic();                  }                    tooLong = false;                  for (int i = 1; i <= alphaSize; ++i)                  {                      j = 0;                      k = i;                      while (parent[k] >= 0)                      {                          k = parent[k];                          j++;                      }                      len[i - 1] = (char)j;                      if (j > maxLen)                      {                          tooLong = true;                      }                  }                    if (!tooLong)                  {                      break;                  }                    for (int i = 1; i < alphaSize; ++i)                  {                      j = weight[i] >> 8;                      j = 1 + (j / 2);                      weight[i] = j << 8;                  }              }
Magic Number,Orvid.Compression.Streams,DeflaterInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Skip,The following statement contains a magic number: if (baseInputStream.CanSeek)              {                  baseInputStream.Seek(count' SeekOrigin.Current);                  return count;              }              else              {                  int length = 2048;                  if (count < length)                  {                      length = (int)count;                  }                    byte[] tmp = new byte[length];                  int readCount = 1;                  long toSkip = count;                    while ((toSkip > 0) && (readCount > 0))                  {                      if (toSkip < length)                      {                          length = (int)toSkip;                      }                        readCount = baseInputStream.Read(tmp' 0' length);                      toSkip -= readCount;                  }                    return count - toSkip;              }
Magic Number,Orvid.Compression.Streams,DeflaterOutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterOutputStream,The following statement contains a magic number: if (bufferSize < 512)              {                  throw new ArgumentOutOfRangeException("bufferSize");              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  byte[] codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new Exception("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  byte[] codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new Exception("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  byte[] codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new Exception("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  byte[] codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new Exception("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  byte[] codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new Exception("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  byte[] codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new Exception("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  byte[] codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new Exception("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  byte[] codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new Exception("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  byte[] codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new Exception("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  byte[] codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new Exception("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  byte[] codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new Exception("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  byte[] codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new Exception("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: int treeSize = 512;
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++)              {                  nextCode[bits] = code;                  code += blCount[bits] << (16 - bits);                  if (bits >= 10)                  {                      int start = nextCode[bits] & 0x1ff80;                      int end = code & 0x1ff80;                      treeSize += (end - start) >> (16 - bits);                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++)              {                  nextCode[bits] = code;                  code += blCount[bits] << (16 - bits);                  if (bits >= 10)                  {                      int start = nextCode[bits] & 0x1ff80;                      int end = code & 0x1ff80;                      treeSize += (end - start) >> (16 - bits);                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++)              {                  nextCode[bits] = code;                  code += blCount[bits] << (16 - bits);                  if (bits >= 10)                  {                      int start = nextCode[bits] & 0x1ff80;                      int end = code & 0x1ff80;                      treeSize += (end - start) >> (16 - bits);                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: int treePtr = 512;
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--)              {                  int end = code & 0x1ff80;                  code -= blCount[bits] << (16 - bits);                  int start = code & 0x1ff80;                  for (int i = start; i < end; i += 1 << 7)                  {                      tree[DeflaterHuffman.BitReverse(i)] = (short)((-treePtr << 4) | bits);                      treePtr += 1 << (bits - 9);                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--)              {                  int end = code & 0x1ff80;                  code -= blCount[bits] << (16 - bits);                  int start = code & 0x1ff80;                  for (int i = start; i < end; i += 1 << 7)                  {                      tree[DeflaterHuffman.BitReverse(i)] = (short)((-treePtr << 4) | bits);                      treePtr += 1 << (bits - 9);                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--)              {                  int end = code & 0x1ff80;                  code -= blCount[bits] << (16 - bits);                  int start = code & 0x1ff80;                  for (int i = start; i < end; i += 1 << 7)                  {                      tree[DeflaterHuffman.BitReverse(i)] = (short)((-treePtr << 4) | bits);                      treePtr += 1 << (bits - 9);                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--)              {                  int end = code & 0x1ff80;                  code -= blCount[bits] << (16 - bits);                  int start = code & 0x1ff80;                  for (int i = start; i < end; i += 1 << 7)                  {                      tree[DeflaterHuffman.BitReverse(i)] = (short)((-treePtr << 4) | bits);                      treePtr += 1 << (bits - 9);                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--)              {                  int end = code & 0x1ff80;                  code -= blCount[bits] << (16 - bits);                  int start = code & 0x1ff80;                  for (int i = start; i < end; i += 1 << 7)                  {                      tree[DeflaterHuffman.BitReverse(i)] = (short)((-treePtr << 4) | bits);                      treePtr += 1 << (bits - 9);                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++)              {                  int bits = codeLengths[i];                  if (bits == 0)                  {                      continue;                  }                  code = nextCode[bits];                  int revcode = DeflaterHuffman.BitReverse(code);                  if (bits <= 9)                  {                      do                      {                          tree[revcode] = (short)((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < 512);                  }                  else                  {                      int subTree = tree[revcode & 511];                      int treeLen = 1 << (subTree & 15);                      subTree = -(subTree >> 4);                      do                      {                          tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < treeLen);                  }                  nextCode[bits] = code + (1 << (16 - bits));              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++)              {                  int bits = codeLengths[i];                  if (bits == 0)                  {                      continue;                  }                  code = nextCode[bits];                  int revcode = DeflaterHuffman.BitReverse(code);                  if (bits <= 9)                  {                      do                      {                          tree[revcode] = (short)((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < 512);                  }                  else                  {                      int subTree = tree[revcode & 511];                      int treeLen = 1 << (subTree & 15);                      subTree = -(subTree >> 4);                      do                      {                          tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < treeLen);                  }                  nextCode[bits] = code + (1 << (16 - bits));              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++)              {                  int bits = codeLengths[i];                  if (bits == 0)                  {                      continue;                  }                  code = nextCode[bits];                  int revcode = DeflaterHuffman.BitReverse(code);                  if (bits <= 9)                  {                      do                      {                          tree[revcode] = (short)((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < 512);                  }                  else                  {                      int subTree = tree[revcode & 511];                      int treeLen = 1 << (subTree & 15);                      subTree = -(subTree >> 4);                      do                      {                          tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < treeLen);                  }                  nextCode[bits] = code + (1 << (16 - bits));              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++)              {                  int bits = codeLengths[i];                  if (bits == 0)                  {                      continue;                  }                  code = nextCode[bits];                  int revcode = DeflaterHuffman.BitReverse(code);                  if (bits <= 9)                  {                      do                      {                          tree[revcode] = (short)((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < 512);                  }                  else                  {                      int subTree = tree[revcode & 511];                      int treeLen = 1 << (subTree & 15);                      subTree = -(subTree >> 4);                      do                      {                          tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < treeLen);                  }                  nextCode[bits] = code + (1 << (16 - bits));              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++)              {                  int bits = codeLengths[i];                  if (bits == 0)                  {                      continue;                  }                  code = nextCode[bits];                  int revcode = DeflaterHuffman.BitReverse(code);                  if (bits <= 9)                  {                      do                      {                          tree[revcode] = (short)((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < 512);                  }                  else                  {                      int subTree = tree[revcode & 511];                      int treeLen = 1 << (subTree & 15);                      subTree = -(subTree >> 4);                      do                      {                          tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < treeLen);                  }                  nextCode[bits] = code + (1 << (16 - bits));              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++)              {                  int bits = codeLengths[i];                  if (bits == 0)                  {                      continue;                  }                  code = nextCode[bits];                  int revcode = DeflaterHuffman.BitReverse(code);                  if (bits <= 9)                  {                      do                      {                          tree[revcode] = (short)((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < 512);                  }                  else                  {                      int subTree = tree[revcode & 511];                      int treeLen = 1 << (subTree & 15);                      subTree = -(subTree >> 4);                      do                      {                          tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < treeLen);                  }                  nextCode[bits] = code + (1 << (16 - bits));              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++)              {                  int bits = codeLengths[i];                  if (bits == 0)                  {                      continue;                  }                  code = nextCode[bits];                  int revcode = DeflaterHuffman.BitReverse(code);                  if (bits <= 9)                  {                      do                      {                          tree[revcode] = (short)((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < 512);                  }                  else                  {                      int subTree = tree[revcode & 511];                      int treeLen = 1 << (subTree & 15);                      subTree = -(subTree >> 4);                      do                      {                          tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < treeLen);                  }                  nextCode[bits] = code + (1 << (16 - bits));              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++)              {                  int bits = codeLengths[i];                  if (bits == 0)                  {                      continue;                  }                  code = nextCode[bits];                  int revcode = DeflaterHuffman.BitReverse(code);                  if (bits <= 9)                  {                      do                      {                          tree[revcode] = (short)((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < 512);                  }                  else                  {                      int subTree = tree[revcode & 511];                      int treeLen = 1 << (subTree & 15);                      subTree = -(subTree >> 4);                      do                      {                          tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < treeLen);                  }                  nextCode[bits] = code + (1 << (16 - bits));              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++)              {                  int bits = codeLengths[i];                  if (bits == 0)                  {                      continue;                  }                  code = nextCode[bits];                  int revcode = DeflaterHuffman.BitReverse(code);                  if (bits <= 9)                  {                      do                      {                          tree[revcode] = (short)((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < 512);                  }                  else                  {                      int subTree = tree[revcode & 511];                      int treeLen = 1 << (subTree & 15);                      subTree = -(subTree >> 4);                      do                      {                          tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < treeLen);                  }                  nextCode[bits] = code + (1 << (16 - bits));              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterDynHeader,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: decode_loop:              for (; ; )              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          mode = DNUM;                          goto case DNUM;                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM;                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          mode = BLLENS;                          goto case BLLENS;                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              blLens[BL_ORDER[ptr]] = (byte)len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS;                      case LENS:                          {                              int symbol;                              while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                              {                                  litdistLens[ptr++] = lastLen = (byte)symbol;                                    if (ptr == num)                                  {                                      return true;                                  }                              }                                if (symbol < 0)                              {                                  return false;                              }                                if (symbol >= 17)                              {                                  lastLen = 0;                              }                              else                              {                                  if (ptr == 0)                                  {                                      throw new Exception();                                  }                              }                              repSymbol = symbol - 16;                          }                          mode = REPS;                          goto case REPS;                      case REPS:                          {                              int bits = repBits[repSymbol];                              int count = input.PeekBits(bits);                              if (count < 0)                              {                                  return false;                              }                              input.DropBits(bits);                              count += repMin[repSymbol];                                if (ptr + count > num)                              {                                  throw new Exception();                              }                              while (count-- > 0)                              {                                  litdistLens[ptr++] = lastLen;                              }                                if (ptr == num)                              {                                  return true;                              }                          }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterDynHeader,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: decode_loop:              for (; ; )              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          mode = DNUM;                          goto case DNUM;                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM;                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          mode = BLLENS;                          goto case BLLENS;                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              blLens[BL_ORDER[ptr]] = (byte)len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS;                      case LENS:                          {                              int symbol;                              while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                              {                                  litdistLens[ptr++] = lastLen = (byte)symbol;                                    if (ptr == num)                                  {                                      return true;                                  }                              }                                if (symbol < 0)                              {                                  return false;                              }                                if (symbol >= 17)                              {                                  lastLen = 0;                              }                              else                              {                                  if (ptr == 0)                                  {                                      throw new Exception();                                  }                              }                              repSymbol = symbol - 16;                          }                          mode = REPS;                          goto case REPS;                      case REPS:                          {                              int bits = repBits[repSymbol];                              int count = input.PeekBits(bits);                              if (count < 0)                              {                                  return false;                              }                              input.DropBits(bits);                              count += repMin[repSymbol];                                if (ptr + count > num)                              {                                  throw new Exception();                              }                              while (count-- > 0)                              {                                  litdistLens[ptr++] = lastLen;                              }                                if (ptr == num)                              {                                  return true;                              }                          }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterDynHeader,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: decode_loop:              for (; ; )              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          mode = DNUM;                          goto case DNUM;                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM;                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          mode = BLLENS;                          goto case BLLENS;                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              blLens[BL_ORDER[ptr]] = (byte)len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS;                      case LENS:                          {                              int symbol;                              while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                              {                                  litdistLens[ptr++] = lastLen = (byte)symbol;                                    if (ptr == num)                                  {                                      return true;                                  }                              }                                if (symbol < 0)                              {                                  return false;                              }                                if (symbol >= 17)                              {                                  lastLen = 0;                              }                              else                              {                                  if (ptr == 0)                                  {                                      throw new Exception();                                  }                              }                              repSymbol = symbol - 16;                          }                          mode = REPS;                          goto case REPS;                      case REPS:                          {                              int bits = repBits[repSymbol];                              int count = input.PeekBits(bits);                              if (count < 0)                              {                                  return false;                              }                              input.DropBits(bits);                              count += repMin[repSymbol];                                if (ptr + count > num)                              {                                  throw new Exception();                              }                              while (count-- > 0)                              {                                  litdistLens[ptr++] = lastLen;                              }                                if (ptr == num)                              {                                  return true;                              }                          }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterDynHeader,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: decode_loop:              for (; ; )              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          mode = DNUM;                          goto case DNUM;                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM;                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          mode = BLLENS;                          goto case BLLENS;                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              blLens[BL_ORDER[ptr]] = (byte)len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS;                      case LENS:                          {                              int symbol;                              while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                              {                                  litdistLens[ptr++] = lastLen = (byte)symbol;                                    if (ptr == num)                                  {                                      return true;                                  }                              }                                if (symbol < 0)                              {                                  return false;                              }                                if (symbol >= 17)                              {                                  lastLen = 0;                              }                              else                              {                                  if (ptr == 0)                                  {                                      throw new Exception();                                  }                              }                              repSymbol = symbol - 16;                          }                          mode = REPS;                          goto case REPS;                      case REPS:                          {                              int bits = repBits[repSymbol];                              int count = input.PeekBits(bits);                              if (count < 0)                              {                                  return false;                              }                              input.DropBits(bits);                              count += repMin[repSymbol];                                if (ptr + count > num)                              {                                  throw new Exception();                              }                              while (count-- > 0)                              {                                  litdistLens[ptr++] = lastLen;                              }                                if (ptr == num)                              {                                  return true;                              }                          }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterDynHeader,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: decode_loop:              for (; ; )              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          mode = DNUM;                          goto case DNUM;                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM;                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          mode = BLLENS;                          goto case BLLENS;                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              blLens[BL_ORDER[ptr]] = (byte)len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS;                      case LENS:                          {                              int symbol;                              while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                              {                                  litdistLens[ptr++] = lastLen = (byte)symbol;                                    if (ptr == num)                                  {                                      return true;                                  }                              }                                if (symbol < 0)                              {                                  return false;                              }                                if (symbol >= 17)                              {                                  lastLen = 0;                              }                              else                              {                                  if (ptr == 0)                                  {                                      throw new Exception();                                  }                              }                              repSymbol = symbol - 16;                          }                          mode = REPS;                          goto case REPS;                      case REPS:                          {                              int bits = repBits[repSymbol];                              int count = input.PeekBits(bits);                              if (count < 0)                              {                                  return false;                              }                              input.DropBits(bits);                              count += repMin[repSymbol];                                if (ptr + count > num)                              {                                  throw new Exception();                              }                              while (count-- > 0)                              {                                  litdistLens[ptr++] = lastLen;                              }                                if (ptr == num)                              {                                  return true;                              }                          }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterDynHeader,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: decode_loop:              for (; ; )              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          mode = DNUM;                          goto case DNUM;                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM;                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          mode = BLLENS;                          goto case BLLENS;                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              blLens[BL_ORDER[ptr]] = (byte)len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS;                      case LENS:                          {                              int symbol;                              while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                              {                                  litdistLens[ptr++] = lastLen = (byte)symbol;                                    if (ptr == num)                                  {                                      return true;                                  }                              }                                if (symbol < 0)                              {                                  return false;                              }                                if (symbol >= 17)                              {                                  lastLen = 0;                              }                              else                              {                                  if (ptr == 0)                                  {                                      throw new Exception();                                  }                              }                              repSymbol = symbol - 16;                          }                          mode = REPS;                          goto case REPS;                      case REPS:                          {                              int bits = repBits[repSymbol];                              int count = input.PeekBits(bits);                              if (count < 0)                              {                                  return false;                              }                              input.DropBits(bits);                              count += repMin[repSymbol];                                if (ptr + count > num)                              {                                  throw new Exception();                              }                              while (count-- > 0)                              {                                  litdistLens[ptr++] = lastLen;                              }                                if (ptr == num)                              {                                  return true;                              }                          }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterDynHeader,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: decode_loop:              for (; ; )              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          mode = DNUM;                          goto case DNUM;                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM;                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          mode = BLLENS;                          goto case BLLENS;                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              blLens[BL_ORDER[ptr]] = (byte)len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS;                      case LENS:                          {                              int symbol;                              while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                              {                                  litdistLens[ptr++] = lastLen = (byte)symbol;                                    if (ptr == num)                                  {                                      return true;                                  }                              }                                if (symbol < 0)                              {                                  return false;                              }                                if (symbol >= 17)                              {                                  lastLen = 0;                              }                              else                              {                                  if (ptr == 0)                                  {                                      throw new Exception();                                  }                              }                              repSymbol = symbol - 16;                          }                          mode = REPS;                          goto case REPS;                      case REPS:                          {                              int bits = repBits[repSymbol];                              int count = input.PeekBits(bits);                              if (count < 0)                              {                                  return false;                              }                              input.DropBits(bits);                              count += repMin[repSymbol];                                if (ptr + count > num)                              {                                  throw new Exception();                              }                              while (count-- > 0)                              {                                  litdistLens[ptr++] = lastLen;                              }                                if (ptr == num)                              {                                  return true;                              }                          }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterDynHeader,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: decode_loop:              for (; ; )              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          mode = DNUM;                          goto case DNUM;                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM;                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          mode = BLLENS;                          goto case BLLENS;                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              blLens[BL_ORDER[ptr]] = (byte)len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS;                      case LENS:                          {                              int symbol;                              while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                              {                                  litdistLens[ptr++] = lastLen = (byte)symbol;                                    if (ptr == num)                                  {                                      return true;                                  }                              }                                if (symbol < 0)                              {                                  return false;                              }                                if (symbol >= 17)                              {                                  lastLen = 0;                              }                              else                              {                                  if (ptr == 0)                                  {                                      throw new Exception();                                  }                              }                              repSymbol = symbol - 16;                          }                          mode = REPS;                          goto case REPS;                      case REPS:                          {                              int bits = repBits[repSymbol];                              int count = input.PeekBits(bits);                              if (count < 0)                              {                                  return false;                              }                              input.DropBits(bits);                              count += repMin[repSymbol];                                if (ptr + count > num)                              {                                  throw new Exception();                              }                              while (count-- > 0)                              {                                  litdistLens[ptr++] = lastLen;                              }                                if (ptr == num)                              {                                  return true;                              }                          }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterDynHeader,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: decode_loop:              for (; ; )              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          mode = DNUM;                          goto case DNUM;                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM;                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          mode = BLLENS;                          goto case BLLENS;                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              blLens[BL_ORDER[ptr]] = (byte)len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS;                      case LENS:                          {                              int symbol;                              while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                              {                                  litdistLens[ptr++] = lastLen = (byte)symbol;                                    if (ptr == num)                                  {                                      return true;                                  }                              }                                if (symbol < 0)                              {                                  return false;                              }                                if (symbol >= 17)                              {                                  lastLen = 0;                              }                              else                              {                                  if (ptr == 0)                                  {                                      throw new Exception();                                  }                              }                              repSymbol = symbol - 16;                          }                          mode = REPS;                          goto case REPS;                      case REPS:                          {                              int bits = repBits[repSymbol];                              int count = input.PeekBits(bits);                              if (count < 0)                              {                                  return false;                              }                              input.DropBits(bits);                              count += repMin[repSymbol];                                if (ptr + count > num)                              {                                  throw new Exception();                              }                              while (count-- > 0)                              {                                  litdistLens[ptr++] = lastLen;                              }                                if (ptr == num)                              {                                  return true;                              }                          }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterDynHeader,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: decode_loop:              for (; ; )              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          mode = DNUM;                          goto case DNUM;                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM;                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          mode = BLLENS;                          goto case BLLENS;                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              blLens[BL_ORDER[ptr]] = (byte)len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS;                      case LENS:                          {                              int symbol;                              while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                              {                                  litdistLens[ptr++] = lastLen = (byte)symbol;                                    if (ptr == num)                                  {                                      return true;                                  }                              }                                if (symbol < 0)                              {                                  return false;                              }                                if (symbol >= 17)                              {                                  lastLen = 0;                              }                              else                              {                                  if (ptr == 0)                                  {                                      throw new Exception();                                  }                              }                              repSymbol = symbol - 16;                          }                          mode = REPS;                          goto case REPS;                      case REPS:                          {                              int bits = repBits[repSymbol];                              int count = input.PeekBits(bits);                              if (count < 0)                              {                                  return false;                              }                              input.DropBits(bits);                              count += repMin[repSymbol];                                if (ptr + count > num)                              {                                  throw new Exception();                              }                              while (count-- > 0)                              {                                  litdistLens[ptr++] = lastLen;                              }                                if (ptr == num)                              {                                  return true;                              }                          }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterDynHeader,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: decode_loop:              for (; ; )              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          mode = DNUM;                          goto case DNUM;                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM;                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          mode = BLLENS;                          goto case BLLENS;                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              blLens[BL_ORDER[ptr]] = (byte)len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS;                      case LENS:                          {                              int symbol;                              while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                              {                                  litdistLens[ptr++] = lastLen = (byte)symbol;                                    if (ptr == num)                                  {                                      return true;                                  }                              }                                if (symbol < 0)                              {                                  return false;                              }                                if (symbol >= 17)                              {                                  lastLen = 0;                              }                              else                              {                                  if (ptr == 0)                                  {                                      throw new Exception();                                  }                              }                              repSymbol = symbol - 16;                          }                          mode = REPS;                          goto case REPS;                      case REPS:                          {                              int bits = repBits[repSymbol];                              int count = input.PeekBits(bits);                              if (count < 0)                              {                                  return false;                              }                              input.DropBits(bits);                              count += repMin[repSymbol];                                if (ptr + count > num)                              {                                  throw new Exception();                              }                              while (count-- > 0)                              {                                  litdistLens[ptr++] = lastLen;                              }                                if (ptr == num)                              {                                  return true;                              }                          }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterDynHeader,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: decode_loop:              for (; ; )              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          mode = DNUM;                          goto case DNUM;                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM;                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          mode = BLLENS;                          goto case BLLENS;                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              blLens[BL_ORDER[ptr]] = (byte)len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS;                      case LENS:                          {                              int symbol;                              while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                              {                                  litdistLens[ptr++] = lastLen = (byte)symbol;                                    if (ptr == num)                                  {                                      return true;                                  }                              }                                if (symbol < 0)                              {                                  return false;                              }                                if (symbol >= 17)                              {                                  lastLen = 0;                              }                              else                              {                                  if (ptr == 0)                                  {                                      throw new Exception();                                  }                              }                              repSymbol = symbol - 16;                          }                          mode = REPS;                          goto case REPS;                      case REPS:                          {                              int bits = repBits[repSymbol];                              int count = input.PeekBits(bits);                              if (count < 0)                              {                                  return false;                              }                              input.DropBits(bits);                              count += repMin[repSymbol];                                if (ptr + count > num)                              {                                  throw new Exception();                              }                              while (count-- > 0)                              {                                  litdistLens[ptr++] = lastLen;                              }                                if (ptr == num)                              {                                  return true;                              }                          }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterDynHeader,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: decode_loop:              for (; ; )              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          mode = DNUM;                          goto case DNUM;                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM;                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          mode = BLLENS;                          goto case BLLENS;                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              blLens[BL_ORDER[ptr]] = (byte)len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS;                      case LENS:                          {                              int symbol;                              while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                              {                                  litdistLens[ptr++] = lastLen = (byte)symbol;                                    if (ptr == num)                                  {                                      return true;                                  }                              }                                if (symbol < 0)                              {                                  return false;                              }                                if (symbol >= 17)                              {                                  lastLen = 0;                              }                              else                              {                                  if (ptr == 0)                                  {                                      throw new Exception();                                  }                              }                              repSymbol = symbol - 16;                          }                          mode = REPS;                          goto case REPS;                      case REPS:                          {                              int bits = repBits[repSymbol];                              int count = input.PeekBits(bits);                              if (count < 0)                              {                                  return false;                              }                              input.DropBits(bits);                              count += repMin[repSymbol];                                if (ptr + count > num)                              {                                  throw new Exception();                              }                              while (count-- > 0)                              {                                  litdistLens[ptr++] = lastLen;                              }                                if (ptr == num)                              {                                  return true;                              }                          }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,Orvid.Compression.Streams,InflaterDynHeader,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: decode_loop:              for (; ; )              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          mode = DNUM;                          goto case DNUM;                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM;                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          mode = BLLENS;                          goto case BLLENS;                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              blLens[BL_ORDER[ptr]] = (byte)len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS;                      case LENS:                          {                              int symbol;                              while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                              {                                  litdistLens[ptr++] = lastLen = (byte)symbol;                                    if (ptr == num)                                  {                                      return true;                                  }                              }                                if (symbol < 0)                              {                                  return false;                              }                                if (symbol >= 17)                              {                                  lastLen = 0;                              }                              else                              {                                  if (ptr == 0)                                  {                                      throw new Exception();                                  }                              }                              repSymbol = symbol - 16;                          }                          mode = REPS;                          goto case REPS;                      case REPS:                          {                              int bits = repBits[repSymbol];                              int count = input.PeekBits(bits);                              if (count < 0)                              {                                  return false;                              }                              input.DropBits(bits);                              count += repMin[repSymbol];                                if (ptr + count > num)                              {                                  throw new Exception();                              }                              while (count-- > 0)                              {                                  litdistLens[ptr++] = lastLen;                              }                                if (ptr == num)                              {                                  return true;                              }                          }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,Orvid.Compression.Streams,StreamManipulator,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount)              {                  if (windowStart_ == windowEnd_)                  {                      return -1;                  }                  buffer_ |= (uint)((window_[windowStart_++] & 0xff |                                   (window_[windowStart_++] & 0xff) << 8) << bitsInBuffer_);                  bitsInBuffer_ += 16;              }
Magic Number,Orvid.Compression.Streams,StreamManipulator,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount)              {                  if (windowStart_ == windowEnd_)                  {                      return -1;                  }                  buffer_ |= (uint)((window_[windowStart_++] & 0xff |                                   (window_[windowStart_++] & 0xff) << 8) << bitsInBuffer_);                  bitsInBuffer_ += 16;              }
Magic Number,Orvid.Compression.Streams,StreamManipulator,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SkipToByteBoundary,The following statement contains a magic number: buffer_ >>= (bitsInBuffer_ & 7);
Magic Number,Orvid.Compression.Streams,StreamManipulator,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SkipToByteBoundary,The following statement contains a magic number: bitsInBuffer_ &= ~7;
Magic Number,Orvid.Compression.Streams,StreamManipulator,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CopyBytes,The following statement contains a magic number: if ((bitsInBuffer_ & 7) != 0)              {                  throw new InvalidOperationException("Bit buffer is not byte aligned!");              }
Magic Number,Orvid.Compression.Streams,StreamManipulator,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0))              {                  output[offset++] = (byte)buffer_;                  buffer_ >>= 8;                  bitsInBuffer_ -= 8;                  length--;                  count++;              }
Magic Number,Orvid.Compression.Streams,StreamManipulator,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0))              {                  output[offset++] = (byte)buffer_;                  buffer_ >>= 8;                  bitsInBuffer_ -= 8;                  length--;                  count++;              }
Magic Number,Orvid.Compression.Streams,StreamManipulator,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CopyBytes,The following statement contains a magic number: if (((windowStart_ - windowEnd_) & 1) != 0)              {                  buffer_ = (uint)(window_[windowStart_++] & 0xff);                  bitsInBuffer_ = 8;              }
Magic Number,Orvid.Compression.Streams,StreamManipulator,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SetInput,The following statement contains a magic number: if ((count & 1) != 0)              {                  buffer_ |= (uint)((buffer[offset++] & 0xff) << bitsInBuffer_);                  bitsInBuffer_ += 8;              }
Magic Number,Orvid.Compression.Streams,PendingBuffer,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteShort,The following statement contains a magic number: buffer_[end++] = unchecked((byte)(value >> 8));
Magic Number,Orvid.Compression.Streams,PendingBuffer,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteInt,The following statement contains a magic number: buffer_[end++] = unchecked((byte)(value >> 8));
Magic Number,Orvid.Compression.Streams,PendingBuffer,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteInt,The following statement contains a magic number: buffer_[end++] = unchecked((byte)(value >> 16));
Magic Number,Orvid.Compression.Streams,PendingBuffer,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteInt,The following statement contains a magic number: buffer_[end++] = unchecked((byte)(value >> 24));
Magic Number,Orvid.Compression.Streams,PendingBuffer,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0)              {                  buffer_[end++] = unchecked((byte)bits);                  if (bitCount > 8)                  {                      buffer_[end++] = unchecked((byte)(bits >> 8));                  }              }
Magic Number,Orvid.Compression.Streams,PendingBuffer,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0)              {                  buffer_[end++] = unchecked((byte)bits);                  if (bitCount > 8)                  {                      buffer_[end++] = unchecked((byte)(bits >> 8));                  }              }
Magic Number,Orvid.Compression.Streams,PendingBuffer,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16)              {                  buffer_[end++] = unchecked((byte)bits);                  buffer_[end++] = unchecked((byte)(bits >> 8));                  bits >>= 16;                  bitCount -= 16;              }
Magic Number,Orvid.Compression.Streams,PendingBuffer,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16)              {                  buffer_[end++] = unchecked((byte)bits);                  buffer_[end++] = unchecked((byte)(bits >> 8));                  bits >>= 16;                  bitCount -= 16;              }
Magic Number,Orvid.Compression.Streams,PendingBuffer,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16)              {                  buffer_[end++] = unchecked((byte)bits);                  buffer_[end++] = unchecked((byte)(bits >> 8));                  bits >>= 16;                  bitCount -= 16;              }
Magic Number,Orvid.Compression.Streams,PendingBuffer,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16)              {                  buffer_[end++] = unchecked((byte)bits);                  buffer_[end++] = unchecked((byte)(bits >> 8));                  bits >>= 16;                  bitCount -= 16;              }
Magic Number,Orvid.Compression.Streams,PendingBuffer,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteShortMSB,The following statement contains a magic number: buffer_[end++] = unchecked((byte)(s >> 8));
Magic Number,Orvid.Compression.Streams,PendingBuffer,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Flush,The following statement contains a magic number: if (bitCount >= 8)              {                  buffer_[end++] = unchecked((byte)bits);                  bits >>= 8;                  bitCount -= 8;              }
Magic Number,Orvid.Compression.Streams,PendingBuffer,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Flush,The following statement contains a magic number: if (bitCount >= 8)              {                  buffer_[end++] = unchecked((byte)bits);                  bits >>= 8;                  bitCount -= 8;              }
Magic Number,Orvid.Compression.Streams,PendingBuffer,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Flush,The following statement contains a magic number: if (bitCount >= 8)              {                  buffer_[end++] = unchecked((byte)bits);                  bits >>= 8;                  bitCount -= 8;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144)              {                  staticLCodes[i] = BitReverse((0x030 + i) << 8);                  staticLLength[i++] = 8;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144)              {                  staticLCodes[i] = BitReverse((0x030 + i) << 8);                  staticLLength[i++] = 8;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144)              {                  staticLCodes[i] = BitReverse((0x030 + i) << 8);                  staticLLength[i++] = 8;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256)              {                  staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);                  staticLLength[i++] = 9;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256)              {                  staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);                  staticLLength[i++] = 9;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256)              {                  staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);                  staticLLength[i++] = 9;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256)              {                  staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);                  staticLLength[i++] = 9;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280)              {                  staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);                  staticLLength[i++] = 7;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280)              {                  staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);                  staticLLength[i++] = 7;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280)              {                  staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);                  staticLLength[i++] = 7;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280)              {                  staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);                  staticLLength[i++] = 7;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM)              {                  staticLCodes[i] = BitReverse((0x0c0 - 280 + i) << 8);                  staticLLength[i++] = 8;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM)              {                  staticLCodes[i] = BitReverse((0x0c0 - 280 + i) << 8);                  staticLLength[i++] = 8;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM)              {                  staticLCodes[i] = BitReverse((0x0c0 - 280 + i) << 8);                  staticLLength[i++] = 8;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++)              {                  staticDCodes[i] = BitReverse(i << 11);                  staticDLength[i] = 5;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++)              {                  staticDCodes[i] = BitReverse(i << 11);                  staticDLength[i] = 5;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree(this' LITERAL_NUM' 257' 15);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree(this' LITERAL_NUM' 257' 15);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: distTree = new Tree(this' DIST_NUM' 1' 15);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree(this' BITLEN_NUM' 4' 7);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree(this' BITLEN_NUM' 4' 7);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(literalTree.numCodes - 257' 5);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(literalTree.numCodes - 257' 5);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(distTree.numCodes - 1' 5);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(blTreeCodes - 4' 4);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(blTreeCodes - 4' 4);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SendAllTrees,The following statement contains a magic number: for (int rank = 0; rank < blTreeCodes; rank++)              {                  pending.WriteBits(blTree.length[BL_ORDER[rank]]' 3);              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++)              {                  int litlen = l_buf[i] & 0xff;                  int dist = d_buf[i];                  if (dist-- != 0)                  {                      int lc = Lcode(litlen);                      literalTree.WriteSymbol(lc);                        int bits = (lc - 261) / 4;                      if (bits > 0 && bits <= 5)                      {                          pending.WriteBits(litlen & ((1 << bits) - 1)' bits);                      }                        int dc = Dcode(dist);                      distTree.WriteSymbol(dc);                        bits = dc / 2 - 1;                      if (bits > 0)                      {                          pending.WriteBits(dist & ((1 << bits) - 1)' bits);                      }                  }                  else                  {                      literalTree.WriteSymbol(litlen);                  }              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++)              {                  int litlen = l_buf[i] & 0xff;                  int dist = d_buf[i];                  if (dist-- != 0)                  {                      int lc = Lcode(litlen);                      literalTree.WriteSymbol(lc);                        int bits = (lc - 261) / 4;                      if (bits > 0 && bits <= 5)                      {                          pending.WriteBits(litlen & ((1 << bits) - 1)' bits);                      }                        int dc = Dcode(dist);                      distTree.WriteSymbol(dc);                        bits = dc / 2 - 1;                      if (bits > 0)                      {                          pending.WriteBits(dist & ((1 << bits) - 1)' bits);                      }                  }                  else                  {                      literalTree.WriteSymbol(litlen);                  }              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++)              {                  int litlen = l_buf[i] & 0xff;                  int dist = d_buf[i];                  if (dist-- != 0)                  {                      int lc = Lcode(litlen);                      literalTree.WriteSymbol(lc);                        int bits = (lc - 261) / 4;                      if (bits > 0 && bits <= 5)                      {                          pending.WriteBits(litlen & ((1 << bits) - 1)' bits);                      }                        int dc = Dcode(dist);                      distTree.WriteSymbol(dc);                        bits = dc / 2 - 1;                      if (bits > 0)                      {                          pending.WriteBits(dist & ((1 << bits) - 1)' bits);                      }                  }                  else                  {                      literalTree.WriteSymbol(litlen);                  }              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++)              {                  int litlen = l_buf[i] & 0xff;                  int dist = d_buf[i];                  if (dist-- != 0)                  {                      int lc = Lcode(litlen);                      literalTree.WriteSymbol(lc);                        int bits = (lc - 261) / 4;                      if (bits > 0 && bits <= 5)                      {                          pending.WriteBits(litlen & ((1 << bits) - 1)' bits);                      }                        int dc = Dcode(dist);                      distTree.WriteSymbol(dc);                        bits = dc / 2 - 1;                      if (bits > 0)                      {                          pending.WriteBits(dist & ((1 << bits) - 1)' bits);                      }                  }                  else                  {                      literalTree.WriteSymbol(litlen);                  }              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FlushStoredBlock,The following statement contains a magic number: pending.WriteBits((DeflaterConstants.STORED_BLOCK << 1) + (lastBlock ? 1 : 0)' 3);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FlushBlock,The following statement contains a magic number: int blTreeCodes = 4;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FlushBlock,The following statement contains a magic number: for (int i = 18; i > blTreeCodes; i--)              {                  if (blTree.length[BL_ORDER[i]] > 0)                  {                      blTreeCodes = i + 1;                  }              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FlushBlock,The following statement contains a magic number: int opt_len = 14 + blTreeCodes * 3 + blTree.GetEncodedLength() +                  literalTree.GetEncodedLength() + distTree.GetEncodedLength() +                  extra_bits;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FlushBlock,The following statement contains a magic number: int opt_len = 14 + blTreeCodes * 3 + blTree.GetEncodedLength() +                  literalTree.GetEncodedLength() + distTree.GetEncodedLength() +                  extra_bits;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3)              {                  FlushStoredBlock(stored' storedOffset' storedLength' lastBlock);              }              else if (opt_len == static_len)              {                  pending.WriteBits((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);                  literalTree.SetStaticCodes(staticLCodes' staticLLength);                  distTree.SetStaticCodes(staticDCodes' staticDLength);                  CompressBlock();                  Reset();              }              else              {                  pending.WriteBits((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);                  SendAllTrees(blTreeCodes);                  CompressBlock();                  Reset();              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3)              {                  FlushStoredBlock(stored' storedOffset' storedLength' lastBlock);              }              else if (opt_len == static_len)              {                  pending.WriteBits((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);                  literalTree.SetStaticCodes(staticLCodes' staticLLength);                  distTree.SetStaticCodes(staticDCodes' staticDLength);                  CompressBlock();                  Reset();              }              else              {                  pending.WriteBits((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);                  SendAllTrees(blTreeCodes);                  CompressBlock();                  Reset();              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3)              {                  FlushStoredBlock(stored' storedOffset' storedLength' lastBlock);              }              else if (opt_len == static_len)              {                  pending.WriteBits((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);                  literalTree.SetStaticCodes(staticLCodes' staticLLength);                  distTree.SetStaticCodes(staticDCodes' staticDLength);                  CompressBlock();                  Reset();              }              else              {                  pending.WriteBits((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);                  SendAllTrees(blTreeCodes);                  CompressBlock();                  Reset();              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3)              {                  FlushStoredBlock(stored' storedOffset' storedLength' lastBlock);              }              else if (opt_len == static_len)              {                  pending.WriteBits((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);                  literalTree.SetStaticCodes(staticLCodes' staticLLength);                  distTree.SetStaticCodes(staticDCodes' staticDLength);                  CompressBlock();                  Reset();              }              else              {                  pending.WriteBits((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);                  SendAllTrees(blTreeCodes);                  CompressBlock();                  Reset();              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,TallyDist,The following statement contains a magic number: l_buf[last_lit++] = (byte)(length - 3);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,TallyDist,The following statement contains a magic number: int lc = Lcode(length - 3);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285)              {                  extra_bits += (lc - 261) / 4;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285)              {                  extra_bits += (lc - 261) / 4;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285)              {                  extra_bits += (lc - 261) / 4;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285)              {                  extra_bits += (lc - 261) / 4;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,TallyDist,The following statement contains a magic number: if (dc >= 4)              {                  extra_bits += dc / 2 - 1;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,TallyDist,The following statement contains a magic number: if (dc >= 4)              {                  extra_bits += dc / 2 - 1;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse[toReverse & 0xF] << 12 |                              bit4Reverse[(toReverse >> 4) & 0xF] << 8 |                              bit4Reverse[(toReverse >> 8) & 0xF] << 4 |                              bit4Reverse[toReverse >> 12]);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse[toReverse & 0xF] << 12 |                              bit4Reverse[(toReverse >> 4) & 0xF] << 8 |                              bit4Reverse[(toReverse >> 8) & 0xF] << 4 |                              bit4Reverse[toReverse >> 12]);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse[toReverse & 0xF] << 12 |                              bit4Reverse[(toReverse >> 4) & 0xF] << 8 |                              bit4Reverse[(toReverse >> 8) & 0xF] << 4 |                              bit4Reverse[toReverse >> 12]);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse[toReverse & 0xF] << 12 |                              bit4Reverse[(toReverse >> 4) & 0xF] << 8 |                              bit4Reverse[(toReverse >> 8) & 0xF] << 4 |                              bit4Reverse[toReverse >> 12]);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse[toReverse & 0xF] << 12 |                              bit4Reverse[(toReverse >> 4) & 0xF] << 8 |                              bit4Reverse[(toReverse >> 8) & 0xF] << 4 |                              bit4Reverse[toReverse >> 12]);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse[toReverse & 0xF] << 12 |                              bit4Reverse[(toReverse >> 4) & 0xF] << 8 |                              bit4Reverse[(toReverse >> 8) & 0xF] << 4 |                              bit4Reverse[toReverse >> 12]);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Lcode,The following statement contains a magic number: if (length == 255)              {                  return 285;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Lcode,The following statement contains a magic number: if (length == 255)              {                  return 285;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Lcode,The following statement contains a magic number: int code = 257;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Lcode,The following statement contains a magic number: while (length >= 8)              {                  code += 4;                  length >>= 1;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Lcode,The following statement contains a magic number: while (length >= 8)              {                  code += 4;                  length >>= 1;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Dcode,The following statement contains a magic number: while (distance >= 4)              {                  code += 2;                  distance >>= 1;              }
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Dcode,The following statement contains a magic number: while (distance >= 4)              {                  code += 2;                  distance >>= 1;              }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildCodes,The following statement contains a magic number: for (int bits = 0; bits < maxLength; bits++)                  {                      nextCode[bits] = code;                      code += bl_counts[bits] << (15 - bits);                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildCodes,The following statement contains a magic number: for (int i = 0; i < numCodes; i++)                  {                      int bits = length[i];                      if (bits > 0)                      {                            codes[i] = BitReverse(nextCode[bits - 1]);                          nextCode[bits - 1] += 1 << (16 - bits);                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int n = 0; n < numSymbols; n++)                  {                      int freq = freqs[n];                      if (freq != 0)                      {                          int pos = heapLen++;                          int ppos;                          while (pos > 0 && freqs[heap[ppos = (pos - 1) / 2]] > freq)                          {                              heap[pos] = heap[ppos];                              pos = ppos;                          }                          heap[pos] = n;                            maxCode = n;                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: while (heapLen < 2)                  {                      int node = maxCode < 2 ? ++maxCode : 0;                      heap[heapLen++] = node;                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: while (heapLen < 2)                  {                      int node = maxCode < 2 ? ++maxCode : 0;                      heap[heapLen++] = node;                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: int[] childs = new int[4 * heapLen - 2];
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: int[] childs = new int[4 * heapLen - 2];
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: int[] values = new int[2 * heapLen - 1];
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < heapLen; i++)                  {                      int node = heap[i];                      childs[2 * i] = node;                      childs[2 * i + 1] = -1;                      values[i] = freqs[node] << 8;                      heap[i] = i;                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < heapLen; i++)                  {                      int node = heap[i];                      childs[2 * i] = node;                      childs[2 * i + 1] = -1;                      values[i] = freqs[node] << 8;                      heap[i] = i;                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < heapLen; i++)                  {                      int node = heap[i];                      childs[2 * i] = node;                      childs[2 * i + 1] = -1;                      values[i] = freqs[node] << 8;                      heap[i] = i;                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: do                  {                      int first = heap[0];                      int last = heap[--heapLen];                        int ppos = 0;                      int path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = path * 2 + 1;                      }                        int lastVal = values[last];                      while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                          int second = heap[0];                        last = numNodes++;                      childs[2 * last] = first;                      childs[2 * last + 1] = second;                      int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);                      values[last] = lastVal = values[first] + values[second] - mindepth + 1;                        ppos = 0;                      path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = ppos * 2 + 1;                      }                        while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                  } while (heapLen > 1);
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: do                  {                      int first = heap[0];                      int last = heap[--heapLen];                        int ppos = 0;                      int path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = path * 2 + 1;                      }                        int lastVal = values[last];                      while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                          int second = heap[0];                        last = numNodes++;                      childs[2 * last] = first;                      childs[2 * last + 1] = second;                      int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);                      values[last] = lastVal = values[first] + values[second] - mindepth + 1;                        ppos = 0;                      path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = ppos * 2 + 1;                      }                        while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                  } while (heapLen > 1);
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: do                  {                      int first = heap[0];                      int last = heap[--heapLen];                        int ppos = 0;                      int path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = path * 2 + 1;                      }                        int lastVal = values[last];                      while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                          int second = heap[0];                        last = numNodes++;                      childs[2 * last] = first;                      childs[2 * last + 1] = second;                      int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);                      values[last] = lastVal = values[first] + values[second] - mindepth + 1;                        ppos = 0;                      path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = ppos * 2 + 1;                      }                        while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                  } while (heapLen > 1);
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: do                  {                      int first = heap[0];                      int last = heap[--heapLen];                        int ppos = 0;                      int path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = path * 2 + 1;                      }                        int lastVal = values[last];                      while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                          int second = heap[0];                        last = numNodes++;                      childs[2 * last] = first;                      childs[2 * last + 1] = second;                      int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);                      values[last] = lastVal = values[first] + values[second] - mindepth + 1;                        ppos = 0;                      path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = ppos * 2 + 1;                      }                        while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                  } while (heapLen > 1);
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: do                  {                      int first = heap[0];                      int last = heap[--heapLen];                        int ppos = 0;                      int path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = path * 2 + 1;                      }                        int lastVal = values[last];                      while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                          int second = heap[0];                        last = numNodes++;                      childs[2 * last] = first;                      childs[2 * last + 1] = second;                      int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);                      values[last] = lastVal = values[first] + values[second] - mindepth + 1;                        ppos = 0;                      path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = ppos * 2 + 1;                      }                        while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                  } while (heapLen > 1);
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: do                  {                      int first = heap[0];                      int last = heap[--heapLen];                        int ppos = 0;                      int path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = path * 2 + 1;                      }                        int lastVal = values[last];                      while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                          int second = heap[0];                        last = numNodes++;                      childs[2 * last] = first;                      childs[2 * last + 1] = second;                      int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);                      values[last] = lastVal = values[first] + values[second] - mindepth + 1;                        ppos = 0;                      path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = ppos * 2 + 1;                      }                        while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                  } while (heapLen > 1);
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: if (heap[0] != childs.Length / 2 - 1)                  {                      throw new Exception("Heap invariant violated");                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.freqs[nextlen]++;                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          blTree.freqs[curlen] += (short)count;                      }                      else if (curlen != 0)                      {                          blTree.freqs[REP_3_6]++;                      }                      else if (count <= 10)                      {                          blTree.freqs[REP_3_10]++;                      }                      else                      {                          blTree.freqs[REP_11_138]++;                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.freqs[nextlen]++;                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          blTree.freqs[curlen] += (short)count;                      }                      else if (curlen != 0)                      {                          blTree.freqs[REP_3_6]++;                      }                      else if (count <= 10)                      {                          blTree.freqs[REP_3_10]++;                      }                      else                      {                          blTree.freqs[REP_11_138]++;                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.freqs[nextlen]++;                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          blTree.freqs[curlen] += (short)count;                      }                      else if (curlen != 0)                      {                          blTree.freqs[REP_3_6]++;                      }                      else if (count <= 10)                      {                          blTree.freqs[REP_3_10]++;                      }                      else                      {                          blTree.freqs[REP_11_138]++;                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.freqs[nextlen]++;                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          blTree.freqs[curlen] += (short)count;                      }                      else if (curlen != 0)                      {                          blTree.freqs[REP_3_6]++;                      }                      else if (count <= 10)                      {                          blTree.freqs[REP_3_10]++;                      }                      else                      {                          blTree.freqs[REP_11_138]++;                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.freqs[nextlen]++;                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          blTree.freqs[curlen] += (short)count;                      }                      else if (curlen != 0)                      {                          blTree.freqs[REP_3_6]++;                      }                      else if (count <= 10)                      {                          blTree.freqs[REP_3_10]++;                      }                      else                      {                          blTree.freqs[REP_11_138]++;                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildLength,The following statement contains a magic number: int numNodes = childs.Length / 2;
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildLength,The following statement contains a magic number: int numLeafs = (numNodes + 1) / 2;
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildLength,The following statement contains a magic number: for (int i = numNodes - 1; i >= 0; i--)                  {                      if (childs[2 * i + 1] != -1)                      {                          int bitLength = lengths[i] + 1;                          if (bitLength > maxLength)                          {                              bitLength = maxLength;                              overflow++;                          }                          lengths[childs[2 * i]] = lengths[childs[2 * i + 1]] = bitLength;                      }                      else                      {                          int bitLength = lengths[i];                          bl_counts[bitLength - 1]++;                          this.length[childs[2 * i]] = (byte)lengths[i];                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildLength,The following statement contains a magic number: for (int i = numNodes - 1; i >= 0; i--)                  {                      if (childs[2 * i + 1] != -1)                      {                          int bitLength = lengths[i] + 1;                          if (bitLength > maxLength)                          {                              bitLength = maxLength;                              overflow++;                          }                          lengths[childs[2 * i]] = lengths[childs[2 * i + 1]] = bitLength;                      }                      else                      {                          int bitLength = lengths[i];                          bl_counts[bitLength - 1]++;                          this.length[childs[2 * i]] = (byte)lengths[i];                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildLength,The following statement contains a magic number: for (int i = numNodes - 1; i >= 0; i--)                  {                      if (childs[2 * i + 1] != -1)                      {                          int bitLength = lengths[i] + 1;                          if (bitLength > maxLength)                          {                              bitLength = maxLength;                              overflow++;                          }                          lengths[childs[2 * i]] = lengths[childs[2 * i + 1]] = bitLength;                      }                      else                      {                          int bitLength = lengths[i];                          bl_counts[bitLength - 1]++;                          this.length[childs[2 * i]] = (byte)lengths[i];                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildLength,The following statement contains a magic number: for (int i = numNodes - 1; i >= 0; i--)                  {                      if (childs[2 * i + 1] != -1)                      {                          int bitLength = lengths[i] + 1;                          if (bitLength > maxLength)                          {                              bitLength = maxLength;                              overflow++;                          }                          lengths[childs[2 * i]] = lengths[childs[2 * i + 1]] = bitLength;                      }                      else                      {                          int bitLength = lengths[i];                          bl_counts[bitLength - 1]++;                          this.length[childs[2 * i]] = (byte)lengths[i];                      }                  }
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildLength,The following statement contains a magic number: bl_counts[maxLength - 2] -= overflow;
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildLength,The following statement contains a magic number: int nodePtr = 2 * numLeafs;
Magic Number,Orvid.Compression.Streams,Tree,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildLength,The following statement contains a magic number: for (int bits = maxLength; bits != 0; bits--)                  {                      int n = bl_counts[bits - 1];                      while (n > 0)                      {                          int childPtr = 2 * childs[nodePtr++];                          if (childs[childPtr + 1] == -1)                          {                              length[childs[childPtr]] = (byte)bits;                              n--;                          }                      }                  }
Magic Number,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterEngine,The following statement contains a magic number: window = new byte[2 * WSIZE];
Magic Number,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SetDictionary,The following statement contains a magic number: strstart += 2;
Magic Number,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SetLevel,The following statement contains a magic number: if ((level < 0) || (level > 9))              {                  throw new ArgumentOutOfRangeException("level");              }
Magic Number,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FillWindow,The following statement contains a magic number: while (lookahead < DeflaterConstants.MIN_LOOKAHEAD && inputOff < inputEnd)              {                  int more = 2 * WSIZE - lookahead - strstart;                    if (more > inputEnd - inputOff)                  {                      more = inputEnd - inputOff;                  }                    System.Array.Copy(inputBuf' inputOff' window' strstart + lookahead' more);                  adler.Update(inputBuf' inputOff' more);                    inputOff += more;                  totalIn += more;                  lookahead += more;              }
Magic Number,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FindLongestMatch,The following statement contains a magic number: if (best_len >= this.goodLength)              {                  chainLength >>= 2;              }
Magic Number,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FindLongestMatch,The following statement contains a magic number: do              {                    if (window[curMatch + best_len] != scan_end ||                      window[curMatch + best_len - 1] != scan_end1 ||                      window[curMatch] != window[scan] ||                      window[curMatch + 1] != window[scan + 1])                  {                      continue;                  }                    match = curMatch + 2;                  scan += 2;                    /* We check for insufficient lookahead only every 8th comparison;                  * the 256th check will be made at strstart + 258.                  */                  while (                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      (scan < strend))                  {                      // Do nothing                  }                    if (scan > best_end)                  {                      matchStart = curMatch;                      best_end = scan;                      best_len = scan - strstart;                        if (best_len >= niceLength)                      {                          break;                      }                        scan_end1 = window[best_end - 1];                      scan_end = window[best_end];                  }                  scan = strstart;              } while ((curMatch = (prev[curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);
Magic Number,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FindLongestMatch,The following statement contains a magic number: do              {                    if (window[curMatch + best_len] != scan_end ||                      window[curMatch + best_len - 1] != scan_end1 ||                      window[curMatch] != window[scan] ||                      window[curMatch + 1] != window[scan + 1])                  {                      continue;                  }                    match = curMatch + 2;                  scan += 2;                    /* We check for insufficient lookahead only every 8th comparison;                  * the 256th check will be made at strstart + 258.                  */                  while (                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      (scan < strend))                  {                      // Do nothing                  }                    if (scan > best_end)                  {                      matchStart = curMatch;                      best_end = scan;                      best_len = scan - strstart;                        if (best_len >= niceLength)                      {                          break;                      }                        scan_end1 = window[best_end - 1];                      scan_end = window[best_end];                  }                  scan = strstart;              } while ((curMatch = (prev[curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);
Magic Number,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateFast,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush)              {                  if (lookahead == 0)                  {                      // We are flushing everything                      huffman.FlushBlock(window' blockStart' strstart - blockStart' finish);                      blockStart = strstart;                      return false;                  }                    if (strstart > 2 * WSIZE - MIN_LOOKAHEAD)                  {                      /* slide window' as FindLongestMatch needs this.                       * This should only happen when flushing and the window                       * is almost full.                       */                      SlideWindow();                  }                    int hashHead;                  if (lookahead >= MIN_MATCH &&                      (hashHead = InsertString()) != 0 &&                      strategy != DeflateStrategy.HuffmanOnly &&                      strstart - hashHead <= MAX_DIST &&                      FindLongestMatch(hashHead))                  {                      // longestMatch sets matchStart and matchLen                        bool full = huffman.TallyDist(strstart - matchStart' matchLen);                        lookahead -= matchLen;                      if (matchLen <= max_lazy && lookahead >= MIN_MATCH)                      {                          while (--matchLen > 0)                          {                              ++strstart;                              InsertString();                          }                          ++strstart;                      }                      else                      {                          strstart += matchLen;                          if (lookahead >= MIN_MATCH - 1)                          {                              UpdateHash();                          }                      }                      matchLen = MIN_MATCH - 1;                      if (!full)                      {                          continue;                      }                  }                  else                  {                      // No match found                      huffman.TallyLit(window[strstart] & 0xff);                      ++strstart;                      --lookahead;                  }                    if (huffman.IsFull())                  {                      bool lastBlock = finish && (lookahead == 0);                      huffman.FlushBlock(window' blockStart' strstart - blockStart' lastBlock);                      blockStart = strstart;                      return !lastBlock;                  }              }
Magic Number,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush)              {                  if (lookahead == 0)                  {                      if (prevAvailable)                      {                          huffman.TallyLit(window[strstart - 1] & 0xff);                      }                      prevAvailable = false;                        // We are flushing everything                      huffman.FlushBlock(window' blockStart' strstart - blockStart' finish);                      blockStart = strstart;                      return false;                  }                    if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD)                  {                      /* slide window' as FindLongestMatch needs this.                       * This should only happen when flushing and the window                       * is almost full.                       */                      SlideWindow();                  }                    int prevMatch = matchStart;                  int prevLen = matchLen;                  if (lookahead >= MIN_MATCH)                  {                        int hashHead = InsertString();                        if (strategy != DeflateStrategy.HuffmanOnly &&                          hashHead != 0 &&                          strstart - hashHead <= MAX_DIST &&                          FindLongestMatch(hashHead))                      {                            // longestMatch sets matchStart and matchLen                            // Discard match if too small and too far away                          if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar)))                          {                              matchLen = MIN_MATCH - 1;                          }                      }                  }                    // previous match was better                  if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen))                  {                      huffman.TallyDist(strstart - 1 - prevMatch' prevLen);                      prevLen -= 2;                      do                      {                          strstart++;                          lookahead--;                          if (lookahead >= MIN_MATCH)                          {                              InsertString();                          }                      } while (--prevLen > 0);                        strstart++;                      lookahead--;                      prevAvailable = false;                      matchLen = MIN_MATCH - 1;                  }                  else                  {                      if (prevAvailable)                      {                          huffman.TallyLit(window[strstart - 1] & 0xff);                      }                      prevAvailable = true;                      strstart++;                      lookahead--;                  }                    if (huffman.IsFull())                  {                      int len = strstart - blockStart;                      if (prevAvailable)                      {                          len--;                      }                      bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);                      huffman.FlushBlock(window' blockStart' len' lastBlock);                      blockStart += len;                      return !lastBlock;                  }              }
Magic Number,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush)              {                  if (lookahead == 0)                  {                      if (prevAvailable)                      {                          huffman.TallyLit(window[strstart - 1] & 0xff);                      }                      prevAvailable = false;                        // We are flushing everything                      huffman.FlushBlock(window' blockStart' strstart - blockStart' finish);                      blockStart = strstart;                      return false;                  }                    if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD)                  {                      /* slide window' as FindLongestMatch needs this.                       * This should only happen when flushing and the window                       * is almost full.                       */                      SlideWindow();                  }                    int prevMatch = matchStart;                  int prevLen = matchLen;                  if (lookahead >= MIN_MATCH)                  {                        int hashHead = InsertString();                        if (strategy != DeflateStrategy.HuffmanOnly &&                          hashHead != 0 &&                          strstart - hashHead <= MAX_DIST &&                          FindLongestMatch(hashHead))                      {                            // longestMatch sets matchStart and matchLen                            // Discard match if too small and too far away                          if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar)))                          {                              matchLen = MIN_MATCH - 1;                          }                      }                  }                    // previous match was better                  if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen))                  {                      huffman.TallyDist(strstart - 1 - prevMatch' prevLen);                      prevLen -= 2;                      do                      {                          strstart++;                          lookahead--;                          if (lookahead >= MIN_MATCH)                          {                              InsertString();                          }                      } while (--prevLen > 0);                        strstart++;                      lookahead--;                      prevAvailable = false;                      matchLen = MIN_MATCH - 1;                  }                  else                  {                      if (prevAvailable)                      {                          huffman.TallyLit(window[strstart - 1] & 0xff);                      }                      prevAvailable = true;                      strstart++;                      lookahead--;                  }                    if (huffman.IsFull())                  {                      int len = strstart - blockStart;                      if (prevAvailable)                      {                          len--;                      }                      bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);                      huffman.FlushBlock(window' blockStart' len' lastBlock);                      blockStart += len;                      return !lastBlock;                  }              }
Magic Number,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush)              {                  if (lookahead == 0)                  {                      if (prevAvailable)                      {                          huffman.TallyLit(window[strstart - 1] & 0xff);                      }                      prevAvailable = false;                        // We are flushing everything                      huffman.FlushBlock(window' blockStart' strstart - blockStart' finish);                      blockStart = strstart;                      return false;                  }                    if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD)                  {                      /* slide window' as FindLongestMatch needs this.                       * This should only happen when flushing and the window                       * is almost full.                       */                      SlideWindow();                  }                    int prevMatch = matchStart;                  int prevLen = matchLen;                  if (lookahead >= MIN_MATCH)                  {                        int hashHead = InsertString();                        if (strategy != DeflateStrategy.HuffmanOnly &&                          hashHead != 0 &&                          strstart - hashHead <= MAX_DIST &&                          FindLongestMatch(hashHead))                      {                            // longestMatch sets matchStart and matchLen                            // Discard match if too small and too far away                          if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar)))                          {                              matchLen = MIN_MATCH - 1;                          }                      }                  }                    // previous match was better                  if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen))                  {                      huffman.TallyDist(strstart - 1 - prevMatch' prevLen);                      prevLen -= 2;                      do                      {                          strstart++;                          lookahead--;                          if (lookahead >= MIN_MATCH)                          {                              InsertString();                          }                      } while (--prevLen > 0);                        strstart++;                      lookahead--;                      prevAvailable = false;                      matchLen = MIN_MATCH - 1;                  }                  else                  {                      if (prevAvailable)                      {                          huffman.TallyLit(window[strstart - 1] & 0xff);                      }                      prevAvailable = true;                      strstart++;                      lookahead--;                  }                    if (huffman.IsFull())                  {                      int len = strstart - blockStart;                      if (prevAvailable)                      {                          len--;                      }                      bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);                      huffman.FlushBlock(window' blockStart' len' lastBlock);                      blockStart += len;                      return !lastBlock;                  }              }
Magic Number,Orvid.Compression.Streams,Deflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflater,The following statement contains a magic number: if (level == DEFAULT_COMPRESSION)              {                  level = 6;              }              else if (level < NO_COMPRESSION || level > BEST_COMPRESSION)              {                  throw new ArgumentOutOfRangeException("level");              }
Magic Number,Orvid.Compression.Streams,Deflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SetLevel,The following statement contains a magic number: if (level == DEFAULT_COMPRESSION)              {                  level = 6;              }              else if (level < NO_COMPRESSION || level > BEST_COMPRESSION)              {                  throw new ArgumentOutOfRangeException("level");              }
Magic Number,Orvid.Compression.Streams,Deflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE)              {                  // output header                  int header = (DEFLATED +                      ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;                  int level_flags = (level - 1) >> 1;                  if (level_flags < 0 || level_flags > 3)                  {                      level_flags = 3;                  }                  header |= level_flags << 6;                  if ((state & IS_SETDICT) != 0)                  {                      // Dictionary was set                      header |= DeflaterConstants.PRESET_DICT;                  }                  header += 31 - (header % 31);                    pending.WriteShortMSB(header);                  if ((state & IS_SETDICT) != 0)                  {                      int chksum = engine.Adler;                      engine.ResetAdler();                      pending.WriteShortMSB(chksum >> 16);                      pending.WriteShortMSB(chksum & 0xffff);                  }                    state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));              }
Magic Number,Orvid.Compression.Streams,Deflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE)              {                  // output header                  int header = (DEFLATED +                      ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;                  int level_flags = (level - 1) >> 1;                  if (level_flags < 0 || level_flags > 3)                  {                      level_flags = 3;                  }                  header |= level_flags << 6;                  if ((state & IS_SETDICT) != 0)                  {                      // Dictionary was set                      header |= DeflaterConstants.PRESET_DICT;                  }                  header += 31 - (header % 31);                    pending.WriteShortMSB(header);                  if ((state & IS_SETDICT) != 0)                  {                      int chksum = engine.Adler;                      engine.ResetAdler();                      pending.WriteShortMSB(chksum >> 16);                      pending.WriteShortMSB(chksum & 0xffff);                  }                    state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));              }
Magic Number,Orvid.Compression.Streams,Deflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE)              {                  // output header                  int header = (DEFLATED +                      ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;                  int level_flags = (level - 1) >> 1;                  if (level_flags < 0 || level_flags > 3)                  {                      level_flags = 3;                  }                  header |= level_flags << 6;                  if ((state & IS_SETDICT) != 0)                  {                      // Dictionary was set                      header |= DeflaterConstants.PRESET_DICT;                  }                  header += 31 - (header % 31);                    pending.WriteShortMSB(header);                  if ((state & IS_SETDICT) != 0)                  {                      int chksum = engine.Adler;                      engine.ResetAdler();                      pending.WriteShortMSB(chksum >> 16);                      pending.WriteShortMSB(chksum & 0xffff);                  }                    state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));              }
Magic Number,Orvid.Compression.Streams,Deflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE)              {                  // output header                  int header = (DEFLATED +                      ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;                  int level_flags = (level - 1) >> 1;                  if (level_flags < 0 || level_flags > 3)                  {                      level_flags = 3;                  }                  header |= level_flags << 6;                  if ((state & IS_SETDICT) != 0)                  {                      // Dictionary was set                      header |= DeflaterConstants.PRESET_DICT;                  }                  header += 31 - (header % 31);                    pending.WriteShortMSB(header);                  if ((state & IS_SETDICT) != 0)                  {                      int chksum = engine.Adler;                      engine.ResetAdler();                      pending.WriteShortMSB(chksum >> 16);                      pending.WriteShortMSB(chksum & 0xffff);                  }                    state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));              }
Magic Number,Orvid.Compression.Streams,Deflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE)              {                  // output header                  int header = (DEFLATED +                      ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;                  int level_flags = (level - 1) >> 1;                  if (level_flags < 0 || level_flags > 3)                  {                      level_flags = 3;                  }                  header |= level_flags << 6;                  if ((state & IS_SETDICT) != 0)                  {                      // Dictionary was set                      header |= DeflaterConstants.PRESET_DICT;                  }                  header += 31 - (header % 31);                    pending.WriteShortMSB(header);                  if ((state & IS_SETDICT) != 0)                  {                      int chksum = engine.Adler;                      engine.ResetAdler();                      pending.WriteShortMSB(chksum >> 16);                      pending.WriteShortMSB(chksum & 0xffff);                  }                    state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));              }
Magic Number,Orvid.Compression.Streams,Deflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE)              {                  // output header                  int header = (DEFLATED +                      ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;                  int level_flags = (level - 1) >> 1;                  if (level_flags < 0 || level_flags > 3)                  {                      level_flags = 3;                  }                  header |= level_flags << 6;                  if ((state & IS_SETDICT) != 0)                  {                      // Dictionary was set                      header |= DeflaterConstants.PRESET_DICT;                  }                  header += 31 - (header % 31);                    pending.WriteShortMSB(header);                  if ((state & IS_SETDICT) != 0)                  {                      int chksum = engine.Adler;                      engine.ResetAdler();                      pending.WriteShortMSB(chksum >> 16);                      pending.WriteShortMSB(chksum & 0xffff);                  }                    state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));              }
Magic Number,Orvid.Compression.Streams,Deflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE)              {                  // output header                  int header = (DEFLATED +                      ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;                  int level_flags = (level - 1) >> 1;                  if (level_flags < 0 || level_flags > 3)                  {                      level_flags = 3;                  }                  header |= level_flags << 6;                  if ((state & IS_SETDICT) != 0)                  {                      // Dictionary was set                      header |= DeflaterConstants.PRESET_DICT;                  }                  header += 31 - (header % 31);                    pending.WriteShortMSB(header);                  if ((state & IS_SETDICT) != 0)                  {                      int chksum = engine.Adler;                      engine.ResetAdler();                      pending.WriteShortMSB(chksum >> 16);                      pending.WriteShortMSB(chksum & 0xffff);                  }                    state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));              }
Magic Number,Orvid.Compression.Streams,Deflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE)              {                  // output header                  int header = (DEFLATED +                      ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;                  int level_flags = (level - 1) >> 1;                  if (level_flags < 0 || level_flags > 3)                  {                      level_flags = 3;                  }                  header |= level_flags << 6;                  if ((state & IS_SETDICT) != 0)                  {                      // Dictionary was set                      header |= DeflaterConstants.PRESET_DICT;                  }                  header += 31 - (header % 31);                    pending.WriteShortMSB(header);                  if ((state & IS_SETDICT) != 0)                  {                      int chksum = engine.Adler;                      engine.ResetAdler();                      pending.WriteShortMSB(chksum >> 16);                      pending.WriteShortMSB(chksum & 0xffff);                  }                    state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));              }
Magic Number,Orvid.Compression.Streams,Deflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE)              {                  // output header                  int header = (DEFLATED +                      ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;                  int level_flags = (level - 1) >> 1;                  if (level_flags < 0 || level_flags > 3)                  {                      level_flags = 3;                  }                  header |= level_flags << 6;                  if ((state & IS_SETDICT) != 0)                  {                      // Dictionary was set                      header |= DeflaterConstants.PRESET_DICT;                  }                  header += 31 - (header % 31);                    pending.WriteShortMSB(header);                  if ((state & IS_SETDICT) != 0)                  {                      int chksum = engine.Adler;                      engine.ResetAdler();                      pending.WriteShortMSB(chksum >> 16);                      pending.WriteShortMSB(chksum & 0xffff);                  }                    state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));              }
Magic Number,Orvid.Compression.Streams,Deflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: for (; ; )              {                  int count = pending.Flush(output' offset' length);                  offset += count;                  totalOut += count;                  length -= count;                    if (length == 0 || state == FINISHED_STATE)                  {                      break;                  }                    if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0))                  {                      if (state == BUSY_STATE)                      {                          // We need more input now                          return origLength - length;                      }                      else if (state == FLUSHING_STATE)                      {                          if (level != NO_COMPRESSION)                          {                              /* We have to supply some lookahead.  8 bit lookahead                               * is needed by the zlib inflater' and we must fill                               * the next byte' so that all bits are flushed.                               */                              int neededbits = 8 + ((-pending.BitCount) & 7);                              while (neededbits > 0)                              {                                  /* write a static tree block consisting solely of                                   * an EOF:                                   */                                  pending.WriteBits(2' 10);                                  neededbits -= 10;                              }                          }                          state = BUSY_STATE;                      }                      else if (state == FINISHING_STATE)                      {                          pending.AlignToByte();                            // Compressed data is complete.  Write footer information if required.                          if (!noZlibHeaderOrFooter)                          {                              int adler = engine.Adler;                              pending.WriteShortMSB(adler >> 16);                              pending.WriteShortMSB(adler & 0xffff);                          }                          state = FINISHED_STATE;                      }                  }              }
Magic Number,Orvid.Compression.Streams,Deflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: for (; ; )              {                  int count = pending.Flush(output' offset' length);                  offset += count;                  totalOut += count;                  length -= count;                    if (length == 0 || state == FINISHED_STATE)                  {                      break;                  }                    if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0))                  {                      if (state == BUSY_STATE)                      {                          // We need more input now                          return origLength - length;                      }                      else if (state == FLUSHING_STATE)                      {                          if (level != NO_COMPRESSION)                          {                              /* We have to supply some lookahead.  8 bit lookahead                               * is needed by the zlib inflater' and we must fill                               * the next byte' so that all bits are flushed.                               */                              int neededbits = 8 + ((-pending.BitCount) & 7);                              while (neededbits > 0)                              {                                  /* write a static tree block consisting solely of                                   * an EOF:                                   */                                  pending.WriteBits(2' 10);                                  neededbits -= 10;                              }                          }                          state = BUSY_STATE;                      }                      else if (state == FINISHING_STATE)                      {                          pending.AlignToByte();                            // Compressed data is complete.  Write footer information if required.                          if (!noZlibHeaderOrFooter)                          {                              int adler = engine.Adler;                              pending.WriteShortMSB(adler >> 16);                              pending.WriteShortMSB(adler & 0xffff);                          }                          state = FINISHED_STATE;                      }                  }              }
Magic Number,Orvid.Compression.Streams,Deflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: for (; ; )              {                  int count = pending.Flush(output' offset' length);                  offset += count;                  totalOut += count;                  length -= count;                    if (length == 0 || state == FINISHED_STATE)                  {                      break;                  }                    if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0))                  {                      if (state == BUSY_STATE)                      {                          // We need more input now                          return origLength - length;                      }                      else if (state == FLUSHING_STATE)                      {                          if (level != NO_COMPRESSION)                          {                              /* We have to supply some lookahead.  8 bit lookahead                               * is needed by the zlib inflater' and we must fill                               * the next byte' so that all bits are flushed.                               */                              int neededbits = 8 + ((-pending.BitCount) & 7);                              while (neededbits > 0)                              {                                  /* write a static tree block consisting solely of                                   * an EOF:                                   */                                  pending.WriteBits(2' 10);                                  neededbits -= 10;                              }                          }                          state = BUSY_STATE;                      }                      else if (state == FINISHING_STATE)                      {                          pending.AlignToByte();                            // Compressed data is complete.  Write footer information if required.                          if (!noZlibHeaderOrFooter)                          {                              int adler = engine.Adler;                              pending.WriteShortMSB(adler >> 16);                              pending.WriteShortMSB(adler & 0xffff);                          }                          state = FINISHED_STATE;                      }                  }              }
Magic Number,Orvid.Compression.Streams,Deflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: for (; ; )              {                  int count = pending.Flush(output' offset' length);                  offset += count;                  totalOut += count;                  length -= count;                    if (length == 0 || state == FINISHED_STATE)                  {                      break;                  }                    if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0))                  {                      if (state == BUSY_STATE)                      {                          // We need more input now                          return origLength - length;                      }                      else if (state == FLUSHING_STATE)                      {                          if (level != NO_COMPRESSION)                          {                              /* We have to supply some lookahead.  8 bit lookahead                               * is needed by the zlib inflater' and we must fill                               * the next byte' so that all bits are flushed.                               */                              int neededbits = 8 + ((-pending.BitCount) & 7);                              while (neededbits > 0)                              {                                  /* write a static tree block consisting solely of                                   * an EOF:                                   */                                  pending.WriteBits(2' 10);                                  neededbits -= 10;                              }                          }                          state = BUSY_STATE;                      }                      else if (state == FINISHING_STATE)                      {                          pending.AlignToByte();                            // Compressed data is complete.  Write footer information if required.                          if (!noZlibHeaderOrFooter)                          {                              int adler = engine.Adler;                              pending.WriteShortMSB(adler >> 16);                              pending.WriteShortMSB(adler & 0xffff);                          }                          state = FINISHED_STATE;                      }                  }              }
Magic Number,Orvid.Compression.Streams,Deflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: for (; ; )              {                  int count = pending.Flush(output' offset' length);                  offset += count;                  totalOut += count;                  length -= count;                    if (length == 0 || state == FINISHED_STATE)                  {                      break;                  }                    if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0))                  {                      if (state == BUSY_STATE)                      {                          // We need more input now                          return origLength - length;                      }                      else if (state == FLUSHING_STATE)                      {                          if (level != NO_COMPRESSION)                          {                              /* We have to supply some lookahead.  8 bit lookahead                               * is needed by the zlib inflater' and we must fill                               * the next byte' so that all bits are flushed.                               */                              int neededbits = 8 + ((-pending.BitCount) & 7);                              while (neededbits > 0)                              {                                  /* write a static tree block consisting solely of                                   * an EOF:                                   */                                  pending.WriteBits(2' 10);                                  neededbits -= 10;                              }                          }                          state = BUSY_STATE;                      }                      else if (state == FINISHING_STATE)                      {                          pending.AlignToByte();                            // Compressed data is complete.  Write footer information if required.                          if (!noZlibHeaderOrFooter)                          {                              int adler = engine.Adler;                              pending.WriteShortMSB(adler >> 16);                              pending.WriteShortMSB(adler & 0xffff);                          }                          state = FINISHED_STATE;                      }                  }              }
Magic Number,Orvid.Compression.Streams,Deflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: for (; ; )              {                  int count = pending.Flush(output' offset' length);                  offset += count;                  totalOut += count;                  length -= count;                    if (length == 0 || state == FINISHED_STATE)                  {                      break;                  }                    if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0))                  {                      if (state == BUSY_STATE)                      {                          // We need more input now                          return origLength - length;                      }                      else if (state == FLUSHING_STATE)                      {                          if (level != NO_COMPRESSION)                          {                              /* We have to supply some lookahead.  8 bit lookahead                               * is needed by the zlib inflater' and we must fill                               * the next byte' so that all bits are flushed.                               */                              int neededbits = 8 + ((-pending.BitCount) & 7);                              while (neededbits > 0)                              {                                  /* write a static tree block consisting solely of                                   * an EOF:                                   */                                  pending.WriteBits(2' 10);                                  neededbits -= 10;                              }                          }                          state = BUSY_STATE;                      }                      else if (state == FINISHING_STATE)                      {                          pending.AlignToByte();                            // Compressed data is complete.  Write footer information if required.                          if (!noZlibHeaderOrFooter)                          {                              int adler = engine.Adler;                              pending.WriteShortMSB(adler >> 16);                              pending.WriteShortMSB(adler & 0xffff);                          }                          state = FINISHED_STATE;                      }                  }              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHeader,The following statement contains a magic number: int header = input.PeekBits(16);
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHeader,The following statement contains a magic number: input.DropBits(16);
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHeader,The following statement contains a magic number: if (header % 31 != 0)              {                  throw new Exception("Header checksum illegal");              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0f00) != (Deflater.DEFLATED << 8))              {                  throw new Exception("Compression Method unknown");              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0020) == 0)              { // Dictionary flag?                  mode = DECODE_BLOCKS;              }              else              {                  mode = DECODE_DICT;                  neededBits = 32;              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0)              {                  int dictByte = input.PeekBits(8);                  if (dictByte < 0)                  {                      return false;                  }                  input.DropBits(8);                  readAdler = (readAdler << 8) | dictByte;                  neededBits -= 8;              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0)              {                  int dictByte = input.PeekBits(8);                  if (dictByte < 0)                  {                      return false;                  }                  input.DropBits(8);                  readAdler = (readAdler << 8) | dictByte;                  neededBits -= 8;              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0)              {                  int dictByte = input.PeekBits(8);                  if (dictByte < 0)                  {                      return false;                  }                  input.DropBits(8);                  readAdler = (readAdler << 8) | dictByte;                  neededBits -= 8;              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0)              {                  int dictByte = input.PeekBits(8);                  if (dictByte < 0)                  {                      return false;                  }                  input.DropBits(8);                  readAdler = (readAdler << 8) | dictByte;                  neededBits -= 8;              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)              {                  int symbol;                  switch (mode)                  {                      case DECODE_HUFFMAN:                          // This is the inner loop so it is optimized a bit                          while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)                          {                              outputWindow.Write(symbol);                              if (--free < 258)                              {                                  return true;                              }                          }                            if (symbol < 257)                          {                              if (symbol < 0)                              {                                  return false;                              }                              else                              {                                  // symbol == 256: end of block                                  distTree = null;                                  litlenTree = null;                                  mode = DECODE_BLOCKS;                                  return true;                              }                          }                            try                          {                              repLength = CPLENS[symbol - 257];                              neededBits = CPLEXT[symbol - 257];                          }                          catch (Exception)                          {                              throw new Exception("Illegal rep length code");                          }                          goto case DECODE_HUFFMAN_LENBITS; // fall through                        case DECODE_HUFFMAN_LENBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_LENBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repLength += i;                          }                          mode = DECODE_HUFFMAN_DIST;                          goto case DECODE_HUFFMAN_DIST; // fall through                        case DECODE_HUFFMAN_DIST:                          symbol = distTree.GetSymbol(input);                          if (symbol < 0)                          {                              return false;                          }                            try                          {                              repDist = CPDIST[symbol];                              neededBits = CPDEXT[symbol];                          }                          catch (Exception)                          {                              throw new Exception("Illegal rep dist code");                          }                            goto case DECODE_HUFFMAN_DISTBITS; // fall through                        case DECODE_HUFFMAN_DISTBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_DISTBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repDist += i;                          }                            outputWindow.Repeat(repLength' repDist);                          free -= repLength;                          mode = DECODE_HUFFMAN;                          break;                        default:                          throw new Exception("Inflater unknown mode");                  }              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)              {                  int symbol;                  switch (mode)                  {                      case DECODE_HUFFMAN:                          // This is the inner loop so it is optimized a bit                          while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)                          {                              outputWindow.Write(symbol);                              if (--free < 258)                              {                                  return true;                              }                          }                            if (symbol < 257)                          {                              if (symbol < 0)                              {                                  return false;                              }                              else                              {                                  // symbol == 256: end of block                                  distTree = null;                                  litlenTree = null;                                  mode = DECODE_BLOCKS;                                  return true;                              }                          }                            try                          {                              repLength = CPLENS[symbol - 257];                              neededBits = CPLEXT[symbol - 257];                          }                          catch (Exception)                          {                              throw new Exception("Illegal rep length code");                          }                          goto case DECODE_HUFFMAN_LENBITS; // fall through                        case DECODE_HUFFMAN_LENBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_LENBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repLength += i;                          }                          mode = DECODE_HUFFMAN_DIST;                          goto case DECODE_HUFFMAN_DIST; // fall through                        case DECODE_HUFFMAN_DIST:                          symbol = distTree.GetSymbol(input);                          if (symbol < 0)                          {                              return false;                          }                            try                          {                              repDist = CPDIST[symbol];                              neededBits = CPDEXT[symbol];                          }                          catch (Exception)                          {                              throw new Exception("Illegal rep dist code");                          }                            goto case DECODE_HUFFMAN_DISTBITS; // fall through                        case DECODE_HUFFMAN_DISTBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_DISTBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repDist += i;                          }                            outputWindow.Repeat(repLength' repDist);                          free -= repLength;                          mode = DECODE_HUFFMAN;                          break;                        default:                          throw new Exception("Inflater unknown mode");                  }              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)              {                  int symbol;                  switch (mode)                  {                      case DECODE_HUFFMAN:                          // This is the inner loop so it is optimized a bit                          while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)                          {                              outputWindow.Write(symbol);                              if (--free < 258)                              {                                  return true;                              }                          }                            if (symbol < 257)                          {                              if (symbol < 0)                              {                                  return false;                              }                              else                              {                                  // symbol == 256: end of block                                  distTree = null;                                  litlenTree = null;                                  mode = DECODE_BLOCKS;                                  return true;                              }                          }                            try                          {                              repLength = CPLENS[symbol - 257];                              neededBits = CPLEXT[symbol - 257];                          }                          catch (Exception)                          {                              throw new Exception("Illegal rep length code");                          }                          goto case DECODE_HUFFMAN_LENBITS; // fall through                        case DECODE_HUFFMAN_LENBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_LENBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repLength += i;                          }                          mode = DECODE_HUFFMAN_DIST;                          goto case DECODE_HUFFMAN_DIST; // fall through                        case DECODE_HUFFMAN_DIST:                          symbol = distTree.GetSymbol(input);                          if (symbol < 0)                          {                              return false;                          }                            try                          {                              repDist = CPDIST[symbol];                              neededBits = CPDEXT[symbol];                          }                          catch (Exception)                          {                              throw new Exception("Illegal rep dist code");                          }                            goto case DECODE_HUFFMAN_DISTBITS; // fall through                        case DECODE_HUFFMAN_DISTBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_DISTBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repDist += i;                          }                            outputWindow.Repeat(repLength' repDist);                          free -= repLength;                          mode = DECODE_HUFFMAN;                          break;                        default:                          throw new Exception("Inflater unknown mode");                  }              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)              {                  int symbol;                  switch (mode)                  {                      case DECODE_HUFFMAN:                          // This is the inner loop so it is optimized a bit                          while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)                          {                              outputWindow.Write(symbol);                              if (--free < 258)                              {                                  return true;                              }                          }                            if (symbol < 257)                          {                              if (symbol < 0)                              {                                  return false;                              }                              else                              {                                  // symbol == 256: end of block                                  distTree = null;                                  litlenTree = null;                                  mode = DECODE_BLOCKS;                                  return true;                              }                          }                            try                          {                              repLength = CPLENS[symbol - 257];                              neededBits = CPLEXT[symbol - 257];                          }                          catch (Exception)                          {                              throw new Exception("Illegal rep length code");                          }                          goto case DECODE_HUFFMAN_LENBITS; // fall through                        case DECODE_HUFFMAN_LENBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_LENBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repLength += i;                          }                          mode = DECODE_HUFFMAN_DIST;                          goto case DECODE_HUFFMAN_DIST; // fall through                        case DECODE_HUFFMAN_DIST:                          symbol = distTree.GetSymbol(input);                          if (symbol < 0)                          {                              return false;                          }                            try                          {                              repDist = CPDIST[symbol];                              neededBits = CPDEXT[symbol];                          }                          catch (Exception)                          {                              throw new Exception("Illegal rep dist code");                          }                            goto case DECODE_HUFFMAN_DISTBITS; // fall through                        case DECODE_HUFFMAN_DISTBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_DISTBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repDist += i;                          }                            outputWindow.Repeat(repLength' repDist);                          free -= repLength;                          mode = DECODE_HUFFMAN;                          break;                        default:                          throw new Exception("Inflater unknown mode");                  }              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)              {                  int symbol;                  switch (mode)                  {                      case DECODE_HUFFMAN:                          // This is the inner loop so it is optimized a bit                          while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)                          {                              outputWindow.Write(symbol);                              if (--free < 258)                              {                                  return true;                              }                          }                            if (symbol < 257)                          {                              if (symbol < 0)                              {                                  return false;                              }                              else                              {                                  // symbol == 256: end of block                                  distTree = null;                                  litlenTree = null;                                  mode = DECODE_BLOCKS;                                  return true;                              }                          }                            try                          {                              repLength = CPLENS[symbol - 257];                              neededBits = CPLEXT[symbol - 257];                          }                          catch (Exception)                          {                              throw new Exception("Illegal rep length code");                          }                          goto case DECODE_HUFFMAN_LENBITS; // fall through                        case DECODE_HUFFMAN_LENBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_LENBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repLength += i;                          }                          mode = DECODE_HUFFMAN_DIST;                          goto case DECODE_HUFFMAN_DIST; // fall through                        case DECODE_HUFFMAN_DIST:                          symbol = distTree.GetSymbol(input);                          if (symbol < 0)                          {                              return false;                          }                            try                          {                              repDist = CPDIST[symbol];                              neededBits = CPDEXT[symbol];                          }                          catch (Exception)                          {                              throw new Exception("Illegal rep dist code");                          }                            goto case DECODE_HUFFMAN_DISTBITS; // fall through                        case DECODE_HUFFMAN_DISTBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_DISTBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repDist += i;                          }                            outputWindow.Repeat(repLength' repDist);                          free -= repLength;                          mode = DECODE_HUFFMAN;                          break;                        default:                          throw new Exception("Inflater unknown mode");                  }              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0)              {                  int chkByte = input.PeekBits(8);                  if (chkByte < 0)                  {                      return false;                  }                  input.DropBits(8);                  readAdler = (readAdler << 8) | chkByte;                  neededBits -= 8;              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0)              {                  int chkByte = input.PeekBits(8);                  if (chkByte < 0)                  {                      return false;                  }                  input.DropBits(8);                  readAdler = (readAdler << 8) | chkByte;                  neededBits -= 8;              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0)              {                  int chkByte = input.PeekBits(8);                  if (chkByte < 0)                  {                      return false;                  }                  input.DropBits(8);                  readAdler = (readAdler << 8) | chkByte;                  neededBits -= 8;              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0)              {                  int chkByte = input.PeekBits(8);                  if (chkByte < 0)                  {                      return false;                  }                  input.DropBits(8);                  readAdler = (readAdler << 8) | chkByte;                  neededBits -= 8;              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          else                          {                              input.SkipToByteBoundary();                              neededBits = 32;                              mode = DECODE_CHKSUM;                              return true;                          }                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new Exception("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                      {                          if ((uncomprLen = input.PeekBits(16)) < 0)                          {                              return false;                          }                          input.DropBits(16);                          mode = DECODE_STORED_LEN2;                      }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                      {                          int nlen = input.PeekBits(16);                          if (nlen < 0)                          {                              return false;                          }                          input.DropBits(16);                          if (nlen != (uncomprLen ^ 0xffff))                          {                              throw new Exception("broken uncompressed block");                          }                          mode = DECODE_STORED;                      }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                      {                          int more = outputWindow.CopyStored(input' uncomprLen);                          uncomprLen -= more;                          if (uncomprLen == 0)                          {                              mode = DECODE_BLOCKS;                              return true;                          }                          return !input.IsNeedingInput;                      }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new Exception("Inflater.Decode unknown mode");              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          else                          {                              input.SkipToByteBoundary();                              neededBits = 32;                              mode = DECODE_CHKSUM;                              return true;                          }                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new Exception("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                      {                          if ((uncomprLen = input.PeekBits(16)) < 0)                          {                              return false;                          }                          input.DropBits(16);                          mode = DECODE_STORED_LEN2;                      }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                      {                          int nlen = input.PeekBits(16);                          if (nlen < 0)                          {                              return false;                          }                          input.DropBits(16);                          if (nlen != (uncomprLen ^ 0xffff))                          {                              throw new Exception("broken uncompressed block");                          }                          mode = DECODE_STORED;                      }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                      {                          int more = outputWindow.CopyStored(input' uncomprLen);                          uncomprLen -= more;                          if (uncomprLen == 0)                          {                              mode = DECODE_BLOCKS;                              return true;                          }                          return !input.IsNeedingInput;                      }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new Exception("Inflater.Decode unknown mode");              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          else                          {                              input.SkipToByteBoundary();                              neededBits = 32;                              mode = DECODE_CHKSUM;                              return true;                          }                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new Exception("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                      {                          if ((uncomprLen = input.PeekBits(16)) < 0)                          {                              return false;                          }                          input.DropBits(16);                          mode = DECODE_STORED_LEN2;                      }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                      {                          int nlen = input.PeekBits(16);                          if (nlen < 0)                          {                              return false;                          }                          input.DropBits(16);                          if (nlen != (uncomprLen ^ 0xffff))                          {                              throw new Exception("broken uncompressed block");                          }                          mode = DECODE_STORED;                      }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                      {                          int more = outputWindow.CopyStored(input' uncomprLen);                          uncomprLen -= more;                          if (uncomprLen == 0)                          {                              mode = DECODE_BLOCKS;                              return true;                          }                          return !input.IsNeedingInput;                      }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new Exception("Inflater.Decode unknown mode");              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          else                          {                              input.SkipToByteBoundary();                              neededBits = 32;                              mode = DECODE_CHKSUM;                              return true;                          }                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new Exception("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                      {                          if ((uncomprLen = input.PeekBits(16)) < 0)                          {                              return false;                          }                          input.DropBits(16);                          mode = DECODE_STORED_LEN2;                      }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                      {                          int nlen = input.PeekBits(16);                          if (nlen < 0)                          {                              return false;                          }                          input.DropBits(16);                          if (nlen != (uncomprLen ^ 0xffff))                          {                              throw new Exception("broken uncompressed block");                          }                          mode = DECODE_STORED;                      }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                      {                          int more = outputWindow.CopyStored(input' uncomprLen);                          uncomprLen -= more;                          if (uncomprLen == 0)                          {                              mode = DECODE_BLOCKS;                              return true;                          }                          return !input.IsNeedingInput;                      }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new Exception("Inflater.Decode unknown mode");              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          else                          {                              input.SkipToByteBoundary();                              neededBits = 32;                              mode = DECODE_CHKSUM;                              return true;                          }                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new Exception("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                      {                          if ((uncomprLen = input.PeekBits(16)) < 0)                          {                              return false;                          }                          input.DropBits(16);                          mode = DECODE_STORED_LEN2;                      }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                      {                          int nlen = input.PeekBits(16);                          if (nlen < 0)                          {                              return false;                          }                          input.DropBits(16);                          if (nlen != (uncomprLen ^ 0xffff))                          {                              throw new Exception("broken uncompressed block");                          }                          mode = DECODE_STORED;                      }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                      {                          int more = outputWindow.CopyStored(input' uncomprLen);                          uncomprLen -= more;                          if (uncomprLen == 0)                          {                              mode = DECODE_BLOCKS;                              return true;                          }                          return !input.IsNeedingInput;                      }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new Exception("Inflater.Decode unknown mode");              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          else                          {                              input.SkipToByteBoundary();                              neededBits = 32;                              mode = DECODE_CHKSUM;                              return true;                          }                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new Exception("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                      {                          if ((uncomprLen = input.PeekBits(16)) < 0)                          {                              return false;                          }                          input.DropBits(16);                          mode = DECODE_STORED_LEN2;                      }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                      {                          int nlen = input.PeekBits(16);                          if (nlen < 0)                          {                              return false;                          }                          input.DropBits(16);                          if (nlen != (uncomprLen ^ 0xffff))                          {                              throw new Exception("broken uncompressed block");                          }                          mode = DECODE_STORED;                      }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                      {                          int more = outputWindow.CopyStored(input' uncomprLen);                          uncomprLen -= more;                          if (uncomprLen == 0)                          {                              mode = DECODE_BLOCKS;                              return true;                          }                          return !input.IsNeedingInput;                      }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new Exception("Inflater.Decode unknown mode");              }
Magic Number,Orvid.Compression.Streams,Inflater,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          else                          {                              input.SkipToByteBoundary();                              neededBits = 32;                              mode = DECODE_CHKSUM;                              return true;                          }                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new Exception("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                      {                          if ((uncomprLen = input.PeekBits(16)) < 0)                          {                              return false;                          }                          input.DropBits(16);                          mode = DECODE_STORED_LEN2;                      }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                      {                          int nlen = input.PeekBits(16);                          if (nlen < 0)                          {                              return false;                          }                          input.DropBits(16);                          if (nlen != (uncomprLen ^ 0xffff))                          {                              throw new Exception("broken uncompressed block");                          }                          mode = DECODE_STORED;                      }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                      {                          int more = outputWindow.CopyStored(input' uncomprLen);                          uncomprLen -= more;                          if (uncomprLen == 0)                          {                              mode = DECODE_BLOCKS;                              return true;                          }                          return !input.IsNeedingInput;                      }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new Exception("Inflater.Decode unknown mode");              }
Magic Number,Orvid.Compression.Streams,InflaterInputBuffer,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterInputBuffer,The following statement contains a magic number: if (bufferSize < 1024)              {                  bufferSize = 1024;              }
Magic Number,Orvid.Compression.Streams,InflaterInputBuffer,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterInputBuffer,The following statement contains a magic number: if (bufferSize < 1024)              {                  bufferSize = 1024;              }
Magic Number,Orvid.Compression.Streams,InflaterInputBuffer,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,ReadLeShort,The following statement contains a magic number: return ReadLeByte() | (ReadLeByte() << 8);
Magic Number,Orvid.Compression.Streams,InflaterInputBuffer,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,ReadLeInt,The following statement contains a magic number: return ReadLeShort() | (ReadLeShort() << 16);
Magic Number,Orvid.Compression.Streams,InflaterInputBuffer,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,ReadLeLong,The following statement contains a magic number: return (uint)ReadLeInt() | ((long)ReadLeInt() << 32);
Magic Number,Orvid.Compression.Streams,GZipOutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer)              {                  state_ = OutputState.Finished;                  base.Finish();                    uint totalin = (uint)(deflater_.TotalIn & 0xffffffff);                  uint crcval = (uint)(crc.Value & 0xffffffff);                    byte[] gzipFooter;                    unchecked                  {                      gzipFooter = new byte[] {  					(byte) crcval' (byte) (crcval >> 8)'  					(byte) (crcval >> 16)' (byte) (crcval >> 24)'  					  					(byte) totalin' (byte) (totalin >> 8)'  					(byte) (totalin >> 16)' (byte) (totalin >> 24)  				};                  }                    baseOutputStream_.Write(gzipFooter' 0' gzipFooter.Length);              }
Magic Number,Orvid.Compression.Streams,GZipOutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer)              {                  state_ = OutputState.Finished;                  base.Finish();                    uint totalin = (uint)(deflater_.TotalIn & 0xffffffff);                  uint crcval = (uint)(crc.Value & 0xffffffff);                    byte[] gzipFooter;                    unchecked                  {                      gzipFooter = new byte[] {  					(byte) crcval' (byte) (crcval >> 8)'  					(byte) (crcval >> 16)' (byte) (crcval >> 24)'  					  					(byte) totalin' (byte) (totalin >> 8)'  					(byte) (totalin >> 16)' (byte) (totalin >> 24)  				};                  }                    baseOutputStream_.Write(gzipFooter' 0' gzipFooter.Length);              }
Magic Number,Orvid.Compression.Streams,GZipOutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer)              {                  state_ = OutputState.Finished;                  base.Finish();                    uint totalin = (uint)(deflater_.TotalIn & 0xffffffff);                  uint crcval = (uint)(crc.Value & 0xffffffff);                    byte[] gzipFooter;                    unchecked                  {                      gzipFooter = new byte[] {  					(byte) crcval' (byte) (crcval >> 8)'  					(byte) (crcval >> 16)' (byte) (crcval >> 24)'  					  					(byte) totalin' (byte) (totalin >> 8)'  					(byte) (totalin >> 16)' (byte) (totalin >> 24)  				};                  }                    baseOutputStream_.Write(gzipFooter' 0' gzipFooter.Length);              }
Magic Number,Orvid.Compression.Streams,GZipOutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer)              {                  state_ = OutputState.Finished;                  base.Finish();                    uint totalin = (uint)(deflater_.TotalIn & 0xffffffff);                  uint crcval = (uint)(crc.Value & 0xffffffff);                    byte[] gzipFooter;                    unchecked                  {                      gzipFooter = new byte[] {  					(byte) crcval' (byte) (crcval >> 8)'  					(byte) (crcval >> 16)' (byte) (crcval >> 24)'  					  					(byte) totalin' (byte) (totalin >> 8)'  					(byte) (totalin >> 16)' (byte) (totalin >> 24)  				};                  }                    baseOutputStream_.Write(gzipFooter' 0' gzipFooter.Length);              }
Magic Number,Orvid.Compression.Streams,GZipOutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer)              {                  state_ = OutputState.Finished;                  base.Finish();                    uint totalin = (uint)(deflater_.TotalIn & 0xffffffff);                  uint crcval = (uint)(crc.Value & 0xffffffff);                    byte[] gzipFooter;                    unchecked                  {                      gzipFooter = new byte[] {  					(byte) crcval' (byte) (crcval >> 8)'  					(byte) (crcval >> 16)' (byte) (crcval >> 24)'  					  					(byte) totalin' (byte) (totalin >> 8)'  					(byte) (totalin >> 16)' (byte) (totalin >> 24)  				};                  }                    baseOutputStream_.Write(gzipFooter' 0' gzipFooter.Length);              }
Magic Number,Orvid.Compression.Streams,GZipOutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer)              {                  state_ = OutputState.Finished;                  base.Finish();                    uint totalin = (uint)(deflater_.TotalIn & 0xffffffff);                  uint crcval = (uint)(crc.Value & 0xffffffff);                    byte[] gzipFooter;                    unchecked                  {                      gzipFooter = new byte[] {  					(byte) crcval' (byte) (crcval >> 8)'  					(byte) (crcval >> 16)' (byte) (crcval >> 24)'  					  					(byte) totalin' (byte) (totalin >> 8)'  					(byte) (totalin >> 16)' (byte) (totalin >> 24)  				};                  }                    baseOutputStream_.Write(gzipFooter' 0' gzipFooter.Length);              }
Magic Number,Orvid.Compression.Streams,GZipOutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header)              {                  state_ = OutputState.Footer;                  int mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);                  byte[] gzipHeader = {  					(byte) (0x1F8B >> 8)' (byte) (0x1F8B & 0xff)'  					(byte) Deflater.DEFLATED'  					0'  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'  					0'  					(byte) 255  				};                  baseOutputStream_.Write(gzipHeader' 0' gzipHeader.Length);              }
Magic Number,Orvid.Compression.Streams,GZipOutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header)              {                  state_ = OutputState.Footer;                  int mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);                  byte[] gzipHeader = {  					(byte) (0x1F8B >> 8)' (byte) (0x1F8B & 0xff)'  					(byte) Deflater.DEFLATED'  					0'  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'  					0'  					(byte) 255  				};                  baseOutputStream_.Write(gzipHeader' 0' gzipHeader.Length);              }
Magic Number,Orvid.Compression.Streams,GZipOutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header)              {                  state_ = OutputState.Footer;                  int mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);                  byte[] gzipHeader = {  					(byte) (0x1F8B >> 8)' (byte) (0x1F8B & 0xff)'  					(byte) Deflater.DEFLATED'  					0'  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'  					0'  					(byte) 255  				};                  baseOutputStream_.Write(gzipHeader' 0' gzipHeader.Length);              }
Magic Number,Orvid.Compression.Streams,GZipOutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header)              {                  state_ = OutputState.Footer;                  int mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);                  byte[] gzipHeader = {  					(byte) (0x1F8B >> 8)' (byte) (0x1F8B & 0xff)'  					(byte) Deflater.DEFLATED'  					0'  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'  					0'  					(byte) 255  				};                  baseOutputStream_.Write(gzipHeader' 0' gzipHeader.Length);              }
Magic Number,Orvid.Compression.Streams,GZipOutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header)              {                  state_ = OutputState.Footer;                  int mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);                  byte[] gzipHeader = {  					(byte) (0x1F8B >> 8)' (byte) (0x1F8B & 0xff)'  					(byte) Deflater.DEFLATED'  					0'  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'  					0'  					(byte) 255  				};                  baseOutputStream_.Write(gzipHeader' 0' gzipHeader.Length);              }
Magic Number,Orvid.Compression.Streams,GZipOutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header)              {                  state_ = OutputState.Footer;                  int mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);                  byte[] gzipHeader = {  					(byte) (0x1F8B >> 8)' (byte) (0x1F8B & 0xff)'  					(byte) Deflater.DEFLATED'  					0'  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'  					0'  					(byte) 255  				};                  baseOutputStream_.Write(gzipHeader' 0' gzipHeader.Length);              }
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadHeader,The following statement contains a magic number: if (magic != (0x1F8B >> 8))              {                  throw new Exception("Error GZIP header' first magic byte doesn't match");              }
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadHeader,The following statement contains a magic number: if (compressionType != 8)              {                  throw new Exception("Error GZIP header' data not in deflate format");              }
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  int readByte = inputBuffer.ReadLeByte();                  if (readByte < 0)                  {                      throw new EndOfStreamException("EOS reading GZIP header");                  }                  headCRC.Update(readByte);              }
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadHeader,The following statement contains a magic number: if ((flags & 0x4) != 0)              {                  for (int i = 0; i < 2; i++)                  {                      int readByte = inputBuffer.ReadLeByte();                      if (readByte < 0)                      {                          throw new EndOfStreamException("EOS reading GZIP header");                      }                      headCRC.Update(readByte);                  }                    if (inputBuffer.ReadLeByte() < 0 || inputBuffer.ReadLeByte() < 0)                  {                      throw new EndOfStreamException("EOS reading GZIP header");                  }                    int len1' len2;                  len1 = inputBuffer.ReadLeByte();                  len2 = inputBuffer.ReadLeByte();                  if ((len1 < 0) || (len2 < 0))                  {                      throw new EndOfStreamException("EOS reading GZIP header");                  }                  headCRC.Update(len1);                  headCRC.Update(len2);                    int extraLen = (len1 << 8) | len2;                  for (int i = 0; i < extraLen; i++)                  {                      int readByte = inputBuffer.ReadLeByte();                      if (readByte < 0)                      {                          throw new EndOfStreamException("EOS reading GZIP header");                      }                      headCRC.Update(readByte);                  }              }
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadHeader,The following statement contains a magic number: if ((flags & 0x4) != 0)              {                  for (int i = 0; i < 2; i++)                  {                      int readByte = inputBuffer.ReadLeByte();                      if (readByte < 0)                      {                          throw new EndOfStreamException("EOS reading GZIP header");                      }                      headCRC.Update(readByte);                  }                    if (inputBuffer.ReadLeByte() < 0 || inputBuffer.ReadLeByte() < 0)                  {                      throw new EndOfStreamException("EOS reading GZIP header");                  }                    int len1' len2;                  len1 = inputBuffer.ReadLeByte();                  len2 = inputBuffer.ReadLeByte();                  if ((len1 < 0) || (len2 < 0))                  {                      throw new EndOfStreamException("EOS reading GZIP header");                  }                  headCRC.Update(len1);                  headCRC.Update(len2);                    int extraLen = (len1 << 8) | len2;                  for (int i = 0; i < extraLen; i++)                  {                      int readByte = inputBuffer.ReadLeByte();                      if (readByte < 0)                      {                          throw new EndOfStreamException("EOS reading GZIP header");                      }                      headCRC.Update(readByte);                  }              }
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadHeader,The following statement contains a magic number: if ((flags & 0x2) != 0)              {                  int tempByte;                  int crcval = inputBuffer.ReadLeByte();                  if (crcval < 0)                  {                      throw new EndOfStreamException("EOS reading GZIP header");                  }                    tempByte = inputBuffer.ReadLeByte();                  if (tempByte < 0)                  {                      throw new EndOfStreamException("EOS reading GZIP header");                  }                    crcval = (crcval << 8) | tempByte;                  if (crcval != ((int)headCRC.Value & 0xffff))                  {                      throw new Exception("Header CRC value mismatch");                  }              }
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: byte[] footer = new byte[8];
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: int needed = 8;
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: while (needed > 0)              {                  int count = inputBuffer.ReadClearTextBuffer(footer' 8 - needed' needed);                  if (count <= 0)                  {                      throw new EndOfStreamException("EOS reading GZIP footer");                  }                  needed -= count;              }
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: uint total =                  (uint)((uint)footer[4] & 0xff) |                  (uint)(((uint)footer[5] & 0xff) << 8) |                  (uint)(((uint)footer[6] & 0xff) << 16) |                  (uint)((uint)footer[7] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: uint total =                  (uint)((uint)footer[4] & 0xff) |                  (uint)(((uint)footer[5] & 0xff) << 8) |                  (uint)(((uint)footer[6] & 0xff) << 16) |                  (uint)((uint)footer[7] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: uint total =                  (uint)((uint)footer[4] & 0xff) |                  (uint)(((uint)footer[5] & 0xff) << 8) |                  (uint)(((uint)footer[6] & 0xff) << 16) |                  (uint)((uint)footer[7] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: uint total =                  (uint)((uint)footer[4] & 0xff) |                  (uint)(((uint)footer[5] & 0xff) << 8) |                  (uint)(((uint)footer[6] & 0xff) << 16) |                  (uint)((uint)footer[7] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: uint total =                  (uint)((uint)footer[4] & 0xff) |                  (uint)(((uint)footer[5] & 0xff) << 8) |                  (uint)(((uint)footer[6] & 0xff) << 16) |                  (uint)((uint)footer[7] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: uint total =                  (uint)((uint)footer[4] & 0xff) |                  (uint)(((uint)footer[5] & 0xff) << 8) |                  (uint)(((uint)footer[6] & 0xff) << 16) |                  (uint)((uint)footer[7] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: uint total =                  (uint)((uint)footer[4] & 0xff) |                  (uint)(((uint)footer[5] & 0xff) << 8) |                  (uint)(((uint)footer[6] & 0xff) << 16) |                  (uint)((uint)footer[7] << 24);
Magic Number,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: MainLoop: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: MainLoop: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: MainLoop: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: MainLoop: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: MainLoop: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: MainLoop: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: MainLoop: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: MainLoop: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: MainLoop: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: MainLoop: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,ResetBuf,The following statement contains a magic number: int pos = bitPosition >> 3;
Magic Number,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,ParseHeader,The following statement contains a magic number: if (hdr[0] != (LzwConstants.MAGIC >> 8) || hdr[1] != (LzwConstants.MAGIC & 0xff))              {                  throw new Exception(String.Format("Wrong LZW header. Magic bytes don't match. 0x{0:x2} 0x{1:x2}"' hdr[0]' hdr[1]));              }
Magic Number,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,ParseHeader,The following statement contains a magic number: blockMode = (hdr[2] & LzwConstants.BLOCK_MODE_MASK) > 0;
Magic Number,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,ParseHeader,The following statement contains a magic number: maxBits = hdr[2] & LzwConstants.BIT_MASK;
Magic Number,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,ParseHeader,The following statement contains a magic number: if ((hdr[2] & LzwConstants.RESERVED_MASK) > 0)              {                  throw new Exception("Unsupported bits set in the header.");              }
Magic Number,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,ParseHeader,The following statement contains a magic number: freeEnt = blockMode ? TBL_FIRST : 256;
Magic Number,Orvid.Compression.Streams,LzwInputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,ParseHeader,The following statement contains a magic number: for (int idx = 255; idx >= 0; idx--)                  tabSuffix[idx] = (byte)idx;
Duplicate Code,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 24)' (14' 33)' (23' 42)' (32' 51))
Duplicate Code,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 50)' (14' 59))
Duplicate Code,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 24)' (23' 42)' (32' 51))
Duplicate Code,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((64' 97)' (79' 112))
Duplicate Code,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((64' 83)' (94' 113))
Duplicate Code,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The method contains a code clone-set at the following line numbers (starting from the method definition): ((49' 72)' (81' 104))
Missing Default,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The following switch statement is missing a default case: switch (zPend % 2)                              {                                  case 0:                                      szptr[wr] = (short)BZip2Constants.RunA;                                      wr++;                                      mtfFreq[BZip2Constants.RunA]++;                                      break;                                  case 1:                                      szptr[wr] = (short)BZip2Constants.RunB;                                      wr++;                                      mtfFreq[BZip2Constants.RunB]++;                                      break;                              }
Missing Default,Orvid.Compression.Streams,BZip2OutputStream,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The following switch statement is missing a default case: switch (zPend % 2)                      {                          case 0:                              szptr[wr] = (short)BZip2Constants.RunA;                              wr++;                              mtfFreq[BZip2Constants.RunA]++;                              break;                          case 1:                              szptr[wr] = (short)BZip2Constants.RunB;                              wr++;                              mtfFreq[BZip2Constants.RunB]++;                              break;                      }
Missing Default,Orvid.Compression.Streams,InflaterDynHeader,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following switch statement is missing a default case: switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          mode = DNUM;                          goto case DNUM;                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM;                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          mode = BLLENS;                          goto case BLLENS;                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              blLens[BL_ORDER[ptr]] = (byte)len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS;                      case LENS:                          {                              int symbol;                              while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                              {                                  litdistLens[ptr++] = lastLen = (byte)symbol;                                    if (ptr == num)                                  {                                      return true;                                  }                              }                                if (symbol < 0)                              {                                  return false;                              }                                if (symbol >= 17)                              {                                  lastLen = 0;                              }                              else                              {                                  if (ptr == 0)                                  {                                      throw new Exception();                                  }                              }                              repSymbol = symbol - 16;                          }                          mode = REPS;                          goto case REPS;                      case REPS:                          {                              int bits = repBits[repSymbol];                              int count = input.PeekBits(bits);                              if (count < 0)                              {                                  return false;                              }                              input.DropBits(bits);                              count += repMin[repSymbol];                                if (ptr + count > num)                              {                                  throw new Exception();                              }                              while (count-- > 0)                              {                                  litdistLens[ptr++] = lastLen;                              }                                if (ptr == num)                              {                                  return true;                              }                          }                          mode = LENS;                          goto decode_loop;                  }
Missing Default,Orvid.Compression.Streams,DeflaterEngine,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SetLevel,The following switch statement is missing a default case: switch (compressionFunction)                  {                      case DEFLATE_STORED:                          if (strstart > blockStart)                          {                              huffman.FlushStoredBlock(window' blockStart'                                  strstart - blockStart' false);                              blockStart = strstart;                          }                          UpdateHash();                          break;                        case DEFLATE_FAST:                          if (strstart > blockStart)                          {                              huffman.FlushBlock(window' blockStart' strstart - blockStart'                                  false);                              blockStart = strstart;                          }                          break;                        case DEFLATE_SLOW:                          if (prevAvailable)                          {                              huffman.TallyLit(window[strstart - 1] & 0xff);                          }                          if (strstart > blockStart)                          {                              huffman.FlushBlock(window' blockStart' strstart - blockStart' false);                              blockStart = strstart;                          }                          prevAvailable = false;                          matchLen = MIN_MATCH - 1;                          break;                  }
