Implementation smell,Namespace,Class,File,Method,Description
Long Method,Orvid.Compression,LZMADecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Code,The method has 114 lines of code.
Long Method,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The method has 449 lines of code.
Long Method,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,CodeOneBlock,The method has 156 lines of code.
Long Method,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,The method has 122 lines of code.
Long Method,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GetAndMoveToFrontDecode,The method has 152 lines of code.
Long Method,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The method has 351 lines of code.
Long Method,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,QSort3,The method has 119 lines of code.
Long Method,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The method has 196 lines of code.
Long Method,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,FullGtU,The method has 126 lines of code.
Long Method,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The method has 102 lines of code.
Long Method,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The method has 139 lines of code.
Long Method,Orvid.Compression.Streams,InflaterDynHeader,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The method has 115 lines of code.
Long Method,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The method has 110 lines of code.
Long Method,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadHeader,The method has 151 lines of code.
Long Method,Orvid.Compression.Streams,LzwInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The method has 179 lines of code.
Complex Method,Orvid.Compression,LZMADecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Code,Cyclomatic complexity of the method is 15
Complex Method,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,Cyclomatic complexity of the method is 64
Complex Method,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,CodeOneBlock,Cyclomatic complexity of the method is 24
Complex Method,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetCoderProperties,Cyclomatic complexity of the method is 26
Complex Method,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,Cyclomatic complexity of the method is 22
Complex Method,Orvid.Compression.Checksums,Adler32,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\Adler32.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,Cyclomatic complexity of the method is 18
Complex Method,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GetAndMoveToFrontDecode,Cyclomatic complexity of the method is 18
Complex Method,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbCreateDecodeTables,Cyclomatic complexity of the method is 10
Complex Method,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,Cyclomatic complexity of the method is 63
Complex Method,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SimpleSort,Cyclomatic complexity of the method is 15
Complex Method,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,QSort3,Cyclomatic complexity of the method is 16
Complex Method,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,Cyclomatic complexity of the method is 25
Complex Method,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,Cyclomatic complexity of the method is 14
Complex Method,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,Cyclomatic complexity of the method is 22
Complex Method,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,Cyclomatic complexity of the method is 10
Complex Method,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FlushBlock,Cyclomatic complexity of the method is 8
Complex Method,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CalcBLFreq,Cyclomatic complexity of the method is 9
Complex Method,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteTree,Cyclomatic complexity of the method is 10
Complex Method,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildLength,Cyclomatic complexity of the method is 9
Complex Method,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SetLevel,Cyclomatic complexity of the method is 9
Complex Method,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateFast,Cyclomatic complexity of the method is 11
Complex Method,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateSlow,Cyclomatic complexity of the method is 13
Complex Method,Orvid.Compression.Streams,Deflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,Cyclomatic complexity of the method is 15
Complex Method,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHuffman,Cyclomatic complexity of the method is 15
Complex Method,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,Cyclomatic complexity of the method is 23
Complex Method,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadHeader,Cyclomatic complexity of the method is 30
Long Parameter List,Orvid.Compression,LZMADecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,Orvid.Compression,LZMARangeBitTreeEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,ReverseEncode,The method has 5 parameters. Parameters: Models' startIndex' rangeEncoder' NumBitLevels' symbol
Long Parameter List,Orvid.Compression,ICoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbCreateDecodeTables,The method has 7 parameters. Parameters: limit' baseArray' perm' length' minLen' maxLen' alphaSize
Long Parameter List,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbAssignCodes,The method has 5 parameters. Parameters: code' length' minLen' maxLen' alphaSize
Long Parameter List,Orvid.Compression.Streams,DeflaterInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Orvid.Compression.Streams,DeflaterOutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Orvid.Compression.Streams,DeflaterOutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Orvid.Compression.Streams,LzwInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Identifier,Orvid.Compression,LZMABase,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,,The length of the parameter kNumLitPosStatesBitsEncodingMax is 31.
Long Statement,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The length of the statement  "                                UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 130.
Long Statement,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The length of the statement  "                                        UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 130.
Long Statement,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,FillDistancesPrices,The length of the statement  "                        _posSlotPrices[st + posSlot] += ((((posSlot >> 1) - 1) - LZMABase.kNumAlignBits) << LZMARangeBitEncoder.kNumBitPriceShiftBits); " is 127.
Long Statement,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The length of the statement  "                        while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) " is 127.
Long Statement,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The length of the statement  "                        (int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff))); " is 125.
Long Statement,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateSlow,The length of the statement  "                        if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) " is 121.
Long Statement,Orvid.Compression.Streams,LzwInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,ParseHeader,The length of the statement  "                throw new Exception("Stream compressed with " + maxBits + " bits' but decompression can only handle " + LzwConstants.MAX_BITS + " bits."); " is 138.
Complex Conditional,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,Initialize,The conditional expression  "magic1 != 'B' || magic2 != 'Z' || magic3 != 'h' || magic4 < '1' || magic4 > '9'"  is complex.
Complex Conditional,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,InitBlock,The conditional expression  "magic1 == 0x17 && magic2 == 0x72 && magic3 == 0x45 && magic4 == 0x38 && magic5 == 0x50 && magic6 == 0x90"  is complex.
Complex Conditional,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,InitBlock,The conditional expression  "magic1 != 0x31 || magic2 != 0x41 || magic3 != 0x59 || magic4 != 0x26 || magic5 != 0x53 || magic6 != 0x59"  is complex.
Complex Conditional,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SetDecompressStructureSizes,The conditional expression  "!(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k && blockSize100k <= 9)"  is complex.
Complex Conditional,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The conditional expression  "ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1)"  is complex.
Complex Conditional,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,AllocateCompressStructures,The conditional expression  "block == null || quadrant == null || zptr == null || ftab == null"  is complex.
Complex Conditional,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FindLongestMatch,The conditional expression  "window[curMatch + best_len] != scan_end ||                      window[curMatch + best_len - 1] != scan_end1 ||                      window[curMatch] != window[scan] ||                      window[curMatch + 1] != window[scan + 1]"  is complex.
Complex Conditional,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FindLongestMatch,The conditional expression  "window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      (scan < strend)"  is complex.
Complex Conditional,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateStored,The conditional expression  "(storedLength >= DeflaterConstants.MAX_BLOCK_SIZE) || // Block is full                  (blockStart < WSIZE && storedLength >= MAX_DIST) ||   // Block may move out of window                  flush"  is complex.
Complex Conditional,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateFast,The conditional expression  "lookahead >= MIN_MATCH &&                      (hashHead = InsertString()) != 0 &&                      strategy != DeflateStrategy.HuffmanOnly &&                      strstart - hashHead <= MAX_DIST &&                      FindLongestMatch(hashHead)"  is complex.
Complex Conditional,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateSlow,The conditional expression  "strategy != DeflateStrategy.HuffmanOnly &&                          hashHead != 0 &&                          strstart - hashHead <= MAX_DIST &&                          FindLongestMatch(hashHead)"  is complex.
Complex Conditional,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateSlow,The conditional expression  "matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))"  is complex.
Magic Number,Orvid.Compression,LZMA,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Compress,The following statement contains a magic number: outStream.WriteByte((Byte)(fileSize >> (8 * i)));
Magic Number,Orvid.Compression,LZMA,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Compress,The following statement contains a magic number: i < 8
Magic Number,Orvid.Compression,LZMA,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Decompress,The following statement contains a magic number: byte[] properties2 = new byte[5];
Magic Number,Orvid.Compression,LZMA,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Decompress,The following statement contains a magic number: newInStream.Read(properties2' 0' 5) != 5
Magic Number,Orvid.Compression,LZMA,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Decompress,The following statement contains a magic number: newInStream.Read(properties2' 0' 5) != 5
Magic Number,Orvid.Compression,LZMA,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Decompress,The following statement contains a magic number: outSize |= ((long)(byte)v) << (8 * i);
Magic Number,Orvid.Compression,LZMA,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Decompress,The following statement contains a magic number: i < 8
Magic Number,Orvid.Compression,State,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateChar,The following statement contains a magic number: Index < 4
Magic Number,Orvid.Compression,State,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Orvid.Compression,State,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Orvid.Compression,State,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Orvid.Compression,State,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Orvid.Compression,State,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Orvid.Compression,State,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Orvid.Compression,State,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Orvid.Compression,State,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Orvid.Compression,State,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Orvid.Compression,State,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,IsCharState,The following statement contains a magic number: return Index < 7;
Magic Number,Orvid.Compression,LZMADecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetDictionarySize,The following statement contains a magic number: uint blockSize = Math.Max(m_DictionarySizeCheck' (1 << 12));
Magic Number,Orvid.Compression,LZMADecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetLiteralProperties,The following statement contains a magic number: lp > 8
Magic Number,Orvid.Compression,LZMADecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetLiteralProperties,The following statement contains a magic number: lc > 8
Magic Number,Orvid.Compression,LZMADecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetDecoderProperties,The following statement contains a magic number: properties.Length < 5
Magic Number,Orvid.Compression,LZMADecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetDecoderProperties,The following statement contains a magic number: int lc = properties[0] % 9;
Magic Number,Orvid.Compression,LZMADecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetDecoderProperties,The following statement contains a magic number: int remainder = properties[0] / 9;
Magic Number,Orvid.Compression,LZMADecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetDecoderProperties,The following statement contains a magic number: int lp = remainder % 5;
Magic Number,Orvid.Compression,LZMADecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetDecoderProperties,The following statement contains a magic number: int pb = remainder / 5;
Magic Number,Orvid.Compression,LZMADecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetDecoderProperties,The following statement contains a magic number: dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,Orvid.Compression,LZMADecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetDecoderProperties,The following statement contains a magic number: i < 4
Magic Number,Orvid.Compression,LiteralDecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetState,The following statement contains a magic number: return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
Magic Number,Orvid.Compression,Decoder2,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,DecodeWithMatchByte,The following statement contains a magic number: uint matchBit = (uint)(matchByte >> 7) & 1;
Magic Number,Orvid.Compression,Decoder2,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,DecodeWithMatchByte,The following statement contains a magic number: uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,LZMAEncoder,The following statement contains a magic number: const Byte kFastSlots = 22;
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,LZMAEncoder,The following statement contains a magic number: int c = 2;
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot,The following statement contains a magic number: pos < (1 << 11)
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot,The following statement contains a magic number: pos < (1 << 21)
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot2,The following statement contains a magic number: pos < (1 << 17)
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot2,The following statement contains a magic number: pos < (1 << 27)
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: int numHashBytes = 4;
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: numHashBytes = 2;
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,ReadMatchDistances,The following statement contains a magic number: lenRes = _matchDistances[numDistancePairs - 2];
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: numAvailableBytes < 2
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: lenEnd < 2
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs2 = reps[2];
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs3 = reps[3];
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: repLen < 2
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: offs += 2;
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: offs += 2;
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: _optimum[cur].Backs2 = reps[2];
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: _optimum[cur].Backs3 = reps[3];
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: UInt32 curAnd1Price = curPrice +                          _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                          _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                          GetPrice(!state.IsCharState()' matchByte' currentByte);
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: numAvailableBytes < 2
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: lenTest2 >= 2
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: UInt32 startLen = 2;
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: lenTest < 2
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: lenTest2 >= 2
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: numDistancePairs += 2;
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: offs += 2;
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: lenTest2 >= 2
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetOptimum,The following statement contains a magic number: offs += 2;
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,ChangePair,The following statement contains a magic number: const int kDif = 7;
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,ChangePair,The following statement contains a magic number: return (smallDist < ((UInt32)(1) << (32 - kDif)) && bigDist >= (smallDist << kDif));
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,WriteEndMarker,The following statement contains a magic number: int footerBits = 30;
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,CodeOneBlock,The following statement contains a magic number: _matchPriceCount >= (1 << 7)
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,CodeOneBlock,The following statement contains a magic number: nowPos64 - progressPosValuePrev >= (1 << 12)
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,WriteCoderProperties,The following statement contains a magic number: properties[1 + i] = (Byte)(_dictionarySize >> (8 * i));
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,WriteCoderProperties,The following statement contains a magic number: i < 4
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,FillDistancesPrices,The following statement contains a magic number: UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs[i])                      {                          case CoderPropID.NumFastBytes:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 numFastBytes = (Int32)prop;                                  if (numFastBytes < 5 || numFastBytes > LZMABase.kMatchMaxLen)                                      throw new Exception();                                  _numFastBytes = (UInt32)numFastBytes;                                  break;                              }                          case CoderPropID.Algorithm:                              {                                  break;                              }                          case CoderPropID.MatchFinder:                              {                                  if (!(prop is String))                                      throw new Exception();                                  EMatchFinderType matchFinderIndexPrev = _matchFinderType;                                  int m = FindMatchFinder(((string)prop).ToUpper());                                  if (m < 0)                                      throw new Exception();                                  _matchFinderType = (EMatchFinderType)m;                                  if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                                  {                                      _dictionarySizePrev = 0xFFFFFFFF;                                      _matchFinder = null;                                  }                                  break;                              }                          case CoderPropID.DictionarySize:                              {                                  const int kDicLogSizeMaxCompress = 30;                                  if (!(prop is Int32))                                      throw new Exception(); ;                                  Int32 dictionarySize = (Int32)prop;                                  if (dictionarySize < (UInt32)(1 << LZMABase.kDicLogSizeMin) ||                                      dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                                      throw new Exception();                                  _dictionarySize = (UInt32)dictionarySize;                                  int dicLogSize;                                  for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                                      if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                          break;                                  _distTableSize = (UInt32)dicLogSize * 2;                                  break;                              }                          case CoderPropID.PosStateBits:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 v = (Int32)prop;                                  if (v < 0 || v > (UInt32)LZMABase.kNumPosStatesBitsEncodingMax)                                      throw new Exception();                                  _posStateBits = (int)v;                                  _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                                  break;                              }                          case CoderPropID.LitPosBits:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 v = (Int32)prop;                                  if (v < 0 || v > (UInt32)LZMABase.kNumLitPosStatesBitsEncodingMax)                                      throw new Exception();                                  _numLiteralPosStateBits = (int)v;                                  break;                              }                          case CoderPropID.LitContextBits:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 v = (Int32)prop;                                  if (v < 0 || v > (UInt32)LZMABase.kNumLitContextBitsMax)                                      throw new Exception(); ;                                  _numLiteralContextBits = (int)v;                                  break;                              }                          case CoderPropID.EndMarker:                              {                                  if (!(prop is Boolean))                                      throw new Exception();                                  SetWriteEndMarkerMode((Boolean)prop);                                  break;                              }                          default:                              throw new Exception();                      }
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs[i])                      {                          case CoderPropID.NumFastBytes:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 numFastBytes = (Int32)prop;                                  if (numFastBytes < 5 || numFastBytes > LZMABase.kMatchMaxLen)                                      throw new Exception();                                  _numFastBytes = (UInt32)numFastBytes;                                  break;                              }                          case CoderPropID.Algorithm:                              {                                  break;                              }                          case CoderPropID.MatchFinder:                              {                                  if (!(prop is String))                                      throw new Exception();                                  EMatchFinderType matchFinderIndexPrev = _matchFinderType;                                  int m = FindMatchFinder(((string)prop).ToUpper());                                  if (m < 0)                                      throw new Exception();                                  _matchFinderType = (EMatchFinderType)m;                                  if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                                  {                                      _dictionarySizePrev = 0xFFFFFFFF;                                      _matchFinder = null;                                  }                                  break;                              }                          case CoderPropID.DictionarySize:                              {                                  const int kDicLogSizeMaxCompress = 30;                                  if (!(prop is Int32))                                      throw new Exception(); ;                                  Int32 dictionarySize = (Int32)prop;                                  if (dictionarySize < (UInt32)(1 << LZMABase.kDicLogSizeMin) ||                                      dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                                      throw new Exception();                                  _dictionarySize = (UInt32)dictionarySize;                                  int dicLogSize;                                  for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                                      if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                          break;                                  _distTableSize = (UInt32)dicLogSize * 2;                                  break;                              }                          case CoderPropID.PosStateBits:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 v = (Int32)prop;                                  if (v < 0 || v > (UInt32)LZMABase.kNumPosStatesBitsEncodingMax)                                      throw new Exception();                                  _posStateBits = (int)v;                                  _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                                  break;                              }                          case CoderPropID.LitPosBits:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 v = (Int32)prop;                                  if (v < 0 || v > (UInt32)LZMABase.kNumLitPosStatesBitsEncodingMax)                                      throw new Exception();                                  _numLiteralPosStateBits = (int)v;                                  break;                              }                          case CoderPropID.LitContextBits:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 v = (Int32)prop;                                  if (v < 0 || v > (UInt32)LZMABase.kNumLitContextBitsMax)                                      throw new Exception(); ;                                  _numLiteralContextBits = (int)v;                                  break;                              }                          case CoderPropID.EndMarker:                              {                                  if (!(prop is Boolean))                                      throw new Exception();                                  SetWriteEndMarkerMode((Boolean)prop);                                  break;                              }                          default:                              throw new Exception();                      }
Magic Number,Orvid.Compression,LZMAEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs[i])                      {                          case CoderPropID.NumFastBytes:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 numFastBytes = (Int32)prop;                                  if (numFastBytes < 5 || numFastBytes > LZMABase.kMatchMaxLen)                                      throw new Exception();                                  _numFastBytes = (UInt32)numFastBytes;                                  break;                              }                          case CoderPropID.Algorithm:                              {                                  break;                              }                          case CoderPropID.MatchFinder:                              {                                  if (!(prop is String))                                      throw new Exception();                                  EMatchFinderType matchFinderIndexPrev = _matchFinderType;                                  int m = FindMatchFinder(((string)prop).ToUpper());                                  if (m < 0)                                      throw new Exception();                                  _matchFinderType = (EMatchFinderType)m;                                  if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                                  {                                      _dictionarySizePrev = 0xFFFFFFFF;                                      _matchFinder = null;                                  }                                  break;                              }                          case CoderPropID.DictionarySize:                              {                                  const int kDicLogSizeMaxCompress = 30;                                  if (!(prop is Int32))                                      throw new Exception(); ;                                  Int32 dictionarySize = (Int32)prop;                                  if (dictionarySize < (UInt32)(1 << LZMABase.kDicLogSizeMin) ||                                      dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                                      throw new Exception();                                  _dictionarySize = (UInt32)dictionarySize;                                  int dicLogSize;                                  for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                                      if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                          break;                                  _distTableSize = (UInt32)dicLogSize * 2;                                  break;                              }                          case CoderPropID.PosStateBits:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 v = (Int32)prop;                                  if (v < 0 || v > (UInt32)LZMABase.kNumPosStatesBitsEncodingMax)                                      throw new Exception();                                  _posStateBits = (int)v;                                  _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                                  break;                              }                          case CoderPropID.LitPosBits:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 v = (Int32)prop;                                  if (v < 0 || v > (UInt32)LZMABase.kNumLitPosStatesBitsEncodingMax)                                      throw new Exception();                                  _numLiteralPosStateBits = (int)v;                                  break;                              }                          case CoderPropID.LitContextBits:                              {                                  if (!(prop is Int32))                                      throw new Exception();                                  Int32 v = (Int32)prop;                                  if (v < 0 || v > (UInt32)LZMABase.kNumLitContextBitsMax)                                      throw new Exception(); ;                                  _numLiteralContextBits = (int)v;                                  break;                              }                          case CoderPropID.EndMarker:                              {                                  if (!(prop is Boolean))                                      throw new Exception();                                  SetWriteEndMarkerMode((Boolean)prop);                                  break;                              }                          default:                              throw new Exception();                      }
Magic Number,Orvid.Compression,LiteralEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetSubCoder,The following statement contains a magic number: return m_Coders[((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits))];
Magic Number,Orvid.Compression,Encoder2,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,EncodeMatched,The following statement contains a magic number: state += ((1 + matchBit) << 8);
Magic Number,Orvid.Compression,Encoder2,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPrice,The following statement contains a magic number: int i = 7;
Magic Number,Orvid.Compression,Encoder2,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetPrice,The following statement contains a magic number: price += m_Encoders[((1 + matchBit) << 8) + context].GetPrice(bit);
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetType,The following statement contains a magic number: HASH_ARRAY = (numHashBytes > 2);
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,SetType,The following statement contains a magic number: kMinMatchCheck = 4;
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: historySize > kMaxValForNormalize - 256
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: _cutValue = 16 + (matchMaxLen >> 1);
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +                          matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +                          matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: _son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: hs |= (hs >> 2);
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: hs |= (hs >> 4);
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: hs |= (hs >> 8);
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Create,The following statement contains a magic number: hs > (1 << 24)
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,The following statement contains a magic number: distances[offset++] = maxLen = 2;
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,The following statement contains a magic number: offset -= 2;
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,The following statement contains a magic number: distances[offset++] = maxLen = 3;
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetMatches,The following statement contains a magic number: offset -= 2;
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Skip,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Skip,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Skip,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Skip,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
Magic Number,Orvid.Compression,LZBinTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Normalize,The following statement contains a magic number: NormalizeLinks(_son' _cyclicBufferSize * 2' subValue);
Magic Number,Orvid.Compression,CRC,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,CRC,The following statement contains a magic number: Table = new uint[256];
Magic Number,Orvid.Compression,CRC,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,CRC,The following statement contains a magic number: j < 8
Magic Number,Orvid.Compression,CRC,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,CRC,The following statement contains a magic number: i < 256
Magic Number,Orvid.Compression,CRC,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,UpdateByte,The following statement contains a magic number: _value = Table[(((byte)(_value)) ^ b)] ^ (_value >> 8);
Magic Number,Orvid.Compression,CRC,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Update,The following statement contains a magic number: _value = Table[(((byte)(_value)) ^ data[offset + i])] ^ (_value >> 8);
Magic Number,Orvid.Compression,LZMARangeEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,FlushData,The following statement contains a magic number: i < 5
Magic Number,Orvid.Compression,LZMARangeEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Encode,The following statement contains a magic number: Range <<= 8;
Magic Number,Orvid.Compression,LZMARangeEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,ShiftLow,The following statement contains a magic number: Stream.WriteByte((byte)(temp + (Low >> 32)));
Magic Number,Orvid.Compression,LZMARangeEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,ShiftLow,The following statement contains a magic number: _cache = (byte)(((uint)Low) >> 24);
Magic Number,Orvid.Compression,LZMARangeEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,ShiftLow,The following statement contains a magic number: (uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1
Magic Number,Orvid.Compression,LZMARangeEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,ShiftLow,The following statement contains a magic number: Low = ((uint)Low) << 8;
Magic Number,Orvid.Compression,LZMARangeEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,EncodeDirectBits,The following statement contains a magic number: Range <<= 8;
Magic Number,Orvid.Compression,LZMARangeEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,EncodeBit,The following statement contains a magic number: Range <<= 8;
Magic Number,Orvid.Compression,LZMARangeEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,GetProcessedSizeAdd,The following statement contains a magic number: return _cacheSize + Stream.Position - StartPosition + 4;
Magic Number,Orvid.Compression,LZMARangeDecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Init,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,Orvid.Compression,LZMARangeDecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Init,The following statement contains a magic number: i < 5
Magic Number,Orvid.Compression,LZMARangeDecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Normalize,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,Orvid.Compression,LZMARangeDecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Normalize,The following statement contains a magic number: Range <<= 8;
Magic Number,Orvid.Compression,LZMARangeDecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Normalize2,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,Orvid.Compression,LZMARangeDecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Normalize2,The following statement contains a magic number: Range <<= 8;
Magic Number,Orvid.Compression,LZMARangeDecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,DecodeDirectBits,The following statement contains a magic number: uint t = (code - range) >> 31;
Magic Number,Orvid.Compression,LZMARangeDecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,DecodeDirectBits,The following statement contains a magic number: code = (code << 8) | (byte)Stream.ReadByte();
Magic Number,Orvid.Compression,LZMARangeDecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,DecodeDirectBits,The following statement contains a magic number: range <<= 8;
Magic Number,Orvid.Compression,LZMARangeBitEncoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Encode,The following statement contains a magic number: encoder.Range <<= 8;
Magic Number,Orvid.Compression,LZMARangeBitDecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Decode,The following statement contains a magic number: rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();
Magic Number,Orvid.Compression,LZMARangeBitDecoder,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\LZMA.cs,Decode,The following statement contains a magic number: rangeDecoder.Range <<= 8;
Magic Number,Orvid.Compression.Checksums,Adler32,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\Adler32.cs,Update,The following statement contains a magic number: uint s2 = checksum >> 16;
Magic Number,Orvid.Compression.Checksums,Adler32,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) + s1;
Magic Number,Orvid.Compression.Checksums,Adler32,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\Adler32.cs,Update,The following statement contains a magic number: uint s2 = checksum >> 16;
Magic Number,Orvid.Compression.Checksums,Adler32,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\Adler32.cs,Update,The following statement contains a magic number: int n = 3800;
Magic Number,Orvid.Compression.Checksums,Adler32,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) | s1;
Magic Number,Orvid.Compression.Checksums,Crc32,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\CRC32.cs,ComputeCrc32,The following statement contains a magic number: return (uint)(Crc32.CrcTable[(oldCrc ^ value) & 0xFF] ^ (oldCrc >> 8));
Magic Number,Orvid.Compression.Checksums,Crc32,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\CRC32.cs,Update,The following statement contains a magic number: crc  = CrcTable[(crc ^ value) & 0xFF] ^ (crc >> 8);
Magic Number,Orvid.Compression.Checksums,Crc32,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\CRC32.cs,Update,The following statement contains a magic number: crc = CrcTable[(crc ^ buffer[offset++]) & 0xFF] ^ (crc >> 8);
Magic Number,Orvid.Compression.Checksums,StrangeCRC,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\StrangeCRC.cs,Update,The following statement contains a magic number: int temp = (globalCrc >> 24) ^ value;
Magic Number,Orvid.Compression.Checksums,StrangeCRC,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\StrangeCRC.cs,Update,The following statement contains a magic number: temp = 256 + temp;
Magic Number,Orvid.Compression.Checksums,StrangeCRC,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Checksums\StrangeCRC.cs,Update,The following statement contains a magic number: globalCrc = unchecked((int)((globalCrc << 8) ^ crc32Table[temp]));
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MakeMaps,The following statement contains a magic number: i < 256
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,EndBlock,The following statement contains a magic number: computedCombinedCRC = ((computedCombinedCRC << 1) & 0xFFFFFFFF) | (computedCombinedCRC >> 31);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,FillBuffer,The following statement contains a magic number: bsBuff = (bsBuff << 8) | (thech & 0xFF);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,FillBuffer,The following statement contains a magic number: bsLive += 8;
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsGetUChar,The following statement contains a magic number: return (char)BsR(8);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsGetInt32,The following statement contains a magic number: int result = BsR(8);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR(8);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR(8);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR(8);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR(8);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR(8);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR(8);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: bool[] inUse16 = new bool[16];
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: i < 16
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: inUse[i * 16 + j] = (BsR(1) == 1);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: j < 16
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: i < 16
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: int alphaSize = nInUse + 2;
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: int nGroups = BsR(3);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: int nSelectors = BsR(15);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: int curr = BsR(5);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RecvDecodingTables,The following statement contains a magic number: int minLen = 32;
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: byte[] yy = new byte[256];
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: origPtr = BsGetIntVS(24);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: i <= 255
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: i <= 255
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: zn > 20
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SetupBlock,The following statement contains a magic number: int[] cftab = new int[257];
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SetupBlock,The following statement contains a magic number: Array.Copy(unzftab' 0' cftab' 1' 256);
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SetupBlock,The following statement contains a magic number: i <= 256
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SetupBlock,The following statement contains a magic number: ch2 = 256;
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SetupRandPartA,The following statement contains a magic number: rTPos == 512
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SetDecompressStructureSizes,The following statement contains a magic number: !(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k && blockSize100k <= 9)
Magic Number,Orvid.Compression.Streams,BZip2InputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SetDecompressStructureSizes,The following statement contains a magic number: !(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k && blockSize100k <= 9)
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BZip2OutputStream,The following statement contains a magic number: workFactor = 50;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BZip2OutputStream,The following statement contains a magic number: blockSize = 9;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BZip2OutputStream,The following statement contains a magic number: blockSize > 9
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,WriteByte,The following statement contains a magic number: int b = (256 + value) % 256;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,WriteByte,The following statement contains a magic number: int b = (256 + value) % 256;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,WriteByte,The following statement contains a magic number: runLength > 254
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MakeMaps,The following statement contains a magic number: i < 256
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,WriteRun,The following statement contains a magic number: switch (runLength)                  {                      case 1:                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      case 2:                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      case 3:                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      default:                          inUse[runLength - 4] = true;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)(runLength - 4);                          break;                  }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,WriteRun,The following statement contains a magic number: switch (runLength)                  {                      case 1:                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      case 2:                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      case 3:                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      default:                          inUse[runLength - 4] = true;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)(runLength - 4);                          break;                  }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,WriteRun,The following statement contains a magic number: switch (runLength)                  {                      case 1:                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      case 2:                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      case 3:                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      default:                          inUse[runLength - 4] = true;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)(runLength - 4);                          break;                  }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,WriteRun,The following statement contains a magic number: switch (runLength)                  {                      case 1:                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      case 2:                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      case 3:                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          break;                      default:                          inUse[runLength - 4] = true;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)currentChar;                          last++;                          block[last + 1] = (byte)(runLength - 4);                          break;                  }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,InitBlock,The following statement contains a magic number: i < 256
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,InitBlock,The following statement contains a magic number: allowableBlockSize = BZip2Constants.BaseBlockSize * blockSize100k - 20;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,EndBlock,The following statement contains a magic number: combinedCRC = (combinedCRC << 1) | (combinedCRC >> 31);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsFinishedWithStream,The following statement contains a magic number: int ch = (bsBuff >> 24);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsFinishedWithStream,The following statement contains a magic number: bsBuff <<= 8;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsFinishedWithStream,The following statement contains a magic number: bsLive -= 8;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsW,The following statement contains a magic number: int ch = (bsBuff >> 24);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsW,The following statement contains a magic number: bsBuff <<= 8;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsW,The following statement contains a magic number: bsLive -= 8;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsW,The following statement contains a magic number: bsLive >= 8
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsW,The following statement contains a magic number: bsBuff |= (v << (32 - bsLive - n));
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsPutUChar,The following statement contains a magic number: BsW(8' c);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 24) & 0xFF);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 24) & 0xFF);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 16) & 0xFF);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 16) & 0xFF);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 8) & 0xFF);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 8) & 0xFF);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,BsPutint,The following statement contains a magic number: BsW(8' u & 0xFF);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: alphaSize = nInUse + 2;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: nGroups = 2;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: nMTF < 200
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1)
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: cost2 += (short)len[2][icv];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: cost3 += (short)len[3][icv];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: cost4 += (short)len[4][icv];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: cost5 += (short)len[5][icv];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: cost[2] = cost2;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: cost[3] = cost3;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: cost[4] = cost4;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: cost[5] = cost5;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: nGroups == 6
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: bc = 999999999;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: !(nGroups < 8)
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: !(nSelectors < 32768 && nSelectors <= (2 + (900000 / BZip2Constants.GroupSize)))
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: !(nSelectors < 32768 && nSelectors <= (2 + (900000 / BZip2Constants.GroupSize)))
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: !(nSelectors < 32768 && nSelectors <= (2 + (900000 / BZip2Constants.GroupSize)))
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: minLen = 32;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: maxLen > 20
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: bool[] inUse16 = new bool[16];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: inUse[i * 16 + j]
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: j < 16
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: i < 16
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: i < 16
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: inUse[i * 16 + j]
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: j < 16
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: i < 16
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: BsW(3' nGroups);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: BsW(15' nSelectors);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: BsW(5' curr);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: BsW(2' 2);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: BsW(2' 2);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: BsW(2' 3);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SendMTFValues,The following statement contains a magic number: BsW(2' 3);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MoveToFrontCodeAndSend,The following statement contains a magic number: BsPutIntVS(24' origPtr);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,SimpleSort,The following statement contains a magic number: bigN < 2
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: int[] runningOrder = new int[256];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: int[] copy = new int[256];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: bool[] bigDone = new bool[256];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: block[last + i + 2] = block[(i % (last + 1)) + 1];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,MainSort,The following statement contains a magic number: last < 4000
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RandomiseBlock,The following statement contains a magic number: i < 256
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,RandomiseBlock,The following statement contains a magic number: rTPos == 512
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,FullGtU,The following statement contains a magic number: k -= 4;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,AllocateCompressStructures,The following statement contains a magic number: ftab = new int[65537];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,AllocateCompressStructures,The following statement contains a magic number: szptr = new short[2 * n];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The following statement contains a magic number: char[] yy = new char[256];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The following statement contains a magic number: switch (zPend % 2)                      {                          case 0:                              szptr[wr] = (short)BZip2Constants.RunA;                              wr++;                              mtfFreq[BZip2Constants.RunA]++;                              break;                          case 1:                              szptr[wr] = (short)BZip2Constants.RunB;                              wr++;                              mtfFreq[BZip2Constants.RunB]++;                              break;                      }
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The following statement contains a magic number: zPend < 2
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The following statement contains a magic number: zPend = (zPend - 2) / 2;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The following statement contains a magic number: zPend = (zPend - 2) / 2;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: int[] heap = new int[BZip2Constants.MaximumAlphaSize + 2];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: int[] weight = new int[BZip2Constants.MaximumAlphaSize * 2];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: int[] parent = new int[BZip2Constants.MaximumAlphaSize * 2];
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: parent[0] = -2;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: !(nHeap < (BZip2Constants.MaximumAlphaSize + 2))
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: !(nNodes < (BZip2Constants.MaximumAlphaSize * 2))
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: j = weight[i] >> 8;
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: j = 1 + (j / 2);
Magic Number,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,HbMakeCodeLengths,The following statement contains a magic number: weight[i] = j << 8;
Magic Number,Orvid.Compression.Streams,DeflaterOutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterOutputStream,The following statement contains a magic number: bufferSize < 512
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: byte[] codeLengths = new byte[288];
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths[i++] = 8;
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: i < 144
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths[i++] = 9;
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: i < 256
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths[i++] = 7;
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: i < 280
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths[i++] = 8;
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: i < 288
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths = new byte[32];
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths[i++] = 5;
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterHuffmanTree,The following statement contains a magic number: i < 32
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: int treeSize = 512;
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: code += blCount[bits] << (16 - bits);
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: treeSize += (end - start) >> (16 - bits);
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: bits >= 10
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: int treePtr = 512;
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: code -= blCount[bits] << (16 - bits);
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: tree[DeflaterHuffman.BitReverse(i)] = (short)((-treePtr << 4) | bits);
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: treePtr += 1 << (bits - 9);
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: bits >= 10
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: tree[revcode] = (short)((i << 4) | bits);
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: bits <= 9
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: nextCode[bits] = code + (1 << (16 - bits));
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: input.DropBits(symbol & 15);
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: int subtree = -(symbol >> 4);
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: int bitlen = symbol & 15;
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: symbol = tree[subtree | (lookahead >> 9)];
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: input.DropBits(symbol & 15);
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;
Magic Number,Orvid.Compression.Streams,InflaterHuffmanTree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,GetSymbol,The following statement contains a magic number: (lookahead = input.PeekBits(9)) >= 0
Magic Number,Orvid.Compression.Streams,StreamManipulator,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,PeekBits,The following statement contains a magic number: buffer_ |= (uint)((window_[windowStart_++] & 0xff |                                   (window_[windowStart_++] & 0xff) << 8) << bitsInBuffer_);
Magic Number,Orvid.Compression.Streams,StreamManipulator,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,PeekBits,The following statement contains a magic number: bitsInBuffer_ += 16;
Magic Number,Orvid.Compression.Streams,StreamManipulator,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SkipToByteBoundary,The following statement contains a magic number: buffer_ >>= (bitsInBuffer_ & 7);
Magic Number,Orvid.Compression.Streams,StreamManipulator,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SkipToByteBoundary,The following statement contains a magic number: bitsInBuffer_ &= ~7;
Magic Number,Orvid.Compression.Streams,StreamManipulator,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CopyBytes,The following statement contains a magic number: (bitsInBuffer_ & 7) != 0
Magic Number,Orvid.Compression.Streams,StreamManipulator,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CopyBytes,The following statement contains a magic number: buffer_ >>= 8;
Magic Number,Orvid.Compression.Streams,StreamManipulator,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CopyBytes,The following statement contains a magic number: bitsInBuffer_ -= 8;
Magic Number,Orvid.Compression.Streams,StreamManipulator,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CopyBytes,The following statement contains a magic number: bitsInBuffer_ = 8;
Magic Number,Orvid.Compression.Streams,StreamManipulator,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SetInput,The following statement contains a magic number: bitsInBuffer_ += 8;
Magic Number,Orvid.Compression.Streams,PendingBuffer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteShort,The following statement contains a magic number: buffer_[end++] = unchecked((byte)(value >> 8));
Magic Number,Orvid.Compression.Streams,PendingBuffer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteInt,The following statement contains a magic number: buffer_[end++] = unchecked((byte)(value >> 8));
Magic Number,Orvid.Compression.Streams,PendingBuffer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteInt,The following statement contains a magic number: buffer_[end++] = unchecked((byte)(value >> 16));
Magic Number,Orvid.Compression.Streams,PendingBuffer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteInt,The following statement contains a magic number: buffer_[end++] = unchecked((byte)(value >> 24));
Magic Number,Orvid.Compression.Streams,PendingBuffer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,AlignToByte,The following statement contains a magic number: buffer_[end++] = unchecked((byte)(bits >> 8));
Magic Number,Orvid.Compression.Streams,PendingBuffer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,AlignToByte,The following statement contains a magic number: bitCount > 8
Magic Number,Orvid.Compression.Streams,PendingBuffer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteBits,The following statement contains a magic number: buffer_[end++] = unchecked((byte)(bits >> 8));
Magic Number,Orvid.Compression.Streams,PendingBuffer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteBits,The following statement contains a magic number: bits >>= 16;
Magic Number,Orvid.Compression.Streams,PendingBuffer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteBits,The following statement contains a magic number: bitCount -= 16;
Magic Number,Orvid.Compression.Streams,PendingBuffer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteBits,The following statement contains a magic number: bitCount >= 16
Magic Number,Orvid.Compression.Streams,PendingBuffer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteShortMSB,The following statement contains a magic number: buffer_[end++] = unchecked((byte)(s >> 8));
Magic Number,Orvid.Compression.Streams,PendingBuffer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Flush,The following statement contains a magic number: bits >>= 8;
Magic Number,Orvid.Compression.Streams,PendingBuffer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Flush,The following statement contains a magic number: bitCount -= 8;
Magic Number,Orvid.Compression.Streams,PendingBuffer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Flush,The following statement contains a magic number: bitCount >= 8
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes[i] = BitReverse((0x030 + i) << 8);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength[i++] = 8;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: i < 144
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength[i++] = 9;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: i < 256
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength[i++] = 7;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: i < 280
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes[i] = BitReverse((0x0c0 - 280 + i) << 8);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes[i] = BitReverse((0x0c0 - 280 + i) << 8);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength[i++] = 8;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: staticDCodes[i] = BitReverse(i << 11);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: staticDLength[i] = 5;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree(this' LITERAL_NUM' 257' 15);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree(this' LITERAL_NUM' 257' 15);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: distTree = new Tree(this' DIST_NUM' 1' 15);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree(this' BITLEN_NUM' 4' 7);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree(this' BITLEN_NUM' 4' 7);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(literalTree.numCodes - 257' 5);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(literalTree.numCodes - 257' 5);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(distTree.numCodes - 1' 5);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(blTreeCodes - 4' 4);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(blTreeCodes - 4' 4);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(blTree.length[BL_ORDER[rank]]' 3);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CompressBlock,The following statement contains a magic number: int bits = (lc - 261) / 4;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CompressBlock,The following statement contains a magic number: int bits = (lc - 261) / 4;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CompressBlock,The following statement contains a magic number: bits > 0 && bits <= 5
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CompressBlock,The following statement contains a magic number: bits = dc / 2 - 1;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FlushStoredBlock,The following statement contains a magic number: pending.WriteBits((DeflaterConstants.STORED_BLOCK << 1) + (lastBlock ? 1 : 0)' 3);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FlushBlock,The following statement contains a magic number: int blTreeCodes = 4;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FlushBlock,The following statement contains a magic number: int opt_len = 14 + blTreeCodes * 3 + blTree.GetEncodedLength() +                  literalTree.GetEncodedLength() + distTree.GetEncodedLength() +                  extra_bits;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FlushBlock,The following statement contains a magic number: int opt_len = 14 + blTreeCodes * 3 + blTree.GetEncodedLength() +                  literalTree.GetEncodedLength() + distTree.GetEncodedLength() +                  extra_bits;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FlushBlock,The following statement contains a magic number: storedOffset >= 0 && storedLength + 4 < opt_len >> 3
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FlushBlock,The following statement contains a magic number: storedOffset >= 0 && storedLength + 4 < opt_len >> 3
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,TallyDist,The following statement contains a magic number: l_buf[last_lit++] = (byte)(length - 3);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,TallyDist,The following statement contains a magic number: int lc = Lcode(length - 3);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,TallyDist,The following statement contains a magic number: extra_bits += (lc - 261) / 4;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,TallyDist,The following statement contains a magic number: extra_bits += (lc - 261) / 4;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,TallyDist,The following statement contains a magic number: lc >= 265 && lc < 285
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,TallyDist,The following statement contains a magic number: lc >= 265 && lc < 285
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,TallyDist,The following statement contains a magic number: extra_bits += dc / 2 - 1;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,TallyDist,The following statement contains a magic number: dc >= 4
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse[toReverse & 0xF] << 12 |                              bit4Reverse[(toReverse >> 4) & 0xF] << 8 |                              bit4Reverse[(toReverse >> 8) & 0xF] << 4 |                              bit4Reverse[toReverse >> 12]);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse[toReverse & 0xF] << 12 |                              bit4Reverse[(toReverse >> 4) & 0xF] << 8 |                              bit4Reverse[(toReverse >> 8) & 0xF] << 4 |                              bit4Reverse[toReverse >> 12]);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse[toReverse & 0xF] << 12 |                              bit4Reverse[(toReverse >> 4) & 0xF] << 8 |                              bit4Reverse[(toReverse >> 8) & 0xF] << 4 |                              bit4Reverse[toReverse >> 12]);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse[toReverse & 0xF] << 12 |                              bit4Reverse[(toReverse >> 4) & 0xF] << 8 |                              bit4Reverse[(toReverse >> 8) & 0xF] << 4 |                              bit4Reverse[toReverse >> 12]);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse[toReverse & 0xF] << 12 |                              bit4Reverse[(toReverse >> 4) & 0xF] << 8 |                              bit4Reverse[(toReverse >> 8) & 0xF] << 4 |                              bit4Reverse[toReverse >> 12]);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse[toReverse & 0xF] << 12 |                              bit4Reverse[(toReverse >> 4) & 0xF] << 8 |                              bit4Reverse[(toReverse >> 8) & 0xF] << 4 |                              bit4Reverse[toReverse >> 12]);
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Lcode,The following statement contains a magic number: return 285;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Lcode,The following statement contains a magic number: length == 255
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Lcode,The following statement contains a magic number: int code = 257;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Lcode,The following statement contains a magic number: code += 4;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Lcode,The following statement contains a magic number: length >= 8
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Dcode,The following statement contains a magic number: code += 2;
Magic Number,Orvid.Compression.Streams,DeflaterHuffman,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Dcode,The following statement contains a magic number: distance >= 4
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildCodes,The following statement contains a magic number: code += bl_counts[bits] << (15 - bits);
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildCodes,The following statement contains a magic number: nextCode[bits - 1] += 1 << (16 - bits);
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: pos > 0 && freqs[heap[ppos = (pos - 1) / 2]] > freq
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: int node = maxCode < 2 ? ++maxCode : 0;
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: heapLen < 2
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: int[] childs = new int[4 * heapLen - 2];
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: int[] childs = new int[4 * heapLen - 2];
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: int[] values = new int[2 * heapLen - 1];
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: childs[2 * i] = node;
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: childs[2 * i + 1] = -1;
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: values[i] = freqs[node] << 8;
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: path = path * 2 + 1;
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: (path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: childs[2 * last] = first;
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: childs[2 * last + 1] = second;
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: path = ppos * 2 + 1;
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: (path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildTree,The following statement contains a magic number: heap[0] != childs.Length / 2 - 1
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CalcBLFreq,The following statement contains a magic number: max_count = 138;
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,CalcBLFreq,The following statement contains a magic number: min_count = 3;
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteTree,The following statement contains a magic number: max_count = 138;
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,WriteTree,The following statement contains a magic number: min_count = 3;
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildLength,The following statement contains a magic number: int numNodes = childs.Length / 2;
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildLength,The following statement contains a magic number: int numLeafs = (numNodes + 1) / 2;
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildLength,The following statement contains a magic number: lengths[childs[2 * i]] = lengths[childs[2 * i + 1]] = bitLength;
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildLength,The following statement contains a magic number: lengths[childs[2 * i]] = lengths[childs[2 * i + 1]] = bitLength;
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildLength,The following statement contains a magic number: childs[2 * i + 1] != -1
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildLength,The following statement contains a magic number: bl_counts[maxLength - 2] -= overflow;
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildLength,The following statement contains a magic number: int nodePtr = 2 * numLeafs;
Magic Number,Orvid.Compression.Streams,Tree,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,BuildLength,The following statement contains a magic number: int childPtr = 2 * childs[nodePtr++];
Magic Number,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflaterEngine,The following statement contains a magic number: window = new byte[2 * WSIZE];
Magic Number,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SetDictionary,The following statement contains a magic number: strstart += 2;
Magic Number,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SetLevel,The following statement contains a magic number: (level < 0) || (level > 9)
Magic Number,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FillWindow,The following statement contains a magic number: int more = 2 * WSIZE - lookahead - strstart;
Magic Number,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FindLongestMatch,The following statement contains a magic number: chainLength >>= 2;
Magic Number,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FindLongestMatch,The following statement contains a magic number: match = curMatch + 2;
Magic Number,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,FindLongestMatch,The following statement contains a magic number: scan += 2;
Magic Number,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateFast,The following statement contains a magic number: strstart > 2 * WSIZE - MIN_LOOKAHEAD
Magic Number,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateSlow,The following statement contains a magic number: strstart >= 2 * WSIZE - MIN_LOOKAHEAD
Magic Number,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateSlow,The following statement contains a magic number: matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))
Magic Number,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DeflateSlow,The following statement contains a magic number: prevLen -= 2;
Magic Number,Orvid.Compression.Streams,Deflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflater,The following statement contains a magic number: level = 6;
Magic Number,Orvid.Compression.Streams,Deflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SetLevel,The following statement contains a magic number: level = 6;
Magic Number,Orvid.Compression.Streams,Deflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: int header = (DEFLATED +                      ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;
Magic Number,Orvid.Compression.Streams,Deflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: int header = (DEFLATED +                      ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;
Magic Number,Orvid.Compression.Streams,Deflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: int header = (DEFLATED +                      ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;
Magic Number,Orvid.Compression.Streams,Deflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: level_flags = 3;
Magic Number,Orvid.Compression.Streams,Deflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: level_flags < 0 || level_flags > 3
Magic Number,Orvid.Compression.Streams,Deflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: header |= level_flags << 6;
Magic Number,Orvid.Compression.Streams,Deflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);
Magic Number,Orvid.Compression.Streams,Deflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);
Magic Number,Orvid.Compression.Streams,Deflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Deflate,The following statement contains a magic number: pending.WriteShortMSB(chksum >> 16);
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHeader,The following statement contains a magic number: int header = input.PeekBits(16);
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHeader,The following statement contains a magic number: input.DropBits(16);
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHeader,The following statement contains a magic number: header % 31 != 0
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHeader,The following statement contains a magic number: (header & 0x0f00) != (Deflater.DEFLATED << 8)
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeDict,The following statement contains a magic number: int dictByte = input.PeekBits(8);
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeDict,The following statement contains a magic number: input.DropBits(8);
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeDict,The following statement contains a magic number: readAdler = (readAdler << 8) | dictByte;
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeDict,The following statement contains a magic number: neededBits -= 8;
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHuffman,The following statement contains a magic number: switch (mode)                  {                      case DECODE_HUFFMAN:                          // This is the inner loop so it is optimized a bit                          while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)                          {                              outputWindow.Write(symbol);                              if (--free < 258)                              {                                  return true;                              }                          }                            if (symbol < 257)                          {                              if (symbol < 0)                              {                                  return false;                              }                              else                              {                                  // symbol == 256: end of block                                  distTree = null;                                  litlenTree = null;                                  mode = DECODE_BLOCKS;                                  return true;                              }                          }                            try                          {                              repLength = CPLENS[symbol - 257];                              neededBits = CPLEXT[symbol - 257];                          }                          catch (Exception)                          {                              throw new Exception("Illegal rep length code");                          }                          goto case DECODE_HUFFMAN_LENBITS; // fall through                        case DECODE_HUFFMAN_LENBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_LENBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repLength += i;                          }                          mode = DECODE_HUFFMAN_DIST;                          goto case DECODE_HUFFMAN_DIST; // fall through                        case DECODE_HUFFMAN_DIST:                          symbol = distTree.GetSymbol(input);                          if (symbol < 0)                          {                              return false;                          }                            try                          {                              repDist = CPDIST[symbol];                              neededBits = CPDEXT[symbol];                          }                          catch (Exception)                          {                              throw new Exception("Illegal rep dist code");                          }                            goto case DECODE_HUFFMAN_DISTBITS; // fall through                        case DECODE_HUFFMAN_DISTBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_DISTBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repDist += i;                          }                            outputWindow.Repeat(repLength' repDist);                          free -= repLength;                          mode = DECODE_HUFFMAN;                          break;                        default:                          throw new Exception("Inflater unknown mode");                  }
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHuffman,The following statement contains a magic number: switch (mode)                  {                      case DECODE_HUFFMAN:                          // This is the inner loop so it is optimized a bit                          while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)                          {                              outputWindow.Write(symbol);                              if (--free < 258)                              {                                  return true;                              }                          }                            if (symbol < 257)                          {                              if (symbol < 0)                              {                                  return false;                              }                              else                              {                                  // symbol == 256: end of block                                  distTree = null;                                  litlenTree = null;                                  mode = DECODE_BLOCKS;                                  return true;                              }                          }                            try                          {                              repLength = CPLENS[symbol - 257];                              neededBits = CPLEXT[symbol - 257];                          }                          catch (Exception)                          {                              throw new Exception("Illegal rep length code");                          }                          goto case DECODE_HUFFMAN_LENBITS; // fall through                        case DECODE_HUFFMAN_LENBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_LENBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repLength += i;                          }                          mode = DECODE_HUFFMAN_DIST;                          goto case DECODE_HUFFMAN_DIST; // fall through                        case DECODE_HUFFMAN_DIST:                          symbol = distTree.GetSymbol(input);                          if (symbol < 0)                          {                              return false;                          }                            try                          {                              repDist = CPDIST[symbol];                              neededBits = CPDEXT[symbol];                          }                          catch (Exception)                          {                              throw new Exception("Illegal rep dist code");                          }                            goto case DECODE_HUFFMAN_DISTBITS; // fall through                        case DECODE_HUFFMAN_DISTBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_DISTBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repDist += i;                          }                            outputWindow.Repeat(repLength' repDist);                          free -= repLength;                          mode = DECODE_HUFFMAN;                          break;                        default:                          throw new Exception("Inflater unknown mode");                  }
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHuffman,The following statement contains a magic number: switch (mode)                  {                      case DECODE_HUFFMAN:                          // This is the inner loop so it is optimized a bit                          while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)                          {                              outputWindow.Write(symbol);                              if (--free < 258)                              {                                  return true;                              }                          }                            if (symbol < 257)                          {                              if (symbol < 0)                              {                                  return false;                              }                              else                              {                                  // symbol == 256: end of block                                  distTree = null;                                  litlenTree = null;                                  mode = DECODE_BLOCKS;                                  return true;                              }                          }                            try                          {                              repLength = CPLENS[symbol - 257];                              neededBits = CPLEXT[symbol - 257];                          }                          catch (Exception)                          {                              throw new Exception("Illegal rep length code");                          }                          goto case DECODE_HUFFMAN_LENBITS; // fall through                        case DECODE_HUFFMAN_LENBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_LENBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repLength += i;                          }                          mode = DECODE_HUFFMAN_DIST;                          goto case DECODE_HUFFMAN_DIST; // fall through                        case DECODE_HUFFMAN_DIST:                          symbol = distTree.GetSymbol(input);                          if (symbol < 0)                          {                              return false;                          }                            try                          {                              repDist = CPDIST[symbol];                              neededBits = CPDEXT[symbol];                          }                          catch (Exception)                          {                              throw new Exception("Illegal rep dist code");                          }                            goto case DECODE_HUFFMAN_DISTBITS; // fall through                        case DECODE_HUFFMAN_DISTBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_DISTBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repDist += i;                          }                            outputWindow.Repeat(repLength' repDist);                          free -= repLength;                          mode = DECODE_HUFFMAN;                          break;                        default:                          throw new Exception("Inflater unknown mode");                  }
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHuffman,The following statement contains a magic number: switch (mode)                  {                      case DECODE_HUFFMAN:                          // This is the inner loop so it is optimized a bit                          while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)                          {                              outputWindow.Write(symbol);                              if (--free < 258)                              {                                  return true;                              }                          }                            if (symbol < 257)                          {                              if (symbol < 0)                              {                                  return false;                              }                              else                              {                                  // symbol == 256: end of block                                  distTree = null;                                  litlenTree = null;                                  mode = DECODE_BLOCKS;                                  return true;                              }                          }                            try                          {                              repLength = CPLENS[symbol - 257];                              neededBits = CPLEXT[symbol - 257];                          }                          catch (Exception)                          {                              throw new Exception("Illegal rep length code");                          }                          goto case DECODE_HUFFMAN_LENBITS; // fall through                        case DECODE_HUFFMAN_LENBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_LENBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repLength += i;                          }                          mode = DECODE_HUFFMAN_DIST;                          goto case DECODE_HUFFMAN_DIST; // fall through                        case DECODE_HUFFMAN_DIST:                          symbol = distTree.GetSymbol(input);                          if (symbol < 0)                          {                              return false;                          }                            try                          {                              repDist = CPDIST[symbol];                              neededBits = CPDEXT[symbol];                          }                          catch (Exception)                          {                              throw new Exception("Illegal rep dist code");                          }                            goto case DECODE_HUFFMAN_DISTBITS; // fall through                        case DECODE_HUFFMAN_DISTBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_DISTBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repDist += i;                          }                            outputWindow.Repeat(repLength' repDist);                          free -= repLength;                          mode = DECODE_HUFFMAN;                          break;                        default:                          throw new Exception("Inflater unknown mode");                  }
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeHuffman,The following statement contains a magic number: free >= 258
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeChksum,The following statement contains a magic number: int chkByte = input.PeekBits(8);
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeChksum,The following statement contains a magic number: input.DropBits(8);
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeChksum,The following statement contains a magic number: readAdler = (readAdler << 8) | chkByte;
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,DecodeChksum,The following statement contains a magic number: neededBits -= 8;
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          else                          {                              input.SkipToByteBoundary();                              neededBits = 32;                              mode = DECODE_CHKSUM;                              return true;                          }                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new Exception("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                      {                          if ((uncomprLen = input.PeekBits(16)) < 0)                          {                              return false;                          }                          input.DropBits(16);                          mode = DECODE_STORED_LEN2;                      }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                      {                          int nlen = input.PeekBits(16);                          if (nlen < 0)                          {                              return false;                          }                          input.DropBits(16);                          if (nlen != (uncomprLen ^ 0xffff))                          {                              throw new Exception("broken uncompressed block");                          }                          mode = DECODE_STORED;                      }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                      {                          int more = outputWindow.CopyStored(input' uncomprLen);                          uncomprLen -= more;                          if (uncomprLen == 0)                          {                              mode = DECODE_BLOCKS;                              return true;                          }                          return !input.IsNeedingInput;                      }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new Exception("Inflater.Decode unknown mode");              }
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          else                          {                              input.SkipToByteBoundary();                              neededBits = 32;                              mode = DECODE_CHKSUM;                              return true;                          }                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new Exception("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                      {                          if ((uncomprLen = input.PeekBits(16)) < 0)                          {                              return false;                          }                          input.DropBits(16);                          mode = DECODE_STORED_LEN2;                      }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                      {                          int nlen = input.PeekBits(16);                          if (nlen < 0)                          {                              return false;                          }                          input.DropBits(16);                          if (nlen != (uncomprLen ^ 0xffff))                          {                              throw new Exception("broken uncompressed block");                          }                          mode = DECODE_STORED;                      }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                      {                          int more = outputWindow.CopyStored(input' uncomprLen);                          uncomprLen -= more;                          if (uncomprLen == 0)                          {                              mode = DECODE_BLOCKS;                              return true;                          }                          return !input.IsNeedingInput;                      }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new Exception("Inflater.Decode unknown mode");              }
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          else                          {                              input.SkipToByteBoundary();                              neededBits = 32;                              mode = DECODE_CHKSUM;                              return true;                          }                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new Exception("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                      {                          if ((uncomprLen = input.PeekBits(16)) < 0)                          {                              return false;                          }                          input.DropBits(16);                          mode = DECODE_STORED_LEN2;                      }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                      {                          int nlen = input.PeekBits(16);                          if (nlen < 0)                          {                              return false;                          }                          input.DropBits(16);                          if (nlen != (uncomprLen ^ 0xffff))                          {                              throw new Exception("broken uncompressed block");                          }                          mode = DECODE_STORED;                      }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                      {                          int more = outputWindow.CopyStored(input' uncomprLen);                          uncomprLen -= more;                          if (uncomprLen == 0)                          {                              mode = DECODE_BLOCKS;                              return true;                          }                          return !input.IsNeedingInput;                      }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new Exception("Inflater.Decode unknown mode");              }
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          else                          {                              input.SkipToByteBoundary();                              neededBits = 32;                              mode = DECODE_CHKSUM;                              return true;                          }                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new Exception("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                      {                          if ((uncomprLen = input.PeekBits(16)) < 0)                          {                              return false;                          }                          input.DropBits(16);                          mode = DECODE_STORED_LEN2;                      }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                      {                          int nlen = input.PeekBits(16);                          if (nlen < 0)                          {                              return false;                          }                          input.DropBits(16);                          if (nlen != (uncomprLen ^ 0xffff))                          {                              throw new Exception("broken uncompressed block");                          }                          mode = DECODE_STORED;                      }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                      {                          int more = outputWindow.CopyStored(input' uncomprLen);                          uncomprLen -= more;                          if (uncomprLen == 0)                          {                              mode = DECODE_BLOCKS;                              return true;                          }                          return !input.IsNeedingInput;                      }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new Exception("Inflater.Decode unknown mode");              }
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          else                          {                              input.SkipToByteBoundary();                              neededBits = 32;                              mode = DECODE_CHKSUM;                              return true;                          }                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new Exception("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                      {                          if ((uncomprLen = input.PeekBits(16)) < 0)                          {                              return false;                          }                          input.DropBits(16);                          mode = DECODE_STORED_LEN2;                      }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                      {                          int nlen = input.PeekBits(16);                          if (nlen < 0)                          {                              return false;                          }                          input.DropBits(16);                          if (nlen != (uncomprLen ^ 0xffff))                          {                              throw new Exception("broken uncompressed block");                          }                          mode = DECODE_STORED;                      }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                      {                          int more = outputWindow.CopyStored(input' uncomprLen);                          uncomprLen -= more;                          if (uncomprLen == 0)                          {                              mode = DECODE_BLOCKS;                              return true;                          }                          return !input.IsNeedingInput;                      }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new Exception("Inflater.Decode unknown mode");              }
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          else                          {                              input.SkipToByteBoundary();                              neededBits = 32;                              mode = DECODE_CHKSUM;                              return true;                          }                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new Exception("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                      {                          if ((uncomprLen = input.PeekBits(16)) < 0)                          {                              return false;                          }                          input.DropBits(16);                          mode = DECODE_STORED_LEN2;                      }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                      {                          int nlen = input.PeekBits(16);                          if (nlen < 0)                          {                              return false;                          }                          input.DropBits(16);                          if (nlen != (uncomprLen ^ 0xffff))                          {                              throw new Exception("broken uncompressed block");                          }                          mode = DECODE_STORED;                      }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                      {                          int more = outputWindow.CopyStored(input' uncomprLen);                          uncomprLen -= more;                          if (uncomprLen == 0)                          {                              mode = DECODE_BLOCKS;                              return true;                          }                          return !input.IsNeedingInput;                      }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new Exception("Inflater.Decode unknown mode");              }
Magic Number,Orvid.Compression.Streams,Inflater,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          else                          {                              input.SkipToByteBoundary();                              neededBits = 32;                              mode = DECODE_CHKSUM;                              return true;                          }                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new Exception("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                      {                          if ((uncomprLen = input.PeekBits(16)) < 0)                          {                              return false;                          }                          input.DropBits(16);                          mode = DECODE_STORED_LEN2;                      }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                      {                          int nlen = input.PeekBits(16);                          if (nlen < 0)                          {                              return false;                          }                          input.DropBits(16);                          if (nlen != (uncomprLen ^ 0xffff))                          {                              throw new Exception("broken uncompressed block");                          }                          mode = DECODE_STORED;                      }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                      {                          int more = outputWindow.CopyStored(input' uncomprLen);                          uncomprLen -= more;                          if (uncomprLen == 0)                          {                              mode = DECODE_BLOCKS;                              return true;                          }                          return !input.IsNeedingInput;                      }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new Exception("Inflater.Decode unknown mode");              }
Magic Number,Orvid.Compression.Streams,InflaterInputBuffer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterInputBuffer,The following statement contains a magic number: bufferSize = 1024;
Magic Number,Orvid.Compression.Streams,InflaterInputBuffer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,InflaterInputBuffer,The following statement contains a magic number: bufferSize < 1024
Magic Number,Orvid.Compression.Streams,InflaterInputBuffer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,ReadLeShort,The following statement contains a magic number: return ReadLeByte() | (ReadLeByte() << 8);
Magic Number,Orvid.Compression.Streams,InflaterInputBuffer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,ReadLeInt,The following statement contains a magic number: return ReadLeShort() | (ReadLeShort() << 16);
Magic Number,Orvid.Compression.Streams,InflaterInputBuffer,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,ReadLeLong,The following statement contains a magic number: return (uint)ReadLeInt() | ((long)ReadLeInt() << 32);
Magic Number,Orvid.Compression.Streams,GZipOutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,Finish,The following statement contains a magic number: gzipFooter = new byte[] {  					(byte) crcval' (byte) (crcval >> 8)'  					(byte) (crcval >> 16)' (byte) (crcval >> 24)'  					  					(byte) totalin' (byte) (totalin >> 8)'  					(byte) (totalin >> 16)' (byte) (totalin >> 24)  				};
Magic Number,Orvid.Compression.Streams,GZipOutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,Finish,The following statement contains a magic number: gzipFooter = new byte[] {  					(byte) crcval' (byte) (crcval >> 8)'  					(byte) (crcval >> 16)' (byte) (crcval >> 24)'  					  					(byte) totalin' (byte) (totalin >> 8)'  					(byte) (totalin >> 16)' (byte) (totalin >> 24)  				};
Magic Number,Orvid.Compression.Streams,GZipOutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,Finish,The following statement contains a magic number: gzipFooter = new byte[] {  					(byte) crcval' (byte) (crcval >> 8)'  					(byte) (crcval >> 16)' (byte) (crcval >> 24)'  					  					(byte) totalin' (byte) (totalin >> 8)'  					(byte) (totalin >> 16)' (byte) (totalin >> 24)  				};
Magic Number,Orvid.Compression.Streams,GZipOutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,Finish,The following statement contains a magic number: gzipFooter = new byte[] {  					(byte) crcval' (byte) (crcval >> 8)'  					(byte) (crcval >> 16)' (byte) (crcval >> 24)'  					  					(byte) totalin' (byte) (totalin >> 8)'  					(byte) (totalin >> 16)' (byte) (totalin >> 24)  				};
Magic Number,Orvid.Compression.Streams,GZipOutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,Finish,The following statement contains a magic number: gzipFooter = new byte[] {  					(byte) crcval' (byte) (crcval >> 8)'  					(byte) (crcval >> 16)' (byte) (crcval >> 24)'  					  					(byte) totalin' (byte) (totalin >> 8)'  					(byte) (totalin >> 16)' (byte) (totalin >> 24)  				};
Magic Number,Orvid.Compression.Streams,GZipOutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,Finish,The following statement contains a magic number: gzipFooter = new byte[] {  					(byte) crcval' (byte) (crcval >> 8)'  					(byte) (crcval >> 16)' (byte) (crcval >> 24)'  					  					(byte) totalin' (byte) (totalin >> 8)'  					(byte) (totalin >> 16)' (byte) (totalin >> 24)  				};
Magic Number,Orvid.Compression.Streams,GZipOutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,WriteHeader,The following statement contains a magic number: int mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);
Magic Number,Orvid.Compression.Streams,GZipOutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,WriteHeader,The following statement contains a magic number: int mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);
Magic Number,Orvid.Compression.Streams,GZipOutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,WriteHeader,The following statement contains a magic number: byte[] gzipHeader = {  					(byte) (0x1F8B >> 8)' (byte) (0x1F8B & 0xff)'  					(byte) Deflater.DEFLATED'  					0'  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'  					0'  					(byte) 255  				};
Magic Number,Orvid.Compression.Streams,GZipOutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,WriteHeader,The following statement contains a magic number: byte[] gzipHeader = {  					(byte) (0x1F8B >> 8)' (byte) (0x1F8B & 0xff)'  					(byte) Deflater.DEFLATED'  					0'  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'  					0'  					(byte) 255  				};
Magic Number,Orvid.Compression.Streams,GZipOutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,WriteHeader,The following statement contains a magic number: byte[] gzipHeader = {  					(byte) (0x1F8B >> 8)' (byte) (0x1F8B & 0xff)'  					(byte) Deflater.DEFLATED'  					0'  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'  					0'  					(byte) 255  				};
Magic Number,Orvid.Compression.Streams,GZipOutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,WriteHeader,The following statement contains a magic number: byte[] gzipHeader = {  					(byte) (0x1F8B >> 8)' (byte) (0x1F8B & 0xff)'  					(byte) Deflater.DEFLATED'  					0'  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'  					0'  					(byte) 255  				};
Magic Number,Orvid.Compression.Streams,GZipOutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,WriteHeader,The following statement contains a magic number: byte[] gzipHeader = {  					(byte) (0x1F8B >> 8)' (byte) (0x1F8B & 0xff)'  					(byte) Deflater.DEFLATED'  					0'  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'  					0'  					(byte) 255  				};
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadHeader,The following statement contains a magic number: magic != (0x1F8B >> 8)
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadHeader,The following statement contains a magic number: compressionType != 8
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadHeader,The following statement contains a magic number: i < 6
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadHeader,The following statement contains a magic number: i < 2
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadHeader,The following statement contains a magic number: int extraLen = (len1 << 8) | len2;
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadHeader,The following statement contains a magic number: crcval = (crcval << 8) | tempByte;
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: byte[] footer = new byte[8];
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: int needed = 8;
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: int count = inputBuffer.ReadClearTextBuffer(footer' 8 - needed' needed);
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: uint total =                  (uint)((uint)footer[4] & 0xff) |                  (uint)(((uint)footer[5] & 0xff) << 8) |                  (uint)(((uint)footer[6] & 0xff) << 16) |                  (uint)((uint)footer[7] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: uint total =                  (uint)((uint)footer[4] & 0xff) |                  (uint)(((uint)footer[5] & 0xff) << 8) |                  (uint)(((uint)footer[6] & 0xff) << 16) |                  (uint)((uint)footer[7] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: uint total =                  (uint)((uint)footer[4] & 0xff) |                  (uint)(((uint)footer[5] & 0xff) << 8) |                  (uint)(((uint)footer[6] & 0xff) << 16) |                  (uint)((uint)footer[7] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: uint total =                  (uint)((uint)footer[4] & 0xff) |                  (uint)(((uint)footer[5] & 0xff) << 8) |                  (uint)(((uint)footer[6] & 0xff) << 16) |                  (uint)((uint)footer[7] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: uint total =                  (uint)((uint)footer[4] & 0xff) |                  (uint)(((uint)footer[5] & 0xff) << 8) |                  (uint)(((uint)footer[6] & 0xff) << 16) |                  (uint)((uint)footer[7] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: uint total =                  (uint)((uint)footer[4] & 0xff) |                  (uint)(((uint)footer[5] & 0xff) << 8) |                  (uint)(((uint)footer[6] & 0xff) << 16) |                  (uint)((uint)footer[7] << 24);
Magic Number,Orvid.Compression.Streams,GZipInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Gzip.cs,ReadFooter,The following statement contains a magic number: uint total =                  (uint)((uint)footer[4] & 0xff) |                  (uint)(((uint)footer[5] & 0xff) << 8) |                  (uint)(((uint)footer[6] & 0xff) << 16) |                  (uint)((uint)footer[7] << 24);
Magic Number,Orvid.Compression.Streams,LzwInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,Read,The following statement contains a magic number: do              {                  if (end < EXTRA)                  {                      Fill();                  }                    int bitIn = (got > 0) ? (end - end % lNBits) << 3 :                                          (end << 3) - (lNBits - 1);                    while (lBitPos < bitIn)                  {                      #region A                      // handle 1-byte reads correctly                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          maxMaxCode = lMaxMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                        // check for code-width expansion                      if (lFreeEnt > lMaxCode)                      {                          int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) +                          nBytes - (lBitPos - 1 + nBytes) % nBytes;                            lNBits++;                          lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :                                                          (1 << lNBits) - 1;                            lBitMask = (1 << lNBits) - 1;                          lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region B                      // read next code                      int pos = lBitPos >> 3;                      int code = (((lData[pos] & 0xFF) |                          ((lData[pos + 1] & 0xFF) << 8) |                          ((lData[pos + 2] & 0xFF) << 16)) >>                          (lBitPos & 0x7)) & lBitMask;                        lBitPos += lNBits;                        // handle first iteration                      if (lOldCode == -1)                      {                          if (code >= 256)                              throw new Exception("corrupt input: " + code + " > 255");                            lFinChar = (byte)(lOldCode = code);                          buffer[offset++] = lFinChar;                          count--;                          continue;                      }                        // handle CLEAR code                      if (code == TBL_CLEAR && blockMode)                      {                          Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);                          lFreeEnt = TBL_FIRST - 1;                            int nBytes = lNBits << 3;                          lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;                          lNBits = LzwConstants.INIT_BITS;                          lMaxCode = (1 << lNBits) - 1;                          lBitMask = lMaxCode;                            // Code tables reset                            lBitPos = ResetBuf(lBitPos);                          goto MainLoop;                      }                      #endregion                        #region C                      // setup                      int inCode = code;                      lStackP = lStack.Length;                        // Handle KwK case                      if (code >= lFreeEnt)                      {                          if (code > lFreeEnt)                          {                              throw new Exception("corrupt input: code=" + code + "' freeEnt=" + lFreeEnt);                          }                            lStack[--lStackP] = lFinChar;                          code = lOldCode;                      }                        // Generate output characters in reverse order                      while (code >= 256)                      {                          lStack[--lStackP] = lTabSuffix[code];                          code = lTabPrefix[code];                      }                        lFinChar = lTabSuffix[code];                      buffer[offset++] = lFinChar;                      count--;                        // And put them out in forward order                      sSize = lStack.Length - lStackP;                      int num = (sSize >= count) ? count : sSize;                      Array.Copy(lStack' lStackP' buffer' offset' num);                      offset += num;                      count -= num;                      lStackP += num;                      #endregion                        #region D                      // generate new entry in table                      if (lFreeEnt < lMaxMaxCode)                      {                          lTabPrefix[lFreeEnt] = lOldCode;                          lTabSuffix[lFreeEnt] = lFinChar;                          lFreeEnt++;                      }                        // Remember previous code                      lOldCode = inCode;                        // if output buffer full' then return                      if (count == 0)                      {                          nBits = lNBits;                          maxCode = lMaxCode;                          bitMask = lBitMask;                          oldCode = lOldCode;                          finChar = lFinChar;                          stackP = lStackP;                          freeEnt = lFreeEnt;                          bitPos = lBitPos;                            return offset - start;                      }                      #endregion                  }   // while                    lBitPos = ResetBuf(lBitPos);                } while (got > 0);
Magic Number,Orvid.Compression.Streams,LzwInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,ResetBuf,The following statement contains a magic number: int pos = bitPosition >> 3;
Magic Number,Orvid.Compression.Streams,LzwInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,ParseHeader,The following statement contains a magic number: hdr[0] != (LzwConstants.MAGIC >> 8) || hdr[1] != (LzwConstants.MAGIC & 0xff)
Magic Number,Orvid.Compression.Streams,LzwInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,ParseHeader,The following statement contains a magic number: blockMode = (hdr[2] & LzwConstants.BLOCK_MODE_MASK) > 0;
Magic Number,Orvid.Compression.Streams,LzwInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,ParseHeader,The following statement contains a magic number: maxBits = hdr[2] & LzwConstants.BIT_MASK;
Magic Number,Orvid.Compression.Streams,LzwInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,ParseHeader,The following statement contains a magic number: (hdr[2] & LzwConstants.RESERVED_MASK) > 0
Magic Number,Orvid.Compression.Streams,LzwInputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Lzw.cs,ParseHeader,The following statement contains a magic number: freeEnt = blockMode ? TBL_FIRST : 256;
Duplicate Code,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 24)' (14' 33)' (23' 42)' (32' 51))
Duplicate Code,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 50)' (14' 59))
Duplicate Code,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 24)' (23' 42)' (32' 51))
Duplicate Code,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((64' 97)' (79' 112))
Duplicate Code,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((64' 83)' (94' 113))
Duplicate Code,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The method contains a code clone-set at the following line numbers (starting from the method definition): ((49' 72)' (81' 104))
Missing Default,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The following switch statement is missing a default case: switch (zPend % 2)                              {                                  case 0:                                      szptr[wr] = (short)BZip2Constants.RunA;                                      wr++;                                      mtfFreq[BZip2Constants.RunA]++;                                      break;                                  case 1:                                      szptr[wr] = (short)BZip2Constants.RunB;                                      wr++;                                      mtfFreq[BZip2Constants.RunB]++;                                      break;                              }
Missing Default,Orvid.Compression.Streams,BZip2OutputStream,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\BZip2.cs,GenerateMTFValues,The following switch statement is missing a default case: switch (zPend % 2)                      {                          case 0:                              szptr[wr] = (short)BZip2Constants.RunA;                              wr++;                              mtfFreq[BZip2Constants.RunA]++;                              break;                          case 1:                              szptr[wr] = (short)BZip2Constants.RunB;                              wr++;                              mtfFreq[BZip2Constants.RunB]++;                              break;                      }
Missing Default,Orvid.Compression.Streams,InflaterDynHeader,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,Decode,The following switch statement is missing a default case: switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          mode = DNUM;                          goto case DNUM;                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM;                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          mode = BLLENS;                          goto case BLLENS;                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              blLens[BL_ORDER[ptr]] = (byte)len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS;                      case LENS:                          {                              int symbol;                              while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                              {                                  litdistLens[ptr++] = lastLen = (byte)symbol;                                    if (ptr == num)                                  {                                      return true;                                  }                              }                                if (symbol < 0)                              {                                  return false;                              }                                if (symbol >= 17)                              {                                  lastLen = 0;                              }                              else                              {                                  if (ptr == 0)                                  {                                      throw new Exception();                                  }                              }                              repSymbol = symbol - 16;                          }                          mode = REPS;                          goto case REPS;                      case REPS:                          {                              int bits = repBits[repSymbol];                              int count = input.PeekBits(bits);                              if (count < 0)                              {                                  return false;                              }                              input.DropBits(bits);                              count += repMin[repSymbol];                                if (ptr + count > num)                              {                                  throw new Exception();                              }                              while (count-- > 0)                              {                                  litdistLens[ptr++] = lastLen;                              }                                if (ptr == num)                              {                                  return true;                              }                          }                          mode = LENS;                          goto decode_loop;                  }
Missing Default,Orvid.Compression.Streams,DeflaterEngine,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Compression\Streams\Deflate.cs,SetLevel,The following switch statement is missing a default case: switch (compressionFunction)                  {                      case DEFLATE_STORED:                          if (strstart > blockStart)                          {                              huffman.FlushStoredBlock(window' blockStart'                                  strstart - blockStart' false);                              blockStart = strstart;                          }                          UpdateHash();                          break;                        case DEFLATE_FAST:                          if (strstart > blockStart)                          {                              huffman.FlushBlock(window' blockStart' strstart - blockStart'                                  false);                              blockStart = strstart;                          }                          break;                        case DEFLATE_SLOW:                          if (prevAvailable)                          {                              huffman.TallyLit(window[strstart - 1] & 0xff);                          }                          if (strstart > blockStart)                          {                              huffman.FlushBlock(window' blockStart' strstart - blockStart' false);                              blockStart = strstart;                          }                          prevAvailable = false;                          matchLen = MIN_MATCH - 1;                          break;                  }
